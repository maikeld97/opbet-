import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-QWN5BXRD.js";

// node_modules/@btc-vision/transaction/browser/noble-hashes.js
function k0(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Mt(t) {
  if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
  var e = t.default;
  if (typeof e == "function") {
    var s = function i() {
      var n = false;
      try {
        n = this instanceof i;
      } catch {
      }
      return n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    s.prototype = e.prototype;
  } else s = {};
  return Object.defineProperty(s, "__esModule", { value: true }), Object.keys(t).forEach(function(i) {
    var n = Object.getOwnPropertyDescriptor(t, i);
    Object.defineProperty(s, i, n.get ? n : {
      enumerable: true,
      get: function() {
        return t[i];
      }
    });
  }), s;
}
function Oe(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Ut(t, e = "") {
  if (!Number.isSafeInteger(t) || t < 0) {
    const s = e && `"${e}" `;
    throw new Error(`${s}expected integer >= 0, got ${t}`);
  }
}
function ft(t, e, s = "") {
  const i = Oe(t), n = t == null ? void 0 : t.length, r = e !== void 0;
  if (!i || r && n !== e) {
    const c = s && `"${s}" `, o = r ? ` of length ${e}` : "", h = i ? `length=${n}` : `type=${typeof t}`;
    throw new Error(c + "expected Uint8Array" + o + ", got " + h);
  }
  return t;
}
function De(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  Ut(t.outputLen), Ut(t.blockLen);
}
function Ht(t, e = true) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function ie(t, e) {
  ft(t, void 0, "digestInto() output");
  const s = e.outputLen;
  if (t.length < s)
    throw new Error('"digestInto() output" expected to be of length >=' + s);
}
function Fe(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function J(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
function Dt(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function $(t, e) {
  return t << 32 - e | t >>> e;
}
function ht(t, e) {
  return t << e | t >>> 32 - e >>> 0;
}
var Te = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function ve(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Me(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = ve(t[e]);
  return t;
}
var Rt = Te ? (t) => t : Me;
var ce = (
  /* @ts-ignore */
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
);
var Ge = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function O0(t) {
  if (ft(t), ce)
    return t.toHex();
  let e = "";
  for (let s = 0; s < t.length; s++)
    e += Ge[t[s]];
  return e;
}
var et = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Wt(t) {
  if (t >= et._0 && t <= et._9)
    return t - et._0;
  if (t >= et.A && t <= et.F)
    return t - (et.A - 10);
  if (t >= et.a && t <= et.f)
    return t - (et.a - 10);
}
function D0(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (ce)
    return Uint8Array.fromHex(t);
  const e = t.length, s = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const i = new Uint8Array(s);
  for (let n = 0, r = 0; n < s; n++, r += 2) {
    const c = Wt(t.charCodeAt(r)), o = Wt(t.charCodeAt(r + 1));
    if (c === void 0 || o === void 0) {
      const h = t[r] + t[r + 1];
      throw new Error('hex string expected, got non-hex character "' + h + '" at index ' + r);
    }
    i[n] = c * 16 + o;
  }
  return i;
}
function F0(...t) {
  let e = 0;
  for (let i = 0; i < t.length; i++) {
    const n = t[i];
    ft(n), e += n.length;
  }
  const s = new Uint8Array(e);
  for (let i = 0, n = 0; i < t.length; i++) {
    const r = t[i];
    s.set(r, n), n += r.length;
  }
  return s;
}
function tt(t, e = {}) {
  const s = (n, r) => t(r).update(n).digest(), i = t(void 0);
  return s.outputLen = i.outputLen, s.blockLen = i.blockLen, s.create = (n) => t(n), Object.assign(s, e), Object.freeze(s);
}
function T0(t = 32) {
  const e = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof (e == null ? void 0 : e.getRandomValues) != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return e.getRandomValues(new Uint8Array(t));
}
var dt = (t) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, t])
});
var Gt = class {
  constructor(e, s) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    if (De(e), ft(s, void 0, "key"), this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, n = new Uint8Array(i);
    n.set(s.length > i ? e.create().update(s).digest() : s);
    for (let r = 0; r < n.length; r++)
      n[r] ^= 54;
    this.iHash.update(n), this.oHash = e.create();
    for (let r = 0; r < n.length; r++)
      n[r] ^= 106;
    this.oHash.update(n), J(n);
  }
  update(e) {
    return Ht(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Ht(this), ft(e, this.outputLen, "output"), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: s, iHash: i, finished: n, destroyed: r, blockLen: c, outputLen: o } = this;
    return e = e, e.finished = n, e.destroyed = r, e.blockLen = c, e.outputLen = o, e.oHash = s._cloneInto(e.oHash), e.iHash = i._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var oe = (t, e, s) => new Gt(t, e).update(s).digest();
oe.create = (t, e) => new Gt(t, e);
var je = Object.freeze(Object.defineProperty({
  __proto__: null,
  _HMAC: Gt,
  hmac: oe
}, Symbol.toStringTag, { value: "Module" }));
var v0 = Mt(je);
function Et(t, e, s) {
  return t & e ^ ~t & s;
}
function ae(t, e, s) {
  return t & e ^ t & s ^ e & s;
}
var _t = class {
  constructor(e, s, i, n) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = e, this.outputLen = s, this.padOffset = i, this.isLE = n, this.buffer = new Uint8Array(e), this.view = Dt(this.buffer);
  }
  update(e) {
    Ht(this), ft(e);
    const { view: s, buffer: i, blockLen: n } = this, r = e.length;
    for (let c = 0; c < r; ) {
      const o = Math.min(n - this.pos, r - c);
      if (o === n) {
        const h = Dt(e);
        for (; n <= r - c; c += n)
          this.process(h, c);
        continue;
      }
      i.set(e.subarray(c, c + o), this.pos), this.pos += o, c += o, this.pos === n && (this.process(s, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Ht(this), ie(e, this), this.finished = true;
    const { buffer: s, view: i, blockLen: n, isLE: r } = this;
    let { pos: c } = this;
    s[c++] = 128, J(this.buffer.subarray(c)), this.padOffset > n - c && (this.process(i, 0), c = 0);
    for (let f = c; f < n; f++)
      s[f] = 0;
    i.setBigUint64(n - 8, BigInt(this.length * 8), r), this.process(i, 0);
    const o = Dt(e), h = this.outputLen;
    if (h % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const u = h / 4, d = this.get();
    if (u > d.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      o.setUint32(4 * f, d[f], r);
  }
  digest() {
    const { buffer: e, outputLen: s } = this;
    this.digestInto(e);
    const i = e.slice(0, s);
    return this.destroy(), i;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: s, buffer: i, length: n, finished: r, destroyed: c, pos: o } = this;
    return e.destroyed = c, e.finished = r, e.length = n, e.pos = o, n % s && e.buffer.set(i), e;
  }
  clone() {
    return this._cloneInto();
  }
};
var nt = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var rt = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var W = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var q = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);
var xt = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var it = new Uint32Array(80);
var he = class extends _t {
  constructor() {
    super(64, 20, 8, false);
    __publicField(this, "A", xt[0] | 0);
    __publicField(this, "B", xt[1] | 0);
    __publicField(this, "C", xt[2] | 0);
    __publicField(this, "D", xt[3] | 0);
    __publicField(this, "E", xt[4] | 0);
  }
  get() {
    const { A: e, B: s, C: i, D: n, E: r } = this;
    return [e, s, i, n, r];
  }
  set(e, s, i, n, r) {
    this.A = e | 0, this.B = s | 0, this.C = i | 0, this.D = n | 0, this.E = r | 0;
  }
  process(e, s) {
    for (let h = 0; h < 16; h++, s += 4)
      it[h] = e.getUint32(s, false);
    for (let h = 16; h < 80; h++)
      it[h] = ht(it[h - 3] ^ it[h - 8] ^ it[h - 14] ^ it[h - 16], 1);
    let { A: i, B: n, C: r, D: c, E: o } = this;
    for (let h = 0; h < 80; h++) {
      let u, d;
      h < 20 ? (u = Et(n, r, c), d = 1518500249) : h < 40 ? (u = n ^ r ^ c, d = 1859775393) : h < 60 ? (u = ae(n, r, c), d = 2400959708) : (u = n ^ r ^ c, d = 3395469782);
      const f = ht(i, 5) + u + o + d + it[h] | 0;
      o = c, c = r, r = ht(n, 30), n = i, i = f;
    }
    i = i + this.A | 0, n = n + this.B | 0, r = r + this.C | 0, c = c + this.D | 0, o = o + this.E | 0, this.set(i, n, r, c, o);
  }
  roundClean() {
    J(it);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), J(this.buffer);
  }
};
var Pe = tt(() => new he());
var Re = Math.pow(2, 32);
var We = Array.from({ length: 64 }, (t, e) => Math.floor(Re * Math.abs(Math.sin(e + 1))));
var wt = xt.slice(0, 4);
var Ft = new Uint32Array(16);
var fe = class extends _t {
  constructor() {
    super(64, 16, 8, true);
    __publicField(this, "A", wt[0] | 0);
    __publicField(this, "B", wt[1] | 0);
    __publicField(this, "C", wt[2] | 0);
    __publicField(this, "D", wt[3] | 0);
  }
  get() {
    const { A: e, B: s, C: i, D: n } = this;
    return [e, s, i, n];
  }
  set(e, s, i, n) {
    this.A = e | 0, this.B = s | 0, this.C = i | 0, this.D = n | 0;
  }
  process(e, s) {
    for (let o = 0; o < 16; o++, s += 4)
      Ft[o] = e.getUint32(s, true);
    let { A: i, B: n, C: r, D: c } = this;
    for (let o = 0; o < 64; o++) {
      let h, u, d;
      o < 16 ? (h = Et(n, r, c), u = o, d = [7, 12, 17, 22]) : o < 32 ? (h = Et(c, n, r), u = (5 * o + 1) % 16, d = [5, 9, 14, 20]) : o < 48 ? (h = n ^ r ^ c, u = (3 * o + 5) % 16, d = [4, 11, 16, 23]) : (h = r ^ (n | ~c), u = 7 * o % 16, d = [6, 10, 15, 21]), h = h + i + We[o] + Ft[u], i = c, c = r, r = n, n = n + ht(h, d[o % 4]);
    }
    i = i + this.A | 0, n = n + this.B | 0, r = r + this.C | 0, c = c + this.D | 0, this.set(i, n, r, c);
  }
  roundClean() {
    J(Ft);
  }
  destroy() {
    this.set(0, 0, 0, 0), J(this.buffer);
  }
};
var qe = tt(() => new fe());
var Ke = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var de = Uint8Array.from(new Array(16).fill(0).map((t, e) => e));
var Ne = de.map((t) => (9 * t + 5) % 16);
var ue = (() => {
  const s = [[de], [Ne]];
  for (let i = 0; i < 4; i++)
    for (let n of s)
      n.push(n[i].map((r) => Ke[r]));
  return s;
})();
var le = ue[0];
var be = ue[1];
var xe = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((t) => Uint8Array.from(t));
var Xe = le.map((t, e) => t.map((s) => xe[e][s]));
var Je = be.map((t, e) => t.map((s) => xe[e][s]));
var Qe = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Ye = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function qt(t, e, s, i) {
  return t === 0 ? e ^ s ^ i : t === 1 ? e & s | ~e & i : t === 2 ? (e | ~s) ^ i : t === 3 ? e & i | s & ~i : e ^ (s | ~i);
}
var Lt = new Uint32Array(16);
var He = class extends _t {
  constructor() {
    super(64, 20, 8, true);
    __publicField(this, "h0", 1732584193);
    __publicField(this, "h1", -271733879);
    __publicField(this, "h2", -1732584194);
    __publicField(this, "h3", 271733878);
    __publicField(this, "h4", -1009589776);
  }
  get() {
    const { h0: e, h1: s, h2: i, h3: n, h4: r } = this;
    return [e, s, i, n, r];
  }
  set(e, s, i, n, r) {
    this.h0 = e | 0, this.h1 = s | 0, this.h2 = i | 0, this.h3 = n | 0, this.h4 = r | 0;
  }
  process(e, s) {
    for (let p = 0; p < 16; p++, s += 4)
      Lt[p] = e.getUint32(s, true);
    let i = this.h0 | 0, n = i, r = this.h1 | 0, c = r, o = this.h2 | 0, h = o, u = this.h3 | 0, d = u, f = this.h4 | 0, y = f;
    for (let p = 0; p < 5; p++) {
      const g = 4 - p, S2 = Qe[p], U = Ye[p], M2 = le[p], D2 = be[p], H3 = Xe[p], E2 = Je[p];
      for (let A = 0; A < 16; A++) {
        const L = ht(i + qt(p, r, o, u) + Lt[M2[A]] + S2, H3[A]) + f | 0;
        i = f, f = u, u = ht(o, 10) | 0, o = r, r = L;
      }
      for (let A = 0; A < 16; A++) {
        const L = ht(n + qt(g, c, h, d) + Lt[D2[A]] + U, E2[A]) + y | 0;
        n = y, y = d, d = ht(h, 10) | 0, h = c, c = L;
      }
    }
    this.set(this.h1 + o + d | 0, this.h2 + u + y | 0, this.h3 + f + n | 0, this.h4 + i + c | 0, this.h0 + r + h | 0);
  }
  roundClean() {
    J(Lt);
  }
  destroy() {
    this.destroyed = true, J(this.buffer), this.set(0, 0, 0, 0, 0);
  }
};
var Ze = tt(() => new He());
var ze = Object.freeze(Object.defineProperty({
  __proto__: null,
  _MD5: fe,
  _RIPEMD160: He,
  _SHA1: he,
  md5: qe,
  ripemd160: Ze,
  sha1: Pe
}, Symbol.toStringTag, { value: "Module" }));
var M0 = Mt(ze);
var It = BigInt(2 ** 32 - 1);
var Kt = BigInt(32);
function $e(t, e = false) {
  return e ? { h: Number(t & It), l: Number(t >> Kt & It) } : { h: Number(t >> Kt & It) | 0, l: Number(t & It) | 0 };
}
function Ae(t, e = false) {
  const s = t.length;
  let i = new Uint32Array(s), n = new Uint32Array(s);
  for (let r = 0; r < s; r++) {
    const { h: c, l: o } = $e(t[r], e);
    [i[r], n[r]] = [c, o];
  }
  return [i, n];
}
var Nt = (t, e, s) => t >>> s;
var Xt = (t, e, s) => t << 32 - s | e >>> s;
var lt = (t, e, s) => t >>> s | e << 32 - s;
var bt = (t, e, s) => t << 32 - s | e >>> s;
var Bt = (t, e, s) => t << 64 - s | e >>> s - 32;
var mt = (t, e, s) => t >>> s - 32 | e << 64 - s;
var t0 = (t, e, s) => t << s | e >>> 32 - s;
var e0 = (t, e, s) => e << s | t >>> 32 - s;
var s0 = (t, e, s) => e << s - 32 | t >>> 64 - s;
var n0 = (t, e, s) => t << s - 32 | e >>> 64 - s;
function st(t, e, s, i) {
  const n = (e >>> 0) + (i >>> 0);
  return { h: t + s + (n / 2 ** 32 | 0) | 0, l: n | 0 };
}
var r0 = (t, e, s) => (t >>> 0) + (e >>> 0) + (s >>> 0);
var i0 = (t, e, s, i) => e + s + i + (t / 2 ** 32 | 0) | 0;
var c0 = (t, e, s, i) => (t >>> 0) + (e >>> 0) + (s >>> 0) + (i >>> 0);
var o0 = (t, e, s, i, n) => e + s + i + n + (t / 2 ** 32 | 0) | 0;
var a0 = (t, e, s, i, n) => (t >>> 0) + (e >>> 0) + (s >>> 0) + (i >>> 0) + (n >>> 0);
var h0 = (t, e, s, i, n, r) => e + s + i + n + r + (t / 2 ** 32 | 0) | 0;
var f0 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var ct = new Uint32Array(64);
var pe = class extends _t {
  constructor(e) {
    super(64, e, 8, false);
  }
  get() {
    const { A: e, B: s, C: i, D: n, E: r, F: c, G: o, H: h } = this;
    return [e, s, i, n, r, c, o, h];
  }
  // prettier-ignore
  set(e, s, i, n, r, c, o, h) {
    this.A = e | 0, this.B = s | 0, this.C = i | 0, this.D = n | 0, this.E = r | 0, this.F = c | 0, this.G = o | 0, this.H = h | 0;
  }
  process(e, s) {
    for (let f = 0; f < 16; f++, s += 4)
      ct[f] = e.getUint32(s, false);
    for (let f = 16; f < 64; f++) {
      const y = ct[f - 15], p = ct[f - 2], g = $(y, 7) ^ $(y, 18) ^ y >>> 3, S2 = $(p, 17) ^ $(p, 19) ^ p >>> 10;
      ct[f] = S2 + ct[f - 7] + g + ct[f - 16] | 0;
    }
    let { A: i, B: n, C: r, D: c, E: o, F: h, G: u, H: d } = this;
    for (let f = 0; f < 64; f++) {
      const y = $(o, 6) ^ $(o, 11) ^ $(o, 25), p = d + y + Et(o, h, u) + f0[f] + ct[f] | 0, S2 = ($(i, 2) ^ $(i, 13) ^ $(i, 22)) + ae(i, n, r) | 0;
      d = u, u = h, h = o, o = c + p | 0, c = r, r = n, n = i, i = p + S2 | 0;
    }
    i = i + this.A | 0, n = n + this.B | 0, r = r + this.C | 0, c = c + this.D | 0, o = o + this.E | 0, h = h + this.F | 0, u = u + this.G | 0, d = d + this.H | 0, this.set(i, n, r, c, o, h, u, d);
  }
  roundClean() {
    J(ct);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), J(this.buffer);
  }
};
var ye = class extends pe {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", nt[0] | 0);
    __publicField(this, "B", nt[1] | 0);
    __publicField(this, "C", nt[2] | 0);
    __publicField(this, "D", nt[3] | 0);
    __publicField(this, "E", nt[4] | 0);
    __publicField(this, "F", nt[5] | 0);
    __publicField(this, "G", nt[6] | 0);
    __publicField(this, "H", nt[7] | 0);
  }
};
var _e = class extends pe {
  constructor() {
    super(28);
    __publicField(this, "A", rt[0] | 0);
    __publicField(this, "B", rt[1] | 0);
    __publicField(this, "C", rt[2] | 0);
    __publicField(this, "D", rt[3] | 0);
    __publicField(this, "E", rt[4] | 0);
    __publicField(this, "F", rt[5] | 0);
    __publicField(this, "G", rt[6] | 0);
    __publicField(this, "H", rt[7] | 0);
  }
};
var ge = Ae([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t)));
var d0 = ge[0];
var u0 = ge[1];
var ot = new Uint32Array(80);
var at = new Uint32Array(80);
var Vt = class extends _t {
  constructor(e) {
    super(128, e, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: s, Bh: i, Bl: n, Ch: r, Cl: c, Dh: o, Dl: h, Eh: u, El: d, Fh: f, Fl: y, Gh: p, Gl: g, Hh: S2, Hl: U } = this;
    return [e, s, i, n, r, c, o, h, u, d, f, y, p, g, S2, U];
  }
  // prettier-ignore
  set(e, s, i, n, r, c, o, h, u, d, f, y, p, g, S2, U) {
    this.Ah = e | 0, this.Al = s | 0, this.Bh = i | 0, this.Bl = n | 0, this.Ch = r | 0, this.Cl = c | 0, this.Dh = o | 0, this.Dl = h | 0, this.Eh = u | 0, this.El = d | 0, this.Fh = f | 0, this.Fl = y | 0, this.Gh = p | 0, this.Gl = g | 0, this.Hh = S2 | 0, this.Hl = U | 0;
  }
  process(e, s) {
    for (let H3 = 0; H3 < 16; H3++, s += 4)
      ot[H3] = e.getUint32(s), at[H3] = e.getUint32(s += 4);
    for (let H3 = 16; H3 < 80; H3++) {
      const E2 = ot[H3 - 15] | 0, A = at[H3 - 15] | 0, L = lt(E2, A, 1) ^ lt(E2, A, 8) ^ Nt(E2, A, 7), m = bt(E2, A, 1) ^ bt(E2, A, 8) ^ Xt(E2, A, 7), V2 = ot[H3 - 2] | 0, l = at[H3 - 2] | 0, b2 = lt(V2, l, 19) ^ Bt(V2, l, 61) ^ Nt(V2, l, 6), x = bt(V2, l, 19) ^ mt(V2, l, 61) ^ Xt(V2, l, 6), C = c0(m, x, at[H3 - 7], at[H3 - 16]), w = o0(C, L, b2, ot[H3 - 7], ot[H3 - 16]);
      ot[H3] = w | 0, at[H3] = C | 0;
    }
    let { Ah: i, Al: n, Bh: r, Bl: c, Ch: o, Cl: h, Dh: u, Dl: d, Eh: f, El: y, Fh: p, Fl: g, Gh: S2, Gl: U, Hh: M2, Hl: D2 } = this;
    for (let H3 = 0; H3 < 80; H3++) {
      const E2 = lt(f, y, 14) ^ lt(f, y, 18) ^ Bt(f, y, 41), A = bt(f, y, 14) ^ bt(f, y, 18) ^ mt(f, y, 41), L = f & p ^ ~f & S2, m = y & g ^ ~y & U, V2 = a0(D2, A, m, u0[H3], at[H3]), l = h0(V2, M2, E2, L, d0[H3], ot[H3]), b2 = V2 | 0, x = lt(i, n, 28) ^ Bt(i, n, 34) ^ Bt(i, n, 39), C = bt(i, n, 28) ^ mt(i, n, 34) ^ mt(i, n, 39), w = i & r ^ i & o ^ r & o, k2 = n & c ^ n & h ^ c & h;
      M2 = S2 | 0, D2 = U | 0, S2 = p | 0, U = g | 0, p = f | 0, g = y | 0, { h: f, l: y } = st(u | 0, d | 0, l | 0, b2 | 0), u = o | 0, d = h | 0, o = r | 0, h = c | 0, r = i | 0, c = n | 0;
      const v = r0(b2, C, k2);
      i = i0(v, l, x, w), n = v | 0;
    }
    ({ h: i, l: n } = st(this.Ah | 0, this.Al | 0, i | 0, n | 0)), { h: r, l: c } = st(this.Bh | 0, this.Bl | 0, r | 0, c | 0), { h: o, l: h } = st(this.Ch | 0, this.Cl | 0, o | 0, h | 0), { h: u, l: d } = st(this.Dh | 0, this.Dl | 0, u | 0, d | 0), { h: f, l: y } = st(this.Eh | 0, this.El | 0, f | 0, y | 0), { h: p, l: g } = st(this.Fh | 0, this.Fl | 0, p | 0, g | 0), { h: S2, l: U } = st(this.Gh | 0, this.Gl | 0, S2 | 0, U | 0), { h: M2, l: D2 } = st(this.Hh | 0, this.Hl | 0, M2 | 0, D2 | 0), this.set(i, n, r, c, o, h, u, d, f, y, p, g, S2, U, M2, D2);
  }
  roundClean() {
    J(ot, at);
  }
  destroy() {
    J(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Se = class extends Vt {
  constructor() {
    super(64);
    __publicField(this, "Ah", q[0] | 0);
    __publicField(this, "Al", q[1] | 0);
    __publicField(this, "Bh", q[2] | 0);
    __publicField(this, "Bl", q[3] | 0);
    __publicField(this, "Ch", q[4] | 0);
    __publicField(this, "Cl", q[5] | 0);
    __publicField(this, "Dh", q[6] | 0);
    __publicField(this, "Dl", q[7] | 0);
    __publicField(this, "Eh", q[8] | 0);
    __publicField(this, "El", q[9] | 0);
    __publicField(this, "Fh", q[10] | 0);
    __publicField(this, "Fl", q[11] | 0);
    __publicField(this, "Gh", q[12] | 0);
    __publicField(this, "Gl", q[13] | 0);
    __publicField(this, "Hh", q[14] | 0);
    __publicField(this, "Hl", q[15] | 0);
  }
};
var we = class extends Vt {
  constructor() {
    super(48);
    __publicField(this, "Ah", W[0] | 0);
    __publicField(this, "Al", W[1] | 0);
    __publicField(this, "Bh", W[2] | 0);
    __publicField(this, "Bl", W[3] | 0);
    __publicField(this, "Ch", W[4] | 0);
    __publicField(this, "Cl", W[5] | 0);
    __publicField(this, "Dh", W[6] | 0);
    __publicField(this, "Dl", W[7] | 0);
    __publicField(this, "Eh", W[8] | 0);
    __publicField(this, "El", W[9] | 0);
    __publicField(this, "Fh", W[10] | 0);
    __publicField(this, "Fl", W[11] | 0);
    __publicField(this, "Gh", W[12] | 0);
    __publicField(this, "Gl", W[13] | 0);
    __publicField(this, "Hh", W[14] | 0);
    __publicField(this, "Hl", W[15] | 0);
  }
};
var K = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var N = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var Le = class extends Vt {
  constructor() {
    super(28);
    __publicField(this, "Ah", K[0] | 0);
    __publicField(this, "Al", K[1] | 0);
    __publicField(this, "Bh", K[2] | 0);
    __publicField(this, "Bl", K[3] | 0);
    __publicField(this, "Ch", K[4] | 0);
    __publicField(this, "Cl", K[5] | 0);
    __publicField(this, "Dh", K[6] | 0);
    __publicField(this, "Dl", K[7] | 0);
    __publicField(this, "Eh", K[8] | 0);
    __publicField(this, "El", K[9] | 0);
    __publicField(this, "Fh", K[10] | 0);
    __publicField(this, "Fl", K[11] | 0);
    __publicField(this, "Gh", K[12] | 0);
    __publicField(this, "Gl", K[13] | 0);
    __publicField(this, "Hh", K[14] | 0);
    __publicField(this, "Hl", K[15] | 0);
  }
};
var Ie = class extends Vt {
  constructor() {
    super(32);
    __publicField(this, "Ah", N[0] | 0);
    __publicField(this, "Al", N[1] | 0);
    __publicField(this, "Bh", N[2] | 0);
    __publicField(this, "Bl", N[3] | 0);
    __publicField(this, "Ch", N[4] | 0);
    __publicField(this, "Cl", N[5] | 0);
    __publicField(this, "Dh", N[6] | 0);
    __publicField(this, "Dl", N[7] | 0);
    __publicField(this, "Eh", N[8] | 0);
    __publicField(this, "El", N[9] | 0);
    __publicField(this, "Fh", N[10] | 0);
    __publicField(this, "Fl", N[11] | 0);
    __publicField(this, "Gh", N[12] | 0);
    __publicField(this, "Gl", N[13] | 0);
    __publicField(this, "Hh", N[14] | 0);
    __publicField(this, "Hl", N[15] | 0);
  }
};
var l0 = tt(
  () => new ye(),
  dt(1)
);
var b0 = tt(
  () => new _e(),
  dt(4)
);
var x0 = tt(
  () => new Se(),
  dt(3)
);
var H0 = tt(
  () => new we(),
  dt(2)
);
var A0 = tt(
  () => new Ie(),
  dt(6)
);
var p0 = tt(
  () => new Le(),
  dt(5)
);
var y0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  _SHA224: _e,
  _SHA256: ye,
  _SHA384: we,
  _SHA512: Se,
  _SHA512_224: Le,
  _SHA512_256: Ie,
  sha224: b0,
  sha256: l0,
  sha384: H0,
  sha512: x0,
  sha512_224: p0,
  sha512_256: A0
}, Symbol.toStringTag, { value: "Module" }));
var G0 = Mt(y0);
var _0 = BigInt(0);
var At = BigInt(1);
var g0 = BigInt(2);
var S0 = BigInt(7);
var w0 = BigInt(256);
var L0 = BigInt(113);
var Be = [];
var me = [];
var Ue = [];
for (let t = 0, e = At, s = 1, i = 0; t < 24; t++) {
  [s, i] = [i, (2 * s + 3 * i) % 5], Be.push(2 * (5 * i + s)), me.push((t + 1) * (t + 2) / 2 % 64);
  let n = _0;
  for (let r = 0; r < 7; r++)
    e = (e << At ^ (e >> S0) * L0) % w0, e & g0 && (n ^= At << (At << BigInt(r)) - At);
  Ue.push(n);
}
var Ee = Ae(Ue, true);
var I0 = Ee[0];
var B0 = Ee[1];
var Jt = (t, e, s) => s > 32 ? s0(t, e, s) : t0(t, e, s);
var Qt = (t, e, s) => s > 32 ? n0(t, e, s) : e0(t, e, s);
function m0(t, e = 24) {
  const s = new Uint32Array(10);
  for (let i = 24 - e; i < 24; i++) {
    for (let c = 0; c < 10; c++)
      s[c] = t[c] ^ t[c + 10] ^ t[c + 20] ^ t[c + 30] ^ t[c + 40];
    for (let c = 0; c < 10; c += 2) {
      const o = (c + 8) % 10, h = (c + 2) % 10, u = s[h], d = s[h + 1], f = Jt(u, d, 1) ^ s[o], y = Qt(u, d, 1) ^ s[o + 1];
      for (let p = 0; p < 50; p += 10)
        t[c + p] ^= f, t[c + p + 1] ^= y;
    }
    let n = t[2], r = t[3];
    for (let c = 0; c < 24; c++) {
      const o = me[c], h = Jt(n, r, o), u = Qt(n, r, o), d = Be[c];
      n = t[d], r = t[d + 1], t[d] = h, t[d + 1] = u;
    }
    for (let c = 0; c < 50; c += 10) {
      for (let o = 0; o < 10; o++)
        s[o] = t[c + o];
      for (let o = 0; o < 10; o++)
        t[c + o] ^= ~s[(o + 2) % 10] & s[(o + 4) % 10];
    }
    t[0] ^= I0[i], t[1] ^= B0[i];
  }
  J(s);
}
var jt = class _jt2 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, s, i, n = false, r = 24) {
    __publicField(this, "state");
    __publicField(this, "pos", 0);
    __publicField(this, "posOut", 0);
    __publicField(this, "finished", false);
    __publicField(this, "state32");
    __publicField(this, "destroyed", false);
    __publicField(this, "blockLen");
    __publicField(this, "suffix");
    __publicField(this, "outputLen");
    __publicField(this, "enableXOF", false);
    __publicField(this, "rounds");
    if (this.blockLen = e, this.suffix = s, this.outputLen = i, this.enableXOF = n, this.rounds = r, Ut(i, "outputLen"), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = Fe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Rt(this.state32), m0(this.state32, this.rounds), Rt(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Ht(this), ft(e);
    const { blockLen: s, state: i } = this, n = e.length;
    for (let r = 0; r < n; ) {
      const c = Math.min(s - this.pos, n - r);
      for (let o = 0; o < c; o++)
        i[this.pos++] ^= e[r++];
      this.pos === s && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: e, suffix: s, pos: i, blockLen: n } = this;
    e[i] ^= s, (s & 128) !== 0 && i === n - 1 && this.keccak(), e[n - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Ht(this, false), ft(e), this.finish();
    const s = this.state, { blockLen: i } = this;
    for (let n = 0, r = e.length; n < r; ) {
      this.posOut >= i && this.keccak();
      const c = Math.min(i - this.posOut, r - n);
      e.set(s.subarray(this.posOut, this.posOut + c), n), this.posOut += c, n += c;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Ut(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (ie(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, J(this.state);
  }
  _cloneInto(e) {
    const { blockLen: s, suffix: i, outputLen: n, rounds: r, enableXOF: c } = this;
    return e || (e = new _jt2(s, i, n, c, r)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = r, e.suffix = i, e.outputLen = n, e.enableXOF = c, e.destroyed = this.destroyed, e;
  }
};
var Ve = (t, e, s, i = {}) => tt((n = {}) => new jt(e, t, n.dkLen === void 0 ? s : n.dkLen, true), i);
var j0 = Ve(31, 168, 16, dt(11));
var P0 = Ve(31, 136, 32, dt(12));
var z = {};
var F = {};
var X = {};
var Tt = {};
var pt = {};
var Yt;
function U0() {
  return Yt || (Yt = 1, Object.defineProperty(pt, "__esModule", { value: true }), pt.crypto = void 0, pt.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0), pt;
}
var Zt;
function Ct() {
  return Zt || (Zt = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: true }), t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.Hash = t.nextTick = t.swap32IfBE = t.byteSwapIfBE = t.swap8IfBE = t.isLE = void 0, t.isBytes = s, t.anumber = i, t.abytes = n, t.ahash = r, t.aexists = c, t.aoutput = o, t.u8 = h, t.u32 = u, t.clean = d, t.createView = f, t.rotr = y, t.rotl = p, t.byteSwap = g, t.byteSwap32 = S2, t.bytesToHex = D2, t.hexToBytes = A, t.asyncLoop = m, t.utf8ToBytes = V2, t.bytesToUtf8 = l, t.toBytes = b2, t.kdfInputToBytes = x, t.concatBytes = C, t.checkOpts = w, t.createHasher = v, t.createOptHasher = j4, t.createXOFer = P3, t.randomBytes = Q3;
    const e = U0();
    function s(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function i(a) {
      if (!Number.isSafeInteger(a) || a < 0)
        throw new Error("positive integer expected, got " + a);
    }
    function n(a, ..._) {
      if (!s(a))
        throw new Error("Uint8Array expected");
      if (_.length > 0 && !_.includes(a.length))
        throw new Error("Uint8Array expected of length " + _ + ", got length=" + a.length);
    }
    function r(a) {
      if (typeof a != "function" || typeof a.create != "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      i(a.outputLen), i(a.blockLen);
    }
    function c(a, _ = true) {
      if (a.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (_ && a.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function o(a, _) {
      n(a);
      const I2 = _.outputLen;
      if (a.length < I2)
        throw new Error("digestInto() expects output buffer of length at least " + I2);
    }
    function h(a) {
      return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    }
    function u(a) {
      return new Uint32Array(a.buffer, a.byteOffset, Math.floor(a.byteLength / 4));
    }
    function d(...a) {
      for (let _ = 0; _ < a.length; _++)
        a[_].fill(0);
    }
    function f(a) {
      return new DataView(a.buffer, a.byteOffset, a.byteLength);
    }
    function y(a, _) {
      return a << 32 - _ | a >>> _;
    }
    function p(a, _) {
      return a << _ | a >>> 32 - _ >>> 0;
    }
    t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function g(a) {
      return a << 24 & 4278190080 | a << 8 & 16711680 | a >>> 8 & 65280 | a >>> 24 & 255;
    }
    t.swap8IfBE = t.isLE ? (a) => a : (a) => g(a), t.byteSwapIfBE = t.swap8IfBE;
    function S2(a) {
      for (let _ = 0; _ < a.length; _++)
        a[_] = g(a[_]);
      return a;
    }
    t.swap32IfBE = t.isLE ? (a) => a : S2;
    const U = (
      /* @ts-ignore */
      typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
    ), M2 = Array.from({ length: 256 }, (a, _) => _.toString(16).padStart(2, "0"));
    function D2(a) {
      if (n(a), U)
        return a.toHex();
      let _ = "";
      for (let I2 = 0; I2 < a.length; I2++)
        _ += M2[a[I2]];
      return _;
    }
    const H3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function E2(a) {
      if (a >= H3._0 && a <= H3._9)
        return a - H3._0;
      if (a >= H3.A && a <= H3.F)
        return a - (H3.A - 10);
      if (a >= H3.a && a <= H3.f)
        return a - (H3.a - 10);
    }
    function A(a) {
      if (typeof a != "string")
        throw new Error("hex string expected, got " + typeof a);
      if (U)
        return Uint8Array.fromHex(a);
      const _ = a.length, I2 = _ / 2;
      if (_ % 2)
        throw new Error("hex string expected, got unpadded hex of length " + _);
      const O = new Uint8Array(I2);
      for (let T = 0, R3 = 0; T < I2; T++, R3 += 2) {
        const ut4 = E2(a.charCodeAt(R3)), Y2 = E2(a.charCodeAt(R3 + 1));
        if (ut4 === void 0 || Y2 === void 0) {
          const Z3 = a[R3] + a[R3 + 1];
          throw new Error('hex string expected, got non-hex character "' + Z3 + '" at index ' + R3);
        }
        O[T] = ut4 * 16 + Y2;
      }
      return O;
    }
    const L = async () => {
    };
    t.nextTick = L;
    async function m(a, _, I2) {
      let O = Date.now();
      for (let T = 0; T < a; T++) {
        I2(T);
        const R3 = Date.now() - O;
        R3 >= 0 && R3 < _ || (await (0, t.nextTick)(), O += R3);
      }
    }
    function V2(a) {
      if (typeof a != "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(a));
    }
    function l(a) {
      return new TextDecoder().decode(a);
    }
    function b2(a) {
      return typeof a == "string" && (a = V2(a)), n(a), a;
    }
    function x(a) {
      return typeof a == "string" && (a = V2(a)), n(a), a;
    }
    function C(...a) {
      let _ = 0;
      for (let O = 0; O < a.length; O++) {
        const T = a[O];
        n(T), _ += T.length;
      }
      const I2 = new Uint8Array(_);
      for (let O = 0, T = 0; O < a.length; O++) {
        const R3 = a[O];
        I2.set(R3, T), T += R3.length;
      }
      return I2;
    }
    function w(a, _) {
      if (_ !== void 0 && {}.toString.call(_) !== "[object Object]")
        throw new Error("options should be object or undefined");
      return Object.assign(a, _);
    }
    class k2 {
    }
    t.Hash = k2;
    function v(a) {
      const _ = (O) => a().update(b2(O)).digest(), I2 = a();
      return _.outputLen = I2.outputLen, _.blockLen = I2.blockLen, _.create = () => a(), _;
    }
    function j4(a) {
      const _ = (O, T) => a(T).update(b2(O)).digest(), I2 = a({});
      return _.outputLen = I2.outputLen, _.blockLen = I2.blockLen, _.create = (O) => a(O), _;
    }
    function P3(a) {
      const _ = (O, T) => a(T).update(b2(O)).digest(), I2 = a({});
      return _.outputLen = I2.outputLen, _.blockLen = I2.blockLen, _.create = (O) => a(O), _;
    }
    t.wrapConstructor = v, t.wrapConstructorWithOpts = j4, t.wrapXOFConstructorWithOpts = P3;
    function Q3(a = 32) {
      if (e.crypto && typeof e.crypto.getRandomValues == "function")
        return e.crypto.getRandomValues(new Uint8Array(a));
      if (e.crypto && typeof e.crypto.randomBytes == "function")
        return Uint8Array.from(e.crypto.randomBytes(a));
      throw new Error("crypto.getRandomValues must be defined");
    }
  })(Tt)), Tt;
}
var zt;
function E0() {
  if (zt) return X;
  zt = 1, Object.defineProperty(X, "__esModule", { value: true }), X.SHA512_IV = X.SHA384_IV = X.SHA224_IV = X.SHA256_IV = X.HashMD = void 0, X.setBigUint64 = e, X.Chi = s, X.Maj = i;
  const t = Ct();
  function e(r, c, o, h) {
    if (typeof r.setBigUint64 == "function")
      return r.setBigUint64(c, o, h);
    const u = BigInt(32), d = BigInt(4294967295), f = Number(o >> u & d), y = Number(o & d), p = h ? 4 : 0, g = h ? 0 : 4;
    r.setUint32(c + p, f, h), r.setUint32(c + g, y, h);
  }
  function s(r, c, o) {
    return r & c ^ ~r & o;
  }
  function i(r, c, o) {
    return r & c ^ r & o ^ c & o;
  }
  class n extends t.Hash {
    constructor(c, o, h, u) {
      super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = c, this.outputLen = o, this.padOffset = h, this.isLE = u, this.buffer = new Uint8Array(c), this.view = (0, t.createView)(this.buffer);
    }
    update(c) {
      (0, t.aexists)(this), c = (0, t.toBytes)(c), (0, t.abytes)(c);
      const { view: o, buffer: h, blockLen: u } = this, d = c.length;
      for (let f = 0; f < d; ) {
        const y = Math.min(u - this.pos, d - f);
        if (y === u) {
          const p = (0, t.createView)(c);
          for (; u <= d - f; f += u)
            this.process(p, f);
          continue;
        }
        h.set(c.subarray(f, f + y), this.pos), this.pos += y, f += y, this.pos === u && (this.process(o, 0), this.pos = 0);
      }
      return this.length += c.length, this.roundClean(), this;
    }
    digestInto(c) {
      (0, t.aexists)(this), (0, t.aoutput)(c, this), this.finished = true;
      const { buffer: o, view: h, blockLen: u, isLE: d } = this;
      let { pos: f } = this;
      o[f++] = 128, (0, t.clean)(this.buffer.subarray(f)), this.padOffset > u - f && (this.process(h, 0), f = 0);
      for (let U = f; U < u; U++)
        o[U] = 0;
      e(h, u - 8, BigInt(this.length * 8), d), this.process(h, 0);
      const y = (0, t.createView)(c), p = this.outputLen;
      if (p % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const g = p / 4, S2 = this.get();
      if (g > S2.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let U = 0; U < g; U++)
        y.setUint32(4 * U, S2[U], d);
    }
    digest() {
      const { buffer: c, outputLen: o } = this;
      this.digestInto(c);
      const h = c.slice(0, o);
      return this.destroy(), h;
    }
    _cloneInto(c) {
      c || (c = new this.constructor()), c.set(...this.get());
      const { blockLen: o, buffer: h, length: u, finished: d, destroyed: f, pos: y } = this;
      return c.destroyed = f, c.finished = d, c.length = u, c.pos = y, u % o && c.buffer.set(h), c;
    }
    clone() {
      return this._cloneInto();
    }
  }
  return X.HashMD = n, X.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]), X.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]), X.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]), X.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]), X;
}
var B = {};
var $t;
function V0() {
  if ($t) return B;
  $t = 1, Object.defineProperty(B, "__esModule", { value: true }), B.toBig = B.shrSL = B.shrSH = B.rotrSL = B.rotrSH = B.rotrBL = B.rotrBH = B.rotr32L = B.rotr32H = B.rotlSL = B.rotlSH = B.rotlBL = B.rotlBH = B.add5L = B.add5H = B.add4L = B.add4H = B.add3L = B.add3H = void 0, B.add = M2, B.fromBig = s, B.split = i;
  const t = BigInt(2 ** 32 - 1), e = BigInt(32);
  function s(l, b2 = false) {
    return b2 ? { h: Number(l & t), l: Number(l >> e & t) } : { h: Number(l >> e & t) | 0, l: Number(l & t) | 0 };
  }
  function i(l, b2 = false) {
    const x = l.length;
    let C = new Uint32Array(x), w = new Uint32Array(x);
    for (let k2 = 0; k2 < x; k2++) {
      const { h: v, l: j4 } = s(l[k2], b2);
      [C[k2], w[k2]] = [v, j4];
    }
    return [C, w];
  }
  const n = (l, b2) => BigInt(l >>> 0) << e | BigInt(b2 >>> 0);
  B.toBig = n;
  const r = (l, b2, x) => l >>> x;
  B.shrSH = r;
  const c = (l, b2, x) => l << 32 - x | b2 >>> x;
  B.shrSL = c;
  const o = (l, b2, x) => l >>> x | b2 << 32 - x;
  B.rotrSH = o;
  const h = (l, b2, x) => l << 32 - x | b2 >>> x;
  B.rotrSL = h;
  const u = (l, b2, x) => l << 64 - x | b2 >>> x - 32;
  B.rotrBH = u;
  const d = (l, b2, x) => l >>> x - 32 | b2 << 64 - x;
  B.rotrBL = d;
  const f = (l, b2) => b2;
  B.rotr32H = f;
  const y = (l, b2) => l;
  B.rotr32L = y;
  const p = (l, b2, x) => l << x | b2 >>> 32 - x;
  B.rotlSH = p;
  const g = (l, b2, x) => b2 << x | l >>> 32 - x;
  B.rotlSL = g;
  const S2 = (l, b2, x) => b2 << x - 32 | l >>> 64 - x;
  B.rotlBH = S2;
  const U = (l, b2, x) => l << x - 32 | b2 >>> 64 - x;
  B.rotlBL = U;
  function M2(l, b2, x, C) {
    const w = (b2 >>> 0) + (C >>> 0);
    return { h: l + x + (w / 2 ** 32 | 0) | 0, l: w | 0 };
  }
  const D2 = (l, b2, x) => (l >>> 0) + (b2 >>> 0) + (x >>> 0);
  B.add3L = D2;
  const H3 = (l, b2, x, C) => b2 + x + C + (l / 2 ** 32 | 0) | 0;
  B.add3H = H3;
  const E2 = (l, b2, x, C) => (l >>> 0) + (b2 >>> 0) + (x >>> 0) + (C >>> 0);
  B.add4L = E2;
  const A = (l, b2, x, C, w) => b2 + x + C + w + (l / 2 ** 32 | 0) | 0;
  B.add4H = A;
  const L = (l, b2, x, C, w) => (l >>> 0) + (b2 >>> 0) + (x >>> 0) + (C >>> 0) + (w >>> 0);
  B.add5L = L;
  const m = (l, b2, x, C, w, k2) => b2 + x + C + w + k2 + (l / 2 ** 32 | 0) | 0;
  B.add5H = m;
  const V2 = {
    fromBig: s,
    split: i,
    toBig: n,
    shrSH: r,
    shrSL: c,
    rotrSH: o,
    rotrSL: h,
    rotrBH: u,
    rotrBL: d,
    rotr32H: f,
    rotr32L: y,
    rotlSH: p,
    rotlSL: g,
    rotlBH: S2,
    rotlBL: U,
    add: M2,
    add3L: D2,
    add3H: H3,
    add4L: E2,
    add4H: A,
    add5H: m,
    add5L: L
  };
  return B.default = V2, B;
}
var te;
function Ce() {
  if (te) return F;
  te = 1, Object.defineProperty(F, "__esModule", { value: true }), F.sha512_224 = F.sha512_256 = F.sha384 = F.sha512 = F.sha224 = F.sha256 = F.SHA512_256 = F.SHA512_224 = F.SHA384 = F.SHA512 = F.SHA224 = F.SHA256 = void 0;
  const t = E0(), e = V0(), s = Ct(), i = Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), n = new Uint32Array(64);
  class r extends t.HashMD {
    constructor(H3 = 32) {
      super(64, H3, 8, false), this.A = t.SHA256_IV[0] | 0, this.B = t.SHA256_IV[1] | 0, this.C = t.SHA256_IV[2] | 0, this.D = t.SHA256_IV[3] | 0, this.E = t.SHA256_IV[4] | 0, this.F = t.SHA256_IV[5] | 0, this.G = t.SHA256_IV[6] | 0, this.H = t.SHA256_IV[7] | 0;
    }
    get() {
      const { A: H3, B: E2, C: A, D: L, E: m, F: V2, G: l, H: b2 } = this;
      return [H3, E2, A, L, m, V2, l, b2];
    }
    // prettier-ignore
    set(H3, E2, A, L, m, V2, l, b2) {
      this.A = H3 | 0, this.B = E2 | 0, this.C = A | 0, this.D = L | 0, this.E = m | 0, this.F = V2 | 0, this.G = l | 0, this.H = b2 | 0;
    }
    process(H3, E2) {
      for (let w = 0; w < 16; w++, E2 += 4)
        n[w] = H3.getUint32(E2, false);
      for (let w = 16; w < 64; w++) {
        const k2 = n[w - 15], v = n[w - 2], j4 = (0, s.rotr)(k2, 7) ^ (0, s.rotr)(k2, 18) ^ k2 >>> 3, P3 = (0, s.rotr)(v, 17) ^ (0, s.rotr)(v, 19) ^ v >>> 10;
        n[w] = P3 + n[w - 7] + j4 + n[w - 16] | 0;
      }
      let { A, B: L, C: m, D: V2, E: l, F: b2, G: x, H: C } = this;
      for (let w = 0; w < 64; w++) {
        const k2 = (0, s.rotr)(l, 6) ^ (0, s.rotr)(l, 11) ^ (0, s.rotr)(l, 25), v = C + k2 + (0, t.Chi)(l, b2, x) + i[w] + n[w] | 0, P3 = ((0, s.rotr)(A, 2) ^ (0, s.rotr)(A, 13) ^ (0, s.rotr)(A, 22)) + (0, t.Maj)(A, L, m) | 0;
        C = x, x = b2, b2 = l, l = V2 + v | 0, V2 = m, m = L, L = A, A = v + P3 | 0;
      }
      A = A + this.A | 0, L = L + this.B | 0, m = m + this.C | 0, V2 = V2 + this.D | 0, l = l + this.E | 0, b2 = b2 + this.F | 0, x = x + this.G | 0, C = C + this.H | 0, this.set(A, L, m, V2, l, b2, x, C);
    }
    roundClean() {
      (0, s.clean)(n);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, s.clean)(this.buffer);
    }
  }
  F.SHA256 = r;
  class c extends r {
    constructor() {
      super(28), this.A = t.SHA224_IV[0] | 0, this.B = t.SHA224_IV[1] | 0, this.C = t.SHA224_IV[2] | 0, this.D = t.SHA224_IV[3] | 0, this.E = t.SHA224_IV[4] | 0, this.F = t.SHA224_IV[5] | 0, this.G = t.SHA224_IV[6] | 0, this.H = t.SHA224_IV[7] | 0;
    }
  }
  F.SHA224 = c;
  const o = e.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((D2) => BigInt(D2))), h = o[0], u = o[1], d = new Uint32Array(80), f = new Uint32Array(80);
  class y extends t.HashMD {
    constructor(H3 = 64) {
      super(128, H3, 16, false), this.Ah = t.SHA512_IV[0] | 0, this.Al = t.SHA512_IV[1] | 0, this.Bh = t.SHA512_IV[2] | 0, this.Bl = t.SHA512_IV[3] | 0, this.Ch = t.SHA512_IV[4] | 0, this.Cl = t.SHA512_IV[5] | 0, this.Dh = t.SHA512_IV[6] | 0, this.Dl = t.SHA512_IV[7] | 0, this.Eh = t.SHA512_IV[8] | 0, this.El = t.SHA512_IV[9] | 0, this.Fh = t.SHA512_IV[10] | 0, this.Fl = t.SHA512_IV[11] | 0, this.Gh = t.SHA512_IV[12] | 0, this.Gl = t.SHA512_IV[13] | 0, this.Hh = t.SHA512_IV[14] | 0, this.Hl = t.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah: H3, Al: E2, Bh: A, Bl: L, Ch: m, Cl: V2, Dh: l, Dl: b2, Eh: x, El: C, Fh: w, Fl: k2, Gh: v, Gl: j4, Hh: P3, Hl: Q3 } = this;
      return [H3, E2, A, L, m, V2, l, b2, x, C, w, k2, v, j4, P3, Q3];
    }
    // prettier-ignore
    set(H3, E2, A, L, m, V2, l, b2, x, C, w, k2, v, j4, P3, Q3) {
      this.Ah = H3 | 0, this.Al = E2 | 0, this.Bh = A | 0, this.Bl = L | 0, this.Ch = m | 0, this.Cl = V2 | 0, this.Dh = l | 0, this.Dl = b2 | 0, this.Eh = x | 0, this.El = C | 0, this.Fh = w | 0, this.Fl = k2 | 0, this.Gh = v | 0, this.Gl = j4 | 0, this.Hh = P3 | 0, this.Hl = Q3 | 0;
    }
    process(H3, E2) {
      for (let I2 = 0; I2 < 16; I2++, E2 += 4)
        d[I2] = H3.getUint32(E2), f[I2] = H3.getUint32(E2 += 4);
      for (let I2 = 16; I2 < 80; I2++) {
        const O = d[I2 - 15] | 0, T = f[I2 - 15] | 0, R3 = e.rotrSH(O, T, 1) ^ e.rotrSH(O, T, 8) ^ e.shrSH(O, T, 7), ut4 = e.rotrSL(O, T, 1) ^ e.rotrSL(O, T, 8) ^ e.shrSL(O, T, 7), Y2 = d[I2 - 2] | 0, Z3 = f[I2 - 2] | 0, gt5 = e.rotrSH(Y2, Z3, 19) ^ e.rotrBH(Y2, Z3, 61) ^ e.shrSH(Y2, Z3, 6), kt5 = e.rotrSL(Y2, Z3, 19) ^ e.rotrBL(Y2, Z3, 61) ^ e.shrSL(Y2, Z3, 6), St5 = e.add4L(ut4, kt5, f[I2 - 7], f[I2 - 16]), Ot5 = e.add4H(St5, R3, gt5, d[I2 - 7], d[I2 - 16]);
        d[I2] = Ot5 | 0, f[I2] = St5 | 0;
      }
      let { Ah: A, Al: L, Bh: m, Bl: V2, Ch: l, Cl: b2, Dh: x, Dl: C, Eh: w, El: k2, Fh: v, Fl: j4, Gh: P3, Gl: Q3, Hh: a, Hl: _ } = this;
      for (let I2 = 0; I2 < 80; I2++) {
        const O = e.rotrSH(w, k2, 14) ^ e.rotrSH(w, k2, 18) ^ e.rotrBH(w, k2, 41), T = e.rotrSL(w, k2, 14) ^ e.rotrSL(w, k2, 18) ^ e.rotrBL(w, k2, 41), R3 = w & v ^ ~w & P3, ut4 = k2 & j4 ^ ~k2 & Q3, Y2 = e.add5L(_, T, ut4, u[I2], f[I2]), Z3 = e.add5H(Y2, a, O, R3, h[I2], d[I2]), gt5 = Y2 | 0, kt5 = e.rotrSH(A, L, 28) ^ e.rotrBH(A, L, 34) ^ e.rotrBH(A, L, 39), St5 = e.rotrSL(A, L, 28) ^ e.rotrBL(A, L, 34) ^ e.rotrBL(A, L, 39), Ot5 = A & m ^ A & l ^ m & l, ke3 = L & V2 ^ L & b2 ^ V2 & b2;
        a = P3 | 0, _ = Q3 | 0, P3 = v | 0, Q3 = j4 | 0, v = w | 0, j4 = k2 | 0, { h: w, l: k2 } = e.add(x | 0, C | 0, Z3 | 0, gt5 | 0), x = l | 0, C = b2 | 0, l = m | 0, b2 = V2 | 0, m = A | 0, V2 = L | 0;
        const Pt4 = e.add3L(gt5, St5, ke3);
        A = e.add3H(Pt4, Z3, kt5, Ot5), L = Pt4 | 0;
      }
      ({ h: A, l: L } = e.add(this.Ah | 0, this.Al | 0, A | 0, L | 0)), { h: m, l: V2 } = e.add(this.Bh | 0, this.Bl | 0, m | 0, V2 | 0), { h: l, l: b2 } = e.add(this.Ch | 0, this.Cl | 0, l | 0, b2 | 0), { h: x, l: C } = e.add(this.Dh | 0, this.Dl | 0, x | 0, C | 0), { h: w, l: k2 } = e.add(this.Eh | 0, this.El | 0, w | 0, k2 | 0), { h: v, l: j4 } = e.add(this.Fh | 0, this.Fl | 0, v | 0, j4 | 0), { h: P3, l: Q3 } = e.add(this.Gh | 0, this.Gl | 0, P3 | 0, Q3 | 0), { h: a, l: _ } = e.add(this.Hh | 0, this.Hl | 0, a | 0, _ | 0), this.set(A, L, m, V2, l, b2, x, C, w, k2, v, j4, P3, Q3, a, _);
    }
    roundClean() {
      (0, s.clean)(d, f);
    }
    destroy() {
      (0, s.clean)(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  F.SHA512 = y;
  class p extends y {
    constructor() {
      super(48), this.Ah = t.SHA384_IV[0] | 0, this.Al = t.SHA384_IV[1] | 0, this.Bh = t.SHA384_IV[2] | 0, this.Bl = t.SHA384_IV[3] | 0, this.Ch = t.SHA384_IV[4] | 0, this.Cl = t.SHA384_IV[5] | 0, this.Dh = t.SHA384_IV[6] | 0, this.Dl = t.SHA384_IV[7] | 0, this.Eh = t.SHA384_IV[8] | 0, this.El = t.SHA384_IV[9] | 0, this.Fh = t.SHA384_IV[10] | 0, this.Fl = t.SHA384_IV[11] | 0, this.Gh = t.SHA384_IV[12] | 0, this.Gl = t.SHA384_IV[13] | 0, this.Hh = t.SHA384_IV[14] | 0, this.Hl = t.SHA384_IV[15] | 0;
    }
  }
  F.SHA384 = p;
  const g = Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]), S2 = Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  class U extends y {
    constructor() {
      super(28), this.Ah = g[0] | 0, this.Al = g[1] | 0, this.Bh = g[2] | 0, this.Bl = g[3] | 0, this.Ch = g[4] | 0, this.Cl = g[5] | 0, this.Dh = g[6] | 0, this.Dl = g[7] | 0, this.Eh = g[8] | 0, this.El = g[9] | 0, this.Fh = g[10] | 0, this.Fl = g[11] | 0, this.Gh = g[12] | 0, this.Gl = g[13] | 0, this.Hh = g[14] | 0, this.Hl = g[15] | 0;
    }
  }
  F.SHA512_224 = U;
  class M2 extends y {
    constructor() {
      super(32), this.Ah = S2[0] | 0, this.Al = S2[1] | 0, this.Bh = S2[2] | 0, this.Bl = S2[3] | 0, this.Ch = S2[4] | 0, this.Cl = S2[5] | 0, this.Dh = S2[6] | 0, this.Dl = S2[7] | 0, this.Eh = S2[8] | 0, this.El = S2[9] | 0, this.Fh = S2[10] | 0, this.Fl = S2[11] | 0, this.Gh = S2[12] | 0, this.Gl = S2[13] | 0, this.Hh = S2[14] | 0, this.Hl = S2[15] | 0;
    }
  }
  return F.SHA512_256 = M2, F.sha256 = (0, s.createHasher)(() => new r()), F.sha224 = (0, s.createHasher)(() => new c()), F.sha512 = (0, s.createHasher)(() => new y()), F.sha384 = (0, s.createHasher)(() => new p()), F.sha512_256 = (0, s.createHasher)(() => new M2()), F.sha512_224 = (0, s.createHasher)(() => new U()), F;
}
var ee;
function R0() {
  if (ee) return z;
  ee = 1, Object.defineProperty(z, "__esModule", { value: true }), z.sha224 = z.SHA224 = z.sha256 = z.SHA256 = void 0;
  const t = Ce();
  return z.SHA256 = t.SHA256, z.sha256 = t.sha256, z.SHA224 = t.SHA224, z.sha224 = t.sha224, z;
}
var G = {};
var se;
function W0() {
  if (se) return G;
  se = 1, Object.defineProperty(G, "__esModule", { value: true }), G.sha512_256 = G.SHA512_256 = G.sha512_224 = G.SHA512_224 = G.sha384 = G.SHA384 = G.sha512 = G.SHA512 = void 0;
  const t = Ce();
  return G.SHA512 = t.SHA512, G.sha512 = t.sha512, G.SHA384 = t.SHA384, G.sha384 = t.sha384, G.SHA512_224 = t.SHA512_224, G.sha512_224 = t.sha512_224, G.SHA512_256 = t.SHA512_256, G.sha512_256 = t.sha512_256, G;
}
var yt = {};
var vt = {};
var ne;
function C0() {
  return ne || (ne = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: true }), t.hmac = t.HMAC = void 0;
    const e = Ct();
    class s extends e.Hash {
      constructor(r, c) {
        super(), this.finished = false, this.destroyed = false, (0, e.ahash)(r);
        const o = (0, e.toBytes)(c);
        if (this.iHash = r.create(), typeof this.iHash.update != "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const h = this.blockLen, u = new Uint8Array(h);
        u.set(o.length > h ? r.create().update(o).digest() : o);
        for (let d = 0; d < u.length; d++)
          u[d] ^= 54;
        this.iHash.update(u), this.oHash = r.create();
        for (let d = 0; d < u.length; d++)
          u[d] ^= 106;
        this.oHash.update(u), (0, e.clean)(u);
      }
      update(r) {
        return (0, e.aexists)(this), this.iHash.update(r), this;
      }
      digestInto(r) {
        (0, e.aexists)(this), (0, e.abytes)(r, this.outputLen), this.finished = true, this.iHash.digestInto(r), this.oHash.update(r), this.oHash.digestInto(r), this.destroy();
      }
      digest() {
        const r = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(r), r;
      }
      _cloneInto(r) {
        r || (r = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: c, iHash: o, finished: h, destroyed: u, blockLen: d, outputLen: f } = this;
        return r = r, r.finished = h, r.destroyed = u, r.blockLen = d, r.outputLen = f, r.oHash = c._cloneInto(r.oHash), r.iHash = o._cloneInto(r.iHash), r;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
      }
    }
    t.HMAC = s;
    const i = (n, r, c) => new s(n, r).update(c).digest();
    t.hmac = i, t.hmac.create = (n, r) => new s(n, r);
  })(vt)), vt;
}
var re;
function q0() {
  if (re) return yt;
  re = 1, Object.defineProperty(yt, "__esModule", { value: true }), yt.pbkdf2 = n, yt.pbkdf2Async = r;
  const t = C0(), e = Ct();
  function s(c, o, h, u) {
    (0, e.ahash)(c);
    const d = (0, e.checkOpts)({ dkLen: 32, asyncTick: 10 }, u), { c: f, dkLen: y, asyncTick: p } = d;
    if ((0, e.anumber)(f), (0, e.anumber)(y), (0, e.anumber)(p), f < 1)
      throw new Error("iterations (c) should be >= 1");
    const g = (0, e.kdfInputToBytes)(o), S2 = (0, e.kdfInputToBytes)(h), U = new Uint8Array(y), M2 = t.hmac.create(c, g), D2 = M2._cloneInto().update(S2);
    return { c: f, dkLen: y, asyncTick: p, DK: U, PRF: M2, PRFSalt: D2 };
  }
  function i(c, o, h, u, d) {
    return c.destroy(), o.destroy(), u && u.destroy(), (0, e.clean)(d), h;
  }
  function n(c, o, h, u) {
    const { c: d, dkLen: f, DK: y, PRF: p, PRFSalt: g } = s(c, o, h, u);
    let S2;
    const U = new Uint8Array(4), M2 = (0, e.createView)(U), D2 = new Uint8Array(p.outputLen);
    for (let H3 = 1, E2 = 0; E2 < f; H3++, E2 += p.outputLen) {
      const A = y.subarray(E2, E2 + p.outputLen);
      M2.setInt32(0, H3, false), (S2 = g._cloneInto(S2)).update(U).digestInto(D2), A.set(D2.subarray(0, A.length));
      for (let L = 1; L < d; L++) {
        p._cloneInto(S2).update(D2).digestInto(D2);
        for (let m = 0; m < A.length; m++)
          A[m] ^= D2[m];
      }
    }
    return i(p, g, y, S2, D2);
  }
  async function r(c, o, h, u) {
    const { c: d, dkLen: f, asyncTick: y, DK: p, PRF: g, PRFSalt: S2 } = s(c, o, h, u);
    let U;
    const M2 = new Uint8Array(4), D2 = (0, e.createView)(M2), H3 = new Uint8Array(g.outputLen);
    for (let E2 = 1, A = 0; A < f; E2++, A += g.outputLen) {
      const L = p.subarray(A, A + g.outputLen);
      D2.setInt32(0, E2, false), (U = S2._cloneInto(U)).update(M2).digestInto(H3), L.set(H3.subarray(0, L.length)), await (0, e.asyncLoop)(d - 1, y, () => {
        g._cloneInto(U).update(H3).digestInto(H3);
        for (let m = 0; m < L.length; m++)
          L[m] ^= H3[m];
      });
    }
    return i(g, S2, p, U, H3);
  }
  return yt;
}

// node_modules/@btc-vision/transaction/browser/noble-curves.js
var Rt2 = BigInt(0);
var Bt2 = BigInt(1);
function dt2(n, t = "") {
  if (typeof n != "boolean") {
    const r = t && `"${t}" `;
    throw new Error(r + "expected boolean, got type=" + typeof n);
  }
  return n;
}
function zt2(n) {
  if (typeof n == "bigint") {
    if (!ut(n))
      throw new Error("positive bigint expected, got " + n);
  } else
    Ut(n);
  return n;
}
function ct2(n) {
  const t = zt2(n).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function Ct2(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  return n === "" ? Rt2 : BigInt("0x" + n);
}
function wt2(n) {
  return Ct2(O0(n));
}
function Ht2(n) {
  return Ct2(O0(we2(ft(n)).reverse()));
}
function xt2(n, t) {
  Ut(t), n = zt2(n);
  const r = D0(n.toString(16).padStart(t * 2, "0"));
  if (r.length !== t)
    throw new Error("number too large");
  return r;
}
function Xt2(n, t) {
  return xt2(n, t).reverse();
}
function we2(n) {
  return Uint8Array.from(n);
}
var ut = (n) => typeof n == "bigint" && Rt2 <= n;
function ge2(n, t, r) {
  return ut(n) && ut(t) && ut(r) && t <= n && n < r;
}
function me2(n, t, r, e) {
  if (!ge2(t, r, e))
    throw new Error("expected valid " + n + ": " + r + " <= n < " + e + ", got " + t);
}
function be2(n) {
  let t;
  for (t = 0; n > Rt2; n >>= Bt2, t += 1)
    ;
  return t;
}
var St = (n) => (Bt2 << BigInt(n)) - Bt2;
function Ee2(n, t, r) {
  if (Ut(n, "hashLen"), Ut(t, "qByteLen"), typeof r != "function")
    throw new Error("hmacFn must be a function");
  const e = (R3) => new Uint8Array(R3), o = Uint8Array.of(), s = Uint8Array.of(0), i = Uint8Array.of(1), u = 1e3;
  let c = e(n), a = e(n), w = 0;
  const S2 = () => {
    c.fill(1), a.fill(0), w = 0;
  }, q3 = (...R3) => r(a, F0(c, ...R3)), B2 = (R3 = o) => {
    a = q3(s, R3), c = q3(), R3.length !== 0 && (a = q3(i, R3), c = q3());
  }, v = () => {
    if (w++ >= u)
      throw new Error("drbg: tried max amount of iterations");
    let R3 = 0;
    const N3 = [];
    for (; R3 < t; ) {
      c = q3();
      const T = c.slice();
      N3.push(T), R3 += c.length;
    }
    return F0(...N3);
  };
  return (R3, N3) => {
    S2(), B2(R3);
    let T;
    for (; !(T = N3(v())); )
      B2();
    return S2(), T;
  };
}
function Ot(n, t = {}, r = {}) {
  if (!n || typeof n != "object")
    throw new Error("expected valid options object");
  function e(s, i, u) {
    const c = n[s];
    if (u && c === void 0)
      return;
    const a = typeof c;
    if (a !== i || c === null)
      throw new Error(`param "${s}" is invalid: expected ${i}, got ${a}`);
  }
  const o = (s, i) => Object.entries(s).forEach(([u, c]) => e(u, c, i));
  o(t, false), o(r, true);
}
function At2(n) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...e) => {
    const o = t.get(r);
    if (o !== void 0)
      return o;
    const s = n(r, ...e);
    return t.set(r, s), s;
  };
}
function qt2(n) {
  if (!Number.isSafeInteger(n) || n < 0 || n > 4294967295)
    throw new Error("wrong u32 integer:" + n);
  return n;
}
function Gt2(n) {
  return qt2(n), (n & n - 1) === 0 && n !== 0;
}
function ye2(n, t) {
  qt2(n);
  let r = 0;
  for (let e = 0; e < t; e++, n >>>= 1)
    r = r << 1 | n & 1;
  return r;
}
function Wt2(n) {
  return qt2(n), 31 - Math.clz32(n);
}
function Lt2(n) {
  const t = n.length;
  if (t < 2 || !Gt2(t))
    throw new Error("n must be a power of 2 and greater than 1. Got " + t);
  const r = Wt2(t);
  for (let e = 0; e < t; e++) {
    const o = ye2(e, r);
    if (e < o) {
      const s = n[e];
      n[e] = n[o], n[o] = s;
    }
  }
  return n;
}
var Ce2 = (n, t) => {
  const { N: r, roots: e, dit: o, invertButterflies: s = false, skipStages: i = 0, brp: u = true } = t, c = Wt2(r);
  if (!Gt2(r))
    throw new Error("FFT: Polynomial size should be power of two");
  const a = o !== s;
  return (w) => {
    if (w.length !== r)
      throw new Error("FFT: wrong Polynomial length");
    o && u && Lt2(w);
    for (let S2 = 0, q3 = 1; S2 < c - i; S2++) {
      const B2 = o ? S2 + 1 + i : c - S2, v = 1 << B2, _ = v >> 1, R3 = r >> B2;
      for (let N3 = 0; N3 < r; N3 += v)
        for (let T = 0, C = q3++; T < _; T++) {
          const Y2 = s ? o ? r - C : C : T * R3, K3 = N3 + T, M2 = N3 + T + _, F3 = e[Y2], H3 = w[M2], x = w[K3];
          if (a) {
            const P3 = n.mul(H3, F3);
            w[K3] = n.add(x, P3), w[M2] = n.sub(x, P3);
          } else s ? (w[K3] = n.add(H3, x), w[M2] = n.mul(n.sub(H3, x), F3)) : (w[K3] = n.add(x, H3), w[M2] = n.mul(n.sub(x, H3), F3));
        }
    }
    return !o && u && Lt2(w), w;
  };
};
var j = BigInt(0);
var $2 = BigInt(1);
var et2 = BigInt(2);
var Qt2 = BigInt(3);
var Jt2 = BigInt(4);
var Ft2 = BigInt(5);
var Be2 = BigInt(7);
var Pt = BigInt(8);
var pe2 = BigInt(9);
var te2 = BigInt(16);
function X2(n, t) {
  const r = n % t;
  return r >= j ? r : t + r;
}
function z2(n, t, r) {
  let e = n;
  for (; t-- > j; )
    e *= e, e %= r;
  return e;
}
function Dt2(n, t) {
  if (n === j)
    throw new Error("invert: expected non-zero number");
  if (t <= j)
    throw new Error("invert: expected positive modulus, got " + t);
  let r = X2(n, t), e = t, o = j, s = $2;
  for (; r !== j; ) {
    const u = e / r, c = e % r, a = o - s * u;
    e = r, r = c, o = s, s = a;
  }
  if (e !== $2)
    throw new Error("invert: does not exist");
  return X2(o, t);
}
function It2(n, t, r) {
  if (!n.eql(n.sqr(t), r))
    throw new Error("Cannot find square root");
}
function ee2(n, t) {
  const r = (n.ORDER + $2) / Jt2, e = n.pow(t, r);
  return It2(n, e, t), e;
}
function ve2(n, t) {
  const r = (n.ORDER - Ft2) / Pt, e = n.mul(t, et2), o = n.pow(e, r), s = n.mul(t, o), i = n.mul(n.mul(s, et2), o), u = n.mul(s, n.sub(i, n.ONE));
  return It2(n, u, t), u;
}
function Re2(n) {
  const t = gt(n), r = ne2(n), e = r(t, t.neg(t.ONE)), o = r(t, e), s = r(t, t.neg(e)), i = (n + Be2) / te2;
  return (u, c) => {
    let a = u.pow(c, i), w = u.mul(a, e);
    const S2 = u.mul(a, o), q3 = u.mul(a, s), B2 = u.eql(u.sqr(w), c), v = u.eql(u.sqr(S2), c);
    a = u.cmov(a, w, B2), w = u.cmov(q3, S2, v);
    const _ = u.eql(u.sqr(w), c), R3 = u.cmov(a, w, _);
    return It2(u, R3, c), R3;
  };
}
function ne2(n) {
  if (n < Qt2)
    throw new Error("sqrt is not defined for small field");
  let t = n - $2, r = 0;
  for (; t % et2 === j; )
    t /= et2, r++;
  let e = et2;
  const o = gt(n);
  for (; Tt2(o, e) === 1; )
    if (e++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r === 1)
    return ee2;
  let s = o.pow(e, t);
  const i = (t + $2) / et2;
  return function(c, a) {
    if (c.is0(a))
      return a;
    if (Tt2(c, a) !== 1)
      throw new Error("Cannot find square root");
    let w = r, S2 = c.mul(c.ONE, s), q3 = c.pow(a, t), B2 = c.pow(a, i);
    for (; !c.eql(q3, c.ONE); ) {
      if (c.is0(q3))
        return c.ZERO;
      let v = 1, _ = c.sqr(q3);
      for (; !c.eql(_, c.ONE); )
        if (v++, _ = c.sqr(_), v === w)
          throw new Error("Cannot find square root");
      const R3 = $2 << BigInt(w - v - 1), N3 = c.pow(S2, R3);
      w = v, S2 = c.sqr(N3), q3 = c.mul(q3, S2), B2 = c.mul(B2, N3);
    }
    return B2;
  };
}
function xe2(n) {
  return n % Jt2 === Qt2 ? ee2 : n % Pt === Ft2 ? ve2 : n % te2 === pe2 ? Re2(n) : ne2(n);
}
var Se2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Oe2(n) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r = Se2.reduce((e, o) => (e[o] = "function", e), t);
  return Ot(n, r), n;
}
function qe2(n, t, r) {
  if (r < j)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === j)
    return n.ONE;
  if (r === $2)
    return t;
  let e = n.ONE, o = t;
  for (; r > j; )
    r & $2 && (e = n.mul(e, o)), o = n.sqr(o), r >>= $2;
  return e;
}
function re2(n, t, r = false) {
  const e = new Array(t.length).fill(r ? n.ZERO : void 0), o = t.reduce((i, u, c) => n.is0(u) ? i : (e[c] = i, n.mul(i, u)), n.ONE), s = n.inv(o);
  return t.reduceRight((i, u, c) => n.is0(u) ? i : (e[c] = n.mul(i, e[c]), n.mul(i, u)), s), e;
}
function Tt2(n, t) {
  const r = (n.ORDER - $2) / et2, e = n.pow(t, r), o = n.eql(e, n.ONE), s = n.eql(e, n.ZERO), i = n.eql(e, n.neg(n.ONE));
  if (!o && !s && !i)
    throw new Error("invalid Legendre symbol result");
  return o ? 1 : s ? 0 : -1;
}
function Ie2(n, t) {
  t !== void 0 && Ut(t);
  const r = t !== void 0 ? t : n.toString(2).length, e = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: e };
}
var Ne2 = class {
  constructor(t, r = {}) {
    __publicField(this, "ORDER");
    __publicField(this, "BITS");
    __publicField(this, "BYTES");
    __publicField(this, "isLE");
    __publicField(this, "ZERO", j);
    __publicField(this, "ONE", $2);
    __publicField(this, "_lengths");
    __publicField(this, "_sqrt");
    // cached sqrt
    __publicField(this, "_mod");
    var _a37;
    if (t <= j)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let e;
    this.isLE = false, r != null && typeof r == "object" && (typeof r.BITS == "number" && (e = r.BITS), typeof r.sqrt == "function" && (this.sqrt = r.sqrt), typeof r.isLE == "boolean" && (this.isLE = r.isLE), r.allowedLengths && (this._lengths = (_a37 = r.allowedLengths) == null ? void 0 : _a37.slice()), typeof r.modFromBytes == "boolean" && (this._mod = r.modFromBytes));
    const { nBitLength: o, nByteLength: s } = Ie2(t, e);
    if (s > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = o, this.BYTES = s, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return X2(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return j <= t && t < this.ORDER;
  }
  is0(t) {
    return t === j;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & $2) === $2;
  }
  neg(t) {
    return X2(-t, this.ORDER);
  }
  eql(t, r) {
    return t === r;
  }
  sqr(t) {
    return X2(t * t, this.ORDER);
  }
  add(t, r) {
    return X2(t + r, this.ORDER);
  }
  sub(t, r) {
    return X2(t - r, this.ORDER);
  }
  mul(t, r) {
    return X2(t * r, this.ORDER);
  }
  pow(t, r) {
    return qe2(this, t, r);
  }
  div(t, r) {
    return X2(t * Dt2(r, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, r) {
    return t + r;
  }
  subN(t, r) {
    return t - r;
  }
  mulN(t, r) {
    return t * r;
  }
  inv(t) {
    return Dt2(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = xe2(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? Xt2(t, this.BYTES) : xt2(t, this.BYTES);
  }
  fromBytes(t, r = false) {
    ft(t);
    const { _lengths: e, BYTES: o, isLE: s, ORDER: i, _mod: u } = this;
    if (e) {
      if (!e.includes(t.length) || t.length > o)
        throw new Error("Field.fromBytes: expected " + e + " bytes, got " + t.length);
      const a = new Uint8Array(o);
      a.set(t, s ? 0 : a.length - t.length), t = a;
    }
    if (t.length !== o)
      throw new Error("Field.fromBytes: expected " + o + " bytes, got " + t.length);
    let c = s ? Ht2(t) : wt2(t);
    if (u && (c = X2(c, i)), !r && !this.isValid(c))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return c;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return re2(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, r, e) {
    return e ? r : t;
  }
};
function gt(n, t = {}) {
  return new Ne2(n, t);
}
function oe2(n) {
  if (typeof n != "bigint")
    throw new Error("field order must be bigint");
  const t = n.toString(2).length;
  return Math.ceil(t / 8);
}
function ie2(n) {
  const t = oe2(n);
  return t + Math.ceil(t / 2);
}
function _e2(n, t, r = false) {
  ft(n);
  const e = n.length, o = oe2(t), s = ie2(t);
  if (e < 16 || e < s || e > 1024)
    throw new Error("expected " + s + "-1024 bytes of input, got " + e);
  const i = r ? Ht2(n) : wt2(n), u = X2(i, t - $2) + $2;
  return r ? Xt2(u, o) : xt2(u, o);
}
var ot2 = BigInt(0);
var nt2 = BigInt(1);
function at2(n, t) {
  const r = t.negate();
  return n ? r : t;
}
function Ut2(n, t) {
  const r = re2(n.Fp, t.map((e) => e.Z));
  return t.map((e, o) => n.fromAffine(e.toAffine(r[o])));
}
function se2(n, t) {
  if (!Number.isSafeInteger(n) || n <= 0 || n > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + n);
}
function mt2(n, t) {
  se2(n, t);
  const r = Math.ceil(t / n) + 1, e = 2 ** (n - 1), o = 2 ** n, s = St(n), i = BigInt(n);
  return { windows: r, windowSize: e, mask: s, maxNumber: o, shiftBy: i };
}
function Yt2(n, t, r) {
  const { windowSize: e, mask: o, maxNumber: s, shiftBy: i } = r;
  let u = Number(n & o), c = n >> i;
  u > e && (u -= s, c += nt2);
  const a = t * e, w = a + Math.abs(u) - 1, S2 = u === 0, q3 = u < 0, B2 = t % 2 !== 0;
  return { nextN: c, offset: w, isZero: S2, isNeg: q3, isNegF: B2, offsetF: a };
}
var bt2 = /* @__PURE__ */ new WeakMap();
var ce2 = /* @__PURE__ */ new WeakMap();
function Et2(n) {
  return ce2.get(n) || 1;
}
function kt(n) {
  if (n !== ot2)
    throw new Error("invalid wNAF");
}
var Ze2 = class {
  // Parametrized with a given Point class (not individual point)
  constructor(t, r) {
    __publicField(this, "BASE");
    __publicField(this, "ZERO");
    __publicField(this, "Fn");
    __publicField(this, "bits");
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = r;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, r, e = this.ZERO) {
    let o = t;
    for (; r > ot2; )
      r & nt2 && (e = e.add(o)), o = o.double(), r >>= nt2;
    return e;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, r) {
    const { windows: e, windowSize: o } = mt2(r, this.bits), s = [];
    let i = t, u = i;
    for (let c = 0; c < e; c++) {
      u = i, s.push(u);
      for (let a = 1; a < o; a++)
        u = u.add(i), s.push(u);
      i = u.double();
    }
    return s;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, r, e) {
    if (!this.Fn.isValid(e))
      throw new Error("invalid scalar");
    let o = this.ZERO, s = this.BASE;
    const i = mt2(t, this.bits);
    for (let u = 0; u < i.windows; u++) {
      const { nextN: c, offset: a, isZero: w, isNeg: S2, isNegF: q3, offsetF: B2 } = Yt2(e, u, i);
      e = c, w ? s = s.add(at2(q3, r[B2])) : o = o.add(at2(S2, r[a]));
    }
    return kt(e), { p: o, f: s };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, r, e, o = this.ZERO) {
    const s = mt2(t, this.bits);
    for (let i = 0; i < s.windows && e !== ot2; i++) {
      const { nextN: u, offset: c, isZero: a, isNeg: w } = Yt2(e, i, s);
      if (e = u, !a) {
        const S2 = r[c];
        o = o.add(w ? S2.negate() : S2);
      }
    }
    return kt(e), o;
  }
  getPrecomputes(t, r, e) {
    let o = bt2.get(r);
    return o || (o = this.precomputeWindow(r, t), t !== 1 && (typeof e == "function" && (o = e(o)), bt2.set(r, o))), o;
  }
  cached(t, r, e) {
    const o = Et2(t);
    return this.wNAF(o, this.getPrecomputes(o, t, e), r);
  }
  unsafe(t, r, e, o) {
    const s = Et2(t);
    return s === 1 ? this._unsafeLadder(t, r, o) : this.wNAFUnsafe(s, this.getPrecomputes(s, t, e), r, o);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, r) {
    se2(r, this.bits), ce2.set(t, r), bt2.delete(t);
  }
  hasCache(t) {
    return Et2(t) !== 1;
  }
};
function Ae2(n, t, r, e) {
  let o = t, s = n.ZERO, i = n.ZERO;
  for (; r > ot2 || e > ot2; )
    r & nt2 && (s = s.add(o)), e & nt2 && (i = i.add(o)), o = o.double(), r >>= nt2, e >>= nt2;
  return { p1: s, p2: i };
}
function Vt2(n, t, r) {
  if (t) {
    if (t.ORDER !== n)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Oe2(t), t;
  } else
    return gt(n, { isLE: r });
}
function Le2(n, t, r = {}, e) {
  if (e === void 0 && (e = n === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${n} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const a = t[c];
    if (!(typeof a == "bigint" && a > ot2))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const o = Vt2(t.p, r.Fp, e), s = Vt2(t.n, r.Fn, e), u = ["Gx", "Gy", "a", "b"];
  for (const c of u)
    if (!o.isValid(t[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: o, Fn: s };
}
function De2(n, t) {
  return function(e) {
    const o = n(e);
    return { secretKey: o, publicKey: t(o) };
  };
}
var $t2 = (n, t) => (n + (n >= 0 ? t : -t) / fe2) / t;
function Te2(n, t, r) {
  const [[e, o], [s, i]] = t, u = $t2(i * n, r), c = $t2(-o * n, r);
  let a = n - u * e - c * s, w = -u * o - c * i;
  const S2 = a < W2, q3 = w < W2;
  S2 && (a = -a), q3 && (w = -w);
  const B2 = St(Math.ceil(be2(r) / 2)) + rt2;
  if (a < W2 || a >= B2 || w < W2 || w >= B2)
    throw new Error("splitScalar (endomorphism): failed, k=" + n);
  return { k1neg: S2, k1: a, k2neg: q3, k2: w };
}
function pt2(n) {
  if (!["compact", "recovered", "der"].includes(n))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return n;
}
function yt2(n, t) {
  const r = {};
  for (let e of Object.keys(t))
    r[e] = n[e] === void 0 ? t[e] : n[e];
  return dt2(r.lowS, "lowS"), dt2(r.prehash, "prehash"), r.format !== void 0 && pt2(r.format), r;
}
var Ue2 = class extends Error {
  constructor(t = "") {
    super(t);
  }
};
var Q = {
  // asn.1 DER encoding utils
  Err: Ue2,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (n, t) => {
      const { Err: r } = Q;
      if (n < 0 || n > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const e = t.length / 2, o = ct2(e);
      if (o.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const s = e > 127 ? ct2(o.length / 2 | 128) : "";
      return ct2(n) + s + o + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(n, t) {
      const { Err: r } = Q;
      let e = 0;
      if (n < 0 || n > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[e++] !== n)
        throw new r("tlv.decode: wrong tlv");
      const o = t[e++], s = !!(o & 128);
      let i = 0;
      if (!s)
        i = o;
      else {
        const c = o & 127;
        if (!c)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const a = t.subarray(e, e + c);
        if (a.length !== c)
          throw new r("tlv.decode: length bytes not complete");
        if (a[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const w of a)
          i = i << 8 | w;
        if (e += c, i < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const u = t.subarray(e, e + i);
      if (u.length !== i)
        throw new r("tlv.decode: wrong value length");
      return { v: u, l: t.subarray(e + i) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(n) {
      const { Err: t } = Q;
      if (n < W2)
        throw new t("integer: negative integers are not allowed");
      let r = ct2(n);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(n) {
      const { Err: t } = Q;
      if (n[0] & 128)
        throw new t("invalid signature integer: negative");
      if (n[0] === 0 && !(n[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return wt2(n);
    }
  },
  toSig(n) {
    const { Err: t, _int: r, _tlv: e } = Q, o = ft(n, void 0, "signature"), { v: s, l: i } = e.decode(48, o);
    if (i.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: u, l: c } = e.decode(2, s), { v: a, l: w } = e.decode(2, c);
    if (w.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: r.decode(u), s: r.decode(a) };
  },
  hexFromSig(n) {
    const { _tlv: t, _int: r } = Q, e = t.encode(2, r.encode(n.r)), o = t.encode(2, r.encode(n.s)), s = e + o;
    return t.encode(48, s);
  }
};
var W2 = BigInt(0);
var rt2 = BigInt(1);
var fe2 = BigInt(2);
var ft2 = BigInt(3);
var Ye2 = BigInt(4);
function ke(n, t = {}) {
  const r = Le2("weierstrass", n, t), { Fp: e, Fn: o } = r;
  let s = r.CURVE;
  const { h: i, n: u } = s;
  Ot(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: c } = t;
  if (c && (!e.is0(s.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const a = le2(e, o);
  function w() {
    if (!e.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function S2(I2, d, l) {
    const { x: f, y: h } = d.toAffine(), m = e.toBytes(f);
    if (dt2(l, "isCompressed"), l) {
      w();
      const E2 = !e.isOdd(h);
      return F0(ue2(E2), m);
    } else
      return F0(Uint8Array.of(4), m, e.toBytes(h));
  }
  function q3(I2) {
    ft(I2, void 0, "Point");
    const { publicKey: d, publicKeyUncompressed: l } = a, f = I2.length, h = I2[0], m = I2.subarray(1);
    if (f === d && (h === 2 || h === 3)) {
      const E2 = e.fromBytes(m);
      if (!e.isValid(E2))
        throw new Error("bad point: is not on curve, wrong x");
      const b2 = _(E2);
      let g;
      try {
        g = e.sqrt(b2);
      } catch (D2) {
        const Z3 = D2 instanceof Error ? ": " + D2.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + Z3);
      }
      w();
      const y = e.isOdd(g);
      return (h & 1) === 1 !== y && (g = e.neg(g)), { x: E2, y: g };
    } else if (f === l && h === 4) {
      const E2 = e.BYTES, b2 = e.fromBytes(m.subarray(0, E2)), g = e.fromBytes(m.subarray(E2, E2 * 2));
      if (!R3(b2, g))
        throw new Error("bad point: is not on curve");
      return { x: b2, y: g };
    } else
      throw new Error(`bad point: got length ${f}, expected compressed=${d} or uncompressed=${l}`);
  }
  const B2 = t.toBytes || S2, v = t.fromBytes || q3;
  function _(I2) {
    const d = e.sqr(I2), l = e.mul(d, I2);
    return e.add(e.add(l, e.mul(I2, s.a)), s.b);
  }
  function R3(I2, d) {
    const l = e.sqr(d), f = _(I2);
    return e.eql(l, f);
  }
  if (!R3(s.Gx, s.Gy))
    throw new Error("bad curve params: generator point");
  const N3 = e.mul(e.pow(s.a, ft2), Ye2), T = e.mul(e.sqr(s.b), BigInt(27));
  if (e.is0(e.add(N3, T)))
    throw new Error("bad curve params: a or b");
  function C(I2, d, l = false) {
    if (!e.isValid(d) || l && e.is0(d))
      throw new Error(`bad point coordinate ${I2}`);
    return d;
  }
  function Y2(I2) {
    if (!(I2 instanceof x))
      throw new Error("Weierstrass Point expected");
  }
  function K3(I2) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return Te2(I2, c.basises, o.ORDER);
  }
  const M2 = At2((I2, d) => {
    const { X: l, Y: f, Z: h } = I2;
    if (e.eql(h, e.ONE))
      return { x: l, y: f };
    const m = I2.is0();
    d == null && (d = m ? e.ONE : e.inv(h));
    const E2 = e.mul(l, d), b2 = e.mul(f, d), g = e.mul(h, d);
    if (m)
      return { x: e.ZERO, y: e.ZERO };
    if (!e.eql(g, e.ONE))
      throw new Error("invZ was invalid");
    return { x: E2, y: b2 };
  }), F3 = At2((I2) => {
    if (I2.is0()) {
      if (t.allowInfinityPoint && !e.is0(I2.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: d, y: l } = I2.toAffine();
    if (!e.isValid(d) || !e.isValid(l))
      throw new Error("bad point: x or y not field elements");
    if (!R3(d, l))
      throw new Error("bad point: equation left != right");
    if (!I2.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function H3(I2, d, l, f, h) {
    return l = new x(e.mul(l.X, I2), l.Y, l.Z), d = at2(f, d), l = at2(h, l), d.add(l);
  }
  const _x2 = class _x2 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(d, l, f) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      this.X = C("x", d), this.Y = C("y", l, true), this.Z = C("z", f), Object.freeze(this);
    }
    static CURVE() {
      return s;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(d) {
      const { x: l, y: f } = d || {};
      if (!d || !e.isValid(l) || !e.isValid(f))
        throw new Error("invalid affine point");
      if (d instanceof _x2)
        throw new Error("projective point not allowed");
      return e.is0(l) && e.is0(f) ? _x2.ZERO : new _x2(l, f, e.ONE);
    }
    static fromBytes(d) {
      const l = _x2.fromAffine(v(ft(d, void 0, "point")));
      return l.assertValidity(), l;
    }
    static fromHex(d) {
      return _x2.fromBytes(D0(d));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(d = 8, l = true) {
      return tt5.createCache(this, d), l || this.multiply(ft2), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      F3(this);
    }
    hasEvenY() {
      const { y: d } = this.toAffine();
      if (!e.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !e.isOdd(d);
    }
    /** Compare one point to another. */
    equals(d) {
      Y2(d);
      const { X: l, Y: f, Z: h } = this, { X: m, Y: E2, Z: b2 } = d, g = e.eql(e.mul(l, b2), e.mul(m, h)), y = e.eql(e.mul(f, b2), e.mul(E2, h));
      return g && y;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _x2(this.X, e.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: d, b: l } = s, f = e.mul(l, ft2), { X: h, Y: m, Z: E2 } = this;
      let b2 = e.ZERO, g = e.ZERO, y = e.ZERO, p = e.mul(h, h), D2 = e.mul(m, m), Z3 = e.mul(E2, E2), O = e.mul(h, m);
      return O = e.add(O, O), y = e.mul(h, E2), y = e.add(y, y), b2 = e.mul(d, y), g = e.mul(f, Z3), g = e.add(b2, g), b2 = e.sub(D2, g), g = e.add(D2, g), g = e.mul(b2, g), b2 = e.mul(O, b2), y = e.mul(f, y), Z3 = e.mul(d, Z3), O = e.sub(p, Z3), O = e.mul(d, O), O = e.add(O, y), y = e.add(p, p), p = e.add(y, p), p = e.add(p, Z3), p = e.mul(p, O), g = e.add(g, p), Z3 = e.mul(m, E2), Z3 = e.add(Z3, Z3), p = e.mul(Z3, O), b2 = e.sub(b2, p), y = e.mul(Z3, D2), y = e.add(y, y), y = e.add(y, y), new _x2(b2, g, y);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(d) {
      Y2(d);
      const { X: l, Y: f, Z: h } = this, { X: m, Y: E2, Z: b2 } = d;
      let g = e.ZERO, y = e.ZERO, p = e.ZERO;
      const D2 = s.a, Z3 = e.mul(s.b, ft2);
      let O = e.mul(l, m), A = e.mul(f, E2), U = e.mul(h, b2), G3 = e.add(l, f), L = e.add(m, E2);
      G3 = e.mul(G3, L), L = e.add(O, A), G3 = e.sub(G3, L), L = e.add(l, h);
      let k2 = e.add(m, b2);
      return L = e.mul(L, k2), k2 = e.add(O, U), L = e.sub(L, k2), k2 = e.add(f, h), g = e.add(E2, b2), k2 = e.mul(k2, g), g = e.add(A, U), k2 = e.sub(k2, g), p = e.mul(D2, L), g = e.mul(Z3, U), p = e.add(g, p), g = e.sub(A, p), p = e.add(A, p), y = e.mul(g, p), A = e.add(O, O), A = e.add(A, O), U = e.mul(D2, U), L = e.mul(Z3, L), A = e.add(A, U), U = e.sub(O, U), U = e.mul(D2, U), L = e.add(L, U), O = e.mul(A, L), y = e.add(y, O), O = e.mul(k2, L), g = e.mul(G3, g), g = e.sub(g, O), O = e.mul(G3, A), p = e.mul(k2, p), p = e.add(p, O), new _x2(g, y, p);
    }
    subtract(d) {
      return this.add(d.negate());
    }
    is0() {
      return this.equals(_x2.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(d) {
      const { endo: l } = t;
      if (!o.isValidNot0(d))
        throw new Error("invalid scalar: out of range");
      let f, h;
      const m = (E2) => tt5.cached(this, E2, (b2) => Ut2(_x2, b2));
      if (l) {
        const { k1neg: E2, k1: b2, k2neg: g, k2: y } = K3(d), { p, f: D2 } = m(b2), { p: Z3, f: O } = m(y);
        h = D2.add(O), f = H3(l.beta, p, Z3, E2, g);
      } else {
        const { p: E2, f: b2 } = m(d);
        f = E2, h = b2;
      }
      return Ut2(_x2, [f, h])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(d) {
      const { endo: l } = t, f = this;
      if (!o.isValid(d))
        throw new Error("invalid scalar: out of range");
      if (d === W2 || f.is0())
        return _x2.ZERO;
      if (d === rt2)
        return f;
      if (tt5.hasCache(this))
        return this.multiply(d);
      if (l) {
        const { k1neg: h, k1: m, k2neg: E2, k2: b2 } = K3(d), { p1: g, p2: y } = Ae2(_x2, f, m, b2);
        return H3(l.beta, g, y, h, E2);
      } else
        return tt5.unsafe(f, d);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(d) {
      return M2(this, d);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: d } = t;
      return i === rt2 ? true : d ? d(_x2, this) : tt5.unsafe(this, u).is0();
    }
    clearCofactor() {
      const { clearCofactor: d } = t;
      return i === rt2 ? this : d ? d(_x2, this) : this.multiplyUnsafe(i);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i).is0();
    }
    toBytes(d = true) {
      return dt2(d, "isCompressed"), this.assertValidity(), B2(_x2, this, d);
    }
    toHex(d = true) {
      return O0(this.toBytes(d));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_x2, "BASE", new _x2(s.Gx, s.Gy, e.ONE));
  // zero / infinity / identity point
  __publicField(_x2, "ZERO", new _x2(e.ZERO, e.ONE, e.ZERO));
  // 0, 1, 0
  // math field
  __publicField(_x2, "Fp", e);
  // scalar field
  __publicField(_x2, "Fn", o);
  let x = _x2;
  const P3 = o.BITS, tt5 = new Ze2(x, t.endo ? Math.ceil(P3 / 2) : P3);
  return x.BASE.precompute(8), x;
}
function ue2(n) {
  return Uint8Array.of(n ? 2 : 3);
}
function le2(n, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + n.BYTES,
    publicKeyUncompressed: 1 + 2 * n.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * t.BYTES
  };
}
function Ve2(n, t = {}) {
  const { Fn: r } = n, e = t.randomBytes || T0, o = Object.assign(le2(n.Fp, r), { seed: ie2(r.ORDER) });
  function s(B2) {
    try {
      const v = r.fromBytes(B2);
      return r.isValidNot0(v);
    } catch {
      return false;
    }
  }
  function i(B2, v) {
    const { publicKey: _, publicKeyUncompressed: R3 } = o;
    try {
      const N3 = B2.length;
      return v === true && N3 !== _ || v === false && N3 !== R3 ? false : !!n.fromBytes(B2);
    } catch {
      return false;
    }
  }
  function u(B2 = e(o.seed)) {
    return _e2(ft(B2, o.seed, "seed"), r.ORDER);
  }
  function c(B2, v = true) {
    return n.BASE.multiply(r.fromBytes(B2)).toBytes(v);
  }
  function a(B2) {
    const { secretKey: v, publicKey: _, publicKeyUncompressed: R3 } = o;
    if (!Oe(B2) || "_lengths" in r && r._lengths || v === _)
      return;
    const N3 = ft(B2, void 0, "key").length;
    return N3 === _ || N3 === R3;
  }
  function w(B2, v, _ = true) {
    if (a(B2) === true)
      throw new Error("first arg must be private key");
    if (a(v) === false)
      throw new Error("second arg must be public key");
    const R3 = r.fromBytes(B2);
    return n.fromBytes(v).multiply(R3).toBytes(_);
  }
  const S2 = {
    isValidSecretKey: s,
    isValidPublicKey: i,
    randomSecretKey: u
  }, q3 = De2(u, c);
  return Object.freeze({ getPublicKey: c, getSharedSecret: w, keygen: q3, Point: n, utils: S2, lengths: o });
}
function $e2(n, t, r = {}) {
  De(t), Ot(r, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r = Object.assign({}, r);
  const e = r.randomBytes || T0, o = r.hmac || ((l, f) => oe(t, l, f)), { Fp: s, Fn: i } = n, { ORDER: u, BITS: c } = i, { keygen: a, getPublicKey: w, getSharedSecret: S2, utils: q3, lengths: B2 } = Ve2(n, r), v = {
    prehash: true,
    lowS: typeof r.lowS == "boolean" ? r.lowS : true,
    format: "compact",
    extraEntropy: false
  }, _ = u * fe2 < s.ORDER;
  function R3(l) {
    const f = u >> rt2;
    return l > f;
  }
  function N3(l, f) {
    if (!i.isValidNot0(f))
      throw new Error(`invalid signature ${l}: out of range 1..Point.Fn.ORDER`);
    return f;
  }
  function T() {
    if (_)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function C(l, f) {
    pt2(f);
    const h = B2.signature, m = f === "compact" ? h : f === "recovered" ? h + 1 : void 0;
    return ft(l, m);
  }
  class Y2 {
    constructor(f, h, m) {
      __publicField(this, "r");
      __publicField(this, "s");
      __publicField(this, "recovery");
      if (this.r = N3("r", f), this.s = N3("s", h), m != null) {
        if (T(), ![0, 1, 2, 3].includes(m))
          throw new Error("invalid recovery id");
        this.recovery = m;
      }
      Object.freeze(this);
    }
    static fromBytes(f, h = v.format) {
      C(f, h);
      let m;
      if (h === "der") {
        const { r: y, s: p } = Q.toSig(ft(f));
        return new Y2(y, p);
      }
      h === "recovered" && (m = f[0], h = "compact", f = f.subarray(1));
      const E2 = B2.signature / 2, b2 = f.subarray(0, E2), g = f.subarray(E2, E2 * 2);
      return new Y2(i.fromBytes(b2), i.fromBytes(g), m);
    }
    static fromHex(f, h) {
      return this.fromBytes(D0(f), h);
    }
    assertRecovery() {
      const { recovery: f } = this;
      if (f == null)
        throw new Error("invalid recovery id: must be present");
      return f;
    }
    addRecoveryBit(f) {
      return new Y2(this.r, this.s, f);
    }
    recoverPublicKey(f) {
      const { r: h, s: m } = this, E2 = this.assertRecovery(), b2 = E2 === 2 || E2 === 3 ? h + u : h;
      if (!s.isValid(b2))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const g = s.toBytes(b2), y = n.fromBytes(F0(ue2((E2 & 1) === 0), g)), p = i.inv(b2), D2 = M2(ft(f, void 0, "msgHash")), Z3 = i.create(-D2 * p), O = i.create(m * p), A = n.BASE.multiplyUnsafe(Z3).add(y.multiplyUnsafe(O));
      if (A.is0())
        throw new Error("invalid recovery: point at infinify");
      return A.assertValidity(), A;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return R3(this.s);
    }
    toBytes(f = v.format) {
      if (pt2(f), f === "der")
        return D0(Q.hexFromSig(this));
      const { r: h, s: m } = this, E2 = i.toBytes(h), b2 = i.toBytes(m);
      return f === "recovered" ? (T(), F0(Uint8Array.of(this.assertRecovery()), E2, b2)) : F0(E2, b2);
    }
    toHex(f) {
      return O0(this.toBytes(f));
    }
  }
  const K3 = r.bits2int || function(f) {
    if (f.length > 8192)
      throw new Error("input is too large");
    const h = wt2(f), m = f.length * 8 - c;
    return m > 0 ? h >> BigInt(m) : h;
  }, M2 = r.bits2int_modN || function(f) {
    return i.create(K3(f));
  }, F3 = St(c);
  function H3(l) {
    return me2("num < 2^" + c, l, W2, F3), i.toBytes(l);
  }
  function x(l, f) {
    return ft(l, void 0, "message"), f ? ft(t(l), void 0, "prehashed message") : l;
  }
  function P3(l, f, h) {
    const { lowS: m, prehash: E2, extraEntropy: b2 } = yt2(h, v);
    l = x(l, E2);
    const g = M2(l), y = i.fromBytes(f);
    if (!i.isValidNot0(y))
      throw new Error("invalid private key");
    const p = [H3(y), H3(g)];
    if (b2 != null && b2 !== false) {
      const A = b2 === true ? e(B2.secretKey) : b2;
      p.push(ft(A, void 0, "extraEntropy"));
    }
    const D2 = F0(...p), Z3 = g;
    function O(A) {
      const U = K3(A);
      if (!i.isValidNot0(U))
        return;
      const G3 = i.inv(U), L = n.BASE.multiply(U).toAffine(), k2 = i.create(L.x);
      if (k2 === W2)
        return;
      const st4 = i.create(G3 * i.create(Z3 + k2 * y));
      if (st4 === W2)
        return;
      let _t27 = (L.x === k2 ? 0 : 2) | Number(L.y & rt2), Zt4 = st4;
      return m && R3(st4) && (Zt4 = i.neg(st4), _t27 ^= 1), new Y2(k2, Zt4, _ ? void 0 : _t27);
    }
    return { seed: D2, k2sig: O };
  }
  function tt5(l, f, h = {}) {
    const { seed: m, k2sig: E2 } = P3(l, f, h);
    return Ee2(t.outputLen, i.BYTES, o)(m, E2).toBytes(h.format);
  }
  function I2(l, f, h, m = {}) {
    const { lowS: E2, prehash: b2, format: g } = yt2(m, v);
    if (h = ft(h, void 0, "publicKey"), f = x(f, b2), !Oe(l)) {
      const y = l instanceof Y2 ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + y);
    }
    C(l, g);
    try {
      const y = Y2.fromBytes(l, g), p = n.fromBytes(h);
      if (E2 && y.hasHighS())
        return false;
      const { r: D2, s: Z3 } = y, O = M2(f), A = i.inv(Z3), U = i.create(O * A), G3 = i.create(D2 * A), L = n.BASE.multiplyUnsafe(U).add(p.multiplyUnsafe(G3));
      return L.is0() ? false : i.create(L.x) === D2;
    } catch {
      return false;
    }
  }
  function d(l, f, h = {}) {
    const { prehash: m } = yt2(h, v);
    return f = x(f, m), Y2.fromBytes(l, "recovered").recoverPublicKey(f).toBytes();
  }
  return Object.freeze({
    keygen: a,
    getPublicKey: w,
    getSharedSecret: S2,
    utils: q3,
    lengths: B2,
    Point: n,
    sign: tt5,
    verify: I2,
    recoverPublicKey: d,
    Signature: Y2,
    hash: t
  });
}
var Nt2 = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var je2 = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var jt2 = BigInt(2);
function Me2(n) {
  const t = Nt2.p, r = BigInt(3), e = BigInt(6), o = BigInt(11), s = BigInt(22), i = BigInt(23), u = BigInt(44), c = BigInt(88), a = n * n * n % t, w = a * a * n % t, S2 = z2(w, r, t) * w % t, q3 = z2(S2, r, t) * w % t, B2 = z2(q3, jt2, t) * a % t, v = z2(B2, o, t) * B2 % t, _ = z2(v, s, t) * v % t, R3 = z2(_, u, t) * _ % t, N3 = z2(R3, c, t) * R3 % t, T = z2(N3, u, t) * _ % t, C = z2(T, r, t) * w % t, Y2 = z2(C, i, t) * v % t, K3 = z2(Y2, e, t) * a % t, M2 = z2(K3, jt2, t);
  if (!vt2.eql(vt2.sqr(M2), n))
    throw new Error("Cannot find square root");
  return M2;
}
var vt2 = gt(Nt2.p, { sqrt: Me2 });
var Ke2 = ke(Nt2, {
  Fp: vt2,
  endo: je2
});
var He2 = $e2(Ke2, l0);

// node_modules/@btc-vision/transaction/browser/vendors.js
var Id = 4;
var ws = 0;
var _s = 1;
var Td = 2;
function Nt3(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
var jd = 0;
var lu = 1;
var Od = 2;
var Rd = 3;
var Pd = 258;
var Fn = 29;
var pa = 256;
var ia = pa + 1 + Fn;
var It3 = 30;
var $n = 19;
var cu = 2 * ia + 1;
var nt3 = 15;
var xi = 16;
var Ud = 7;
var Kn = 256;
var uu = 16;
var fu = 17;
var du = 18;
var fn = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var Ca = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var Cd = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var hu = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var Ld = 512;
var Ur = new Array((ia + 2) * 2);
Nt3(Ur);
var ea = new Array(It3 * 2);
Nt3(ea);
var oa = new Array(Ld);
Nt3(oa);
var na = new Array(Pd - Rd + 1);
Nt3(na);
var Hn = new Array(Fn);
Nt3(Hn);
var Va = new Array(It3);
Nt3(Va);
function Ai(e, t, r, a, i) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = a, this.max_length = i, this.has_stree = e && e.length;
}
var pu;
var gu;
var bu;
function Bi(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
var mu = (e) => e < 256 ? oa[e] : oa[256 + (e >>> 7)];
var sa = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
};
var Ye3 = (e, t, r) => {
  e.bi_valid > xi - r ? (e.bi_buf |= t << e.bi_valid & 65535, sa(e, e.bi_buf), e.bi_buf = t >> xi - e.bi_valid, e.bi_valid += r - xi) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r);
};
var Er = (e, t, r) => {
  Ye3(
    e,
    r[t * 2],
    r[t * 2 + 1]
    /*.Len*/
  );
};
var yu = (e, t) => {
  let r = 0;
  do
    r |= e & 1, e >>>= 1, r <<= 1;
  while (--t > 0);
  return r >>> 1;
};
var Nd = (e) => {
  e.bi_valid === 16 ? (sa(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
};
var qd = (e, t) => {
  const r = t.dyn_tree, a = t.max_code, i = t.stat_desc.static_tree, o = t.stat_desc.has_stree, s = t.stat_desc.extra_bits, n = t.stat_desc.extra_base, p = t.stat_desc.max_length;
  let d, u, w, y, k2, A, E2 = 0;
  for (y = 0; y <= nt3; y++)
    e.bl_count[y] = 0;
  for (r[e.heap[e.heap_max] * 2 + 1] = 0, d = e.heap_max + 1; d < cu; d++)
    u = e.heap[d], y = r[r[u * 2 + 1] * 2 + 1] + 1, y > p && (y = p, E2++), r[u * 2 + 1] = y, !(u > a) && (e.bl_count[y]++, k2 = 0, u >= n && (k2 = s[u - n]), A = r[u * 2], e.opt_len += A * (y + k2), o && (e.static_len += A * (i[u * 2 + 1] + k2)));
  if (E2 !== 0) {
    do {
      for (y = p - 1; e.bl_count[y] === 0; )
        y--;
      e.bl_count[y]--, e.bl_count[y + 1] += 2, e.bl_count[p]--, E2 -= 2;
    } while (E2 > 0);
    for (y = p; y !== 0; y--)
      for (u = e.bl_count[y]; u !== 0; )
        w = e.heap[--d], !(w > a) && (r[w * 2 + 1] !== y && (e.opt_len += (y - r[w * 2 + 1]) * r[w * 2], r[w * 2 + 1] = y), u--);
  }
};
var vu = (e, t, r) => {
  const a = new Array(nt3 + 1);
  let i = 0, o, s;
  for (o = 1; o <= nt3; o++)
    i = i + r[o - 1] << 1, a[o] = i;
  for (s = 0; s <= t; s++) {
    let n = e[s * 2 + 1];
    n !== 0 && (e[s * 2] = yu(a[n]++, n));
  }
};
var Dd = () => {
  let e, t, r, a, i;
  const o = new Array(nt3 + 1);
  for (r = 0, a = 0; a < Fn - 1; a++)
    for (Hn[a] = r, e = 0; e < 1 << fn[a]; e++)
      na[r++] = a;
  for (na[r - 1] = a, i = 0, a = 0; a < 16; a++)
    for (Va[a] = i, e = 0; e < 1 << Ca[a]; e++)
      oa[i++] = a;
  for (i >>= 7; a < It3; a++)
    for (Va[a] = i << 7, e = 0; e < 1 << Ca[a] - 7; e++)
      oa[256 + i++] = a;
  for (t = 0; t <= nt3; t++)
    o[t] = 0;
  for (e = 0; e <= 143; )
    Ur[e * 2 + 1] = 8, e++, o[8]++;
  for (; e <= 255; )
    Ur[e * 2 + 1] = 9, e++, o[9]++;
  for (; e <= 279; )
    Ur[e * 2 + 1] = 7, e++, o[7]++;
  for (; e <= 287; )
    Ur[e * 2 + 1] = 8, e++, o[8]++;
  for (vu(Ur, ia + 1, o), e = 0; e < It3; e++)
    ea[e * 2 + 1] = 5, ea[e * 2] = yu(e, 5);
  pu = new Ai(Ur, fn, pa + 1, ia, nt3), gu = new Ai(ea, Ca, 0, It3, nt3), bu = new Ai(new Array(0), Cd, 0, $n, Ud);
};
var wu = (e) => {
  let t;
  for (t = 0; t < ia; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < It3; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < $n; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[Kn * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
};
var _u = (e) => {
  e.bi_valid > 8 ? sa(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
};
var ks = (e, t, r, a) => {
  const i = t * 2, o = r * 2;
  return e[i] < e[o] || e[i] === e[o] && a[t] <= a[r];
};
var zi = (e, t, r) => {
  const a = e.heap[r];
  let i = r << 1;
  for (; i <= e.heap_len && (i < e.heap_len && ks(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !ks(t, a, e.heap[i], e.depth)); )
    e.heap[r] = e.heap[i], r = i, i <<= 1;
  e.heap[r] = a;
};
var Es = (e, t, r) => {
  let a, i, o = 0, s, n;
  if (e.sym_next !== 0)
    do
      a = e.pending_buf[e.sym_buf + o++] & 255, a += (e.pending_buf[e.sym_buf + o++] & 255) << 8, i = e.pending_buf[e.sym_buf + o++], a === 0 ? Er(e, i, t) : (s = na[i], Er(e, s + pa + 1, t), n = fn[s], n !== 0 && (i -= Hn[s], Ye3(e, i, n)), a--, s = mu(a), Er(e, s, r), n = Ca[s], n !== 0 && (a -= Va[s], Ye3(e, a, n)));
    while (o < e.sym_next);
  Er(e, Kn, t);
};
var dn = (e, t) => {
  const r = t.dyn_tree, a = t.stat_desc.static_tree, i = t.stat_desc.has_stree, o = t.stat_desc.elems;
  let s, n, p = -1, d;
  for (e.heap_len = 0, e.heap_max = cu, s = 0; s < o; s++)
    r[s * 2] !== 0 ? (e.heap[++e.heap_len] = p = s, e.depth[s] = 0) : r[s * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    d = e.heap[++e.heap_len] = p < 2 ? ++p : 0, r[d * 2] = 1, e.depth[d] = 0, e.opt_len--, i && (e.static_len -= a[d * 2 + 1]);
  for (t.max_code = p, s = e.heap_len >> 1; s >= 1; s--)
    zi(e, r, s);
  d = o;
  do
    s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], zi(
      e,
      r,
      1
      /*SMALLEST*/
    ), n = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = s, e.heap[--e.heap_max] = n, r[d * 2] = r[s * 2] + r[n * 2], e.depth[d] = (e.depth[s] >= e.depth[n] ? e.depth[s] : e.depth[n]) + 1, r[s * 2 + 1] = r[n * 2 + 1] = d, e.heap[
      1
      /*SMALLEST*/
    ] = d++, zi(
      e,
      r,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], qd(e, t), vu(r, p, e.bl_count);
};
var xs = (e, t, r) => {
  let a, i = -1, o, s = t[1], n = 0, p = 7, d = 4;
  for (s === 0 && (p = 138, d = 3), t[(r + 1) * 2 + 1] = 65535, a = 0; a <= r; a++)
    o = s, s = t[(a + 1) * 2 + 1], !(++n < p && o === s) && (n < d ? e.bl_tree[o * 2] += n : o !== 0 ? (o !== i && e.bl_tree[o * 2]++, e.bl_tree[uu * 2]++) : n <= 10 ? e.bl_tree[fu * 2]++ : e.bl_tree[du * 2]++, n = 0, i = o, s === 0 ? (p = 138, d = 3) : o === s ? (p = 6, d = 3) : (p = 7, d = 4));
};
var As = (e, t, r) => {
  let a, i = -1, o, s = t[1], n = 0, p = 7, d = 4;
  for (s === 0 && (p = 138, d = 3), a = 0; a <= r; a++)
    if (o = s, s = t[(a + 1) * 2 + 1], !(++n < p && o === s)) {
      if (n < d)
        do
          Er(e, o, e.bl_tree);
        while (--n !== 0);
      else o !== 0 ? (o !== i && (Er(e, o, e.bl_tree), n--), Er(e, uu, e.bl_tree), Ye3(e, n - 3, 2)) : n <= 10 ? (Er(e, fu, e.bl_tree), Ye3(e, n - 3, 3)) : (Er(e, du, e.bl_tree), Ye3(e, n - 11, 7));
      n = 0, i = o, s === 0 ? (p = 138, d = 3) : o === s ? (p = 6, d = 3) : (p = 7, d = 4);
    }
};
var Md = (e) => {
  let t;
  for (xs(e, e.dyn_ltree, e.l_desc.max_code), xs(e, e.dyn_dtree, e.d_desc.max_code), dn(e, e.bl_desc), t = $n - 1; t >= 3 && e.bl_tree[hu[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
};
var Fd = (e, t, r, a) => {
  let i;
  for (Ye3(e, t - 257, 5), Ye3(e, r - 1, 5), Ye3(e, a - 4, 4), i = 0; i < a; i++)
    Ye3(e, e.bl_tree[hu[i] * 2 + 1], 3);
  As(e, e.dyn_ltree, t - 1), As(e, e.dyn_dtree, r - 1);
};
var $d = (e) => {
  let t = 4093624447, r;
  for (r = 0; r <= 31; r++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[r * 2] !== 0)
      return ws;
  if (e.dyn_ltree[18] !== 0 || e.dyn_ltree[20] !== 0 || e.dyn_ltree[26] !== 0)
    return _s;
  for (r = 32; r < pa; r++)
    if (e.dyn_ltree[r * 2] !== 0)
      return _s;
  return ws;
};
var Bs = false;
var Kd = (e) => {
  Bs || (Dd(), Bs = true), e.l_desc = new Bi(e.dyn_ltree, pu), e.d_desc = new Bi(e.dyn_dtree, gu), e.bl_desc = new Bi(e.bl_tree, bu), e.bi_buf = 0, e.bi_valid = 0, wu(e);
};
var ku = (e, t, r, a) => {
  Ye3(e, (jd << 1) + (a ? 1 : 0), 3), _u(e), sa(e, r), sa(e, ~r), r && e.pending_buf.set(e.window.subarray(t, t + r), e.pending), e.pending += r;
};
var Hd = (e) => {
  Ye3(e, lu << 1, 3), Er(e, Kn, Ur), Nd(e);
};
var Zd = (e, t, r, a) => {
  let i, o, s = 0;
  e.level > 0 ? (e.strm.data_type === Td && (e.strm.data_type = $d(e)), dn(e, e.l_desc), dn(e, e.d_desc), s = Md(e), i = e.opt_len + 3 + 7 >>> 3, o = e.static_len + 3 + 7 >>> 3, o <= i && (i = o)) : i = o = r + 5, r + 4 <= i && t !== -1 ? ku(e, t, r, a) : e.strategy === Id || o === i ? (Ye3(e, (lu << 1) + (a ? 1 : 0), 3), Es(e, Ur, ea)) : (Ye3(e, (Od << 1) + (a ? 1 : 0), 3), Fd(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1), Es(e, e.dyn_ltree, e.dyn_dtree)), wu(e), a && _u(e);
};
var Gd = (e, t, r) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = r, t === 0 ? e.dyn_ltree[r * 2]++ : (e.matches++, t--, e.dyn_ltree[(na[r] + pa + 1) * 2]++, e.dyn_dtree[mu(t) * 2]++), e.sym_next === e.sym_end);
var Vd = Kd;
var Wd = ku;
var Yd = Zd;
var Xd = Gd;
var Jd = Hd;
var Qd = {
  _tr_init: Vd,
  _tr_stored_block: Wd,
  _tr_flush_block: Yd,
  _tr_tally: Xd,
  _tr_align: Jd
};
var eh = (e, t, r, a) => {
  let i = e & 65535 | 0, o = e >>> 16 & 65535 | 0, s = 0;
  for (; r !== 0; ) {
    s = r > 2e3 ? 2e3 : r, r -= s;
    do
      i = i + t[a++] | 0, o = o + i | 0;
    while (--s);
    i %= 65521, o %= 65521;
  }
  return i | o << 16 | 0;
};
var la = eh;
var rh = () => {
  let e, t = [];
  for (var r = 0; r < 256; r++) {
    e = r;
    for (var a = 0; a < 8; a++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[r] = e;
  }
  return t;
};
var th = new Uint32Array(rh());
var ah = (e, t, r, a) => {
  const i = th, o = a + r;
  e ^= -1;
  for (let s = a; s < o; s++)
    e = e >>> 8 ^ i[(e ^ t[s]) & 255];
  return e ^ -1;
};
var Fe2 = ah;
var pt3 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var ga = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init: ih, _tr_stored_block: hn, _tr_flush_block: oh, _tr_tally: Xr, _tr_align: nh } = Qd;
var {
  Z_NO_FLUSH: Jr,
  Z_PARTIAL_FLUSH: sh,
  Z_FULL_FLUSH: lh,
  Z_FINISH: lr,
  Z_BLOCK: zs,
  Z_OK: Ke3,
  Z_STREAM_END: Ss,
  Z_STREAM_ERROR: Br,
  Z_DATA_ERROR: ch,
  Z_BUF_ERROR: Si,
  Z_DEFAULT_COMPRESSION: uh,
  Z_FILTERED: fh,
  Z_HUFFMAN_ONLY: xa,
  Z_RLE: dh,
  Z_FIXED: hh,
  Z_DEFAULT_STRATEGY: ph,
  Z_UNKNOWN: gh,
  Z_DEFLATED: ui
} = ga;
var bh = 9;
var mh = 15;
var yh = 8;
var vh = 29;
var wh = 256;
var pn = wh + 1 + vh;
var _h = 30;
var kh = 19;
var Eh = 2 * pn + 1;
var xh = 15;
var _e3 = 3;
var Wr = 258;
var zr = Wr + _e3 + 1;
var Ah = 32;
var Ot2 = 42;
var Zn = 57;
var gn = 69;
var bn = 73;
var mn = 91;
var yn = 103;
var st2 = 113;
var Wt3 = 666;
var Ve3 = 1;
var qt3 = 2;
var gt2 = 3;
var Dt3 = 4;
var Bh = 3;
var lt2 = (e, t) => (e.msg = pt3[t], t);
var Is = (e) => e * 2 - (e > 4 ? 9 : 0);
var Vr = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
};
var zh = (e) => {
  let t, r, a, i = e.w_size;
  t = e.hash_size, a = t;
  do
    r = e.head[--a], e.head[a] = r >= i ? r - i : 0;
  while (--t);
  t = i, a = t;
  do
    r = e.prev[--a], e.prev[a] = r >= i ? r - i : 0;
  while (--t);
};
var Sh = (e, t, r) => (t << e.hash_shift ^ r) & e.hash_mask;
var Qr = Sh;
var Je2 = (e) => {
  const t = e.state;
  let r = t.pending;
  r > e.avail_out && (r = e.avail_out), r !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + r), e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, t.pending === 0 && (t.pending_out = 0));
};
var rr = (e, t) => {
  oh(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Je2(e.strm);
};
var Ee3 = (e, t) => {
  e.pending_buf[e.pending++] = t;
};
var Ht3 = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
};
var vn = (e, t, r, a) => {
  let i = e.avail_in;
  return i > a && (i = a), i === 0 ? 0 : (e.avail_in -= i, t.set(e.input.subarray(e.next_in, e.next_in + i), r), e.state.wrap === 1 ? e.adler = la(e.adler, t, i, r) : e.state.wrap === 2 && (e.adler = Fe2(e.adler, t, i, r)), e.next_in += i, e.total_in += i, i);
};
var Eu = (e, t) => {
  let r = e.max_chain_length, a = e.strstart, i, o, s = e.prev_length, n = e.nice_match;
  const p = e.strstart > e.w_size - zr ? e.strstart - (e.w_size - zr) : 0, d = e.window, u = e.w_mask, w = e.prev, y = e.strstart + Wr;
  let k2 = d[a + s - 1], A = d[a + s];
  e.prev_length >= e.good_match && (r >>= 2), n > e.lookahead && (n = e.lookahead);
  do
    if (i = t, !(d[i + s] !== A || d[i + s - 1] !== k2 || d[i] !== d[a] || d[++i] !== d[a + 1])) {
      a += 2, i++;
      do
        ;
      while (d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && a < y);
      if (o = Wr - (y - a), a = y - Wr, o > s) {
        if (e.match_start = t, s = o, o >= n)
          break;
        k2 = d[a + s - 1], A = d[a + s];
      }
    }
  while ((t = w[t & u]) > p && --r !== 0);
  return s <= e.lookahead ? s : e.lookahead;
};
var Rt3 = (e) => {
  const t = e.w_size;
  let r, a, i;
  do {
    if (a = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - zr) && (e.window.set(e.window.subarray(t, t + t - a), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), zh(e), a += t), e.strm.avail_in === 0)
      break;
    if (r = vn(e.strm, e.window, e.strstart + e.lookahead, a), e.lookahead += r, e.lookahead + e.insert >= _e3)
      for (i = e.strstart - e.insert, e.ins_h = e.window[i], e.ins_h = Qr(e, e.ins_h, e.window[i + 1]); e.insert && (e.ins_h = Qr(e, e.ins_h, e.window[i + _e3 - 1]), e.prev[i & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = i, i++, e.insert--, !(e.lookahead + e.insert < _e3)); )
        ;
  } while (e.lookahead < zr && e.strm.avail_in !== 0);
};
var xu = (e, t) => {
  let r = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, a, i, o, s = 0, n = e.strm.avail_in;
  do {
    if (a = 65535, o = e.bi_valid + 42 >> 3, e.strm.avail_out < o || (o = e.strm.avail_out - o, i = e.strstart - e.block_start, a > i + e.strm.avail_in && (a = i + e.strm.avail_in), a > o && (a = o), a < r && (a === 0 && t !== lr || t === Jr || a !== i + e.strm.avail_in)))
      break;
    s = t === lr && a === i + e.strm.avail_in ? 1 : 0, hn(e, 0, 0, s), e.pending_buf[e.pending - 4] = a, e.pending_buf[e.pending - 3] = a >> 8, e.pending_buf[e.pending - 2] = ~a, e.pending_buf[e.pending - 1] = ~a >> 8, Je2(e.strm), i && (i > a && (i = a), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + i), e.strm.next_out), e.strm.next_out += i, e.strm.avail_out -= i, e.strm.total_out += i, e.block_start += i, a -= i), a && (vn(e.strm, e.strm.output, e.strm.next_out, a), e.strm.next_out += a, e.strm.avail_out -= a, e.strm.total_out += a);
  } while (s === 0);
  return n -= e.strm.avail_in, n && (n >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= n && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - n, e.strm.next_in), e.strstart), e.strstart += n, e.insert += n > e.w_size - e.insert ? e.w_size - e.insert : n), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), s ? Dt3 : t !== Jr && t !== lr && e.strm.avail_in === 0 && e.strstart === e.block_start ? qt3 : (o = e.window_size - e.strstart, e.strm.avail_in > o && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, o += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), o > e.strm.avail_in && (o = e.strm.avail_in), o && (vn(e.strm, e.window, e.strstart, o), e.strstart += o, e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o), e.high_water < e.strstart && (e.high_water = e.strstart), o = e.bi_valid + 42 >> 3, o = e.pending_buf_size - o > 65535 ? 65535 : e.pending_buf_size - o, r = o > e.w_size ? e.w_size : o, i = e.strstart - e.block_start, (i >= r || (i || t === lr) && t !== Jr && e.strm.avail_in === 0 && i <= o) && (a = i > o ? o : i, s = t === lr && e.strm.avail_in === 0 && a === i ? 1 : 0, hn(e, e.block_start, a, s), e.block_start += a, Je2(e.strm)), s ? gt2 : Ve3);
};
var Ii = (e, t) => {
  let r, a;
  for (; ; ) {
    if (e.lookahead < zr) {
      if (Rt3(e), e.lookahead < zr && t === Jr)
        return Ve3;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= _e3 && (e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + _e3 - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), r !== 0 && e.strstart - r <= e.w_size - zr && (e.match_length = Eu(e, r)), e.match_length >= _e3)
      if (a = Xr(e, e.strstart - e.match_start, e.match_length - _e3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= _e3) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + _e3 - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + 1]);
    else
      a = Xr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (a && (rr(e, false), e.strm.avail_out === 0))
      return Ve3;
  }
  return e.insert = e.strstart < _e3 - 1 ? e.strstart : _e3 - 1, t === lr ? (rr(e, true), e.strm.avail_out === 0 ? gt2 : Dt3) : e.sym_next && (rr(e, false), e.strm.avail_out === 0) ? Ve3 : qt3;
};
var _t2 = (e, t) => {
  let r, a, i;
  for (; ; ) {
    if (e.lookahead < zr) {
      if (Rt3(e), e.lookahead < zr && t === Jr)
        return Ve3;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= _e3 && (e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + _e3 - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = _e3 - 1, r !== 0 && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - zr && (e.match_length = Eu(e, r), e.match_length <= 5 && (e.strategy === fh || e.match_length === _e3 && e.strstart - e.match_start > 4096) && (e.match_length = _e3 - 1)), e.prev_length >= _e3 && e.match_length <= e.prev_length) {
      i = e.strstart + e.lookahead - _e3, a = Xr(e, e.strstart - 1 - e.prev_match, e.prev_length - _e3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= i && (e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + _e3 - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = _e3 - 1, e.strstart++, a && (rr(e, false), e.strm.avail_out === 0))
        return Ve3;
    } else if (e.match_available) {
      if (a = Xr(e, 0, e.window[e.strstart - 1]), a && rr(e, false), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return Ve3;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (a = Xr(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < _e3 - 1 ? e.strstart : _e3 - 1, t === lr ? (rr(e, true), e.strm.avail_out === 0 ? gt2 : Dt3) : e.sym_next && (rr(e, false), e.strm.avail_out === 0) ? Ve3 : qt3;
};
var Ih = (e, t) => {
  let r, a, i, o;
  const s = e.window;
  for (; ; ) {
    if (e.lookahead <= Wr) {
      if (Rt3(e), e.lookahead <= Wr && t === Jr)
        return Ve3;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= _e3 && e.strstart > 0 && (i = e.strstart - 1, a = s[i], a === s[++i] && a === s[++i] && a === s[++i])) {
      o = e.strstart + Wr;
      do
        ;
      while (a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && i < o);
      e.match_length = Wr - (o - i), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= _e3 ? (r = Xr(e, 1, e.match_length - _e3), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = Xr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (rr(e, false), e.strm.avail_out === 0))
      return Ve3;
  }
  return e.insert = 0, t === lr ? (rr(e, true), e.strm.avail_out === 0 ? gt2 : Dt3) : e.sym_next && (rr(e, false), e.strm.avail_out === 0) ? Ve3 : qt3;
};
var Th = (e, t) => {
  let r;
  for (; ; ) {
    if (e.lookahead === 0 && (Rt3(e), e.lookahead === 0)) {
      if (t === Jr)
        return Ve3;
      break;
    }
    if (e.match_length = 0, r = Xr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (rr(e, false), e.strm.avail_out === 0))
      return Ve3;
  }
  return e.insert = 0, t === lr ? (rr(e, true), e.strm.avail_out === 0 ? gt2 : Dt3) : e.sym_next && (rr(e, false), e.strm.avail_out === 0) ? Ve3 : qt3;
};
function pr(e, t, r, a, i) {
  this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = a, this.func = i;
}
var Yt3 = [
  /*      good lazy nice chain */
  new pr(0, 0, 0, 0, xu),
  /* 0 store only */
  new pr(4, 4, 8, 4, Ii),
  /* 1 max speed, no lazy matches */
  new pr(4, 5, 16, 8, Ii),
  /* 2 */
  new pr(4, 6, 32, 32, Ii),
  /* 3 */
  new pr(4, 4, 16, 16, _t2),
  /* 4 lazy matches */
  new pr(8, 16, 32, 32, _t2),
  /* 5 */
  new pr(8, 16, 128, 128, _t2),
  /* 6 */
  new pr(8, 32, 128, 256, _t2),
  /* 7 */
  new pr(32, 128, 258, 1024, _t2),
  /* 8 */
  new pr(32, 258, 258, 4096, _t2)
  /* 9 max compression */
];
var jh = (e) => {
  e.window_size = 2 * e.w_size, Vr(e.head), e.max_lazy_match = Yt3[e.level].max_lazy, e.good_match = Yt3[e.level].good_length, e.nice_match = Yt3[e.level].nice_length, e.max_chain_length = Yt3[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = _e3 - 1, e.match_available = 0, e.ins_h = 0;
};
function Oh() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = ui, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Eh * 2), this.dyn_dtree = new Uint16Array((2 * _h + 1) * 2), this.bl_tree = new Uint16Array((2 * kh + 1) * 2), Vr(this.dyn_ltree), Vr(this.dyn_dtree), Vr(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(xh + 1), this.heap = new Uint16Array(2 * pn + 1), Vr(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * pn + 1), Vr(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
var ba = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.status !== Ot2 && //#ifdef GZIP
  t.status !== Zn && //#endif
  t.status !== gn && t.status !== bn && t.status !== mn && t.status !== yn && t.status !== st2 && t.status !== Wt3 ? 1 : 0;
};
var Au = (e) => {
  if (ba(e))
    return lt2(e, Br);
  e.total_in = e.total_out = 0, e.data_type = gh;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? Zn : (
    //#endif
    t.wrap ? Ot2 : st2
  ), e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, ih(t), Ke3;
};
var Bu = (e) => {
  const t = Au(e);
  return t === Ke3 && jh(e.state), t;
};
var Rh = (e, t) => ba(e) || e.state.wrap !== 2 ? Br : (e.state.gzhead = t, Ke3);
var zu = (e, t, r, a, i, o) => {
  if (!e)
    return Br;
  let s = 1;
  if (t === uh && (t = 6), a < 0 ? (s = 0, a = -a) : a > 15 && (s = 2, a -= 16), i < 1 || i > bh || r !== ui || a < 8 || a > 15 || t < 0 || t > 9 || o < 0 || o > hh || a === 8 && s !== 1)
    return lt2(e, Br);
  a === 8 && (a = 9);
  const n = new Oh();
  return e.state = n, n.strm = e, n.status = Ot2, n.wrap = s, n.gzhead = null, n.w_bits = a, n.w_size = 1 << n.w_bits, n.w_mask = n.w_size - 1, n.hash_bits = i + 7, n.hash_size = 1 << n.hash_bits, n.hash_mask = n.hash_size - 1, n.hash_shift = ~~((n.hash_bits + _e3 - 1) / _e3), n.window = new Uint8Array(n.w_size * 2), n.head = new Uint16Array(n.hash_size), n.prev = new Uint16Array(n.w_size), n.lit_bufsize = 1 << i + 6, n.pending_buf_size = n.lit_bufsize * 4, n.pending_buf = new Uint8Array(n.pending_buf_size), n.sym_buf = n.lit_bufsize, n.sym_end = (n.lit_bufsize - 1) * 3, n.level = t, n.strategy = o, n.method = r, Bu(e);
};
var Ph = (e, t) => zu(e, t, ui, mh, yh, ph);
var Uh = (e, t) => {
  if (ba(e) || t > zs || t < 0)
    return e ? lt2(e, Br) : Br;
  const r = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || r.status === Wt3 && t !== lr)
    return lt2(e, e.avail_out === 0 ? Si : Br);
  const a = r.last_flush;
  if (r.last_flush = t, r.pending !== 0) {
    if (Je2(e), e.avail_out === 0)
      return r.last_flush = -1, Ke3;
  } else if (e.avail_in === 0 && Is(t) <= Is(a) && t !== lr)
    return lt2(e, Si);
  if (r.status === Wt3 && e.avail_in !== 0)
    return lt2(e, Si);
  if (r.status === Ot2 && r.wrap === 0 && (r.status = st2), r.status === Ot2) {
    let i = ui + (r.w_bits - 8 << 4) << 8, o = -1;
    if (r.strategy >= xa || r.level < 2 ? o = 0 : r.level < 6 ? o = 1 : r.level === 6 ? o = 2 : o = 3, i |= o << 6, r.strstart !== 0 && (i |= Ah), i += 31 - i % 31, Ht3(r, i), r.strstart !== 0 && (Ht3(r, e.adler >>> 16), Ht3(r, e.adler & 65535)), e.adler = 1, r.status = st2, Je2(e), r.pending !== 0)
      return r.last_flush = -1, Ke3;
  }
  if (r.status === Zn) {
    if (e.adler = 0, Ee3(r, 31), Ee3(r, 139), Ee3(r, 8), r.gzhead)
      Ee3(
        r,
        (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)
      ), Ee3(r, r.gzhead.time & 255), Ee3(r, r.gzhead.time >> 8 & 255), Ee3(r, r.gzhead.time >> 16 & 255), Ee3(r, r.gzhead.time >> 24 & 255), Ee3(r, r.level === 9 ? 2 : r.strategy >= xa || r.level < 2 ? 4 : 0), Ee3(r, r.gzhead.os & 255), r.gzhead.extra && r.gzhead.extra.length && (Ee3(r, r.gzhead.extra.length & 255), Ee3(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (e.adler = Fe2(e.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = gn;
    else if (Ee3(r, 0), Ee3(r, 0), Ee3(r, 0), Ee3(r, 0), Ee3(r, 0), Ee3(r, r.level === 9 ? 2 : r.strategy >= xa || r.level < 2 ? 4 : 0), Ee3(r, Bh), r.status = st2, Je2(e), r.pending !== 0)
      return r.last_flush = -1, Ke3;
  }
  if (r.status === gn) {
    if (r.gzhead.extra) {
      let i = r.pending, o = (r.gzhead.extra.length & 65535) - r.gzindex;
      for (; r.pending + o > r.pending_buf_size; ) {
        let n = r.pending_buf_size - r.pending;
        if (r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex, r.gzindex + n), r.pending), r.pending = r.pending_buf_size, r.gzhead.hcrc && r.pending > i && (e.adler = Fe2(e.adler, r.pending_buf, r.pending - i, i)), r.gzindex += n, Je2(e), r.pending !== 0)
          return r.last_flush = -1, Ke3;
        i = 0, o -= n;
      }
      let s = new Uint8Array(r.gzhead.extra);
      r.pending_buf.set(s.subarray(r.gzindex, r.gzindex + o), r.pending), r.pending += o, r.gzhead.hcrc && r.pending > i && (e.adler = Fe2(e.adler, r.pending_buf, r.pending - i, i)), r.gzindex = 0;
    }
    r.status = bn;
  }
  if (r.status === bn) {
    if (r.gzhead.name) {
      let i = r.pending, o;
      do {
        if (r.pending === r.pending_buf_size) {
          if (r.gzhead.hcrc && r.pending > i && (e.adler = Fe2(e.adler, r.pending_buf, r.pending - i, i)), Je2(e), r.pending !== 0)
            return r.last_flush = -1, Ke3;
          i = 0;
        }
        r.gzindex < r.gzhead.name.length ? o = r.gzhead.name.charCodeAt(r.gzindex++) & 255 : o = 0, Ee3(r, o);
      } while (o !== 0);
      r.gzhead.hcrc && r.pending > i && (e.adler = Fe2(e.adler, r.pending_buf, r.pending - i, i)), r.gzindex = 0;
    }
    r.status = mn;
  }
  if (r.status === mn) {
    if (r.gzhead.comment) {
      let i = r.pending, o;
      do {
        if (r.pending === r.pending_buf_size) {
          if (r.gzhead.hcrc && r.pending > i && (e.adler = Fe2(e.adler, r.pending_buf, r.pending - i, i)), Je2(e), r.pending !== 0)
            return r.last_flush = -1, Ke3;
          i = 0;
        }
        r.gzindex < r.gzhead.comment.length ? o = r.gzhead.comment.charCodeAt(r.gzindex++) & 255 : o = 0, Ee3(r, o);
      } while (o !== 0);
      r.gzhead.hcrc && r.pending > i && (e.adler = Fe2(e.adler, r.pending_buf, r.pending - i, i));
    }
    r.status = yn;
  }
  if (r.status === yn) {
    if (r.gzhead.hcrc) {
      if (r.pending + 2 > r.pending_buf_size && (Je2(e), r.pending !== 0))
        return r.last_flush = -1, Ke3;
      Ee3(r, e.adler & 255), Ee3(r, e.adler >> 8 & 255), e.adler = 0;
    }
    if (r.status = st2, Je2(e), r.pending !== 0)
      return r.last_flush = -1, Ke3;
  }
  if (e.avail_in !== 0 || r.lookahead !== 0 || t !== Jr && r.status !== Wt3) {
    let i = r.level === 0 ? xu(r, t) : r.strategy === xa ? Th(r, t) : r.strategy === dh ? Ih(r, t) : Yt3[r.level].func(r, t);
    if ((i === gt2 || i === Dt3) && (r.status = Wt3), i === Ve3 || i === gt2)
      return e.avail_out === 0 && (r.last_flush = -1), Ke3;
    if (i === qt3 && (t === sh ? nh(r) : t !== zs && (hn(r, 0, 0, false), t === lh && (Vr(r.head), r.lookahead === 0 && (r.strstart = 0, r.block_start = 0, r.insert = 0))), Je2(e), e.avail_out === 0))
      return r.last_flush = -1, Ke3;
  }
  return t !== lr ? Ke3 : r.wrap <= 0 ? Ss : (r.wrap === 2 ? (Ee3(r, e.adler & 255), Ee3(r, e.adler >> 8 & 255), Ee3(r, e.adler >> 16 & 255), Ee3(r, e.adler >> 24 & 255), Ee3(r, e.total_in & 255), Ee3(r, e.total_in >> 8 & 255), Ee3(r, e.total_in >> 16 & 255), Ee3(r, e.total_in >> 24 & 255)) : (Ht3(r, e.adler >>> 16), Ht3(r, e.adler & 65535)), Je2(e), r.wrap > 0 && (r.wrap = -r.wrap), r.pending !== 0 ? Ke3 : Ss);
};
var Ch = (e) => {
  if (ba(e))
    return Br;
  const t = e.state.status;
  return e.state = null, t === st2 ? lt2(e, ch) : Ke3;
};
var Lh = (e, t) => {
  let r = t.length;
  if (ba(e))
    return Br;
  const a = e.state, i = a.wrap;
  if (i === 2 || i === 1 && a.status !== Ot2 || a.lookahead)
    return Br;
  if (i === 1 && (e.adler = la(e.adler, t, r, 0)), a.wrap = 0, r >= a.w_size) {
    i === 0 && (Vr(a.head), a.strstart = 0, a.block_start = 0, a.insert = 0);
    let p = new Uint8Array(a.w_size);
    p.set(t.subarray(r - a.w_size, r), 0), t = p, r = a.w_size;
  }
  const o = e.avail_in, s = e.next_in, n = e.input;
  for (e.avail_in = r, e.next_in = 0, e.input = t, Rt3(a); a.lookahead >= _e3; ) {
    let p = a.strstart, d = a.lookahead - (_e3 - 1);
    do
      a.ins_h = Qr(a, a.ins_h, a.window[p + _e3 - 1]), a.prev[p & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = p, p++;
    while (--d);
    a.strstart = p, a.lookahead = _e3 - 1, Rt3(a);
  }
  return a.strstart += a.lookahead, a.block_start = a.strstart, a.insert = a.lookahead, a.lookahead = 0, a.match_length = a.prev_length = _e3 - 1, a.match_available = 0, e.next_in = s, e.input = n, e.avail_in = o, a.wrap = i, Ke3;
};
var Nh = Ph;
var qh = zu;
var Dh = Bu;
var Mh = Au;
var Fh = Rh;
var $h = Uh;
var Kh = Ch;
var Hh = Lh;
var Zh = "pako deflate (from Nodeca project)";
var ra = {
  deflateInit: Nh,
  deflateInit2: qh,
  deflateReset: Dh,
  deflateResetKeep: Mh,
  deflateSetHeader: Fh,
  deflate: $h,
  deflateEnd: Kh,
  deflateSetDictionary: Hh,
  deflateInfo: Zh
};
var Gh = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var Vh = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const r = t.shift();
    if (r) {
      if (typeof r != "object")
        throw new TypeError(r + "must be non-object");
      for (const a in r)
        Gh(r, a) && (e[a] = r[a]);
    }
  }
  return e;
};
var Wh = (e) => {
  let t = 0;
  for (let a = 0, i = e.length; a < i; a++)
    t += e[a].length;
  const r = new Uint8Array(t);
  for (let a = 0, i = 0, o = e.length; a < o; a++) {
    let s = e[a];
    r.set(s, i), i += s.length;
  }
  return r;
};
var fi = {
  assign: Vh,
  flattenChunks: Wh
};
var Su = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  Su = false;
}
var ca = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  ca[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
ca[254] = ca[254] = 1;
var Yh = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, r, a, i, o, s = e.length, n = 0;
  for (i = 0; i < s; i++)
    r = e.charCodeAt(i), (r & 64512) === 55296 && i + 1 < s && (a = e.charCodeAt(i + 1), (a & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (a - 56320), i++)), n += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
  for (t = new Uint8Array(n), o = 0, i = 0; o < n; i++)
    r = e.charCodeAt(i), (r & 64512) === 55296 && i + 1 < s && (a = e.charCodeAt(i + 1), (a & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (a - 56320), i++)), r < 128 ? t[o++] = r : r < 2048 ? (t[o++] = 192 | r >>> 6, t[o++] = 128 | r & 63) : r < 65536 ? (t[o++] = 224 | r >>> 12, t[o++] = 128 | r >>> 6 & 63, t[o++] = 128 | r & 63) : (t[o++] = 240 | r >>> 18, t[o++] = 128 | r >>> 12 & 63, t[o++] = 128 | r >>> 6 & 63, t[o++] = 128 | r & 63);
  return t;
};
var Xh = (e, t) => {
  if (t < 65534 && e.subarray && Su)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let r = "";
  for (let a = 0; a < t; a++)
    r += String.fromCharCode(e[a]);
  return r;
};
var Jh = (e, t) => {
  const r = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let a, i;
  const o = new Array(r * 2);
  for (i = 0, a = 0; a < r; ) {
    let s = e[a++];
    if (s < 128) {
      o[i++] = s;
      continue;
    }
    let n = ca[s];
    if (n > 4) {
      o[i++] = 65533, a += n - 1;
      continue;
    }
    for (s &= n === 2 ? 31 : n === 3 ? 15 : 7; n > 1 && a < r; )
      s = s << 6 | e[a++] & 63, n--;
    if (n > 1) {
      o[i++] = 65533;
      continue;
    }
    s < 65536 ? o[i++] = s : (s -= 65536, o[i++] = 55296 | s >> 10 & 1023, o[i++] = 56320 | s & 1023);
  }
  return Xh(o, i);
};
var Qh = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let r = t - 1;
  for (; r >= 0 && (e[r] & 192) === 128; )
    r--;
  return r < 0 || r === 0 ? t : r + ca[e[r]] > t ? r : t;
};
var ua = {
  string2buf: Yh,
  buf2string: Jh,
  utf8border: Qh
};
function ep() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var Iu = ep;
var Tu = Object.prototype.toString;
var {
  Z_NO_FLUSH: rp,
  Z_SYNC_FLUSH: tp,
  Z_FULL_FLUSH: ap,
  Z_FINISH: ip,
  Z_OK: Wa,
  Z_STREAM_END: op,
  Z_DEFAULT_COMPRESSION: np,
  Z_DEFAULT_STRATEGY: sp,
  Z_DEFLATED: lp
} = ga;
function ma(e) {
  this.options = fi.assign({
    level: np,
    method: lp,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: sp
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Iu(), this.strm.avail_out = 0;
  let r = ra.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (r !== Wa)
    throw new Error(pt3[r]);
  if (t.header && ra.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let a;
    if (typeof t.dictionary == "string" ? a = ua.string2buf(t.dictionary) : Tu.call(t.dictionary) === "[object ArrayBuffer]" ? a = new Uint8Array(t.dictionary) : a = t.dictionary, r = ra.deflateSetDictionary(this.strm, a), r !== Wa)
      throw new Error(pt3[r]);
    this._dict_set = true;
  }
}
ma.prototype.push = function(e, t) {
  const r = this.strm, a = this.options.chunkSize;
  let i, o;
  if (this.ended)
    return false;
  for (t === ~~t ? o = t : o = t === true ? ip : rp, typeof e == "string" ? r.input = ua.string2buf(e) : Tu.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length; ; ) {
    if (r.avail_out === 0 && (r.output = new Uint8Array(a), r.next_out = 0, r.avail_out = a), (o === tp || o === ap) && r.avail_out <= 6) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue;
    }
    if (i = ra.deflate(r, o), i === op)
      return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), i = ra.deflateEnd(this.strm), this.onEnd(i), this.ended = true, i === Wa;
    if (r.avail_out === 0) {
      this.onData(r.output);
      continue;
    }
    if (o > 0 && r.next_out > 0) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue;
    }
    if (r.avail_in === 0) break;
  }
  return true;
};
ma.prototype.onData = function(e) {
  this.chunks.push(e);
};
ma.prototype.onEnd = function(e) {
  e === Wa && (this.result = fi.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Gn(e, t) {
  const r = new ma(t);
  if (r.push(e, true), r.err)
    throw r.msg || pt3[r.err];
  return r.result;
}
function cp(e, t) {
  return t = t || {}, t.raw = true, Gn(e, t);
}
function up(e, t) {
  return t = t || {}, t.gzip = true, Gn(e, t);
}
var fp = ma;
var dp = Gn;
var hp = cp;
var pp = up;
var gp = {
  Deflate: fp,
  deflate: dp,
  deflateRaw: hp,
  gzip: pp
};
var Aa = 16209;
var bp = 16191;
var mp = function(t, r) {
  let a, i, o, s, n, p, d, u, w, y, k2, A, E2, x, I2, B2, z4, O, F3, N3, j4, q3, S2, D2;
  const $4 = t.state;
  a = t.next_in, S2 = t.input, i = a + (t.avail_in - 5), o = t.next_out, D2 = t.output, s = o - (r - t.avail_out), n = o + (t.avail_out - 257), p = $4.dmax, d = $4.wsize, u = $4.whave, w = $4.wnext, y = $4.window, k2 = $4.hold, A = $4.bits, E2 = $4.lencode, x = $4.distcode, I2 = (1 << $4.lenbits) - 1, B2 = (1 << $4.distbits) - 1;
  e:
    do {
      A < 15 && (k2 += S2[a++] << A, A += 8, k2 += S2[a++] << A, A += 8), z4 = E2[k2 & I2];
      r:
        for (; ; ) {
          if (O = z4 >>> 24, k2 >>>= O, A -= O, O = z4 >>> 16 & 255, O === 0)
            D2[o++] = z4 & 65535;
          else if (O & 16) {
            F3 = z4 & 65535, O &= 15, O && (A < O && (k2 += S2[a++] << A, A += 8), F3 += k2 & (1 << O) - 1, k2 >>>= O, A -= O), A < 15 && (k2 += S2[a++] << A, A += 8, k2 += S2[a++] << A, A += 8), z4 = x[k2 & B2];
            t:
              for (; ; ) {
                if (O = z4 >>> 24, k2 >>>= O, A -= O, O = z4 >>> 16 & 255, O & 16) {
                  if (N3 = z4 & 65535, O &= 15, A < O && (k2 += S2[a++] << A, A += 8, A < O && (k2 += S2[a++] << A, A += 8)), N3 += k2 & (1 << O) - 1, N3 > p) {
                    t.msg = "invalid distance too far back", $4.mode = Aa;
                    break e;
                  }
                  if (k2 >>>= O, A -= O, O = o - s, N3 > O) {
                    if (O = N3 - O, O > u && $4.sane) {
                      t.msg = "invalid distance too far back", $4.mode = Aa;
                      break e;
                    }
                    if (j4 = 0, q3 = y, w === 0) {
                      if (j4 += d - O, O < F3) {
                        F3 -= O;
                        do
                          D2[o++] = y[j4++];
                        while (--O);
                        j4 = o - N3, q3 = D2;
                      }
                    } else if (w < O) {
                      if (j4 += d + w - O, O -= w, O < F3) {
                        F3 -= O;
                        do
                          D2[o++] = y[j4++];
                        while (--O);
                        if (j4 = 0, w < F3) {
                          O = w, F3 -= O;
                          do
                            D2[o++] = y[j4++];
                          while (--O);
                          j4 = o - N3, q3 = D2;
                        }
                      }
                    } else if (j4 += w - O, O < F3) {
                      F3 -= O;
                      do
                        D2[o++] = y[j4++];
                      while (--O);
                      j4 = o - N3, q3 = D2;
                    }
                    for (; F3 > 2; )
                      D2[o++] = q3[j4++], D2[o++] = q3[j4++], D2[o++] = q3[j4++], F3 -= 3;
                    F3 && (D2[o++] = q3[j4++], F3 > 1 && (D2[o++] = q3[j4++]));
                  } else {
                    j4 = o - N3;
                    do
                      D2[o++] = D2[j4++], D2[o++] = D2[j4++], D2[o++] = D2[j4++], F3 -= 3;
                    while (F3 > 2);
                    F3 && (D2[o++] = D2[j4++], F3 > 1 && (D2[o++] = D2[j4++]));
                  }
                } else if ((O & 64) === 0) {
                  z4 = x[(z4 & 65535) + (k2 & (1 << O) - 1)];
                  continue t;
                } else {
                  t.msg = "invalid distance code", $4.mode = Aa;
                  break e;
                }
                break;
              }
          } else if ((O & 64) === 0) {
            z4 = E2[(z4 & 65535) + (k2 & (1 << O) - 1)];
            continue r;
          } else if (O & 32) {
            $4.mode = bp;
            break e;
          } else {
            t.msg = "invalid literal/length code", $4.mode = Aa;
            break e;
          }
          break;
        }
    } while (a < i && o < n);
  F3 = A >> 3, a -= F3, A -= F3 << 3, k2 &= (1 << A) - 1, t.next_in = a, t.next_out = o, t.avail_in = a < i ? 5 + (i - a) : 5 - (a - i), t.avail_out = o < n ? 257 + (n - o) : 257 - (o - n), $4.hold = k2, $4.bits = A;
};
var kt2 = 15;
var Ts = 852;
var js = 592;
var Os = 0;
var Ti = 1;
var Rs = 2;
var yp = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var vp = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var wp = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var _p = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var kp = (e, t, r, a, i, o, s, n) => {
  const p = n.bits;
  let d = 0, u = 0, w = 0, y = 0, k2 = 0, A = 0, E2 = 0, x = 0, I2 = 0, B2 = 0, z4, O, F3, N3, j4, q3 = null, S2;
  const D2 = new Uint16Array(kt2 + 1), $4 = new Uint16Array(kt2 + 1);
  let m = null, U, C, M2;
  for (d = 0; d <= kt2; d++)
    D2[d] = 0;
  for (u = 0; u < a; u++)
    D2[t[r + u]]++;
  for (k2 = p, y = kt2; y >= 1 && D2[y] === 0; y--)
    ;
  if (k2 > y && (k2 = y), y === 0)
    return i[o++] = 1 << 24 | 64 << 16 | 0, i[o++] = 1 << 24 | 64 << 16 | 0, n.bits = 1, 0;
  for (w = 1; w < y && D2[w] === 0; w++)
    ;
  for (k2 < w && (k2 = w), x = 1, d = 1; d <= kt2; d++)
    if (x <<= 1, x -= D2[d], x < 0)
      return -1;
  if (x > 0 && (e === Os || y !== 1))
    return -1;
  for ($4[1] = 0, d = 1; d < kt2; d++)
    $4[d + 1] = $4[d] + D2[d];
  for (u = 0; u < a; u++)
    t[r + u] !== 0 && (s[$4[t[r + u]]++] = u);
  if (e === Os ? (q3 = m = s, S2 = 20) : e === Ti ? (q3 = yp, m = vp, S2 = 257) : (q3 = wp, m = _p, S2 = 0), B2 = 0, u = 0, d = w, j4 = o, A = k2, E2 = 0, F3 = -1, I2 = 1 << k2, N3 = I2 - 1, e === Ti && I2 > Ts || e === Rs && I2 > js)
    return 1;
  for (; ; ) {
    U = d - E2, s[u] + 1 < S2 ? (C = 0, M2 = s[u]) : s[u] >= S2 ? (C = m[s[u] - S2], M2 = q3[s[u] - S2]) : (C = 96, M2 = 0), z4 = 1 << d - E2, O = 1 << A, w = O;
    do
      O -= z4, i[j4 + (B2 >> E2) + O] = U << 24 | C << 16 | M2 | 0;
    while (O !== 0);
    for (z4 = 1 << d - 1; B2 & z4; )
      z4 >>= 1;
    if (z4 !== 0 ? (B2 &= z4 - 1, B2 += z4) : B2 = 0, u++, --D2[d] === 0) {
      if (d === y)
        break;
      d = t[r + s[u]];
    }
    if (d > k2 && (B2 & N3) !== F3) {
      for (E2 === 0 && (E2 = k2), j4 += w, A = d - E2, x = 1 << A; A + E2 < y && (x -= D2[A + E2], !(x <= 0)); )
        A++, x <<= 1;
      if (I2 += 1 << A, e === Ti && I2 > Ts || e === Rs && I2 > js)
        return 1;
      F3 = B2 & N3, i[F3] = k2 << 24 | A << 16 | j4 - o | 0;
    }
  }
  return B2 !== 0 && (i[j4 + B2] = d - E2 << 24 | 64 << 16 | 0), n.bits = k2, 0;
};
var ta = kp;
var Ep = 0;
var ju = 1;
var Ou = 2;
var {
  Z_FINISH: Ps,
  Z_BLOCK: xp,
  Z_TREES: Ba,
  Z_OK: bt3,
  Z_STREAM_END: Ap,
  Z_NEED_DICT: Bp,
  Z_STREAM_ERROR: cr,
  Z_DATA_ERROR: Ru,
  Z_MEM_ERROR: Pu,
  Z_BUF_ERROR: zp,
  Z_DEFLATED: Us
} = ga;
var di = 16180;
var Cs = 16181;
var Ls = 16182;
var Ns = 16183;
var qs = 16184;
var Ds = 16185;
var Ms = 16186;
var Fs = 16187;
var $s = 16188;
var Ks = 16189;
var Ya = 16190;
var Ir = 16191;
var ji = 16192;
var Hs = 16193;
var Oi = 16194;
var Zs = 16195;
var Gs = 16196;
var Vs = 16197;
var Ws = 16198;
var za = 16199;
var Sa = 16200;
var Ys = 16201;
var Xs = 16202;
var Js = 16203;
var Qs = 16204;
var el = 16205;
var Ri = 16206;
var rl = 16207;
var tl = 16208;
var Ue3 = 16209;
var Uu = 16210;
var Cu = 16211;
var Sp = 852;
var Ip = 592;
var Tp = 15;
var jp = Tp;
var al = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function Op() {
  this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
var yt3 = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.mode < di || t.mode > Cu ? 1 : 0;
};
var Lu = (e) => {
  if (yt3(e))
    return cr;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = di, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(Sp), t.distcode = t.distdyn = new Int32Array(Ip), t.sane = 1, t.back = -1, bt3;
};
var Nu = (e) => {
  if (yt3(e))
    return cr;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, Lu(e);
};
var qu = (e, t) => {
  let r;
  if (yt3(e))
    return cr;
  const a = e.state;
  return t < 0 ? (r = 0, t = -t) : (r = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? cr : (a.window !== null && a.wbits !== t && (a.window = null), a.wrap = r, a.wbits = t, Nu(e));
};
var Du = (e, t) => {
  if (!e)
    return cr;
  const r = new Op();
  e.state = r, r.strm = e, r.window = null, r.mode = di;
  const a = qu(e, t);
  return a !== bt3 && (e.state = null), a;
};
var Rp = (e) => Du(e, jp);
var il = true;
var Pi;
var Ui;
var Pp = (e) => {
  if (il) {
    Pi = new Int32Array(512), Ui = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (ta(ju, e.lens, 0, 288, Pi, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    ta(Ou, e.lens, 0, 32, Ui, 0, e.work, { bits: 5 }), il = false;
  }
  e.lencode = Pi, e.lenbits = 9, e.distcode = Ui, e.distbits = 5;
};
var Mu = (e, t, r, a) => {
  let i;
  const o = e.state;
  return o.window === null && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new Uint8Array(o.wsize)), a >= o.wsize ? (o.window.set(t.subarray(r - o.wsize, r), 0), o.wnext = 0, o.whave = o.wsize) : (i = o.wsize - o.wnext, i > a && (i = a), o.window.set(t.subarray(r - a, r - a + i), o.wnext), a -= i, a ? (o.window.set(t.subarray(r - a, r), 0), o.wnext = a, o.whave = o.wsize) : (o.wnext += i, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += i))), 0;
};
var Up = (e, t) => {
  let r, a, i, o, s, n, p, d, u, w, y, k2, A, E2, x = 0, I2, B2, z4, O, F3, N3, j4, q3;
  const S2 = new Uint8Array(4);
  let D2, $4;
  const m = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (yt3(e) || !e.output || !e.input && e.avail_in !== 0)
    return cr;
  r = e.state, r.mode === Ir && (r.mode = ji), s = e.next_out, i = e.output, p = e.avail_out, o = e.next_in, a = e.input, n = e.avail_in, d = r.hold, u = r.bits, w = n, y = p, q3 = bt3;
  e:
    for (; ; )
      switch (r.mode) {
        case di:
          if (r.wrap === 0) {
            r.mode = ji;
            break;
          }
          for (; u < 16; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if (r.wrap & 2 && d === 35615) {
            r.wbits === 0 && (r.wbits = 15), r.check = 0, S2[0] = d & 255, S2[1] = d >>> 8 & 255, r.check = Fe2(r.check, S2, 2, 0), d = 0, u = 0, r.mode = Cs;
            break;
          }
          if (r.head && (r.head.done = false), !(r.wrap & 1) || /* check if zlib header allowed */
          (((d & 255) << 8) + (d >> 8)) % 31) {
            e.msg = "incorrect header check", r.mode = Ue3;
            break;
          }
          if ((d & 15) !== Us) {
            e.msg = "unknown compression method", r.mode = Ue3;
            break;
          }
          if (d >>>= 4, u -= 4, j4 = (d & 15) + 8, r.wbits === 0 && (r.wbits = j4), j4 > 15 || j4 > r.wbits) {
            e.msg = "invalid window size", r.mode = Ue3;
            break;
          }
          r.dmax = 1 << r.wbits, r.flags = 0, e.adler = r.check = 1, r.mode = d & 512 ? Ks : Ir, d = 0, u = 0;
          break;
        case Cs:
          for (; u < 16; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if (r.flags = d, (r.flags & 255) !== Us) {
            e.msg = "unknown compression method", r.mode = Ue3;
            break;
          }
          if (r.flags & 57344) {
            e.msg = "unknown header flags set", r.mode = Ue3;
            break;
          }
          r.head && (r.head.text = d >> 8 & 1), r.flags & 512 && r.wrap & 4 && (S2[0] = d & 255, S2[1] = d >>> 8 & 255, r.check = Fe2(r.check, S2, 2, 0)), d = 0, u = 0, r.mode = Ls;
        /* falls through */
        case Ls:
          for (; u < 32; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          r.head && (r.head.time = d), r.flags & 512 && r.wrap & 4 && (S2[0] = d & 255, S2[1] = d >>> 8 & 255, S2[2] = d >>> 16 & 255, S2[3] = d >>> 24 & 255, r.check = Fe2(r.check, S2, 4, 0)), d = 0, u = 0, r.mode = Ns;
        /* falls through */
        case Ns:
          for (; u < 16; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          r.head && (r.head.xflags = d & 255, r.head.os = d >> 8), r.flags & 512 && r.wrap & 4 && (S2[0] = d & 255, S2[1] = d >>> 8 & 255, r.check = Fe2(r.check, S2, 2, 0)), d = 0, u = 0, r.mode = qs;
        /* falls through */
        case qs:
          if (r.flags & 1024) {
            for (; u < 16; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            r.length = d, r.head && (r.head.extra_len = d), r.flags & 512 && r.wrap & 4 && (S2[0] = d & 255, S2[1] = d >>> 8 & 255, r.check = Fe2(r.check, S2, 2, 0)), d = 0, u = 0;
          } else r.head && (r.head.extra = null);
          r.mode = Ds;
        /* falls through */
        case Ds:
          if (r.flags & 1024 && (k2 = r.length, k2 > n && (k2 = n), k2 && (r.head && (j4 = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(
            a.subarray(
              o,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              o + k2
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            j4
          )), r.flags & 512 && r.wrap & 4 && (r.check = Fe2(r.check, a, k2, o)), n -= k2, o += k2, r.length -= k2), r.length))
            break e;
          r.length = 0, r.mode = Ms;
        /* falls through */
        case Ms:
          if (r.flags & 2048) {
            if (n === 0)
              break e;
            k2 = 0;
            do
              j4 = a[o + k2++], r.head && j4 && r.length < 65536 && (r.head.name += String.fromCharCode(j4));
            while (j4 && k2 < n);
            if (r.flags & 512 && r.wrap & 4 && (r.check = Fe2(r.check, a, k2, o)), n -= k2, o += k2, j4)
              break e;
          } else r.head && (r.head.name = null);
          r.length = 0, r.mode = Fs;
        /* falls through */
        case Fs:
          if (r.flags & 4096) {
            if (n === 0)
              break e;
            k2 = 0;
            do
              j4 = a[o + k2++], r.head && j4 && r.length < 65536 && (r.head.comment += String.fromCharCode(j4));
            while (j4 && k2 < n);
            if (r.flags & 512 && r.wrap & 4 && (r.check = Fe2(r.check, a, k2, o)), n -= k2, o += k2, j4)
              break e;
          } else r.head && (r.head.comment = null);
          r.mode = $s;
        /* falls through */
        case $s:
          if (r.flags & 512) {
            for (; u < 16; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            if (r.wrap & 4 && d !== (r.check & 65535)) {
              e.msg = "header crc mismatch", r.mode = Ue3;
              break;
            }
            d = 0, u = 0;
          }
          r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = true), e.adler = r.check = 0, r.mode = Ir;
          break;
        case Ks:
          for (; u < 32; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          e.adler = r.check = al(d), d = 0, u = 0, r.mode = Ya;
        /* falls through */
        case Ya:
          if (r.havedict === 0)
            return e.next_out = s, e.avail_out = p, e.next_in = o, e.avail_in = n, r.hold = d, r.bits = u, Bp;
          e.adler = r.check = 1, r.mode = Ir;
        /* falls through */
        case Ir:
          if (t === xp || t === Ba)
            break e;
        /* falls through */
        case ji:
          if (r.last) {
            d >>>= u & 7, u -= u & 7, r.mode = Ri;
            break;
          }
          for (; u < 3; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          switch (r.last = d & 1, d >>>= 1, u -= 1, d & 3) {
            case 0:
              r.mode = Hs;
              break;
            case 1:
              if (Pp(r), r.mode = za, t === Ba) {
                d >>>= 2, u -= 2;
                break e;
              }
              break;
            case 2:
              r.mode = Gs;
              break;
            case 3:
              e.msg = "invalid block type", r.mode = Ue3;
          }
          d >>>= 2, u -= 2;
          break;
        case Hs:
          for (d >>>= u & 7, u -= u & 7; u < 32; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if ((d & 65535) !== (d >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", r.mode = Ue3;
            break;
          }
          if (r.length = d & 65535, d = 0, u = 0, r.mode = Oi, t === Ba)
            break e;
        /* falls through */
        case Oi:
          r.mode = Zs;
        /* falls through */
        case Zs:
          if (k2 = r.length, k2) {
            if (k2 > n && (k2 = n), k2 > p && (k2 = p), k2 === 0)
              break e;
            i.set(a.subarray(o, o + k2), s), n -= k2, o += k2, p -= k2, s += k2, r.length -= k2;
            break;
          }
          r.mode = Ir;
          break;
        case Gs:
          for (; u < 14; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if (r.nlen = (d & 31) + 257, d >>>= 5, u -= 5, r.ndist = (d & 31) + 1, d >>>= 5, u -= 5, r.ncode = (d & 15) + 4, d >>>= 4, u -= 4, r.nlen > 286 || r.ndist > 30) {
            e.msg = "too many length or distance symbols", r.mode = Ue3;
            break;
          }
          r.have = 0, r.mode = Vs;
        /* falls through */
        case Vs:
          for (; r.have < r.ncode; ) {
            for (; u < 3; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            r.lens[m[r.have++]] = d & 7, d >>>= 3, u -= 3;
          }
          for (; r.have < 19; )
            r.lens[m[r.have++]] = 0;
          if (r.lencode = r.lendyn, r.lenbits = 7, D2 = { bits: r.lenbits }, q3 = ta(Ep, r.lens, 0, 19, r.lencode, 0, r.work, D2), r.lenbits = D2.bits, q3) {
            e.msg = "invalid code lengths set", r.mode = Ue3;
            break;
          }
          r.have = 0, r.mode = Ws;
        /* falls through */
        case Ws:
          for (; r.have < r.nlen + r.ndist; ) {
            for (; x = r.lencode[d & (1 << r.lenbits) - 1], I2 = x >>> 24, B2 = x >>> 16 & 255, z4 = x & 65535, !(I2 <= u); ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            if (z4 < 16)
              d >>>= I2, u -= I2, r.lens[r.have++] = z4;
            else {
              if (z4 === 16) {
                for ($4 = I2 + 2; u < $4; ) {
                  if (n === 0)
                    break e;
                  n--, d += a[o++] << u, u += 8;
                }
                if (d >>>= I2, u -= I2, r.have === 0) {
                  e.msg = "invalid bit length repeat", r.mode = Ue3;
                  break;
                }
                j4 = r.lens[r.have - 1], k2 = 3 + (d & 3), d >>>= 2, u -= 2;
              } else if (z4 === 17) {
                for ($4 = I2 + 3; u < $4; ) {
                  if (n === 0)
                    break e;
                  n--, d += a[o++] << u, u += 8;
                }
                d >>>= I2, u -= I2, j4 = 0, k2 = 3 + (d & 7), d >>>= 3, u -= 3;
              } else {
                for ($4 = I2 + 7; u < $4; ) {
                  if (n === 0)
                    break e;
                  n--, d += a[o++] << u, u += 8;
                }
                d >>>= I2, u -= I2, j4 = 0, k2 = 11 + (d & 127), d >>>= 7, u -= 7;
              }
              if (r.have + k2 > r.nlen + r.ndist) {
                e.msg = "invalid bit length repeat", r.mode = Ue3;
                break;
              }
              for (; k2--; )
                r.lens[r.have++] = j4;
            }
          }
          if (r.mode === Ue3)
            break;
          if (r.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", r.mode = Ue3;
            break;
          }
          if (r.lenbits = 9, D2 = { bits: r.lenbits }, q3 = ta(ju, r.lens, 0, r.nlen, r.lencode, 0, r.work, D2), r.lenbits = D2.bits, q3) {
            e.msg = "invalid literal/lengths set", r.mode = Ue3;
            break;
          }
          if (r.distbits = 6, r.distcode = r.distdyn, D2 = { bits: r.distbits }, q3 = ta(Ou, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, D2), r.distbits = D2.bits, q3) {
            e.msg = "invalid distances set", r.mode = Ue3;
            break;
          }
          if (r.mode = za, t === Ba)
            break e;
        /* falls through */
        case za:
          r.mode = Sa;
        /* falls through */
        case Sa:
          if (n >= 6 && p >= 258) {
            e.next_out = s, e.avail_out = p, e.next_in = o, e.avail_in = n, r.hold = d, r.bits = u, mp(e, y), s = e.next_out, i = e.output, p = e.avail_out, o = e.next_in, a = e.input, n = e.avail_in, d = r.hold, u = r.bits, r.mode === Ir && (r.back = -1);
            break;
          }
          for (r.back = 0; x = r.lencode[d & (1 << r.lenbits) - 1], I2 = x >>> 24, B2 = x >>> 16 & 255, z4 = x & 65535, !(I2 <= u); ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if (B2 && (B2 & 240) === 0) {
            for (O = I2, F3 = B2, N3 = z4; x = r.lencode[N3 + ((d & (1 << O + F3) - 1) >> O)], I2 = x >>> 24, B2 = x >>> 16 & 255, z4 = x & 65535, !(O + I2 <= u); ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            d >>>= O, u -= O, r.back += O;
          }
          if (d >>>= I2, u -= I2, r.back += I2, r.length = z4, B2 === 0) {
            r.mode = el;
            break;
          }
          if (B2 & 32) {
            r.back = -1, r.mode = Ir;
            break;
          }
          if (B2 & 64) {
            e.msg = "invalid literal/length code", r.mode = Ue3;
            break;
          }
          r.extra = B2 & 15, r.mode = Ys;
        /* falls through */
        case Ys:
          if (r.extra) {
            for ($4 = r.extra; u < $4; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            r.length += d & (1 << r.extra) - 1, d >>>= r.extra, u -= r.extra, r.back += r.extra;
          }
          r.was = r.length, r.mode = Xs;
        /* falls through */
        case Xs:
          for (; x = r.distcode[d & (1 << r.distbits) - 1], I2 = x >>> 24, B2 = x >>> 16 & 255, z4 = x & 65535, !(I2 <= u); ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if ((B2 & 240) === 0) {
            for (O = I2, F3 = B2, N3 = z4; x = r.distcode[N3 + ((d & (1 << O + F3) - 1) >> O)], I2 = x >>> 24, B2 = x >>> 16 & 255, z4 = x & 65535, !(O + I2 <= u); ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            d >>>= O, u -= O, r.back += O;
          }
          if (d >>>= I2, u -= I2, r.back += I2, B2 & 64) {
            e.msg = "invalid distance code", r.mode = Ue3;
            break;
          }
          r.offset = z4, r.extra = B2 & 15, r.mode = Js;
        /* falls through */
        case Js:
          if (r.extra) {
            for ($4 = r.extra; u < $4; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            r.offset += d & (1 << r.extra) - 1, d >>>= r.extra, u -= r.extra, r.back += r.extra;
          }
          if (r.offset > r.dmax) {
            e.msg = "invalid distance too far back", r.mode = Ue3;
            break;
          }
          r.mode = Qs;
        /* falls through */
        case Qs:
          if (p === 0)
            break e;
          if (k2 = y - p, r.offset > k2) {
            if (k2 = r.offset - k2, k2 > r.whave && r.sane) {
              e.msg = "invalid distance too far back", r.mode = Ue3;
              break;
            }
            k2 > r.wnext ? (k2 -= r.wnext, A = r.wsize - k2) : A = r.wnext - k2, k2 > r.length && (k2 = r.length), E2 = r.window;
          } else
            E2 = i, A = s - r.offset, k2 = r.length;
          k2 > p && (k2 = p), p -= k2, r.length -= k2;
          do
            i[s++] = E2[A++];
          while (--k2);
          r.length === 0 && (r.mode = Sa);
          break;
        case el:
          if (p === 0)
            break e;
          i[s++] = r.length, p--, r.mode = Sa;
          break;
        case Ri:
          if (r.wrap) {
            for (; u < 32; ) {
              if (n === 0)
                break e;
              n--, d |= a[o++] << u, u += 8;
            }
            if (y -= p, e.total_out += y, r.total += y, r.wrap & 4 && y && (e.adler = r.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            r.flags ? Fe2(r.check, i, y, s - y) : la(r.check, i, y, s - y)), y = p, r.wrap & 4 && (r.flags ? d : al(d)) !== r.check) {
              e.msg = "incorrect data check", r.mode = Ue3;
              break;
            }
            d = 0, u = 0;
          }
          r.mode = rl;
        /* falls through */
        case rl:
          if (r.wrap && r.flags) {
            for (; u < 32; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            if (r.wrap & 4 && d !== (r.total & 4294967295)) {
              e.msg = "incorrect length check", r.mode = Ue3;
              break;
            }
            d = 0, u = 0;
          }
          r.mode = tl;
        /* falls through */
        case tl:
          q3 = Ap;
          break e;
        case Ue3:
          q3 = Ru;
          break e;
        case Uu:
          return Pu;
        case Cu:
        /* falls through */
        default:
          return cr;
      }
  return e.next_out = s, e.avail_out = p, e.next_in = o, e.avail_in = n, r.hold = d, r.bits = u, (r.wsize || y !== e.avail_out && r.mode < Ue3 && (r.mode < Ri || t !== Ps)) && Mu(e, e.output, e.next_out, y - e.avail_out), w -= e.avail_in, y -= e.avail_out, e.total_in += w, e.total_out += y, r.total += y, r.wrap & 4 && y && (e.adler = r.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  r.flags ? Fe2(r.check, i, y, e.next_out - y) : la(r.check, i, y, e.next_out - y)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === Ir ? 128 : 0) + (r.mode === za || r.mode === Oi ? 256 : 0), (w === 0 && y === 0 || t === Ps) && q3 === bt3 && (q3 = zp), q3;
};
var Cp = (e) => {
  if (yt3(e))
    return cr;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, bt3;
};
var Lp = (e, t) => {
  if (yt3(e))
    return cr;
  const r = e.state;
  return (r.wrap & 2) === 0 ? cr : (r.head = t, t.done = false, bt3);
};
var Np = (e, t) => {
  const r = t.length;
  let a, i, o;
  return yt3(e) || (a = e.state, a.wrap !== 0 && a.mode !== Ya) ? cr : a.mode === Ya && (i = 1, i = la(i, t, r, 0), i !== a.check) ? Ru : (o = Mu(e, t, r, r), o ? (a.mode = Uu, Pu) : (a.havedict = 1, bt3));
};
var qp = Nu;
var Dp = qu;
var Mp = Lu;
var Fp = Rp;
var $p = Du;
var Kp = Up;
var Hp = Cp;
var Zp = Lp;
var Gp = Np;
var Vp = "pako inflate (from Nodeca project)";
var Cr = {
  inflateReset: qp,
  inflateReset2: Dp,
  inflateResetKeep: Mp,
  inflateInit: Fp,
  inflateInit2: $p,
  inflate: Kp,
  inflateEnd: Hp,
  inflateGetHeader: Zp,
  inflateSetDictionary: Gp,
  inflateInfo: Vp
};
function Wp() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
}
var Yp = Wp;
var Fu = Object.prototype.toString;
var {
  Z_NO_FLUSH: Xp,
  Z_FINISH: Jp,
  Z_OK: fa,
  Z_STREAM_END: Ci,
  Z_NEED_DICT: Li,
  Z_STREAM_ERROR: Qp,
  Z_DATA_ERROR: ol,
  Z_MEM_ERROR: e02
} = ga;
function ya(e) {
  this.options = fi.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15) === 0 && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Iu(), this.strm.avail_out = 0;
  let r = Cr.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (r !== fa)
    throw new Error(pt3[r]);
  if (this.header = new Yp(), Cr.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = ua.string2buf(t.dictionary) : Fu.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = Cr.inflateSetDictionary(this.strm, t.dictionary), r !== fa)))
    throw new Error(pt3[r]);
}
ya.prototype.push = function(e, t) {
  const r = this.strm, a = this.options.chunkSize, i = this.options.dictionary;
  let o, s, n;
  if (this.ended) return false;
  for (t === ~~t ? s = t : s = t === true ? Jp : Xp, Fu.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length; ; ) {
    for (r.avail_out === 0 && (r.output = new Uint8Array(a), r.next_out = 0, r.avail_out = a), o = Cr.inflate(r, s), o === Li && i && (o = Cr.inflateSetDictionary(r, i), o === fa ? o = Cr.inflate(r, s) : o === ol && (o = Li)); r.avail_in > 0 && o === Ci && r.state.wrap > 0 && e[r.next_in] !== 0; )
      Cr.inflateReset(r), o = Cr.inflate(r, s);
    switch (o) {
      case Qp:
      case ol:
      case Li:
      case e02:
        return this.onEnd(o), this.ended = true, false;
    }
    if (n = r.avail_out, r.next_out && (r.avail_out === 0 || o === Ci))
      if (this.options.to === "string") {
        let p = ua.utf8border(r.output, r.next_out), d = r.next_out - p, u = ua.buf2string(r.output, p);
        r.next_out = d, r.avail_out = a - d, d && r.output.set(r.output.subarray(p, p + d), 0), this.onData(u);
      } else
        this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out));
    if (!(o === fa && n === 0)) {
      if (o === Ci)
        return o = Cr.inflateEnd(this.strm), this.onEnd(o), this.ended = true, true;
      if (r.avail_in === 0) break;
    }
  }
  return true;
};
ya.prototype.onData = function(e) {
  this.chunks.push(e);
};
ya.prototype.onEnd = function(e) {
  e === fa && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = fi.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Vn(e, t) {
  const r = new ya(t);
  if (r.push(e), r.err) throw r.msg || pt3[r.err];
  return r.result;
}
function r02(e, t) {
  return t = t || {}, t.raw = true, Vn(e, t);
}
var t02 = ya;
var a02 = Vn;
var i02 = r02;
var o02 = Vn;
var n02 = {
  Inflate: t02,
  inflate: a02,
  inflateRaw: i02,
  ungzip: o02
};
var { Deflate: s02, deflate: l02, deflateRaw: c02, gzip: u02 } = gp;
var { Inflate: f02, inflate: d02, inflateRaw: h02, ungzip: p02 } = n02;
var g02 = s02;
var b02 = l02;
var m02 = c02;
var y02 = u02;
var v02 = f02;
var w02 = d02;
var _02 = h02;
var k02 = p02;
var E02 = ga;
var wy = {
  Deflate: g02,
  deflate: b02,
  deflateRaw: m02,
  gzip: y02,
  Inflate: v02,
  inflate: w02,
  inflateRaw: _02,
  ungzip: k02,
  constants: E02
};
function $u(e) {
  const t = e.length;
  if (t % 2 !== 0) throw new TypeError("fromHexInternal: odd-length hex string");
  const r = new Uint8Array(t / 2);
  for (let a = 0; a < t; a += 2) {
    const i = nl(e.charCodeAt(a)), o = nl(e.charCodeAt(a + 1));
    if (i === -1 || o === -1) throw new TypeError("fromHexInternal: invalid hex character");
    r[a >> 1] = i << 4 | o;
  }
  return r;
}
function nl(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function va(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t] !== 0) return false;
  return true;
}
function x02(e, t) {
  const r = Math.min(e.length, t.length);
  for (let a = 0; a < r; a++) {
    const i = e[a], o = t[a];
    if (i < o) return -1;
    if (i > o) return 1;
  }
  return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
}
function Ge2(e, t) {
  if (e.length !== t.length) return false;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r]) return false;
  return true;
}
function Bt3(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function Ku(...e) {
  let t = 0;
  for (const i of e) t += i.length;
  const r = new Uint8Array(t);
  let a = 0;
  for (const i of e)
    r.set(i, a), a += i.length;
  return r;
}
var hi = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
var A02 = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
var Wn = 21n * 10n ** 14n;
function Hu(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
function B02(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function z0(e) {
  return e instanceof Uint8Array && e.length === 20;
}
function S02(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 || va(e) ? false : Hu(e) < hi;
}
function Zu(e) {
  if (!(e instanceof Uint8Array)) return false;
  const t = e[0];
  return e.length === 33 && (t === 2 || t === 3) || e.length === 65 && (t === 4 || t === 6 || t === 7);
}
function I02(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 ? false : !va(e);
}
function Gu(e) {
  return e instanceof Uint8Array && e.length >= 8 && e.length <= 73;
}
function Vu(e) {
  return e instanceof Uint8Array && e.length === 64;
}
function T02(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function Wu(e) {
  return typeof e == "bigint" && e >= 0n && e <= Wn;
}
function Yn(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertBytes32: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertBytes32: expected 32 bytes, got ${e.length} bytes`);
}
function Yu(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPrivateKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertPrivateKey: expected 32 bytes, got ${e.length} bytes`);
  if (va(e))
    throw new TypeError("assertPrivateKey: key is zero");
  if (Hu(e) >= hi)
    throw new TypeError("assertPrivateKey: key not in range [1, n)");
}
function Xu(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPublicKey: expected Uint8Array");
  if (!Zu(e))
    throw new TypeError(
      `assertPublicKey: invalid SEC1 public key (length=${e.length}, prefix=0x${(e[0] ?? 0).toString(16).padStart(2, "0")})`
    );
}
function Ju(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertXOnlyPublicKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertXOnlyPublicKey: expected 32 bytes, got ${e.length} bytes`);
  if (va(e))
    throw new TypeError("assertXOnlyPublicKey: key is zero");
}
function Qu(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertMessageHash: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertMessageHash: expected 32 bytes, got ${e.length} bytes`);
}
function j02(e) {
  return Yn(e), e;
}
function O02(e) {
  if (!(e instanceof Uint8Array) || e.length !== 20)
    throw new TypeError("createBytes20: expected 20 bytes Uint8Array");
  return e;
}
function Xa(e) {
  return Yu(e), e;
}
function ef(e) {
  return Xu(e), e;
}
function rf(e) {
  return Ju(e), e;
}
function R02(e) {
  if (!Gu(e))
    throw new TypeError(`createSignature: expected 8-73 bytes, got ${e.length} bytes`);
  return e;
}
function P02(e) {
  if (!Vu(e))
    throw new TypeError(`createSchnorrSignature: expected 64 bytes, got ${e.length} bytes`);
  return e;
}
function U02(e) {
  return Qu(e), e;
}
function C02(e) {
  if (!Wu(e))
    throw new TypeError(`createSatoshi: value out of range [0, ${Wn}]`);
  return e;
}
var at3 = {
  /** Can produce ECDSA signatures (requires a private key). */
  EcdsaSign: 1,
  /** Can verify ECDSA signatures. */
  EcdsaVerify: 2,
  /** Can produce BIP-340 Schnorr signatures (requires a private key and backend support). */
  SchnorrSign: 4,
  /** Can verify BIP-340 Schnorr signatures (requires backend support). */
  SchnorrVerify: 8,
  /** Can export the raw private key bytes. */
  PrivateKeyExport: 16,
  /** Can derive a tweaked child key via Taproot-style tweaking. */
  PublicKeyTweak: 32,
  /** Supports BIP-32 hierarchical deterministic derivation. */
  HdDerivation: 64
};
function Xn(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function mt3(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const r = t && `"${t}" `;
    throw new Error(`${r}expected integer >= 0, got ${e}`);
  }
}
function Te3(e, t, r = "") {
  const a = Xn(e), i = e == null ? void 0 : e.length, o = t !== void 0;
  if (!a || o && i !== t) {
    const s = r && `"${r}" `, n = o ? ` of length ${t}` : "", p = a ? `length=${i}` : `type=${typeof e}`;
    throw new Error(s + "expected Uint8Array" + n + ", got " + p);
  }
  return e;
}
function tf(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  mt3(e.outputLen), mt3(e.blockLen);
}
function Ja(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function L02(e, t) {
  Te3(e, void 0, "digestInto() output");
  const r = t.outputLen;
  if (e.length < r)
    throw new Error('"digestInto() output" expected to be of length >=' + r);
}
function Qa(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function Ni(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function gr(e, t) {
  return e << 32 - t | e >>> t;
}
var af = (
  /* @ts-ignore */
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
);
var N0 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function pi(e) {
  if (Te3(e), af)
    return e.toHex();
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += N0[e[r]];
  return t;
}
var Tr = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function sl(e) {
  if (e >= Tr._0 && e <= Tr._9)
    return e - Tr._0;
  if (e >= Tr.A && e <= Tr.F)
    return e - (Tr.A - 10);
  if (e >= Tr.a && e <= Tr.f)
    return e - (Tr.a - 10);
}
function ei(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (af)
    return Uint8Array.fromHex(e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const a = new Uint8Array(r);
  for (let i = 0, o = 0; i < r; i++, o += 2) {
    const s = sl(e.charCodeAt(o)), n = sl(e.charCodeAt(o + 1));
    if (s === void 0 || n === void 0) {
      const p = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + p + '" at index ' + o);
    }
    a[i] = s * 16 + n;
  }
  return a;
}
function Ar(...e) {
  let t = 0;
  for (let a = 0; a < e.length; a++) {
    const i = e[a];
    Te3(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let a = 0, i = 0; a < e.length; a++) {
    const o = e[a];
    r.set(o, i), i += o.length;
  }
  return r;
}
function q02(e, t = {}) {
  const r = (i, o) => e(o).update(i).digest(), a = e(void 0);
  return r.outputLen = a.outputLen, r.blockLen = a.blockLen, r.create = (i) => e(i), Object.assign(r, t), Object.freeze(r);
}
function gi(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof (t == null ? void 0 : t.getRandomValues) != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
var D02 = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function M02(e, t, r) {
  return e & t ^ ~e & r;
}
function F02(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
var $0 = class {
  constructor(t, r, a, i) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = t, this.outputLen = r, this.padOffset = a, this.isLE = i, this.buffer = new Uint8Array(t), this.view = Ni(this.buffer);
  }
  update(t) {
    Ja(this), Te3(t);
    const { view: r, buffer: a, blockLen: i } = this, o = t.length;
    for (let s = 0; s < o; ) {
      const n = Math.min(i - this.pos, o - s);
      if (n === i) {
        const p = Ni(t);
        for (; i <= o - s; s += i)
          this.process(p, s);
        continue;
      }
      a.set(t.subarray(s, s + n), this.pos), this.pos += n, s += n, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Ja(this), L02(t, this), this.finished = true;
    const { buffer: r, view: a, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, Qa(this.buffer.subarray(s)), this.padOffset > i - s && (this.process(a, 0), s = 0);
    for (let w = s; w < i; w++)
      r[w] = 0;
    a.setBigUint64(i - 8, BigInt(this.length * 8), o), this.process(a, 0);
    const n = Ni(t), p = this.outputLen;
    if (p % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const d = p / 4, u = this.get();
    if (d > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let w = 0; w < d; w++)
      n.setUint32(4 * w, u[w], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const a = t.slice(0, r);
    return this.destroy(), a;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: a, length: i, finished: o, destroyed: s, pos: n } = this;
    return t.destroyed = s, t.finished = o, t.length = i, t.pos = n, i % r && t.buffer.set(a), t;
  }
  clone() {
    return this._cloneInto();
  }
};
var Mr = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var K0 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Fr = new Uint32Array(64);
var H02 = class extends $0 {
  constructor(t) {
    super(64, t, 8, false);
  }
  get() {
    const { A: t, B: r, C: a, D: i, E: o, F: s, G: n, H: p } = this;
    return [t, r, a, i, o, s, n, p];
  }
  // prettier-ignore
  set(t, r, a, i, o, s, n, p) {
    this.A = t | 0, this.B = r | 0, this.C = a | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = n | 0, this.H = p | 0;
  }
  process(t, r) {
    for (let w = 0; w < 16; w++, r += 4)
      Fr[w] = t.getUint32(r, false);
    for (let w = 16; w < 64; w++) {
      const y = Fr[w - 15], k2 = Fr[w - 2], A = gr(y, 7) ^ gr(y, 18) ^ y >>> 3, E2 = gr(k2, 17) ^ gr(k2, 19) ^ k2 >>> 10;
      Fr[w] = E2 + Fr[w - 7] + A + Fr[w - 16] | 0;
    }
    let { A: a, B: i, C: o, D: s, E: n, F: p, G: d, H: u } = this;
    for (let w = 0; w < 64; w++) {
      const y = gr(n, 6) ^ gr(n, 11) ^ gr(n, 25), k2 = u + y + M02(n, p, d) + K0[w] + Fr[w] | 0, A = (gr(a, 2) ^ gr(a, 13) ^ gr(a, 22)) + F02(a, i, o) | 0;
      u = d, d = p, p = n, n = s + k2 | 0, s = o, o = i, i = a, a = k2 + A | 0;
    }
    a = a + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, n = n + this.E | 0, p = p + this.F | 0, d = d + this.G | 0, u = u + this.H | 0, this.set(a, i, o, s, n, p, d, u);
  }
  roundClean() {
    Qa(Fr);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Qa(this.buffer);
  }
};
var Z0 = class extends H02 {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", Mr[0] | 0);
    __publicField(this, "B", Mr[1] | 0);
    __publicField(this, "C", Mr[2] | 0);
    __publicField(this, "D", Mr[3] | 0);
    __publicField(this, "E", Mr[4] | 0);
    __publicField(this, "F", Mr[5] | 0);
    __publicField(this, "G", Mr[6] | 0);
    __publicField(this, "H", Mr[7] | 0);
  }
};
var da = q02(
  () => new Z0(),
  D02(1)
);
function G02(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let d = 0; d < t.length; d++)
    t[d] = 255;
  for (let d = 0; d < e.length; d++) {
    const u = e.charAt(d), w = u.charCodeAt(0);
    if (t[w] !== 255)
      throw new TypeError(u + " is ambiguous");
    t[w] = d;
  }
  const r = e.length, a = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function s(d) {
    if (d instanceof Uint8Array || (ArrayBuffer.isView(d) ? d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength) : Array.isArray(d) && (d = Uint8Array.from(d))), !(d instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (d.length === 0)
      return "";
    let u = 0, w = 0, y = 0;
    const k2 = d.length;
    for (; y !== k2 && d[y] === 0; )
      y++, u++;
    const A = (k2 - y) * o + 1 >>> 0, E2 = new Uint8Array(A);
    for (; y !== k2; ) {
      let B2 = d[y], z4 = 0;
      for (let O = A - 1; (B2 !== 0 || z4 < w) && O !== -1; O--, z4++)
        B2 += 256 * E2[O] >>> 0, E2[O] = B2 % r >>> 0, B2 = B2 / r >>> 0;
      if (B2 !== 0)
        throw new Error("Non-zero carry");
      w = z4, y++;
    }
    let x = A - w;
    for (; x !== A && E2[x] === 0; )
      x++;
    let I2 = a.repeat(u);
    for (; x < A; ++x)
      I2 += e.charAt(E2[x]);
    return I2;
  }
  function n(d) {
    if (typeof d != "string")
      throw new TypeError("Expected String");
    if (d.length === 0)
      return new Uint8Array();
    let u = 0, w = 0, y = 0;
    for (; d[u] === a; )
      w++, u++;
    const k2 = (d.length - u) * i + 1 >>> 0, A = new Uint8Array(k2);
    for (; u < d.length; ) {
      const B2 = d.charCodeAt(u);
      if (B2 > 255)
        return;
      let z4 = t[B2];
      if (z4 === 255)
        return;
      let O = 0;
      for (let F3 = k2 - 1; (z4 !== 0 || O < y) && F3 !== -1; F3--, O++)
        z4 += r * A[F3] >>> 0, A[F3] = z4 % 256 >>> 0, z4 = z4 / 256 >>> 0;
      if (z4 !== 0)
        throw new Error("Non-zero carry");
      y = O, u++;
    }
    let E2 = k2 - y;
    for (; E2 !== k2 && A[E2] === 0; )
      E2++;
    const x = new Uint8Array(w + (k2 - E2));
    let I2 = w;
    for (; E2 !== k2; )
      x[I2++] = A[E2++];
    return x;
  }
  function p(d) {
    const u = n(d);
    if (u)
      return u;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: n,
    decode: p
  };
}
var V02 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var qi = G02(V02);
function W02(e) {
  function t(o) {
    const s = e(o), n = o.length + 4, p = new Uint8Array(n);
    return p.set(o, 0), p.set(s.subarray(0, 4), o.length), qi.encode(p);
  }
  function r(o) {
    const s = o.slice(0, -4), n = o.slice(-4), p = e(s);
    if (!(n[0] ^ p[0] | n[1] ^ p[1] | n[2] ^ p[2] | n[3] ^ p[3]))
      return s;
  }
  function a(o) {
    const s = qi.decodeUnsafe(o);
    if (s !== void 0)
      return r(s);
  }
  function i(o) {
    const s = qi.decode(o), n = r(s);
    if (n === void 0)
      throw new Error("Invalid checksum");
    return n;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: a
  };
}
function Y0(e) {
  return da(da(e));
}
var { encode: X0, decode: J0, decodeUnsafe: Q0 } = W02(Y0);
var of = { encode: X0, decode: J0, decodeUnsafe: Q0 };
function eg(e, t) {
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: false
    };
  if (e.length !== 34)
    throw new Error("Invalid WIF length");
  if (e[33] !== 1)
    throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: true
  };
}
function rg(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  const a = new Uint8Array(r ? 34 : 33);
  return new DataView(a.buffer).setUint8(0, e), a.set(t, 1), r && (a[33] = 1), a;
}
function tg(e, t) {
  return eg(of.decode(e));
}
function ag(e) {
  return of.encode(rg(e.version, e.privateKey, e.compressed));
}
function nf(e, t, r) {
  return ag({
    version: r.wif,
    privateKey: e,
    compressed: t
  });
}
function sf(e, t) {
  const r = tg(e), a = r.version;
  if (Array.isArray(t)) {
    const o = t.find((s) => s.wif === a);
    if (!o) throw new Error("Unknown network version");
    return {
      privateKey: Xa(r.privateKey),
      compressed: r.compressed,
      network: o
    };
  }
  const i = t;
  if (a !== i.wif)
    throw new Error("Invalid network version");
  return {
    privateKey: Xa(r.privateKey),
    compressed: r.compressed,
    network: i
  };
}
function ig(e) {
  return e[0] === 3 ? true : e[0] === 4 && e.length === 65 ? (e[64] & 1) === 1 : false;
}
function og(e) {
  const t = e.length === 32 ? e : e.subarray(1, 33);
  return rf(t);
}
var Di = 48;
function ng(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
function sg(e) {
  const t = new Uint8Array(32);
  for (let r = 31; r >= 0; r--)
    t[r] = Number(e & 0xffn), e >>= 8n;
  return t;
}
var _e4, _r, _a, _t3, _i, _o, _n, _Zr_instances, s_fn, l_fn;
var _Zr = class _Zr {
  constructor(t, r, a, i, o) {
    __privateAdd(this, _Zr_instances);
    __privateAdd(this, _e4);
    __privateAdd(this, _r);
    __privateAdd(this, _a);
    __privateAdd(this, _t3);
    __privateAdd(this, _i);
    __privateAdd(this, _o);
    __privateAdd(this, _n);
    if ((o == null ? void 0 : o.compressed) !== void 0 && typeof o.compressed != "boolean")
      throw new TypeError(
        `Expected boolean for compressed, got ${typeof o.compressed}`
      );
    __privateSet(this, _e4, t), __privateSet(this, _r, r), __privateSet(this, _t3, (o == null ? void 0 : o.compressed) ?? true), __privateSet(this, _a, i), a !== void 0 && __privateSet(this, _i, t.pointCompress(a, __privateGet(this, _t3)));
  }
  /** Raw private key bytes, or `undefined` for public-key-only signers. */
  get privateKey() {
    return __privateGet(this, _r);
  }
  /**
   * SEC1-encoded public key.  Lazily derived from the private key when
   * the signer was created via {@link fromPrivateKey} or {@link fromWIF}.
   *
   * @throws If neither a private nor public key is available (should never happen).
   */
  get publicKey() {
    if (__privateGet(this, _i) === void 0) {
      const t = __privateGet(this, _r);
      if (t === void 0)
        throw new Error("Missing both private and public key");
      const r = __privateGet(this, _e4).pointFromScalar(t, __privateGet(this, _t3));
      if (r === null)
        throw new Error("Failed to derive public key from private key");
      __privateSet(this, _i, r);
    }
    return __privateGet(this, _i);
  }
  /** 32-byte BIP-340 x-only public key (lazily derived and cached). */
  get xOnlyPublicKey() {
    return __privateGet(this, _o) === void 0 && __privateSet(this, _o, og(this.publicKey)), __privateGet(this, _o);
  }
  /** Network this signer is bound to. */
  get network() {
    return __privateGet(this, _a);
  }
  /** Whether the public key is in compressed SEC1 form. */
  get compressed() {
    return __privateGet(this, _t3);
  }
  /**
   * Bitmask of {@link SignerCapability} flags representing the operations
   * this signer can perform.  Lazily computed and cached.
   */
  get capabilities() {
    if (__privateGet(this, _n) === void 0) {
      let t = at3.EcdsaVerify | at3.PublicKeyTweak;
      __privateGet(this, _r) !== void 0 && (t |= at3.EcdsaSign | at3.PrivateKeyExport), __privateGet(this, _e4).signSchnorr && __privateGet(this, _r) !== void 0 && (t |= at3.SchnorrSign), __privateGet(this, _e4).verifySchnorr && (t |= at3.SchnorrVerify), __privateSet(this, _n, t);
    }
    return __privateGet(this, _n);
  }
  /**
   * Creates a signer from a raw private key.
   *
   * @param backend - Cryptographic backend to use.
   * @param privateKey - 32-byte secp256k1 private key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws {TypeError} If the private key is not in the valid range `[1, n)`.
   */
  static fromPrivateKey(t, r, a, i) {
    if (!t.isPrivate(r))
      throw new TypeError("Private key not in range [1, n)");
    return new _Zr(t, r, void 0, a, i);
  }
  /**
   * Creates a public-key-only signer (cannot sign, export WIF, etc.).
   *
   * @param backend - Cryptographic backend to use.
   * @param publicKey - SEC1-encoded public key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws If the public key is not a valid curve point.
   */
  static fromPublicKey(t, r, a, i) {
    if (!t.isPoint(r))
      throw new Error("Point not on the curve");
    return new _Zr(t, void 0, r, a, i);
  }
  /**
   * Imports a signer from a WIF-encoded private key string.
   *
   * @param backend - Cryptographic backend to use.
   * @param wifString - Base58Check WIF string.
   * @param network - One or more candidate networks whose WIF version byte is matched.
   * @throws If no network matches the decoded version byte.
   */
  static fromWIF(t, r, a) {
    const i = sf(r, a);
    return _Zr.fromPrivateKey(t, i.privateKey, i.network, {
      compressed: i.compressed
    });
  }
  /**
   * Generates a new signer with a random private key.
   *
   * Uses FIPS 186-5 B.4.2 / RFC 9380 modular reduction:
   * 48 bytes of entropy are reduced via `(seed mod (n  1)) + 1`,
   * producing a key in `[1, n)` with negligible bias (< 2^128).
   *
   * @param backend - Cryptographic backend to use.
   * @param network - Target network.
   * @param options - Optional settings (rng, compressed).
   */
  static makeRandom(t, r, a) {
    const i = ((a == null ? void 0 : a.rng) ?? ((n) => crypto.getRandomValues(new Uint8Array(n))))(Di);
    if (i.length !== Di)
      throw new TypeError(
        `Expected ${Di} bytes from rng, got ${i.length} bytes`
      );
    const o = ng(i) % (hi - 1n) + 1n, s = sg(o);
    return _Zr.fromPrivateKey(
      t,
      Xa(s),
      r,
      a
    );
  }
  /**
   * Tests whether this signer has a specific capability.
   * @param cap - {@link SignerCapability} flag to test.
   */
  hasCapability(t) {
    return (this.capabilities & t) !== 0;
  }
  /**
   * Produces a compact ECDSA signature.
   *
   * When `lowR` is `true`, grinds the nonce until the R value's first
   * byte is `<= 0x7f`, producing a smaller DER encoding.
   *
   * @param hash - 32-byte message digest.
   * @param lowR - Enable low-R grinding.  Defaults to `false`.
   * @throws If this is a public-key-only signer.
   */
  sign(t, r) {
    if (__privateGet(this, _r) === void 0) throw new Error("Missing private key");
    if (!r)
      return __privateGet(this, _e4).sign(t, __privateGet(this, _r));
    let a = __privateGet(this, _e4).sign(t, __privateGet(this, _r));
    const i = new Uint8Array(32), o = new DataView(i.buffer, i.byteOffset, i.byteLength);
    let s = 0;
    for (; ; ) {
      const n = a[0];
      if (n === void 0) throw new Error("Backend returned invalid signature");
      if (n <= 127) break;
      s++, o.setUint32(0, s, true), a = __privateGet(this, _e4).sign(t, __privateGet(this, _r), i);
    }
    return a;
  }
  /**
   * Produces a 64-byte BIP-340 Schnorr signature.
   *
   * @param hash - 32-byte message digest.
   * @throws If this is a public-key-only signer.
   * @throws If the backend does not support Schnorr signing.
   */
  signSchnorr(t) {
    if (__privateGet(this, _r) === void 0) throw new Error("Missing private key");
    if (!__privateGet(this, _e4).signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return __privateGet(this, _e4).signSchnorr(t, __privateGet(this, _r));
  }
  /**
   * Verifies a compact ECDSA signature against this signer's public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - Compact ECDSA signature.
   */
  verify(t, r) {
    return __privateGet(this, _e4).verify(t, this.publicKey, r);
  }
  /**
   * Verifies a BIP-340 Schnorr signature against this signer's x-only public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - 64-byte Schnorr signature.
   * @throws If the backend does not support Schnorr verification.
   */
  verifySchnorr(t, r) {
    if (!__privateGet(this, _e4).verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return __privateGet(this, _e4).verifySchnorr(t, this.xOnlyPublicKey, r);
  }
  /**
   * Derives a new signer by applying a Taproot-style scalar tweak.
   *
   * When a private key is available the tweak is applied to the scalar
   * (negating first if the public key has odd Y).  Otherwise, only the
   * public key is tweaked via x-only point addition.
   *
   * @param t - 32-byte tweak scalar.
   * @throws If the tweaked key is invalid (e.g. lands on the point at infinity).
   */
  tweak(t) {
    return Yn(t), __privateGet(this, _r) !== void 0 ? __privateMethod(this, _Zr_instances, s_fn).call(this, t) : __privateMethod(this, _Zr_instances, l_fn).call(this, t);
  }
  /**
   * Exports the private key as a WIF string using this signer's network.
   *
   * @throws If this is a public-key-only signer.
   */
  toWIF() {
    if (__privateGet(this, _r) === void 0) throw new Error("Missing private key");
    return nf(__privateGet(this, _r), __privateGet(this, _t3), __privateGet(this, _a));
  }
};
_e4 = new WeakMap();
_r = new WeakMap();
_a = new WeakMap();
_t3 = new WeakMap();
_i = new WeakMap();
_o = new WeakMap();
_n = new WeakMap();
_Zr_instances = new WeakSet();
s_fn = function(t) {
  const r = this.publicKey, a = __privateGet(this, _r);
  if (a === void 0)
    throw new Error("Missing private key");
  const i = ig(r) ? __privateGet(this, _e4).privateNegate(a) : a, o = __privateGet(this, _e4).privateAdd(i, t);
  if (o === null) throw new Error("Invalid tweaked private key!");
  return _Zr.fromPrivateKey(__privateGet(this, _e4), o, __privateGet(this, _a), {
    compressed: __privateGet(this, _t3)
  });
};
l_fn = function(t) {
  const r = this.xOnlyPublicKey, a = __privateGet(this, _e4).xOnlyPointAddTweak(r, t);
  if (a === null || a.xOnlyPubkey === null)
    throw new Error("Cannot tweak public key!");
  const i = new Uint8Array([a.parity === 0 ? 2 : 3]), o = Ku(i, a.xOnlyPubkey);
  return _Zr.fromPublicKey(__privateGet(this, _e4), ef(o), __privateGet(this, _a), {
    compressed: __privateGet(this, _t3)
  });
};
var Zr = _Zr;
var Jn = BigInt(0);
var wn = BigInt(1);
function ri(e, t = "") {
  if (typeof e != "boolean") {
    const r = t && `"${t}" `;
    throw new Error(r + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function lf(e) {
  if (typeof e == "bigint") {
    if (!La(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    mt3(e);
  return e;
}
function Ia(e) {
  const t = lf(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function cf(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Jn : BigInt("0x" + e);
}
function wa(e) {
  return cf(pi(e));
}
function uf(e) {
  return cf(pi(lg(Te3(e)).reverse()));
}
function Qn(e, t) {
  mt3(t), e = lf(e);
  const r = ei(e.toString(16).padStart(t * 2, "0"));
  if (r.length !== t)
    throw new Error("number too large");
  return r;
}
function ff(e, t) {
  return Qn(e, t).reverse();
}
function lg(e) {
  return Uint8Array.from(e);
}
function cg(e) {
  return Uint8Array.from(e, (t, r) => {
    const a = t.charCodeAt(0);
    if (t.length !== 1 || a > 127)
      throw new Error(`string contains non-ASCII character "${e[r]}" with code ${a} at position ${r}`);
    return a;
  });
}
var La = (e) => typeof e == "bigint" && Jn <= e;
function ug(e, t, r) {
  return La(e) && La(t) && La(r) && t <= e && e < r;
}
function fg(e, t, r, a) {
  if (!ug(t, r, a))
    throw new Error("expected valid " + e + ": " + r + " <= n < " + a + ", got " + t);
}
function dg(e) {
  let t;
  for (t = 0; e > Jn; e >>= wn, t += 1)
    ;
  return t;
}
var es = (e) => (wn << BigInt(e)) - wn;
function hg(e, t, r) {
  if (mt3(e, "hashLen"), mt3(t, "qByteLen"), typeof r != "function")
    throw new Error("hmacFn must be a function");
  const a = (E2) => new Uint8Array(E2), i = Uint8Array.of(), o = Uint8Array.of(0), s = Uint8Array.of(1), n = 1e3;
  let p = a(e), d = a(e), u = 0;
  const w = () => {
    p.fill(1), d.fill(0), u = 0;
  }, y = (...E2) => r(d, Ar(p, ...E2)), k2 = (E2 = i) => {
    d = y(o, E2), p = y(), E2.length !== 0 && (d = y(s, E2), p = y());
  }, A = () => {
    if (u++ >= n)
      throw new Error("drbg: tried max amount of iterations");
    let E2 = 0;
    const x = [];
    for (; E2 < t; ) {
      p = y();
      const I2 = p.slice();
      x.push(I2), E2 += p.length;
    }
    return Ar(...x);
  };
  return (E2, x) => {
    w(), k2(E2);
    let I2;
    for (; !(I2 = x(A())); )
      k2();
    return w(), I2;
  };
}
function rs(e, t = {}, r = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function a(o, s, n) {
    const p = e[o];
    if (n && p === void 0)
      return;
    const d = typeof p;
    if (d !== s || p === null)
      throw new Error(`param "${o}" is invalid: expected ${s}, got ${d}`);
  }
  const i = (o, s) => Object.entries(o).forEach(([n, p]) => a(n, p, s));
  i(t, false), i(r, true);
}
function ll(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...a) => {
    const i = t.get(r);
    if (i !== void 0)
      return i;
    const o = e(r, ...a);
    return t.set(r, o), o;
  };
}
var Xe2 = BigInt(0);
var We2 = BigInt(1);
var ct3 = BigInt(2);
var df = BigInt(3);
var hf = BigInt(4);
var pf = BigInt(5);
var pg = BigInt(7);
var gf = BigInt(8);
var gg = BigInt(9);
var bf = BigInt(16);
function er(e, t) {
  const r = e % t;
  return r >= Xe2 ? r : t + r;
}
function ir(e, t, r) {
  let a = e;
  for (; t-- > Xe2; )
    a *= a, a %= r;
  return a;
}
function cl(e, t) {
  if (e === Xe2)
    throw new Error("invert: expected non-zero number");
  if (t <= Xe2)
    throw new Error("invert: expected positive modulus, got " + t);
  let r = er(e, t), a = t, i = Xe2, o = We2;
  for (; r !== Xe2; ) {
    const s = a / r, n = a % r, p = i - o * s;
    a = r, r = n, i = o, o = p;
  }
  if (a !== We2)
    throw new Error("invert: does not exist");
  return er(i, t);
}
function ts(e, t, r) {
  if (!e.eql(e.sqr(t), r))
    throw new Error("Cannot find square root");
}
function mf(e, t) {
  const r = (e.ORDER + We2) / hf, a = e.pow(t, r);
  return ts(e, a, t), a;
}
function bg(e, t) {
  const r = (e.ORDER - pf) / gf, a = e.mul(t, ct3), i = e.pow(a, r), o = e.mul(t, i), s = e.mul(e.mul(o, ct3), i), n = e.mul(o, e.sub(s, e.ONE));
  return ts(e, n, t), n;
}
function mg(e) {
  const t = bi(e), r = yf(e), a = r(t, t.neg(t.ONE)), i = r(t, a), o = r(t, t.neg(a)), s = (e + pg) / bf;
  return (n, p) => {
    let d = n.pow(p, s), u = n.mul(d, a);
    const w = n.mul(d, i), y = n.mul(d, o), k2 = n.eql(n.sqr(u), p), A = n.eql(n.sqr(w), p);
    d = n.cmov(d, u, k2), u = n.cmov(y, w, A);
    const E2 = n.eql(n.sqr(u), p), x = n.cmov(d, u, E2);
    return ts(n, x, p), x;
  };
}
function yf(e) {
  if (e < df)
    throw new Error("sqrt is not defined for small field");
  let t = e - We2, r = 0;
  for (; t % ct3 === Xe2; )
    t /= ct3, r++;
  let a = ct3;
  const i = bi(e);
  for (; ul(i, a) === 1; )
    if (a++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r === 1)
    return mf;
  let o = i.pow(a, t);
  const s = (t + We2) / ct3;
  return function(n, p) {
    if (n.is0(p))
      return p;
    if (ul(n, p) !== 1)
      throw new Error("Cannot find square root");
    let d = r, u = n.mul(n.ONE, o), w = n.pow(p, t), y = n.pow(p, s);
    for (; !n.eql(w, n.ONE); ) {
      if (n.is0(w))
        return n.ZERO;
      let k2 = 1, A = n.sqr(w);
      for (; !n.eql(A, n.ONE); )
        if (k2++, A = n.sqr(A), k2 === d)
          throw new Error("Cannot find square root");
      const E2 = We2 << BigInt(d - k2 - 1), x = n.pow(u, E2);
      d = k2, u = n.sqr(x), w = n.mul(w, u), y = n.mul(y, x);
    }
    return y;
  };
}
function yg(e) {
  return e % hf === df ? mf : e % gf === pf ? bg : e % bf === gg ? mg(e) : yf(e);
}
var vg = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function wg(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r = vg.reduce((a, i) => (a[i] = "function", a), t);
  return rs(e, r), e;
}
function _g(e, t, r) {
  if (r < Xe2)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === Xe2)
    return e.ONE;
  if (r === We2)
    return t;
  let a = e.ONE, i = t;
  for (; r > Xe2; )
    r & We2 && (a = e.mul(a, i)), i = e.sqr(i), r >>= We2;
  return a;
}
function vf(e, t, r = false) {
  const a = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((s, n, p) => e.is0(n) ? s : (a[p] = s, e.mul(s, n)), e.ONE), o = e.inv(i);
  return t.reduceRight((s, n, p) => e.is0(n) ? s : (a[p] = e.mul(s, a[p]), e.mul(s, n)), o), a;
}
function ul(e, t) {
  const r = (e.ORDER - We2) / ct3, a = e.pow(t, r), i = e.eql(a, e.ONE), o = e.eql(a, e.ZERO), s = e.eql(a, e.neg(e.ONE));
  if (!i && !o && !s)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : o ? 0 : -1;
}
function kg(e, t) {
  t !== void 0 && mt3(t);
  const r = t !== void 0 ? t : e.toString(2).length, a = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: a };
}
var Eg = class {
  constructor(t, r = {}) {
    __publicField(this, "ORDER");
    __publicField(this, "BITS");
    __publicField(this, "BYTES");
    __publicField(this, "isLE");
    __publicField(this, "ZERO", Xe2);
    __publicField(this, "ONE", We2);
    __publicField(this, "_lengths");
    __publicField(this, "_sqrt");
    // cached sqrt
    __publicField(this, "_mod");
    var _a37;
    if (t <= Xe2)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let a;
    this.isLE = false, r != null && typeof r == "object" && (typeof r.BITS == "number" && (a = r.BITS), typeof r.sqrt == "function" && (this.sqrt = r.sqrt), typeof r.isLE == "boolean" && (this.isLE = r.isLE), r.allowedLengths && (this._lengths = (_a37 = r.allowedLengths) == null ? void 0 : _a37.slice()), typeof r.modFromBytes == "boolean" && (this._mod = r.modFromBytes));
    const { nBitLength: i, nByteLength: o } = kg(t, a);
    if (o > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = o, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return er(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return Xe2 <= t && t < this.ORDER;
  }
  is0(t) {
    return t === Xe2;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & We2) === We2;
  }
  neg(t) {
    return er(-t, this.ORDER);
  }
  eql(t, r) {
    return t === r;
  }
  sqr(t) {
    return er(t * t, this.ORDER);
  }
  add(t, r) {
    return er(t + r, this.ORDER);
  }
  sub(t, r) {
    return er(t - r, this.ORDER);
  }
  mul(t, r) {
    return er(t * r, this.ORDER);
  }
  pow(t, r) {
    return _g(this, t, r);
  }
  div(t, r) {
    return er(t * cl(r, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, r) {
    return t + r;
  }
  subN(t, r) {
    return t - r;
  }
  mulN(t, r) {
    return t * r;
  }
  inv(t) {
    return cl(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = yg(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? ff(t, this.BYTES) : Qn(t, this.BYTES);
  }
  fromBytes(t, r = false) {
    Te3(t);
    const { _lengths: a, BYTES: i, isLE: o, ORDER: s, _mod: n } = this;
    if (a) {
      if (!a.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + a + " bytes, got " + t.length);
      const d = new Uint8Array(i);
      d.set(t, o ? 0 : d.length - t.length), t = d;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let p = o ? uf(t) : wa(t);
    if (n && (p = er(p, s)), !r && !this.isValid(p))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return p;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return vf(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, r, a) {
    return a ? r : t;
  }
};
function bi(e, t = {}) {
  return new Eg(e, t);
}
function wf(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function _f(e) {
  const t = wf(e);
  return t + Math.ceil(t / 2);
}
function kf(e, t, r = false) {
  Te3(e);
  const a = e.length, i = wf(t), o = _f(t);
  if (a < 16 || a < o || a > 1024)
    throw new Error("expected " + o + "-1024 bytes of input, got " + a);
  const s = r ? uf(e) : wa(e), n = er(s, t - We2) + We2;
  return r ? ff(n, i) : Qn(n, i);
}
var Pt2 = BigInt(0);
var ut2 = BigInt(1);
function ti(e, t) {
  const r = t.negate();
  return e ? r : t;
}
function fl(e, t) {
  const r = vf(e.Fp, t.map((a) => a.Z));
  return t.map((a, i) => e.fromAffine(a.toAffine(r[i])));
}
function Ef(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function Mi(e, t) {
  Ef(e, t);
  const r = Math.ceil(t / e) + 1, a = 2 ** (e - 1), i = 2 ** e, o = es(e), s = BigInt(e);
  return { windows: r, windowSize: a, mask: o, maxNumber: i, shiftBy: s };
}
function dl(e, t, r) {
  const { windowSize: a, mask: i, maxNumber: o, shiftBy: s } = r;
  let n = Number(e & i), p = e >> s;
  n > a && (n -= o, p += ut2);
  const d = t * a, u = d + Math.abs(n) - 1, w = n === 0, y = n < 0, k2 = t % 2 !== 0;
  return { nextN: p, offset: u, isZero: w, isNeg: y, isNegF: k2, offsetF: d };
}
var Fi = /* @__PURE__ */ new WeakMap();
var xf = /* @__PURE__ */ new WeakMap();
function $i(e) {
  return xf.get(e) || 1;
}
function hl(e) {
  if (e !== Pt2)
    throw new Error("invalid wNAF");
}
var xg = class {
  // Parametrized with a given Point class (not individual point)
  constructor(t, r) {
    __publicField(this, "BASE");
    __publicField(this, "ZERO");
    __publicField(this, "Fn");
    __publicField(this, "bits");
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = r;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, r, a = this.ZERO) {
    let i = t;
    for (; r > Pt2; )
      r & ut2 && (a = a.add(i)), i = i.double(), r >>= ut2;
    return a;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, r) {
    const { windows: a, windowSize: i } = Mi(r, this.bits), o = [];
    let s = t, n = s;
    for (let p = 0; p < a; p++) {
      n = s, o.push(n);
      for (let d = 1; d < i; d++)
        n = n.add(s), o.push(n);
      s = n.double();
    }
    return o;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, r, a) {
    if (!this.Fn.isValid(a))
      throw new Error("invalid scalar");
    let i = this.ZERO, o = this.BASE;
    const s = Mi(t, this.bits);
    for (let n = 0; n < s.windows; n++) {
      const { nextN: p, offset: d, isZero: u, isNeg: w, isNegF: y, offsetF: k2 } = dl(a, n, s);
      a = p, u ? o = o.add(ti(y, r[k2])) : i = i.add(ti(w, r[d]));
    }
    return hl(a), { p: i, f: o };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, r, a, i = this.ZERO) {
    const o = Mi(t, this.bits);
    for (let s = 0; s < o.windows && a !== Pt2; s++) {
      const { nextN: n, offset: p, isZero: d, isNeg: u } = dl(a, s, o);
      if (a = n, !d) {
        const w = r[p];
        i = i.add(u ? w.negate() : w);
      }
    }
    return hl(a), i;
  }
  getPrecomputes(t, r, a) {
    let i = Fi.get(r);
    return i || (i = this.precomputeWindow(r, t), t !== 1 && (typeof a == "function" && (i = a(i)), Fi.set(r, i))), i;
  }
  cached(t, r, a) {
    const i = $i(t);
    return this.wNAF(i, this.getPrecomputes(i, t, a), r);
  }
  unsafe(t, r, a, i) {
    const o = $i(t);
    return o === 1 ? this._unsafeLadder(t, r, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, a), r, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, r) {
    Ef(r, this.bits), xf.set(t, r), Fi.delete(t);
  }
  hasCache(t) {
    return $i(t) !== 1;
  }
};
function Ag(e, t, r, a) {
  let i = t, o = e.ZERO, s = e.ZERO;
  for (; r > Pt2 || a > Pt2; )
    r & ut2 && (o = o.add(i)), a & ut2 && (s = s.add(i)), i = i.double(), r >>= ut2, a >>= ut2;
  return { p1: o, p2: s };
}
function pl(e, t, r) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return wg(t), t;
  } else
    return bi(e, { isLE: r });
}
function Bg(e, t, r = {}, a) {
  if (a === void 0 && (a = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const n of ["p", "n", "h"]) {
    const p = t[n];
    if (!(typeof p == "bigint" && p > Pt2))
      throw new Error(`CURVE.${n} must be positive bigint`);
  }
  const i = pl(t.p, r.Fp, a), o = pl(t.n, r.Fn, a), s = ["Gx", "Gy", "a", "b"];
  for (const n of s)
    if (!i.isValid(t[n]))
      throw new Error(`CURVE.${n} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: o };
}
function Af(e, t) {
  return function(r) {
    const a = e(r);
    return { secretKey: a, publicKey: t(a) };
  };
}
var Bf = class {
  constructor(t, r) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    if (tf(t), Te3(r, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const a = this.blockLen, i = new Uint8Array(a);
    i.set(r.length > a ? t.create().update(r).digest() : r);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), Qa(i);
  }
  update(t) {
    return Ja(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Ja(this), Te3(t, this.outputLen, "output"), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: a, finished: i, destroyed: o, blockLen: s, outputLen: n } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = n, t.oHash = r._cloneInto(t.oHash), t.iHash = a._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var zf = (e, t, r) => new Bf(e, t).update(r).digest();
zf.create = (e, t) => new Bf(e, t);
var gl = (e, t) => (e + (e >= 0 ? t : -t) / Sf) / t;
function zg(e, t, r) {
  const [[a, i], [o, s]] = t, n = gl(s * e, r), p = gl(-i * e, r);
  let d = e - n * a - p * o, u = -n * i - p * s;
  const w = d < Lr, y = u < Lr;
  w && (d = -d), y && (u = -u);
  const k2 = es(Math.ceil(dg(r) / 2)) + Tt3;
  if (d < Lr || d >= k2 || u < Lr || u >= k2)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: w, k1: d, k2neg: y, k2: u };
}
function _n2(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function Ki(e, t) {
  const r = {};
  for (let a of Object.keys(t))
    r[a] = e[a] === void 0 ? t[a] : e[a];
  return ri(r.lowS, "lowS"), ri(r.prehash, "prehash"), r.format !== void 0 && _n2(r.format), r;
}
var Sg = class extends Error {
  constructor(t = "") {
    super(t);
  }
};
var Gr = {
  // asn.1 DER encoding utils
  Err: Sg,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = Gr;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const a = t.length / 2, i = Ia(a);
      if (i.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const o = a > 127 ? Ia(i.length / 2 | 128) : "";
      return Ia(e) + o + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = Gr;
      let a = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[a++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const i = t[a++], o = !!(i & 128);
      let s = 0;
      if (!o)
        s = i;
      else {
        const p = i & 127;
        if (!p)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (p > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const d = t.subarray(a, a + p);
        if (d.length !== p)
          throw new r("tlv.decode: length bytes not complete");
        if (d[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const u of d)
          s = s << 8 | u;
        if (a += p, s < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const n = t.subarray(a, a + s);
      if (n.length !== s)
        throw new r("tlv.decode: wrong value length");
      return { v: n, l: t.subarray(a + s) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = Gr;
      if (e < Lr)
        throw new t("integer: negative integers are not allowed");
      let r = Ia(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(e) {
      const { Err: t } = Gr;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return wa(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: a } = Gr, i = Te3(e, void 0, "signature"), { v: o, l: s } = a.decode(48, i);
    if (s.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: n, l: p } = a.decode(2, o), { v: d, l: u } = a.decode(2, p);
    if (u.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: r.decode(n), s: r.decode(d) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = Gr, a = t.encode(2, r.encode(e.r)), i = t.encode(2, r.encode(e.s)), o = a + i;
    return t.encode(48, o);
  }
};
var Lr = BigInt(0);
var Tt3 = BigInt(1);
var Sf = BigInt(2);
var Ta = BigInt(3);
var Ig = BigInt(4);
function Tg(e, t = {}) {
  const r = Bg("weierstrass", e, t), { Fp: a, Fn: i } = r;
  let o = r.CURVE;
  const { h: s, n } = o;
  rs(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: p } = t;
  if (p && (!a.is0(o.a) || typeof p.beta != "bigint" || !Array.isArray(p.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const d = Tf(a, i);
  function u() {
    if (!a.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function w(m, U, C) {
    const { x: M2, y: V2 } = U.toAffine(), te5 = a.toBytes(M2);
    if (ri(C, "isCompressed"), C) {
      u();
      const ie4 = !a.isOdd(V2);
      return Ar(If(ie4), te5);
    } else
      return Ar(Uint8Array.of(4), te5, a.toBytes(V2));
  }
  function y(m) {
    Te3(m, void 0, "Point");
    const { publicKey: U, publicKeyUncompressed: C } = d, M2 = m.length, V2 = m[0], te5 = m.subarray(1);
    if (M2 === U && (V2 === 2 || V2 === 3)) {
      const ie4 = a.fromBytes(te5);
      if (!a.isValid(ie4))
        throw new Error("bad point: is not on curve, wrong x");
      const oe5 = E2(ie4);
      let ne3;
      try {
        ne3 = a.sqrt(oe5);
      } catch (P3) {
        const Z3 = P3 instanceof Error ? ": " + P3.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + Z3);
      }
      u();
      const le4 = a.isOdd(ne3);
      return (V2 & 1) === 1 !== le4 && (ne3 = a.neg(ne3)), { x: ie4, y: ne3 };
    } else if (M2 === C && V2 === 4) {
      const ie4 = a.BYTES, oe5 = a.fromBytes(te5.subarray(0, ie4)), ne3 = a.fromBytes(te5.subarray(ie4, ie4 * 2));
      if (!x(oe5, ne3))
        throw new Error("bad point: is not on curve");
      return { x: oe5, y: ne3 };
    } else
      throw new Error(`bad point: got length ${M2}, expected compressed=${U} or uncompressed=${C}`);
  }
  const k2 = t.toBytes || w, A = t.fromBytes || y;
  function E2(m) {
    const U = a.sqr(m), C = a.mul(U, m);
    return a.add(a.add(C, a.mul(m, o.a)), o.b);
  }
  function x(m, U) {
    const C = a.sqr(U), M2 = E2(m);
    return a.eql(C, M2);
  }
  if (!x(o.Gx, o.Gy))
    throw new Error("bad curve params: generator point");
  const I2 = a.mul(a.pow(o.a, Ta), Ig), B2 = a.mul(a.sqr(o.b), BigInt(27));
  if (a.is0(a.add(I2, B2)))
    throw new Error("bad curve params: a or b");
  function z4(m, U, C = false) {
    if (!a.isValid(U) || C && a.is0(U))
      throw new Error(`bad point coordinate ${m}`);
    return U;
  }
  function O(m) {
    if (!(m instanceof S2))
      throw new Error("Weierstrass Point expected");
  }
  function F3(m) {
    if (!p || !p.basises)
      throw new Error("no endo");
    return zg(m, p.basises, i.ORDER);
  }
  const N3 = ll((m, U) => {
    const { X: C, Y: M2, Z: V2 } = m;
    if (a.eql(V2, a.ONE))
      return { x: C, y: M2 };
    const te5 = m.is0();
    U == null && (U = te5 ? a.ONE : a.inv(V2));
    const ie4 = a.mul(C, U), oe5 = a.mul(M2, U), ne3 = a.mul(V2, U);
    if (te5)
      return { x: a.ZERO, y: a.ZERO };
    if (!a.eql(ne3, a.ONE))
      throw new Error("invZ was invalid");
    return { x: ie4, y: oe5 };
  }), j4 = ll((m) => {
    if (m.is0()) {
      if (t.allowInfinityPoint && !a.is0(m.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: U, y: C } = m.toAffine();
    if (!a.isValid(U) || !a.isValid(C))
      throw new Error("bad point: x or y not field elements");
    if (!x(U, C))
      throw new Error("bad point: equation left != right");
    if (!m.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function q3(m, U, C, M2, V2) {
    return C = new S2(a.mul(C.X, m), C.Y, C.Z), U = ti(M2, U), C = ti(V2, C), U.add(C);
  }
  const _S8 = class _S8 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(U, C, M2) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      this.X = z4("x", U), this.Y = z4("y", C, true), this.Z = z4("z", M2), Object.freeze(this);
    }
    static CURVE() {
      return o;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(U) {
      const { x: C, y: M2 } = U || {};
      if (!U || !a.isValid(C) || !a.isValid(M2))
        throw new Error("invalid affine point");
      if (U instanceof _S8)
        throw new Error("projective point not allowed");
      return a.is0(C) && a.is0(M2) ? _S8.ZERO : new _S8(C, M2, a.ONE);
    }
    static fromBytes(U) {
      const C = _S8.fromAffine(A(Te3(U, void 0, "point")));
      return C.assertValidity(), C;
    }
    static fromHex(U) {
      return _S8.fromBytes(ei(U));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(U = 8, C = true) {
      return $4.createCache(this, U), C || this.multiply(Ta), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      j4(this);
    }
    hasEvenY() {
      const { y: U } = this.toAffine();
      if (!a.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !a.isOdd(U);
    }
    /** Compare one point to another. */
    equals(U) {
      O(U);
      const { X: C, Y: M2, Z: V2 } = this, { X: te5, Y: ie4, Z: oe5 } = U, ne3 = a.eql(a.mul(C, oe5), a.mul(te5, V2)), le4 = a.eql(a.mul(M2, oe5), a.mul(ie4, V2));
      return ne3 && le4;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _S8(this.X, a.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: U, b: C } = o, M2 = a.mul(C, Ta), { X: V2, Y: te5, Z: ie4 } = this;
      let oe5 = a.ZERO, ne3 = a.ZERO, le4 = a.ZERO, P3 = a.mul(V2, V2), Z3 = a.mul(te5, te5), T = a.mul(ie4, ie4), K3 = a.mul(V2, te5);
      return K3 = a.add(K3, K3), le4 = a.mul(V2, ie4), le4 = a.add(le4, le4), oe5 = a.mul(U, le4), ne3 = a.mul(M2, T), ne3 = a.add(oe5, ne3), oe5 = a.sub(Z3, ne3), ne3 = a.add(Z3, ne3), ne3 = a.mul(oe5, ne3), oe5 = a.mul(K3, oe5), le4 = a.mul(M2, le4), T = a.mul(U, T), K3 = a.sub(P3, T), K3 = a.mul(U, K3), K3 = a.add(K3, le4), le4 = a.add(P3, P3), P3 = a.add(le4, P3), P3 = a.add(P3, T), P3 = a.mul(P3, K3), ne3 = a.add(ne3, P3), T = a.mul(te5, ie4), T = a.add(T, T), P3 = a.mul(T, K3), oe5 = a.sub(oe5, P3), le4 = a.mul(T, Z3), le4 = a.add(le4, le4), le4 = a.add(le4, le4), new _S8(oe5, ne3, le4);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(U) {
      O(U);
      const { X: C, Y: M2, Z: V2 } = this, { X: te5, Y: ie4, Z: oe5 } = U;
      let ne3 = a.ZERO, le4 = a.ZERO, P3 = a.ZERO;
      const Z3 = o.a, T = a.mul(o.b, Ta);
      let K3 = a.mul(C, te5), W3 = a.mul(M2, ie4), X3 = a.mul(V2, oe5), re4 = a.add(C, M2), Q3 = a.add(te5, ie4);
      re4 = a.mul(re4, Q3), Q3 = a.add(K3, W3), re4 = a.sub(re4, Q3), Q3 = a.add(C, V2);
      let ae4 = a.add(te5, oe5);
      return Q3 = a.mul(Q3, ae4), ae4 = a.add(K3, X3), Q3 = a.sub(Q3, ae4), ae4 = a.add(M2, V2), ne3 = a.add(ie4, oe5), ae4 = a.mul(ae4, ne3), ne3 = a.add(W3, X3), ae4 = a.sub(ae4, ne3), P3 = a.mul(Z3, Q3), ne3 = a.mul(T, X3), P3 = a.add(ne3, P3), ne3 = a.sub(W3, P3), P3 = a.add(W3, P3), le4 = a.mul(ne3, P3), W3 = a.add(K3, K3), W3 = a.add(W3, K3), X3 = a.mul(Z3, X3), Q3 = a.mul(T, Q3), W3 = a.add(W3, X3), X3 = a.sub(K3, X3), X3 = a.mul(Z3, X3), Q3 = a.add(Q3, X3), K3 = a.mul(W3, Q3), le4 = a.add(le4, K3), K3 = a.mul(ae4, Q3), ne3 = a.mul(re4, ne3), ne3 = a.sub(ne3, K3), K3 = a.mul(re4, W3), P3 = a.mul(ae4, P3), P3 = a.add(P3, K3), new _S8(ne3, le4, P3);
    }
    subtract(U) {
      return this.add(U.negate());
    }
    is0() {
      return this.equals(_S8.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(U) {
      const { endo: C } = t;
      if (!i.isValidNot0(U))
        throw new Error("invalid scalar: out of range");
      let M2, V2;
      const te5 = (ie4) => $4.cached(this, ie4, (oe5) => fl(_S8, oe5));
      if (C) {
        const { k1neg: ie4, k1: oe5, k2neg: ne3, k2: le4 } = F3(U), { p: P3, f: Z3 } = te5(oe5), { p: T, f: K3 } = te5(le4);
        V2 = Z3.add(K3), M2 = q3(C.beta, P3, T, ie4, ne3);
      } else {
        const { p: ie4, f: oe5 } = te5(U);
        M2 = ie4, V2 = oe5;
      }
      return fl(_S8, [M2, V2])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(U) {
      const { endo: C } = t, M2 = this;
      if (!i.isValid(U))
        throw new Error("invalid scalar: out of range");
      if (U === Lr || M2.is0())
        return _S8.ZERO;
      if (U === Tt3)
        return M2;
      if ($4.hasCache(this))
        return this.multiply(U);
      if (C) {
        const { k1neg: V2, k1: te5, k2neg: ie4, k2: oe5 } = F3(U), { p1: ne3, p2: le4 } = Ag(_S8, M2, te5, oe5);
        return q3(C.beta, ne3, le4, V2, ie4);
      } else
        return $4.unsafe(M2, U);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(U) {
      return N3(this, U);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: U } = t;
      return s === Tt3 ? true : U ? U(_S8, this) : $4.unsafe(this, n).is0();
    }
    clearCofactor() {
      const { clearCofactor: U } = t;
      return s === Tt3 ? this : U ? U(_S8, this) : this.multiplyUnsafe(s);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(s).is0();
    }
    toBytes(U = true) {
      return ri(U, "isCompressed"), this.assertValidity(), k2(_S8, this, U);
    }
    toHex(U = true) {
      return pi(this.toBytes(U));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_S8, "BASE", new _S8(o.Gx, o.Gy, a.ONE));
  // zero / infinity / identity point
  __publicField(_S8, "ZERO", new _S8(a.ZERO, a.ONE, a.ZERO));
  // 0, 1, 0
  // math field
  __publicField(_S8, "Fp", a);
  // scalar field
  __publicField(_S8, "Fn", i);
  let S2 = _S8;
  const D2 = i.BITS, $4 = new xg(S2, t.endo ? Math.ceil(D2 / 2) : D2);
  return S2.BASE.precompute(8), S2;
}
function If(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function Tf(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * t.BYTES
  };
}
function jg(e, t = {}) {
  const { Fn: r } = e, a = t.randomBytes || gi, i = Object.assign(Tf(e.Fp, r), { seed: _f(r.ORDER) });
  function o(k2) {
    try {
      const A = r.fromBytes(k2);
      return r.isValidNot0(A);
    } catch {
      return false;
    }
  }
  function s(k2, A) {
    const { publicKey: E2, publicKeyUncompressed: x } = i;
    try {
      const I2 = k2.length;
      return A === true && I2 !== E2 || A === false && I2 !== x ? false : !!e.fromBytes(k2);
    } catch {
      return false;
    }
  }
  function n(k2 = a(i.seed)) {
    return kf(Te3(k2, i.seed, "seed"), r.ORDER);
  }
  function p(k2, A = true) {
    return e.BASE.multiply(r.fromBytes(k2)).toBytes(A);
  }
  function d(k2) {
    const { secretKey: A, publicKey: E2, publicKeyUncompressed: x } = i;
    if (!Xn(k2) || "_lengths" in r && r._lengths || A === E2)
      return;
    const I2 = Te3(k2, void 0, "key").length;
    return I2 === E2 || I2 === x;
  }
  function u(k2, A, E2 = true) {
    if (d(k2) === true)
      throw new Error("first arg must be private key");
    if (d(A) === false)
      throw new Error("second arg must be public key");
    const x = r.fromBytes(k2);
    return e.fromBytes(A).multiply(x).toBytes(E2);
  }
  const w = {
    isValidSecretKey: o,
    isValidPublicKey: s,
    randomSecretKey: n
  }, y = Af(n, p);
  return Object.freeze({ getPublicKey: p, getSharedSecret: u, keygen: y, Point: e, utils: w, lengths: i });
}
function Og(e, t, r = {}) {
  tf(t), rs(r, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r = Object.assign({}, r);
  const a = r.randomBytes || gi, i = r.hmac || ((C, M2) => zf(t, C, M2)), { Fp: o, Fn: s } = e, { ORDER: n, BITS: p } = s, { keygen: d, getPublicKey: u, getSharedSecret: w, utils: y, lengths: k2 } = jg(e, r), A = {
    prehash: true,
    lowS: typeof r.lowS == "boolean" ? r.lowS : true,
    format: "compact",
    extraEntropy: false
  }, E2 = n * Sf < o.ORDER;
  function x(C) {
    const M2 = n >> Tt3;
    return C > M2;
  }
  function I2(C, M2) {
    if (!s.isValidNot0(M2))
      throw new Error(`invalid signature ${C}: out of range 1..Point.Fn.ORDER`);
    return M2;
  }
  function B2() {
    if (E2)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function z4(C, M2) {
    _n2(M2);
    const V2 = k2.signature, te5 = M2 === "compact" ? V2 : M2 === "recovered" ? V2 + 1 : void 0;
    return Te3(C, te5);
  }
  class O {
    constructor(M2, V2, te5) {
      __publicField(this, "r");
      __publicField(this, "s");
      __publicField(this, "recovery");
      if (this.r = I2("r", M2), this.s = I2("s", V2), te5 != null) {
        if (B2(), ![0, 1, 2, 3].includes(te5))
          throw new Error("invalid recovery id");
        this.recovery = te5;
      }
      Object.freeze(this);
    }
    static fromBytes(M2, V2 = A.format) {
      z4(M2, V2);
      let te5;
      if (V2 === "der") {
        const { r: le4, s: P3 } = Gr.toSig(Te3(M2));
        return new O(le4, P3);
      }
      V2 === "recovered" && (te5 = M2[0], V2 = "compact", M2 = M2.subarray(1));
      const ie4 = k2.signature / 2, oe5 = M2.subarray(0, ie4), ne3 = M2.subarray(ie4, ie4 * 2);
      return new O(s.fromBytes(oe5), s.fromBytes(ne3), te5);
    }
    static fromHex(M2, V2) {
      return this.fromBytes(ei(M2), V2);
    }
    assertRecovery() {
      const { recovery: M2 } = this;
      if (M2 == null)
        throw new Error("invalid recovery id: must be present");
      return M2;
    }
    addRecoveryBit(M2) {
      return new O(this.r, this.s, M2);
    }
    recoverPublicKey(M2) {
      const { r: V2, s: te5 } = this, ie4 = this.assertRecovery(), oe5 = ie4 === 2 || ie4 === 3 ? V2 + n : V2;
      if (!o.isValid(oe5))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const ne3 = o.toBytes(oe5), le4 = e.fromBytes(Ar(If((ie4 & 1) === 0), ne3)), P3 = s.inv(oe5), Z3 = N3(Te3(M2, void 0, "msgHash")), T = s.create(-Z3 * P3), K3 = s.create(te5 * P3), W3 = e.BASE.multiplyUnsafe(T).add(le4.multiplyUnsafe(K3));
      if (W3.is0())
        throw new Error("invalid recovery: point at infinify");
      return W3.assertValidity(), W3;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return x(this.s);
    }
    toBytes(M2 = A.format) {
      if (_n2(M2), M2 === "der")
        return ei(Gr.hexFromSig(this));
      const { r: V2, s: te5 } = this, ie4 = s.toBytes(V2), oe5 = s.toBytes(te5);
      return M2 === "recovered" ? (B2(), Ar(Uint8Array.of(this.assertRecovery()), ie4, oe5)) : Ar(ie4, oe5);
    }
    toHex(M2) {
      return pi(this.toBytes(M2));
    }
  }
  const F3 = r.bits2int || function(C) {
    if (C.length > 8192)
      throw new Error("input is too large");
    const M2 = wa(C), V2 = C.length * 8 - p;
    return V2 > 0 ? M2 >> BigInt(V2) : M2;
  }, N3 = r.bits2int_modN || function(C) {
    return s.create(F3(C));
  }, j4 = es(p);
  function q3(C) {
    return fg("num < 2^" + p, C, Lr, j4), s.toBytes(C);
  }
  function S2(C, M2) {
    return Te3(C, void 0, "message"), M2 ? Te3(t(C), void 0, "prehashed message") : C;
  }
  function D2(C, M2, V2) {
    const { lowS: te5, prehash: ie4, extraEntropy: oe5 } = Ki(V2, A);
    C = S2(C, ie4);
    const ne3 = N3(C), le4 = s.fromBytes(M2);
    if (!s.isValidNot0(le4))
      throw new Error("invalid private key");
    const P3 = [q3(le4), q3(ne3)];
    if (oe5 != null && oe5 !== false) {
      const W3 = oe5 === true ? a(k2.secretKey) : oe5;
      P3.push(Te3(W3, void 0, "extraEntropy"));
    }
    const Z3 = Ar(...P3), T = ne3;
    function K3(W3) {
      const X3 = F3(W3);
      if (!s.isValidNot0(X3))
        return;
      const re4 = s.inv(X3), Q3 = e.BASE.multiply(X3).toAffine(), ae4 = s.create(Q3.x);
      if (ae4 === Lr)
        return;
      const ce5 = s.create(re4 * s.create(T + ae4 * le4));
      if (ce5 === Lr)
        return;
      let ue5 = (Q3.x === ae4 ? 0 : 2) | Number(Q3.y & Tt3), de3 = ce5;
      return te5 && x(ce5) && (de3 = s.neg(ce5), ue5 ^= 1), new O(ae4, de3, E2 ? void 0 : ue5);
    }
    return { seed: Z3, k2sig: K3 };
  }
  function $4(C, M2, V2 = {}) {
    const { seed: te5, k2sig: ie4 } = D2(C, M2, V2);
    return hg(t.outputLen, s.BYTES, i)(te5, ie4).toBytes(V2.format);
  }
  function m(C, M2, V2, te5 = {}) {
    const { lowS: ie4, prehash: oe5, format: ne3 } = Ki(te5, A);
    if (V2 = Te3(V2, void 0, "publicKey"), M2 = S2(M2, oe5), !Xn(C)) {
      const le4 = C instanceof O ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + le4);
    }
    z4(C, ne3);
    try {
      const le4 = O.fromBytes(C, ne3), P3 = e.fromBytes(V2);
      if (ie4 && le4.hasHighS())
        return false;
      const { r: Z3, s: T } = le4, K3 = N3(M2), W3 = s.inv(T), X3 = s.create(K3 * W3), re4 = s.create(Z3 * W3), Q3 = e.BASE.multiplyUnsafe(X3).add(P3.multiplyUnsafe(re4));
      return Q3.is0() ? false : s.create(Q3.x) === Z3;
    } catch {
      return false;
    }
  }
  function U(C, M2, V2 = {}) {
    const { prehash: te5 } = Ki(V2, A);
    return M2 = S2(M2, te5), O.fromBytes(C, "recovered").recoverPublicKey(M2).toBytes();
  }
  return Object.freeze({
    keygen: d,
    getPublicKey: u,
    getSharedSecret: w,
    utils: y,
    lengths: k2,
    Point: e,
    sign: $4,
    verify: m,
    recoverPublicKey: U,
    Signature: O,
    hash: t
  });
}
var mi = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var Rg = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var Pg = BigInt(0);
var kn = BigInt(2);
function Ug(e) {
  const t = mi.p, r = BigInt(3), a = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), n = BigInt(44), p = BigInt(88), d = e * e * e % t, u = d * d * e % t, w = ir(u, r, t) * u % t, y = ir(w, r, t) * u % t, k2 = ir(y, kn, t) * d % t, A = ir(k2, i, t) * k2 % t, E2 = ir(A, o, t) * A % t, x = ir(E2, n, t) * E2 % t, I2 = ir(x, p, t) * x % t, B2 = ir(I2, n, t) * E2 % t, z4 = ir(B2, r, t) * u % t, O = ir(z4, s, t) * A % t, F3 = ir(O, a, t) * d % t, N3 = ir(F3, kn, t);
  if (!ai.eql(ai.sqr(N3), e))
    throw new Error("Cannot find square root");
  return N3;
}
var ai = bi(mi.p, { sqrt: Ug });
var vt3 = Tg(mi, {
  Fp: ai,
  endo: Rg
});
var it2 = Og(vt3, da);
var bl = {};
function ii(e, ...t) {
  let r = bl[e];
  if (r === void 0) {
    const a = da(cg(e));
    r = Ar(a, a), bl[e] = r;
  }
  return da(Ar(r, ...t));
}
var as = (e) => e.toBytes(true).slice(1);
var is = (e) => e % kn === Pg;
function En(e) {
  const { Fn: t, BASE: r } = vt3, a = t.fromBytes(e), i = r.multiply(a);
  return { scalar: is(i.y) ? a : t.neg(a), bytes: as(i) };
}
function jf(e) {
  const t = ai;
  if (!t.isValidNot0(e))
    throw new Error("invalid x: Fail if x  p");
  const r = t.create(e * e), a = t.create(r * e + BigInt(7));
  let i = t.sqrt(a);
  is(i) || (i = t.neg(i));
  const o = vt3.fromAffine({ x: e, y: i });
  return o.assertValidity(), o;
}
var aa = wa;
function Of(...e) {
  return vt3.Fn.create(aa(ii("BIP0340/challenge", ...e)));
}
function ml(e) {
  return En(e).bytes;
}
function Cg(e, t, r = gi(32)) {
  const { Fn: a } = vt3, i = Te3(e, void 0, "message"), { bytes: o, scalar: s } = En(t), n = Te3(r, 32, "auxRand"), p = a.toBytes(s ^ aa(ii("BIP0340/aux", n))), d = ii("BIP0340/nonce", p, o, i), { bytes: u, scalar: w } = En(d), y = Of(u, o, i), k2 = new Uint8Array(64);
  if (k2.set(u, 0), k2.set(a.toBytes(a.create(w + y * s)), 32), !Rf(k2, i, o))
    throw new Error("sign: Invalid signature produced");
  return k2;
}
function Rf(e, t, r) {
  const { Fp: a, Fn: i, BASE: o } = vt3, s = Te3(e, 64, "signature"), n = Te3(t, void 0, "message"), p = Te3(r, 32, "publicKey");
  try {
    const d = jf(aa(p)), u = aa(s.subarray(0, 32));
    if (!a.isValidNot0(u))
      return false;
    const w = aa(s.subarray(32, 64));
    if (!i.isValidNot0(w))
      return false;
    const y = Of(i.toBytes(u), as(d), n), k2 = o.multiplyUnsafe(w).add(d.multiplyUnsafe(i.neg(y))), { x: A, y: E2 } = k2.toAffine();
    return !(k2.is0() || !is(E2) || A !== u);
  } catch {
    return false;
  }
}
var Zt2 = (() => {
  const e = (t = gi(48)) => kf(t, mi.n);
  return {
    keygen: Af(e, ml),
    getPublicKey: ml,
    sign: Cg,
    verify: Rf,
    Point: vt3,
    utils: {
      randomSecretKey: e,
      taggedHash: ii,
      lift_x: jf,
      pointToBytes: as
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: false,
      signature: 64,
      seed: 48
    }
  };
})();
var zt3 = it2.Point;
var ja = zt3.Fn.ORDER;
function yl(e) {
  const t = e.toString(16).padStart(64, "0"), r = new Uint8Array(32);
  for (let a = 0; a < 32; a++)
    r[a] = parseInt(t.slice(a * 2, a * 2 + 2), 16);
  return r;
}
function rt3(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
var Pf = class {
  /** @inheritDoc */
  isPrivate(t) {
    return it2.utils.isValidSecretKey(t);
  }
  /** @inheritDoc */
  isPoint(t) {
    try {
      return zt3.fromHex(Bt3(t)), true;
    } catch {
      return false;
    }
  }
  /** @inheritDoc */
  isXOnlyPoint(t) {
    if (t.length !== 32) return false;
    try {
      return Zt2.utils.lift_x(rt3(t)), true;
    } catch {
      return false;
    }
  }
  /** @inheritDoc */
  pointFromScalar(t, r) {
    try {
      return it2.getPublicKey(t, r ?? true);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  pointCompress(t, r) {
    return zt3.fromHex(Bt3(t)).toBytes(r ?? true);
  }
  /** @inheritDoc */
  pointAddScalar(t, r, a) {
    try {
      const i = zt3.fromHex(Bt3(t));
      if (rt3(r) === 0n)
        return i.toBytes(a ?? true);
      const o = it2.getPublicKey(r, true), s = zt3.fromHex(Bt3(o));
      return i.add(s).toBytes(a ?? true);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t, r) {
    try {
      const a = Zt2.utils.lift_x(rt3(t));
      if (rt3(r) >= ja) return null;
      const i = it2.getPublicKey(r, true), o = zt3.fromHex(Bt3(i)), s = a.add(o), n = Zt2.utils.pointToBytes(s);
      return {
        parity: Number(s.y & 1n),
        xOnlyPubkey: n
      };
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  privateAdd(t, r) {
    const a = rt3(t), i = rt3(r), o = er(a + i, ja);
    return o === 0n ? null : yl(o);
  }
  /** @inheritDoc */
  privateNegate(t) {
    const r = rt3(t), a = er(ja - r, ja);
    return yl(a);
  }
  /** @inheritDoc */
  sign(t, r, a) {
    return it2.sign(t, r, {
      prehash: false,
      lowS: true,
      extraEntropy: a ?? false
    });
  }
  /** @inheritDoc */
  verify(t, r, a) {
    return it2.verify(a, t, r, {
      prehash: false,
      lowS: true
    });
  }
  /** @inheritDoc */
  signSchnorr(t, r, a) {
    return Zt2.sign(t, r, a);
  }
  /** @inheritDoc */
  verifySchnorr(t, r, a) {
    return Zt2.verify(a, t, r);
  }
};
function Lg() {
  return new Pf();
}
var _e5;
var Uf = class {
  /**
   * @param ecc - Object implementing the {@link TinySecp256k1Interface}.
   */
  constructor(t) {
    __privateAdd(this, _e5);
    __privateSet(this, _e5, t);
  }
  /** `true` when the underlying library supports Schnorr signing. */
  get hasSchnorrSign() {
    return typeof __privateGet(this, _e5).signSchnorr == "function";
  }
  /** `true` when the underlying library supports Schnorr verification. */
  get hasSchnorrVerify() {
    return typeof __privateGet(this, _e5).verifySchnorr == "function";
  }
  /** @inheritDoc */
  isPrivate(t) {
    return __privateGet(this, _e5).isPrivate(t);
  }
  /** @inheritDoc */
  isPoint(t) {
    return __privateGet(this, _e5).isPoint(t);
  }
  /** @inheritDoc */
  isXOnlyPoint(t) {
    if (t.length !== 32) return false;
    const r = new Uint8Array(33);
    return r[0] = 2, r.set(t, 1), __privateGet(this, _e5).isPoint(r);
  }
  /** @inheritDoc */
  pointFromScalar(t, r) {
    return __privateGet(this, _e5).pointFromScalar(t, r);
  }
  /** @inheritDoc */
  pointCompress(t, r) {
    return __privateGet(this, _e5).pointCompress(t, r);
  }
  /** @inheritDoc */
  pointAddScalar(t, r, a) {
    return __privateGet(this, _e5).pointAddScalar(t, r, a);
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t, r) {
    const a = __privateGet(this, _e5).xOnlyPointAddTweak(t, r);
    return a === null ? null : {
      parity: a.parity,
      xOnlyPubkey: a.xOnlyPubkey
    };
  }
  /** @inheritDoc */
  privateAdd(t, r) {
    return __privateGet(this, _e5).privateAdd(t, r);
  }
  /** @inheritDoc */
  privateNegate(t) {
    return __privateGet(this, _e5).privateNegate(t);
  }
  /** @inheritDoc */
  sign(t, r, a) {
    return __privateGet(this, _e5).sign(t, r, a);
  }
  /** @inheritDoc */
  verify(t, r, a) {
    return __privateGet(this, _e5).verify(t, r, a);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `signSchnorr`.
   */
  signSchnorr(t, r, a) {
    if (!__privateGet(this, _e5).signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return __privateGet(this, _e5).signSchnorr(t, r, a);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `verifySchnorr`.
   */
  verifySchnorr(t, r, a) {
    if (!__privateGet(this, _e5).verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return __privateGet(this, _e5).verifySchnorr(t, r, a);
  }
};
_e5 = new WeakMap();
function Ng(e) {
  return new Uf(e);
}
function fe3(e) {
  return $u(e);
}
function Ae3(e, t) {
  if (!e) throw new Error(`verifyCryptoBackend: ${t}`);
}
function qg(e) {
  Ae3(
    e.isPoint(fe3("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPoint should accept generator point"
  ), Ae3(
    !e.isPoint(fe3("030000000000000000000000000000000000000000000000000000000000000005")),
    "isPoint should reject invalid point"
  ), Ae3(
    e.isXOnlyPoint(
      fe3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "isXOnlyPoint should accept generator x-coordinate"
  ), Ae3(
    !e.isXOnlyPoint(
      fe3("0000000000000000000000000000000000000000000000000000000000000005")
    ),
    "isXOnlyPoint should reject x-coordinate not on curve"
  ), Ae3(
    !e.isXOnlyPoint(
      fe3("0000000000000000000000000000000000000000000000000000000000000000")
    ),
    "isXOnlyPoint should reject zero"
  ), Ae3(
    !e.isXOnlyPoint(fe3("79be667ef9dcbbac55a06295ce870b07")),
    "isXOnlyPoint should reject wrong length"
  ), Ae3(
    e.isPrivate(fe3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPrivate should accept valid scalar"
  ), Ae3(
    e.isPrivate(fe3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")),
    "isPrivate should accept n-1"
  ), Ae3(
    !e.isPrivate(fe3("0000000000000000000000000000000000000000000000000000000000000000")),
    "isPrivate should reject zero"
  ), Ae3(
    !e.isPrivate(fe3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")),
    "isPrivate should reject n"
  ), Ae3(
    !e.isPrivate(fe3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")),
    "isPrivate should reject n+1"
  );
  const t = e.privateAdd(
    fe3("0000000000000000000000000000000000000000000000000000000000000001"),
    fe3("0000000000000000000000000000000000000000000000000000000000000000")
  );
  Ae3(
    t !== null && Ge2(
      t,
      fe3("0000000000000000000000000000000000000000000000000000000000000001")
    ),
    "privateAdd: 1 + 0 should equal 1"
  ), Ae3(
    e.privateAdd(
      fe3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      fe3("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null,
    "privateAdd: (n-3) + 3 should return null (result is zero mod n)"
  );
  const r = e.privateAdd(
    fe3("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
    fe3("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
  );
  Ae3(
    r !== null && Ge2(
      r,
      fe3("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    ),
    "privateAdd: known vector failed"
  ), Ae3(
    Ge2(
      e.privateNegate(
        fe3("0000000000000000000000000000000000000000000000000000000000000001")
      ),
      fe3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ),
    "privateNegate(1) should equal n-1"
  ), Ae3(
    Ge2(
      e.privateNegate(
        fe3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      ),
      fe3("0000000000000000000000000000000000000000000000000000000000000003")
    ),
    "privateNegate(n-3) should equal 3"
  ), Ae3(
    Ge2(
      e.privateNegate(
        fe3("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      ),
      fe3("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    ),
    "privateNegate known vector failed"
  ), Ae3(
    Ge2(
      e.pointCompress(
        fe3(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        true
      ),
      fe3("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress uncompressed->compressed failed"
  ), Ae3(
    Ge2(
      e.pointCompress(
        fe3(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        false
      ),
      fe3(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress uncompressed->uncompressed failed"
  ), Ae3(
    Ge2(
      e.pointCompress(
        fe3(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        true
      ),
      fe3("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress compressed->compressed failed"
  ), Ae3(
    Ge2(
      e.pointCompress(
        fe3(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        false
      ),
      fe3(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress compressed->uncompressed failed"
  );
  const a = e.pointFromScalar(
    fe3("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
  );
  Ae3(
    a !== null && Ge2(
      a,
      fe3("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    ),
    "pointFromScalar known vector failed"
  ), Ae3(
    e.xOnlyPointAddTweak(
      fe3("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      fe3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null,
    "xOnlyPointAddTweak should return null for infinity result"
  );
  let i = e.xOnlyPointAddTweak(
    fe3("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    fe3("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  Ae3(
    i !== null && Ge2(
      i.xOnlyPubkey,
      fe3("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && i.parity === 1,
    "xOnlyPointAddTweak parity=1 case failed"
  ), i = e.xOnlyPointAddTweak(
    fe3("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    fe3("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), Ae3(
    i !== null && Ge2(
      i.xOnlyPubkey,
      fe3("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && i.parity === 0,
    "xOnlyPointAddTweak parity=0 case failed"
  );
  const o = e.sign(
    fe3("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
    fe3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
  );
  if (Ae3(
    Ge2(
      o,
      fe3(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    ),
    "sign known vector failed"
  ), Ae3(
    e.verify(
      fe3("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      fe3("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      o
    ),
    "verify known vector failed"
  ), e.signSchnorr) {
    const s = e.signSchnorr(
      fe3("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      fe3("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
      fe3("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
    );
    Ae3(
      Ge2(
        s,
        fe3(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      ),
      "signSchnorr known vector failed"
    );
  }
  e.verifySchnorr && Ae3(
    e.verifySchnorr(
      fe3(
        "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"
      ),
      fe3(
        "dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"
      ),
      fe3(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    ),
    "verifySchnorr known vector failed"
  );
}
var Dg = Object.freeze(Object.defineProperty({
  __proto__: null,
  ECPairSigner: Zr,
  EC_N: hi,
  EC_P: A02,
  LegacyBackend: Uf,
  NobleBackend: Pf,
  SATOSHI_MAX: Wn,
  SignerCapability: at3,
  assertBytes32: Yn,
  assertMessageHash: Qu,
  assertPrivateKey: Yu,
  assertPublicKey: Xu,
  assertXOnlyPublicKey: Ju,
  bytesEqual: Ge2,
  compareBytes: x02,
  concatBytes: Ku,
  createBytes20: O02,
  createBytes32: j02,
  createLegacyBackend: Ng,
  createMessageHash: U02,
  createNobleBackend: Lg,
  createPrivateKey: Xa,
  createPublicKey: ef,
  createSatoshi: C02,
  createSchnorrSignature: P02,
  createSignature: R02,
  createXOnlyPublicKey: rf,
  decodeWIF: sf,
  encodeWIF: nf,
  fromHexInternal: $u,
  isBytes20: z0,
  isBytes32: B02,
  isMessageHash: T02,
  isPrivateKey: S02,
  isPublicKey: Zu,
  isSatoshi: Wu,
  isSchnorrSignature: Vu,
  isSignature: Gu,
  isXOnlyPublicKey: I02,
  isZeroBytes: va,
  toHex: Bt3,
  verifyCryptoBackend: qg
}, Symbol.toStringTag, { value: "Module" }));
var Hi = {};
var br = {};
var Et3 = {};
var vl;
function Cf() {
  if (vl) return Et3;
  vl = 1, Object.defineProperty(Et3, "__esModule", { value: true }), Et3.hash160 = a, Et3.hash256 = i, Et3.hmacSHA512 = o;
  const e = v0, t = M0, r = G0;
  function a(s) {
    return (0, t.ripemd160)((0, r.sha256)(s));
  }
  function i(s) {
    return (0, r.sha256)(s);
  }
  function o(s, n) {
    return (0, e.hmac)(r.sha512, s, n);
  }
  return Et3;
}
var mr = {};
var oi = "0123456789abcdefABCDEF";
var ni = oi.split("").map((e) => e.codePointAt(0));
var si = Array(256).fill(true).map((e, t) => {
  const r = String.fromCodePoint(t), a = oi.indexOf(r);
  return a < 0 ? void 0 : a < 16 ? a : a - 6;
});
var Lf = new TextEncoder();
var Nf = new TextDecoder();
function Mg(e) {
  return Nf.decode(e);
}
function Fg(e) {
  return Lf.encode(e);
}
function $g(e) {
  const t = e.reduce((i, o) => i + o.length, 0), r = new Uint8Array(t);
  let a = 0;
  for (const i of e)
    r.set(i, a), a += i.length;
  return r;
}
function Kg(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? Zg(t) : Hg(t);
}
function Hg(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += oi[si[ni[e[r] >> 4]]], t += oi[si[ni[e[r] & 15]]];
  return t;
}
function Zg(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = ni[e[r] >> 4], t[r * 2 + 1] = ni[e[r] & 15];
  return Nf.decode(t);
}
function Gg(e) {
  const t = Lf.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let a;
  for (a = 0; a < r.length; a++) {
    const i = si[t[a * 2]], o = si[t[a * 2 + 1]];
    if (i === void 0 || o === void 0)
      break;
    r[a] = i << 4 | o;
  }
  return a === r.length ? r : r.slice(0, a);
}
function Vg(e) {
  return btoa(String.fromCharCode(...e));
}
function Wg(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let a = 0; a < t.length; a++)
    r[a] = t.charCodeAt(a);
  return r;
}
function Yg(e, t) {
  const r = Math.min(e.length, t.length);
  for (let a = 0; a < r; ++a)
    if (e[a] !== t[a])
      return e[a] < t[a] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function Xg(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  return e[t] = r, t + 1;
}
function Jg(e, t, r, a) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (a = a.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  return a === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function Qg(e, t, r, a) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (a = a.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return a === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function eb(e, t, r, a) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (a = a.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  return a === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function rb(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function tb(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let a = 0;
    return a = (a << 8) + e[t + 1], a = (a << 8) + e[t], a;
  } else {
    let a = 0;
    return a = (a << 8) + e[t], a = (a << 8) + e[t + 1], a;
  }
}
function ab(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let a = 0;
    return a = (a << 8) + e[t + 3] >>> 0, a = (a << 8) + e[t + 2] >>> 0, a = (a << 8) + e[t + 1] >>> 0, a = (a << 8) + e[t] >>> 0, a;
  } else {
    let a = 0;
    return a = (a << 8) + e[t] >>> 0, a = (a << 8) + e[t + 1] >>> 0, a = (a << 8) + e[t + 2] >>> 0, a = (a << 8) + e[t + 3] >>> 0, a;
  }
}
function ib(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let a = 0n;
    return a = (a << 8n) + BigInt(e[t + 7]), a = (a << 8n) + BigInt(e[t + 6]), a = (a << 8n) + BigInt(e[t + 5]), a = (a << 8n) + BigInt(e[t + 4]), a = (a << 8n) + BigInt(e[t + 3]), a = (a << 8n) + BigInt(e[t + 2]), a = (a << 8n) + BigInt(e[t + 1]), a = (a << 8n) + BigInt(e[t]), a;
  } else {
    let a = 0n;
    return a = (a << 8n) + BigInt(e[t]), a = (a << 8n) + BigInt(e[t + 1]), a = (a << 8n) + BigInt(e[t + 2]), a = (a << 8n) + BigInt(e[t + 3]), a = (a << 8n) + BigInt(e[t + 4]), a = (a << 8n) + BigInt(e[t + 5]), a = (a << 8n) + BigInt(e[t + 6]), a = (a << 8n) + BigInt(e[t + 7]), a;
  }
}
function ob(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 127 || r < -128)
    throw new Error(`The value of "value" is out of range. It must be >= -128 and <= 127. Received ${r}`);
  return e[t] = r, t + 1;
}
function nb(e, t, r, a) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 32767 || r < -32768)
    throw new Error(`The value of "value" is out of range. It must be >= -32768 and <= 32767. Received ${r}`);
  return a = a.toUpperCase(), a === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function sb(e, t, r, a) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 2147483647 || r < -2147483648)
    throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
  return a = a.toUpperCase(), a === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function lb(e, t, r, a) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return a = a.toUpperCase(), a === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function cb(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  const r = e[t];
  return r <= 127 ? r : r - 256;
}
function ub(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const a = e[t] + (e[t + 1] << 8);
    return e[t + 1] <= 127 ? a : a - 65536;
  } else {
    const a = (e[t] << 8) + e[t + 1];
    return e[t] <= 127 ? a : a - 65536;
  }
}
function fb(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const a = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
    return e[t + 3] <= 127 ? a : a - 4294967296;
  } else {
    const a = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
    return e[t] <= 127 ? a : a - 4294967296;
  }
}
function db(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let a = 0n;
  if (r === "LE")
    return a = (a << 8n) + BigInt(e[t + 7]), a = (a << 8n) + BigInt(e[t + 6]), a = (a << 8n) + BigInt(e[t + 5]), a = (a << 8n) + BigInt(e[t + 4]), a = (a << 8n) + BigInt(e[t + 3]), a = (a << 8n) + BigInt(e[t + 2]), a = (a << 8n) + BigInt(e[t + 1]), a = (a << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? a : a - 0x10000000000000000n;
  {
    let i = 0n;
    return i = (i << 8n) + BigInt(e[t]), i = (i << 8n) + BigInt(e[t + 1]), i = (i << 8n) + BigInt(e[t + 2]), i = (i << 8n) + BigInt(e[t + 3]), i = (i << 8n) + BigInt(e[t + 4]), i = (i << 8n) + BigInt(e[t + 5]), i = (i << 8n) + BigInt(e[t + 6]), i = (i << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? i : i - 0x10000000000000000n;
  }
}
var hb = Object.freeze(Object.defineProperty({
  __proto__: null,
  compare: Yg,
  concat: $g,
  fromBase64: Wg,
  fromHex: Gg,
  fromUtf8: Fg,
  readInt16: ub,
  readInt32: fb,
  readInt64: db,
  readInt8: cb,
  readUInt16: tb,
  readUInt32: ab,
  readUInt64: ib,
  readUInt8: rb,
  toBase64: Vg,
  toHex: Kg,
  toUtf8: Mg,
  writeInt16: nb,
  writeInt32: sb,
  writeInt64: lb,
  writeInt8: ob,
  writeUInt16: Jg,
  writeUInt32: Qg,
  writeUInt64: eb,
  writeUInt8: Xg
}, Symbol.toStringTag, { value: "Module" }));
var os = Mt(hb);
var wl;
function pb() {
  if (wl) return mr;
  wl = 1;
  var e = mr && mr.__createBinding || (Object.create ? (function(n, p, d, u) {
    u === void 0 && (u = d);
    var w = Object.getOwnPropertyDescriptor(p, d);
    (!w || ("get" in w ? !p.__esModule : w.writable || w.configurable)) && (w = { enumerable: true, get: function() {
      return p[d];
    } }), Object.defineProperty(n, u, w);
  }) : (function(n, p, d, u) {
    u === void 0 && (u = d), n[u] = p[d];
  })), t = mr && mr.__setModuleDefault || (Object.create ? (function(n, p) {
    Object.defineProperty(n, "default", { enumerable: true, value: p });
  }) : function(n, p) {
    n.default = p;
  }), r = mr && mr.__importStar || /* @__PURE__ */ (function() {
    var n = function(p) {
      return n = Object.getOwnPropertyNames || function(d) {
        var u = [];
        for (var w in d) Object.prototype.hasOwnProperty.call(d, w) && (u[u.length] = w);
        return u;
      }, n(p);
    };
    return function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var u = n(p), w = 0; w < u.length; w++) u[w] !== "default" && e(d, p, u[w]);
      return t(d, p), d;
    };
  })();
  Object.defineProperty(mr, "__esModule", { value: true }), mr.testEcc = o;
  const a = r(os), i = (n) => a.fromHex(n);
  function o(n) {
    if (s(n.isPoint(i("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), s(!n.isPoint(i("030000000000000000000000000000000000000000000000000000000000000005"))), s(n.isPrivate(i("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), s(n.isPrivate(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), s(!n.isPrivate(i("0000000000000000000000000000000000000000000000000000000000000000"))), s(!n.isPrivate(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), s(!n.isPrivate(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), s(a.compare(n.pointFromScalar(i("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), i("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), n.xOnlyPointAddTweak) {
      s(n.xOnlyPointAddTweak(i("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
      let p = n.xOnlyPointAddTweak(i("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), i("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
      s(a.compare(p.xOnlyPubkey, i("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && p.parity === 1), p = n.xOnlyPointAddTweak(i("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), i("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
    }
    s(a.compare(n.pointAddScalar(i("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), i("0000000000000000000000000000000000000000000000000000000000000003")), i("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), s(a.compare(n.privateAdd(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), i("0000000000000000000000000000000000000000000000000000000000000002")), i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), n.privateNegate && (s(a.compare(n.privateNegate(i("0000000000000000000000000000000000000000000000000000000000000001")), i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), s(a.compare(n.privateNegate(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), i("0000000000000000000000000000000000000000000000000000000000000003")) === 0), s(a.compare(n.privateNegate(i("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), i("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), s(a.compare(n.sign(i("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), i("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), s(n.verify(i("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), i("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), i("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), n.signSchnorr && s(a.compare(n.signSchnorr(i("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), i("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), i("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), i("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), n.verifySchnorr && s(n.verifySchnorr(i("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), i("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), i("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
  }
  function s(n) {
    if (!n)
      throw new Error("ecc library invalid");
  }
  return mr;
}
function gb(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let d = 0; d < t.length; d++)
    t[d] = 255;
  for (let d = 0; d < e.length; d++) {
    const u = e.charAt(d), w = u.charCodeAt(0);
    if (t[w] !== 255)
      throw new TypeError(u + " is ambiguous");
    t[w] = d;
  }
  const r = e.length, a = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function s(d) {
    if (d instanceof Uint8Array || (ArrayBuffer.isView(d) ? d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength) : Array.isArray(d) && (d = Uint8Array.from(d))), !(d instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (d.length === 0)
      return "";
    let u = 0, w = 0, y = 0;
    const k2 = d.length;
    for (; y !== k2 && d[y] === 0; )
      y++, u++;
    const A = (k2 - y) * o + 1 >>> 0, E2 = new Uint8Array(A);
    for (; y !== k2; ) {
      let B2 = d[y], z4 = 0;
      for (let O = A - 1; (B2 !== 0 || z4 < w) && O !== -1; O--, z4++)
        B2 += 256 * E2[O] >>> 0, E2[O] = B2 % r >>> 0, B2 = B2 / r >>> 0;
      if (B2 !== 0)
        throw new Error("Non-zero carry");
      w = z4, y++;
    }
    let x = A - w;
    for (; x !== A && E2[x] === 0; )
      x++;
    let I2 = a.repeat(u);
    for (; x < A; ++x)
      I2 += e.charAt(E2[x]);
    return I2;
  }
  function n(d) {
    if (typeof d != "string")
      throw new TypeError("Expected String");
    if (d.length === 0)
      return new Uint8Array();
    let u = 0, w = 0, y = 0;
    for (; d[u] === a; )
      w++, u++;
    const k2 = (d.length - u) * i + 1 >>> 0, A = new Uint8Array(k2);
    for (; u < d.length; ) {
      const B2 = d.charCodeAt(u);
      if (B2 > 255)
        return;
      let z4 = t[B2];
      if (z4 === 255)
        return;
      let O = 0;
      for (let F3 = k2 - 1; (z4 !== 0 || O < y) && F3 !== -1; F3--, O++)
        z4 += r * A[F3] >>> 0, A[F3] = z4 % 256 >>> 0, z4 = z4 / 256 >>> 0;
      if (z4 !== 0)
        throw new Error("Non-zero carry");
      y = O, u++;
    }
    let E2 = k2 - y;
    for (; E2 !== k2 && A[E2] === 0; )
      E2++;
    const x = new Uint8Array(w + (k2 - E2));
    let I2 = w;
    for (; E2 !== k2; )
      x[I2++] = A[E2++];
    return x;
  }
  function p(d) {
    const u = n(d);
    if (u)
      return u;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: n,
    decode: p
  };
}
var bb = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Zi = gb(bb);
function qf(e) {
  function t(o) {
    const s = e(o), n = o.length + 4, p = new Uint8Array(n);
    return p.set(o, 0), p.set(s.subarray(0, 4), o.length), Zi.encode(p);
  }
  function r(o) {
    const s = o.slice(0, -4), n = o.slice(-4), p = e(s);
    if (!(n[0] ^ p[0] | n[1] ^ p[1] | n[2] ^ p[2] | n[3] ^ p[3]))
      return s;
  }
  function a(o) {
    const s = Zi.decodeUnsafe(o);
    if (s !== void 0)
      return r(s);
  }
  function i(o) {
    const s = Zi.decode(o), n = r(s);
    if (n === void 0)
      throw new Error("Invalid checksum");
    return n;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: a
  };
}
function mb(e) {
  return l0(l0(e));
}
var { encode: Df, decode: Mf, decodeUnsafe: Ff } = qf(mb);
var ns = { encode: Df, decode: Mf, decodeUnsafe: Ff };
var yb = Object.freeze(Object.defineProperty({
  __proto__: null,
  bs58checkBase: qf,
  decode: Mf,
  decodeUnsafe: Ff,
  default: ns,
  encode: Df
}, Symbol.toStringTag, { value: "Module" }));
var $f = Mt(yb);
var xt3 = {};
var _l;
function Kf() {
  if (_l) return xt3;
  _l = 1, Object.defineProperty(xt3, "__esModule", { value: true }), xt3.validateBip32Path = t, xt3.validateBytes32 = r, xt3.validateBytes33 = a;
  const e = /^(m\/)?(\d+'?\/)*\d+'?$/;
  function t(i) {
    if (typeof i != "string" || !e.test(i))
      throw new TypeError("Expected BIP32 derivation path");
  }
  function r(i) {
    if (!(i instanceof Uint8Array) || i.length !== 32)
      throw new TypeError("Expected Uint8Array of length 32");
  }
  function a(i) {
    if (!(i instanceof Uint8Array) || i.length !== 33)
      throw new TypeError("Expected Uint8Array of length 33");
  }
  return xt3;
}
function Hf(e, t) {
  if (t !== void 0 && e[0] !== t)
    throw new Error("Invalid network version");
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: false
    };
  if (e.length !== 34)
    throw new Error("Invalid WIF length");
  if (e[33] !== 1)
    throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: true
  };
}
function Zf(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  const a = new Uint8Array(r ? 34 : 33);
  return new DataView(a.buffer).setUint8(0, e), a.set(t, 1), r && (a[33] = 1), a;
}
function vb(e, t) {
  return Hf(ns.decode(e), t);
}
function wb(e) {
  return ns.encode(Zf(e.version, e.privateKey, e.compressed));
}
var _b = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: vb,
  decodeRaw: Hf,
  encode: wb,
  encodeRaw: Zf
}, Symbol.toStringTag, { value: "Module" }));
var kb = Mt(_b);
var jr = {};
var kl;
function yi() {
  return kl || (kl = 1, Object.defineProperty(jr, "__esModule", { value: true }), jr.REGTEST = jr.TESTNET = jr.BITCOIN = void 0, jr.BITCOIN = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, jr.TESTNET = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "tb",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  }, jr.REGTEST = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bcrt",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  }), jr;
}
var Eb = Mt(Dg);
var El;
function xb() {
  if (El) return br;
  El = 1;
  var e = br && br.__createBinding || (Object.create ? (function(A, E2, x, I2) {
    I2 === void 0 && (I2 = x);
    var B2 = Object.getOwnPropertyDescriptor(E2, x);
    (!B2 || ("get" in B2 ? !E2.__esModule : B2.writable || B2.configurable)) && (B2 = { enumerable: true, get: function() {
      return E2[x];
    } }), Object.defineProperty(A, I2, B2);
  }) : (function(A, E2, x, I2) {
    I2 === void 0 && (I2 = x), A[I2] = E2[x];
  })), t = br && br.__setModuleDefault || (Object.create ? (function(A, E2) {
    Object.defineProperty(A, "default", { enumerable: true, value: E2 });
  }) : function(A, E2) {
    A.default = E2;
  }), r = br && br.__importStar || /* @__PURE__ */ (function() {
    var A = function(E2) {
      return A = Object.getOwnPropertyNames || function(x) {
        var I2 = [];
        for (var B2 in x) Object.prototype.hasOwnProperty.call(x, B2) && (I2[I2.length] = B2);
        return I2;
      }, A(E2);
    };
    return function(E2) {
      if (E2 && E2.__esModule) return E2;
      var x = {};
      if (E2 != null) for (var I2 = A(E2), B2 = 0; B2 < I2.length; B2++) I2[B2] !== "default" && e(x, E2, I2[B2]);
      return t(x, E2), x;
    };
  })();
  Object.defineProperty(br, "__esModule", { value: true }), br.BIP32Factory = k2;
  const a = r(Cf()), i = pb(), o = r($f), s = Kf(), n = r(kb), p = r(os), d = yi(), u = Eb, w = p.fromUtf8("Bitcoin seed"), y = /* @__PURE__ */ new WeakSet();
  function k2(A) {
    var _e25;
    const E2 = A;
    y.has(E2) || ((0, i.testEcc)(E2), y.add(E2));
    const x = 2147483648;
    function I2($4) {
      return $4.length === 32 ? $4 : $4.slice(1, 33);
    }
    class B2 {
      constructor(m, U, C) {
        __publicField(this, "__D");
        __publicField(this, "__Q");
        __publicField(this, "network");
        __publicField(this, "lowR", false);
        this.__D = m, this.__Q = U, this.network = C;
      }
      get publicKey() {
        return this.__Q === void 0 && (this.__Q = E2.pointFromScalar(this.__D, true)), this.__Q;
      }
      get xOnlyPublicKey() {
        return I2(this.publicKey);
      }
      get privateKey() {
        return this.__D;
      }
      get compressed() {
        return true;
      }
      get capabilities() {
        let m = u.SignerCapability.EcdsaVerify | u.SignerCapability.PublicKeyTweak;
        return this.__D !== void 0 && (m |= u.SignerCapability.EcdsaSign | u.SignerCapability.PrivateKeyExport), E2.signSchnorr && this.__D !== void 0 && (m |= u.SignerCapability.SchnorrSign), E2.verifySchnorr && (m |= u.SignerCapability.SchnorrVerify), m;
      }
      hasCapability(m) {
        return (this.capabilities & m) !== 0;
      }
      sign(m, U) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (U === void 0 && (U = this.lowR), U) {
          let C = E2.sign(m, this.privateKey);
          const M2 = new Uint8Array(32);
          let V2 = 0;
          for (; C[0] > 127; )
            V2++, p.writeUInt32(M2, 0, V2, "LE"), C = E2.sign(m, this.privateKey, M2);
          return C;
        } else
          return E2.sign(m, this.privateKey);
      }
      signSchnorr(m) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (!E2.signSchnorr)
          throw new Error("signSchnorr not supported by ecc library");
        return E2.signSchnorr(m, this.privateKey);
      }
      verify(m, U) {
        return E2.verify(m, this.publicKey, U);
      }
      verifySchnorr(m, U) {
        if (!E2.verifySchnorr)
          throw new Error("verifySchnorr not supported by ecc library");
        return E2.verifySchnorr(m, this.publicKey.subarray(1, 33), U);
      }
      tweak(m) {
        return this.privateKey ? this.tweakFromPrivateKey(m) : this.tweakFromPublicKey(m);
      }
      toWIF() {
        if (!this.privateKey)
          throw new TypeError("Missing private key");
        return n.encode({
          version: this.network.wif,
          privateKey: this.privateKey,
          compressed: true
        });
      }
      tweakFromPublicKey(m) {
        const U = I2(this.publicKey), C = E2.xOnlyPointAddTweak;
        if (!C)
          throw new Error("xOnlyPointAddTweak not supported by ecc library");
        const M2 = C(U, m);
        if (!M2 || M2.xOnlyPubkey === null)
          throw new Error("Cannot tweak public key!");
        const V2 = Uint8Array.from([
          M2.parity === 0 ? 2 : 3
        ]), te5 = p.concat([
          V2,
          M2.xOnlyPubkey
        ]);
        return new B2(void 0, te5, this.network);
      }
      tweakFromPrivateKey(m) {
        const U = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, C = (() => {
          if (U) {
            if (E2.privateNegate)
              return E2.privateNegate(this.privateKey);
            throw new Error("privateNegate not supported by ecc library");
          } else return this.privateKey;
        })(), M2 = E2.privateAdd(C, m);
        if (!M2)
          throw new Error("Invalid tweaked private key!");
        return new B2(M2, void 0, this.network);
      }
    }
    const _z2 = class _z2 extends B2 {
      constructor(m, U, C, M2, V2 = 0, te5 = 0, ie4 = 0) {
        super(m, U, M2);
        __publicField(this, "chainCode");
        __publicField(this, "__DEPTH");
        __publicField(this, "__INDEX");
        __publicField(this, "__PARENT_FINGERPRINT");
        __privateAdd(this, _e25);
        this.chainCode = C, this.__DEPTH = V2, this.__INDEX = te5, this.__PARENT_FINGERPRINT = ie4;
      }
      get capabilities() {
        return super.capabilities | u.SignerCapability.HdDerivation;
      }
      get depth() {
        return this.__DEPTH;
      }
      get index() {
        return this.__INDEX;
      }
      get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
      }
      get identifier() {
        return __privateGet(this, _e25) === void 0 && __privateSet(this, _e25, a.hash160(this.publicKey)), __privateGet(this, _e25);
      }
      get fingerprint() {
        return this.identifier.subarray(0, 4);
      }
      // Private === not neutered
      // Public === neutered
      isNeutered() {
        return this.__D === void 0;
      }
      neutered() {
        return new _z2(void 0, this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
      toBase58() {
        const m = this.network, U = this.isNeutered() ? m.bip32.public : m.bip32.private, C = new Uint8Array(78);
        return p.writeUInt32(C, 0, U, "BE"), p.writeUInt8(C, 4, this.depth), p.writeUInt32(C, 5, this.parentFingerprint, "BE"), p.writeUInt32(C, 9, this.index, "BE"), C.set(this.chainCode, 13), this.isNeutered() ? C.set(this.publicKey, 45) : (p.writeUInt8(C, 45, 0), C.set(this.privateKey, 46)), o.encode(C);
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
      derive(m) {
        if (m !== m >>> 0)
          throw new TypeError("Expected UInt32, got " + m);
        const U = m >= x, C = new Uint8Array(37);
        if (U) {
          if (this.isNeutered())
            throw new TypeError("Missing private key for hardened child key");
          C[0] = 0, C.set(this.privateKey, 1), p.writeUInt32(C, 33, m, "BE");
        } else
          C.set(this.publicKey, 0), p.writeUInt32(C, 33, m, "BE");
        const M2 = a.hmacSHA512(this.chainCode, C), V2 = M2.slice(0, 32), te5 = M2.slice(32);
        if (!E2.isPrivate(V2))
          return this.derive(m + 1);
        const ie4 = p.readUInt32(this.fingerprint, 0, "BE"), oe5 = this.depth + 1;
        if (this.isNeutered()) {
          const ne3 = E2.pointAddScalar(this.publicKey, V2, true);
          return ne3 === null ? this.derive(m + 1) : new _z2(void 0, ne3, te5, this.network, oe5, m, ie4);
        } else {
          const ne3 = E2.privateAdd(this.privateKey, V2);
          return ne3 == null ? this.derive(m + 1) : new _z2(ne3, void 0, te5, this.network, oe5, m, ie4);
        }
      }
      deriveHardened(m) {
        if (!Number.isInteger(m) || m < 0 || m > 2147483647)
          throw new TypeError("Expected UInt31, got " + m);
        return this.derive(m + x);
      }
      derivePath(m) {
        (0, s.validateBip32Path)(m);
        let U = m.split("/");
        if (U[0] === "m") {
          if (this.parentFingerprint)
            throw new TypeError("Expected master, got child");
          U = U.slice(1);
        }
        return U.reduce((C, M2) => {
          let V2;
          return M2.slice(-1) === "'" ? (V2 = parseInt(M2.slice(0, -1), 10), C.deriveHardened(V2)) : (V2 = parseInt(M2, 10), C.derive(V2));
        }, this);
      }
    };
    _e25 = new WeakMap();
    let z4 = _z2;
    function O($4, m) {
      const U = o.decode($4);
      if (U.length !== 78)
        throw new TypeError("Invalid buffer length");
      m = m || d.BITCOIN;
      const C = p.readUInt32(U, 0, "BE");
      if (C !== m.bip32.private && C !== m.bip32.public)
        throw new TypeError("Invalid network version");
      const M2 = U[4], V2 = p.readUInt32(U, 5, "BE");
      if (M2 === 0 && V2 !== 0)
        throw new TypeError("Invalid parent fingerprint");
      const te5 = p.readUInt32(U, 9, "BE");
      if (M2 === 0 && te5 !== 0)
        throw new TypeError("Invalid index");
      const ie4 = U.slice(13, 45);
      let oe5;
      if (C === m.bip32.private) {
        if (U[45] !== 0)
          throw new TypeError("Invalid private key");
        const ne3 = U.slice(46, 78);
        oe5 = N3(ne3, ie4, m, M2, te5, V2);
      } else {
        const ne3 = U.slice(45, 78);
        oe5 = q3(ne3, ie4, m, M2, te5, V2);
      }
      return oe5;
    }
    function F3($4, m, U) {
      return N3($4, m, U);
    }
    function N3($4, m, U, C, M2, V2) {
      if ((0, s.validateBytes32)($4), (0, s.validateBytes32)(m), U = U || d.BITCOIN, !E2.isPrivate($4))
        throw new TypeError("Private key not in range [1, n)");
      return new z4($4, void 0, m, U, C, M2, V2);
    }
    function j4($4, m, U) {
      return q3($4, m, U);
    }
    function q3($4, m, U, C, M2, V2) {
      if ((0, s.validateBytes33)($4), (0, s.validateBytes32)(m), U = U || d.BITCOIN, !E2.isPoint($4))
        throw new TypeError("Point is not on the curve");
      return new z4(void 0, $4, m, U, C, M2, V2);
    }
    function S2($4, m) {
      if (!($4 instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if ($4.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
      if ($4.length > 64)
        throw new TypeError("Seed should be at most 512 bits");
      m = m || d.BITCOIN;
      const U = a.hmacSHA512(w, $4), C = U.slice(0, 32), M2 = U.slice(32);
      return F3(C, M2, m);
    }
    function D2($4, m, U, C, M2, V2, te5) {
      return new z4($4, m, U, te5 || d.BITCOIN, C, M2, V2);
    }
    return {
      fromSeed: S2,
      fromBase58: O,
      fromPublicKey: j4,
      fromPrivateKey: F3,
      fromPrecomputed: D2
    };
  }
  return br;
}
var Gi = {};
var fr = {};
var xn = T0;
function ss(e, t) {
  if (e.length !== t.length)
    return false;
  let r = 0;
  for (let a = 0; a < e.length; a++)
    r |= e[a] ^ t[a];
  return r === 0;
}
function Ab(e) {
  return Uint8Array.from(e);
}
function ls(e) {
  if (typeof e != "object" || e === null || Oe(e))
    throw new Error("expected opts to be an object");
}
function li(e) {
  ls(e), e.context !== void 0 && ft(e.context, void 0, "opts.context");
}
function Na(e) {
  li(e), e.extraEntropy !== false && e.extraEntropy !== void 0 && ft(e.extraEntropy, void 0, "opts.extraEntropy");
}
function Xt3(e, ...t) {
  const r = (i) => typeof i == "number" ? i : i.bytesLen, a = t.reduce((i, o) => i + r(o), 0);
  return {
    bytesLen: a,
    encode: (i) => {
      const o = new Uint8Array(a);
      for (let s = 0, n = 0; s < t.length; s++) {
        const p = t[s], d = r(p), u = typeof p == "number" ? i[s] : p.encode(i[s]);
        ft(u, d, e), o.set(u, n), typeof p != "number" && u.fill(0), n += d;
      }
      return o;
    },
    decode: (i) => {
      ft(i, a, e);
      const o = [];
      for (const s of t) {
        const n = r(s), p = i.subarray(0, n);
        o.push(typeof s == "number" ? p : s.decode(p)), i = i.subarray(n);
      }
      return o;
    }
  };
}
function ot3(e, t) {
  const r = t * e.bytesLen;
  return {
    bytesLen: r,
    encode: (a) => {
      if (a.length !== t)
        throw new Error(`vecCoder.encode: wrong length=${a.length}. Expected: ${t}`);
      const i = new Uint8Array(r);
      for (let o = 0, s = 0; o < a.length; o++) {
        const n = e.encode(a[o]);
        i.set(n, s), n.fill(0), s += n.length;
      }
      return i;
    },
    decode: (a) => {
      ft(a, r);
      const i = [];
      for (let o = 0; o < a.length; o += e.bytesLen)
        i.push(e.decode(a.subarray(o, o + e.bytesLen)));
      return i;
    }
  };
}
function Pr(...e) {
  for (const t of e)
    if (Array.isArray(t))
      for (const r of t)
        r.fill(0);
    else
      t.fill(0);
}
function An(e) {
  return (1 << e) - 1;
}
var cs = Uint8Array.of();
function Bn(e, t = cs) {
  if (ft(e), ft(t), t.length > 255)
    throw new Error("context should be less than 255 bytes");
  return F0(new Uint8Array([0, t.length]), t, e);
}
var Bb = Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2]);
function Gf(e, t = 0) {
  if (!e.oid || !ss(e.oid.subarray(0, 10), Bb))
    throw new Error("hash.oid is invalid: expected NIST hash");
  const r = e.outputLen * 8 / 2;
  if (t > r)
    throw new Error("Pre-hash security strength too low: " + r + ", required: " + t);
}
function zn(e, t, r = cs) {
  if (ft(t), ft(r), r.length > 255)
    throw new Error("context should be less than 255 bytes");
  const a = e(t);
  return F0(new Uint8Array([1, r.length]), r, e.oid, a);
}
var zb = Object.freeze(Object.defineProperty({
  __proto__: null,
  EMPTY: cs,
  abytes: ft,
  checkHash: Gf,
  cleanBytes: Pr,
  concatBytes: F0,
  copyBytes: Ab,
  equalBytes: ss,
  getMask: An,
  getMessage: Bn,
  getMessagePrehash: zn,
  randomBytes: xn,
  splitCoder: Xt3,
  validateOpts: ls,
  validateSigOpts: Na,
  validateVerOpts: li,
  vecCoder: ot3
}, Symbol.toStringTag, { value: "Module" }));
var Sb = Mt(zb);
var Or = {};
var Ib = (e) => {
  const { newPoly: t, N: r, Q: a, F: i, ROOT_OF_UNITY: o, brvBits: s } = e, n = (I2, B2 = a) => {
    const z4 = I2 % B2 | 0;
    return (z4 >= 0 ? z4 | 0 : B2 + z4 | 0) | 0;
  }, p = (I2, B2 = a) => {
    const z4 = n(I2, B2) | 0;
    return (z4 > B2 >> 1 ? z4 - B2 | 0 : z4) | 0;
  };
  function d() {
    const I2 = t(r);
    for (let B2 = 0; B2 < r; B2++) {
      const z4 = ye2(B2, s), O = BigInt(o) ** BigInt(z4) % BigInt(a);
      I2[B2] = Number(O) | 0;
    }
    return I2;
  }
  const u = d(), w = {
    add: (I2, B2) => n((I2 | 0) + (B2 | 0)) | 0,
    sub: (I2, B2) => n((I2 | 0) - (B2 | 0)) | 0,
    mul: (I2, B2) => n((I2 | 0) * (B2 | 0)) | 0,
    inv: (I2) => {
      throw new Error("not implemented");
    }
  }, y = {
    N: r,
    roots: u,
    invertButterflies: true,
    skipStages: 0,
    brp: false
  }, k2 = Ce2(w, { dit: false, ...y }), A = Ce2(w, { dit: true, ...y });
  return { mod: n, smod: p, nttZetas: u, NTT: {
    encode: (I2) => k2(I2),
    decode: (I2) => {
      A(I2);
      for (let B2 = 0; B2 < I2.length; B2++)
        I2[B2] = n(i * I2[B2]);
      return I2;
    }
  }, bitsCoder: (I2, B2) => {
    const z4 = An(I2), O = I2 * (r / 8);
    return {
      bytesLen: O,
      encode: (F3) => {
        const N3 = new Uint8Array(O);
        for (let j4 = 0, q3 = 0, S2 = 0, D2 = 0; j4 < F3.length; j4++)
          for (q3 |= (B2.encode(F3[j4]) & z4) << S2, S2 += I2; S2 >= 8; S2 -= 8, q3 >>= 8)
            N3[D2++] = q3 & An(S2);
        return N3;
      },
      decode: (F3) => {
        const N3 = t(r);
        for (let j4 = 0, q3 = 0, S2 = 0, D2 = 0; j4 < F3.length; j4++)
          for (q3 |= F3[j4] << S2, S2 += 8; S2 >= I2; S2 -= I2, q3 >>= I2)
            N3[D2++] = B2.decode(q3 & z4);
        return N3;
      }
    };
  } };
};
var Vf = (e) => (t, r) => {
  r || (r = e.blockLen);
  const a = new Uint8Array(t.length + 2);
  a.set(t);
  const i = t.length, o = new Uint8Array(r);
  let s = e.create({}), n = 0, p = 0;
  return {
    stats: () => ({ calls: n, xofs: p }),
    get: (d, u) => (a[i + 0] = d, a[i + 1] = u, s.destroy(), s = e.create({}).update(a), n++, () => (p++, s.xofInto(o))),
    clean: () => {
      s.destroy(), Pr(o, a);
    }
  };
};
var us = Vf(j0);
var fs = Vf(P0);
function xl(e) {
  ls(e), e.externalMu !== void 0 && dt2(e.externalMu, "opts.externalMu");
}
var je3 = 256;
var Yr = 8380417;
var Tb = 1753;
var jb = 8347681;
var ht2 = 13;
var Sn = Math.floor((Yr - 1) / 88) | 0;
var In = Math.floor((Yr - 1) / 32) | 0;
var vi = {
  2: { K: 4, L: 4, D: ht2, GAMMA1: 2 ** 17, GAMMA2: Sn, TAU: 39, ETA: 2, OMEGA: 80 },
  3: { K: 6, L: 5, D: ht2, GAMMA1: 2 ** 19, GAMMA2: In, TAU: 49, ETA: 4, OMEGA: 55 },
  5: { K: 8, L: 7, D: ht2, GAMMA1: 2 ** 19, GAMMA2: In, TAU: 60, ETA: 2, OMEGA: 75 }
};
var Qe2 = (e) => new Int32Array(e);
var { mod: ft3, smod: qa, NTT: $e3, bitsCoder: Ob } = Ib({
  N: je3,
  Q: Yr,
  F: jb,
  ROOT_OF_UNITY: Tb,
  newPoly: Qe2,
  brvBits: 8
});
var Al = (e) => e;
var Gt3 = (e, t = Al, r = Al) => Ob(e, {
  encode: (a) => t(r(a)),
  decode: (a) => r(t(a))
});
var $r = (e, t) => {
  for (let r = 0; r < e.length; r++)
    e[r] = ft3(e[r] + t[r]);
  return e;
};
var Bl = (e, t) => {
  for (let r = 0; r < e.length; r++)
    e[r] = ft3(e[r] - t[r]);
  return e;
};
var Rb = (e) => {
  for (let t = 0; t < je3; t++)
    e[t] <<= ht2;
  return e;
};
var Vt3 = (e, t) => {
  for (let r = 0; r < je3; r++)
    if (Math.abs(qa(e[r])) >= t)
      return true;
  return false;
};
var Kr = (e, t) => {
  const r = Qe2(je3);
  for (let a = 0; a < e.length; a++)
    r[a] = ft3(e[a] * t[a]);
  return r;
};
function Oa(e) {
  const t = Qe2(je3);
  for (let r = 0; r < je3; ) {
    const a = e();
    if (a.length % 3)
      throw new Error("RejNTTPoly: unaligned block");
    for (let i = 0; r < je3 && i <= a.length - 3; i += 3) {
      const o = (a[i + 0] | a[i + 1] << 8 | a[i + 2] << 16) & 8388607;
      o < Yr && (t[r++] = o);
    }
  }
  return t;
}
function ds(e) {
  const { K: t, L: r, GAMMA1: a, GAMMA2: i, TAU: o, ETA: s, OMEGA: n } = e, { CRH_BYTES: p, TR_BYTES: d, C_TILDE_BYTES: u, XOF128: w, XOF256: y, securityLevel: k2 } = e;
  if (![2, 4].includes(s))
    throw new Error("Wrong ETA");
  if (![1 << 17, 1 << 19].includes(a))
    throw new Error("Wrong GAMMA1");
  if (![Sn, In].includes(i))
    throw new Error("Wrong GAMMA2");
  const A = o * s, E2 = (T) => {
    const K3 = ft3(T), W3 = qa(K3, 2 * i) | 0;
    return K3 - W3 === Yr - 1 ? { r1: 0, r0: W3 - 1 | 0 } : { r1: Math.floor((K3 - W3) / (2 * i)) | 0, r0: W3 };
  }, x = (T) => E2(T).r1, I2 = (T) => E2(T).r0, B2 = (T, K3) => T <= i || T > Yr - i || T === Yr - i && K3 === 0 ? 0 : 1, z4 = (T, K3) => {
    const W3 = Math.floor((Yr - 1) / (2 * i)), { r1: X3, r0: re4 } = E2(K3);
    return T === 1 ? re4 > 0 ? ft3(X3 + 1, W3) | 0 : ft3(X3 - 1, W3) | 0 : X3 | 0;
  }, O = (T) => {
    const K3 = ft3(T), W3 = qa(K3, 2 ** ht2) | 0;
    return { r1: Math.floor((K3 - W3) / 2 ** ht2) | 0, r0: W3 };
  }, F3 = {
    bytesLen: n + t,
    encode: (T) => {
      if (T === false)
        throw new Error("hint.encode: hint is false");
      const K3 = new Uint8Array(n + t);
      for (let W3 = 0, X3 = 0; W3 < t; W3++) {
        for (let re4 = 0; re4 < je3; re4++)
          T[W3][re4] !== 0 && (K3[X3++] = re4);
        K3[n + W3] = X3;
      }
      return K3;
    },
    decode: (T) => {
      const K3 = [];
      let W3 = 0;
      for (let X3 = 0; X3 < t; X3++) {
        const re4 = Qe2(je3);
        if (T[n + X3] < W3 || T[n + X3] > n)
          return false;
        for (let Q3 = W3; Q3 < T[n + X3]; Q3++) {
          if (Q3 > W3 && T[Q3] <= T[Q3 - 1])
            return false;
          re4[T[Q3]] = 1;
        }
        W3 = T[n + X3], K3.push(re4);
      }
      for (let X3 = W3; X3 < n; X3++)
        if (T[X3] !== 0)
          return false;
      return K3;
    }
  }, N3 = Gt3(s === 2 ? 3 : 4, (T) => s - T, (T) => {
    if (!(-s <= T && T <= s))
      throw new Error(`malformed key s1/s3 ${T} outside of ETA range [${-s}, ${s}]`);
    return T;
  }), j4 = Gt3(13, (T) => (1 << ht2 - 1) - T), q3 = Gt3(10), S2 = Gt3(a === 1 << 17 ? 18 : 20, (T) => qa(a - T)), D2 = Gt3(i === Sn ? 6 : 4), $4 = ot3(D2, t), m = Xt3("publicKey", 32, ot3(q3, t)), U = Xt3("secretKey", 32, 32, d, ot3(N3, r), ot3(N3, t), ot3(j4, t)), C = Xt3("signature", u, ot3(S2, r), F3), M2 = s === 2 ? (T) => T < 15 ? 2 - T % 5 : false : (T) => T < 9 ? 4 - T : false;
  function V2(T) {
    const K3 = Qe2(je3);
    for (let W3 = 0; W3 < je3; ) {
      const X3 = T();
      for (let re4 = 0; W3 < je3 && re4 < X3.length; re4 += 1) {
        const Q3 = M2(X3[re4] & 15), ae4 = M2(X3[re4] >> 4 & 15);
        Q3 !== false && (K3[W3++] = Q3), W3 < je3 && ae4 !== false && (K3[W3++] = ae4);
      }
    }
    return K3;
  }
  const te5 = (T) => {
    const K3 = Qe2(je3), W3 = P0.create({}).update(T), X3 = new Uint8Array(P0.blockLen);
    W3.xofInto(X3);
    const re4 = X3.slice(0, 8);
    for (let Q3 = je3 - o, ae4 = 8, ce5 = 0, ue5 = 0; Q3 < je3; Q3++) {
      let de3 = Q3 + 1;
      for (; de3 > Q3; )
        de3 = X3[ae4++], !(ae4 < P0.blockLen) && (W3.xofInto(X3), ae4 = 0);
      K3[Q3] = K3[de3], K3[de3] = 1 - ((re4[ce5] >> ue5++ & 1) << 1), ue5 >= 8 && (ce5++, ue5 = 0);
    }
    return K3;
  }, ie4 = (T) => {
    const K3 = Qe2(je3), W3 = Qe2(je3);
    for (let X3 = 0; X3 < T.length; X3++) {
      const { r0: re4, r1: Q3 } = O(T[X3]);
      K3[X3] = re4, W3[X3] = Q3;
    }
    return { r0: K3, r1: W3 };
  }, oe5 = (T, K3) => {
    for (let W3 = 0; W3 < je3; W3++)
      T[W3] = z4(K3[W3], T[W3]);
    return T;
  }, ne3 = (T, K3) => {
    const W3 = Qe2(je3);
    let X3 = 0;
    for (let re4 = 0; re4 < je3; re4++) {
      const Q3 = B2(T[re4], K3[re4]);
      W3[re4] = Q3, X3 += Q3;
    }
    return { v: W3, cnt: X3 };
  }, le4 = 32, P3 = Xt3("seed", 32, 64, 32), Z3 = {
    info: { type: "internal-ml-dsa" },
    lengths: {
      secretKey: U.bytesLen,
      publicKey: m.bytesLen,
      seed: 32,
      signature: C.bytesLen,
      signRand: le4
    },
    keygen: (T) => {
      const K3 = new Uint8Array(34), W3 = T === void 0;
      W3 && (T = xn(32)), ft(T, 32, "seed"), K3.set(T), W3 && Pr(T), K3[32] = t, K3[33] = r;
      const [X3, re4, Q3] = P3.decode(P0(K3, { dkLen: P3.bytesLen })), ae4 = y(re4), ce5 = [];
      for (let se4 = 0; se4 < r; se4++)
        ce5.push(V2(ae4.get(se4 & 255, se4 >> 8 & 255)));
      const ue5 = [];
      for (let se4 = r; se4 < r + t; se4++)
        ue5.push(V2(ae4.get(se4 & 255, se4 >> 8 & 255)));
      const de3 = ce5.map((se4) => $e3.encode(se4.slice())), pe5 = [], ve5 = [], ge5 = w(X3), ke3 = Qe2(je3);
      for (let se4 = 0; se4 < t; se4++) {
        Pr(ke3);
        for (let Be5 = 0; Be5 < r; Be5++) {
          const Oe5 = Oa(ge5.get(Be5, se4));
          $r(ke3, Kr(Oe5, de3[Be5]));
        }
        $e3.decode(ke3);
        const { r0: he4, r1: be4 } = ie4($r(ke3, ue5[se4]));
        pe5.push(he4), ve5.push(be4);
      }
      const Le4 = m.encode([X3, ve5]), Y2 = P0(Le4, { dkLen: d }), Ne4 = U.encode([X3, Q3, Y2, ce5, ue5, pe5]);
      return ge5.clean(), ae4.clean(), Pr(X3, re4, Q3, ce5, ue5, de3, ke3, pe5, ve5, Y2, K3), { publicKey: Le4, secretKey: Ne4 };
    },
    getPublicKey: (T) => {
      const [K3, W3, X3, re4, Q3, ae4] = U.decode(T), ce5 = w(K3), ue5 = re4.map((ve5) => $e3.encode(ve5.slice())), de3 = [], pe5 = Qe2(je3);
      for (let ve5 = 0; ve5 < t; ve5++) {
        pe5.fill(0);
        for (let ke3 = 0; ke3 < r; ke3++) {
          const Le4 = Oa(ce5.get(ke3, ve5));
          $r(pe5, Kr(Le4, ue5[ke3]));
        }
        $e3.decode(pe5), $r(pe5, Q3[ve5]);
        const { r1: ge5 } = ie4(pe5);
        de3.push(ge5);
      }
      return ce5.clean(), Pr(pe5, ue5, ae4, re4, Q3), m.encode([K3, de3]);
    },
    // NOTE: random is optional.
    sign: (T, K3, W3 = {}) => {
      Na(W3), xl(W3);
      let { extraEntropy: X3, externalMu: re4 = false } = W3;
      const [Q3, ae4, ce5, ue5, de3, pe5] = U.decode(K3), ve5 = [], ge5 = w(Q3);
      for (let se4 = 0; se4 < t; se4++) {
        const he4 = [];
        for (let be4 = 0; be4 < r; be4++)
          he4.push(Oa(ge5.get(be4, se4)));
        ve5.push(he4);
      }
      ge5.clean();
      for (let se4 = 0; se4 < r; se4++)
        $e3.encode(ue5[se4]);
      for (let se4 = 0; se4 < t; se4++)
        $e3.encode(de3[se4]), $e3.encode(pe5[se4]);
      const ke3 = re4 ? T : P0.create({ dkLen: p }).update(ce5).update(T).digest(), Le4 = X3 === false ? new Uint8Array(32) : X3 === void 0 ? xn(le4) : X3;
      ft(Le4, 32, "extraEntropy");
      const Y2 = P0.create({ dkLen: p }).update(ae4).update(Le4).update(ke3).digest();
      ft(Y2, p);
      const Ne4 = y(Y2, S2.bytesLen);
      e: for (let se4 = 0; ; ) {
        const he4 = [];
        for (let f = 0; f < r; f++, se4++)
          he4.push(S2.decode(Ne4.get(se4 & 255, se4 >> 8)()));
        const be4 = he4.map((f) => $e3.encode(f.slice())), Be5 = [];
        for (let f = 0; f < t; f++) {
          const v = Qe2(je3);
          for (let R3 = 0; R3 < r; R3++)
            $r(v, Kr(ve5[f][R3], be4[R3]));
          $e3.decode(v), Be5.push(v);
        }
        const Oe5 = Be5.map((f) => f.map(x)), ar2 = P0.create({ dkLen: u }).update(ke3).update($4.encode(Oe5)).digest(), Sr2 = $e3.encode(te5(ar2)), He3 = ue5.map((f) => Kr(f, Sr2));
        for (let f = 0; f < r; f++)
          if ($r($e3.decode(He3[f]), he4[f]), Vt3(He3[f], a - A))
            continue e;
        let ur3 = 0;
        const g = [];
        for (let f = 0; f < t; f++) {
          const v = $e3.decode(Kr(de3[f], Sr2)), R3 = Bl(Be5[f], v).map(I2);
          if (Vt3(R3, i - A))
            continue e;
          const H3 = $e3.decode(Kr(pe5[f], Sr2));
          if (Vt3(H3, i))
            continue e;
          $r(R3, H3);
          const J4 = ne3(R3, Oe5[f]);
          g.push(J4.v), ur3 += J4.cnt;
        }
        if (ur3 > n)
          continue;
        Ne4.clean();
        const l = C.encode([ar2, He3, g]);
        return Pr(ar2, He3, g, Sr2, Oe5, Be5, be4, he4, Y2, ke3, ue5, de3, pe5, ...ve5), l;
      }
      throw new Error("Unreachable code path reached, report this error");
    },
    verify: (T, K3, W3, X3 = {}) => {
      xl(X3);
      const { externalMu: re4 = false } = X3, [Q3, ae4] = m.decode(W3), ce5 = P0(W3, { dkLen: d });
      if (T.length !== C.bytesLen)
        return false;
      const [ue5, de3, pe5] = C.decode(T);
      if (pe5 === false)
        return false;
      for (let se4 = 0; se4 < r; se4++)
        if (Vt3(de3[se4], a - A))
          return false;
      const ve5 = re4 ? K3 : P0.create({ dkLen: p }).update(ce5).update(K3).digest(), ge5 = $e3.encode(te5(ue5)), ke3 = de3.map((se4) => se4.slice());
      for (let se4 = 0; se4 < r; se4++)
        $e3.encode(ke3[se4]);
      const Le4 = [], Y2 = w(Q3);
      for (let se4 = 0; se4 < t; se4++) {
        const he4 = Kr($e3.encode(Rb(ae4[se4])), ge5), be4 = Qe2(je3);
        for (let Oe5 = 0; Oe5 < r; Oe5++) {
          const ar2 = Oa(Y2.get(Oe5, se4));
          $r(be4, Kr(ar2, ke3[Oe5]));
        }
        const Be5 = $e3.decode(Bl(be4, he4));
        Le4.push(oe5(Be5, pe5[se4]));
      }
      Y2.clean();
      const Ne4 = P0.create({ dkLen: u }).update(ve5).update($4.encode(Le4)).digest();
      for (const se4 of pe5)
        if (!(se4.reduce((be4, Be5) => be4 + Be5, 0) <= n))
          return false;
      for (const se4 of de3)
        if (Vt3(se4, a - A))
          return false;
      return ss(ue5, Ne4);
    }
  };
  return {
    info: { type: "ml-dsa" },
    internal: Z3,
    securityLevel: k2,
    keygen: Z3.keygen,
    lengths: Z3.lengths,
    getPublicKey: Z3.getPublicKey,
    sign: (T, K3, W3 = {}) => {
      Na(W3);
      const X3 = Bn(T, W3.context), re4 = Z3.sign(X3, K3, W3);
      return Pr(X3), re4;
    },
    verify: (T, K3, W3, X3 = {}) => (li(X3), Z3.verify(T, Bn(K3, X3.context), W3)),
    prehash: (T) => (Gf(T, k2), {
      info: { type: "hashml-dsa" },
      securityLevel: k2,
      lengths: Z3.lengths,
      keygen: Z3.keygen,
      getPublicKey: Z3.getPublicKey,
      sign: (K3, W3, X3 = {}) => {
        Na(X3);
        const re4 = zn(T, K3, X3.context), Q3 = Z3.sign(re4, W3, X3);
        return Pr(re4), Q3;
      },
      verify: (K3, W3, X3, re4 = {}) => (li(re4), Z3.verify(K3, zn(T, W3, re4.context), X3))
    })
  };
}
var Pb = ds({
  ...vi[2],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 32,
  XOF128: us,
  XOF256: fs,
  securityLevel: 128
});
var Ub = ds({
  ...vi[3],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 48,
  XOF128: us,
  XOF256: fs,
  securityLevel: 192
});
var Cb = ds({
  ...vi[5],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 64,
  XOF128: us,
  XOF256: fs,
  securityLevel: 256
});
var Lb = Object.freeze(Object.defineProperty({
  __proto__: null,
  PARAMS: vi,
  ml_dsa44: Pb,
  ml_dsa65: Ub,
  ml_dsa87: Cb
}, Symbol.toStringTag, { value: "Module" }));
var Nb = Mt(Lb);
var zl;
function Wf() {
  if (zl) return Or;
  zl = 1, Object.defineProperty(Or, "__esModule", { value: true }), Or.DEFAULT_SECURITY_LEVEL = Or.MLDSASecurityLevel = void 0, Or.getMLDSAConfig = i, Or.findNetworkByVersion = o;
  const e = Nb, t = yi();
  var r;
  (function(s) {
    s[s.LEVEL2 = 44] = "LEVEL2", s[s.LEVEL3 = 65] = "LEVEL3", s[s.LEVEL5 = 87] = "LEVEL5";
  })(r || (Or.MLDSASecurityLevel = r = {}));
  const a = {
    [r.LEVEL2]: {
      level: r.LEVEL2,
      privateKeySize: 2560,
      publicKeySize: 1312,
      signatureSize: 2420,
      algorithm: e.ml_dsa44
    },
    [r.LEVEL3]: {
      level: r.LEVEL3,
      privateKeySize: 4032,
      publicKeySize: 1952,
      signatureSize: 3309,
      algorithm: e.ml_dsa65
    },
    [r.LEVEL5]: {
      level: r.LEVEL5,
      privateKeySize: 4896,
      publicKeySize: 2592,
      signatureSize: 4627,
      algorithm: e.ml_dsa87
    }
  };
  Or.DEFAULT_SECURITY_LEVEL = r.LEVEL2;
  function i(s, n) {
    const p = a[s];
    if (!p)
      throw new TypeError(`Invalid ML-DSA security level: ${s}. Must be MLDSASecurityLevel.LEVEL2 (44), LEVEL3 (65), or LEVEL5 (87)`);
    return {
      ...p,
      network: n
    };
  }
  function o(s) {
    const n = [t.BITCOIN, t.TESTNET, t.REGTEST];
    for (const p of n) {
      if (s === p.bip32.private)
        return { network: p, isPrivate: true };
      if (s === p.bip32.public)
        return { network: p, isPrivate: false };
    }
    return null;
  }
  return Or;
}
var Sl;
function qb() {
  var _e25;
  if (Sl) return fr;
  Sl = 1;
  var e = fr && fr.__createBinding || (Object.create ? (function(F3, N3, j4, q3) {
    q3 === void 0 && (q3 = j4);
    var S2 = Object.getOwnPropertyDescriptor(N3, j4);
    (!S2 || ("get" in S2 ? !N3.__esModule : S2.writable || S2.configurable)) && (S2 = { enumerable: true, get: function() {
      return N3[j4];
    } }), Object.defineProperty(F3, q3, S2);
  }) : (function(F3, N3, j4, q3) {
    q3 === void 0 && (q3 = j4), F3[q3] = N3[j4];
  })), t = fr && fr.__setModuleDefault || (Object.create ? (function(F3, N3) {
    Object.defineProperty(F3, "default", { enumerable: true, value: N3 });
  }) : function(F3, N3) {
    F3.default = N3;
  }), r = fr && fr.__importStar || /* @__PURE__ */ (function() {
    var F3 = function(N3) {
      return F3 = Object.getOwnPropertyNames || function(j4) {
        var q3 = [];
        for (var S2 in j4) Object.prototype.hasOwnProperty.call(j4, S2) && (q3[q3.length] = S2);
        return q3;
      }, F3(N3);
    };
    return function(N3) {
      if (N3 && N3.__esModule) return N3;
      var j4 = {};
      if (N3 != null) for (var q3 = F3(N3), S2 = 0; S2 < q3.length; S2++) q3[S2] !== "default" && e(j4, N3, q3[S2]);
      return t(j4, N3), j4;
    };
  })();
  Object.defineProperty(fr, "__esModule", { value: true }), fr.QuantumBIP32Factory = void 0;
  const a = Sb, i = r(Cf()), o = r(os), s = Kf(), n = r($f), p = Wf(), d = yi(), u = 32, w = 2147483648, y = o.fromUtf8("Bitcoin seed");
  class k2 {
    constructor(N3, j4, q3) {
      __publicField(this, "_privateKey");
      __publicField(this, "_publicKey");
      __publicField(this, "config");
      this._privateKey = N3, this._publicKey = j4, this.config = q3;
    }
    get publicKey() {
      if (!this._publicKey)
        throw new Error("Public key not available");
      return this._publicKey;
    }
    get privateKey() {
      return this._privateKey;
    }
    sign(N3) {
      if (!this._privateKey)
        throw new Error("Missing private key");
      return this.config.algorithm.sign(N3, this._privateKey, {
        extraEntropy: (0, a.randomBytes)(32)
      });
    }
    verify(N3, j4) {
      return this.config.algorithm.verify(j4, N3, this._publicKey);
    }
  }
  const _A5 = class _A5 extends k2 {
    constructor(N3, j4, q3, S2, D2 = 0, $4 = 0, m = 0) {
      super(N3, j4, S2);
      __publicField(this, "chainCode");
      __publicField(this, "_depth");
      __publicField(this, "_index");
      __publicField(this, "_parentFingerprint");
      __privateAdd(this, _e25);
      this.chainCode = q3, this._depth = D2, this._index = $4, this._parentFingerprint = m;
    }
    get depth() {
      return this._depth;
    }
    get index() {
      return this._index;
    }
    get parentFingerprint() {
      return this._parentFingerprint;
    }
    get identifier() {
      return __privateGet(this, _e25) === void 0 && __privateSet(this, _e25, i.hash160(this.publicKey)), __privateGet(this, _e25);
    }
    get fingerprint() {
      return this.identifier.subarray(0, 4);
    }
    get securityLevel() {
      return this.config.level;
    }
    get network() {
      return this.config.network;
    }
    isNeutered() {
      return this._privateKey === void 0;
    }
    neutered() {
      return new _A5(void 0, this.publicKey, this.chainCode, this.config, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const N3 = this.isNeutered() ? this.config.network.bip32.public : this.config.network.bip32.private, j4 = !this.isNeutered(), S2 = 45 + (j4 ? this.config.privateKeySize : this.config.publicKeySize), D2 = new Uint8Array(S2);
      let $4 = 0;
      return o.writeUInt32(D2, $4, N3, "BE"), $4 += 4, o.writeUInt8(D2, $4, this.depth), $4 += 1, o.writeUInt32(D2, $4, this.parentFingerprint, "BE"), $4 += 4, o.writeUInt32(D2, $4, this.index, "BE"), $4 += 4, D2.set(this.chainCode, $4), $4 += 32, j4 ? D2.set(this._privateKey, $4) : D2.set(this._publicKey, $4), n.encode(D2);
    }
    /**
     * Derive a child key using BIP32 HMAC chain for seed derivation,
     * then ML-DSA for key generation
     */
    derive(N3) {
      if (N3 !== N3 >>> 0)
        throw new TypeError("Expected UInt32, got " + N3);
      if (this.isNeutered())
        throw new TypeError("Cannot derive child keys without private key");
      const j4 = N3 >= w;
      let q3;
      if (j4) {
        const C = i.hash256(this._privateKey);
        q3 = new Uint8Array(37), q3[0] = 0, q3.set(C, 1), o.writeUInt32(q3, 33, N3, "BE");
      } else {
        const C = i.hash256(this._privateKey);
        q3 = new Uint8Array(36), q3.set(C, 0), o.writeUInt32(q3, 32, N3, "BE");
      }
      const S2 = i.hmacSHA512(this.chainCode, q3), D2 = S2.slice(0, 32), $4 = S2.slice(32), { secretKey: m, publicKey: U } = this.config.algorithm.keygen(D2);
      return new _A5(m, U, $4, this.config, this.depth + 1, N3, o.readUInt32(this.fingerprint, 0, "BE"));
    }
    deriveHardened(N3) {
      if (!Number.isInteger(N3) || N3 < 0 || N3 > 2147483647)
        throw new TypeError("Expected UInt31, got " + N3);
      return this.derive(N3 + w);
    }
    derivePath(N3) {
      (0, s.validateBip32Path)(N3);
      let j4 = N3.split("/");
      if (j4[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        j4 = j4.slice(1);
      }
      return j4.reduce((q3, S2) => {
        let D2;
        return S2.slice(-1) === "'" ? (D2 = parseInt(S2.slice(0, -1), 10), q3.deriveHardened(D2)) : (D2 = parseInt(S2, 10), q3.derive(D2));
      }, this);
    }
  };
  _e25 = new WeakMap();
  let A = _A5;
  function E2(F3, N3, j4) {
    if (!(F3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (F3.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (F3.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    const q3 = (0, p.getMLDSAConfig)(j4 || p.MLDSASecurityLevel.LEVEL2, N3 || d.BITCOIN), S2 = i.hmacSHA512(y, F3), D2 = S2.slice(0, 32), $4 = S2.slice(32), { secretKey: m, publicKey: U } = q3.algorithm.keygen(D2);
    return new A(
      m,
      U,
      $4,
      // Chain code
      q3,
      0,
      // depth
      0,
      // index
      0
    );
  }
  function x(F3) {
    const N3 = n.decode(F3), j4 = o.readUInt32(N3, 0, "BE"), q3 = (0, p.findNetworkByVersion)(j4);
    if (!q3)
      throw new TypeError("Unknown network version");
    const { network: S2, isPrivate: D2 } = q3, m = N3.length - 45;
    let U;
    if (D2)
      if (m === 2560)
        U = p.MLDSASecurityLevel.LEVEL2;
      else if (m === 4032)
        U = p.MLDSASecurityLevel.LEVEL3;
      else if (m === 4896)
        U = p.MLDSASecurityLevel.LEVEL5;
      else
        throw new TypeError(`Invalid private key size: ${m}`);
    else if (m === 1312)
      U = p.MLDSASecurityLevel.LEVEL2;
    else if (m === 1952)
      U = p.MLDSASecurityLevel.LEVEL3;
    else if (m === 2592)
      U = p.MLDSASecurityLevel.LEVEL5;
    else
      throw new TypeError(`Invalid public key size: ${m}`);
    const C = (0, p.getMLDSAConfig)(U, S2), M2 = D2 ? 45 + C.privateKeySize : 45 + C.publicKeySize;
    if (N3.length !== M2)
      throw new TypeError(`Invalid buffer length: expected ${M2}, got ${N3.length}`);
    let V2 = 4;
    const te5 = N3[V2];
    V2 += 1;
    const ie4 = o.readUInt32(N3, V2, "BE");
    if (te5 === 0 && ie4 !== 0)
      throw new TypeError("Invalid parent fingerprint");
    V2 += 4;
    const oe5 = o.readUInt32(N3, V2, "BE");
    if (te5 === 0 && oe5 !== 0)
      throw new TypeError("Invalid index");
    V2 += 4;
    const ne3 = N3.slice(V2, V2 + 32);
    if (V2 += 32, D2) {
      const le4 = N3.slice(V2, V2 + C.privateKeySize), P3 = C.algorithm.getPublicKey(le4);
      return new A(le4, P3, ne3, C, te5, oe5, ie4);
    } else {
      const le4 = N3.slice(V2, V2 + C.publicKeySize);
      return new A(void 0, le4, ne3, C, te5, oe5, ie4);
    }
  }
  function I2(F3, N3, j4, q3) {
    const S2 = (0, p.getMLDSAConfig)(q3 || p.MLDSASecurityLevel.LEVEL2, j4 || d.BITCOIN);
    if (F3.length !== S2.publicKeySize)
      throw new TypeError(`Invalid public key length for ML-DSA-${q3}: expected ${S2.publicKeySize}, got ${F3.length}`);
    if (N3.length !== u)
      throw new TypeError(`Invalid chain code length: expected ${u}, got ${N3.length}`);
    return new A(void 0, F3, N3, S2, 0, 0, 0);
  }
  function B2(F3, N3, j4, q3) {
    const S2 = (0, p.getMLDSAConfig)(q3 || p.MLDSASecurityLevel.LEVEL2, j4 || d.BITCOIN);
    if (F3.length !== S2.privateKeySize)
      throw new TypeError(`Invalid private key length for ML-DSA-${q3}: expected ${S2.privateKeySize}, got ${F3.length}`);
    if (N3.length !== u)
      throw new TypeError(`Invalid chain code length: expected ${u}, got ${N3.length}`);
    const D2 = S2.algorithm.getPublicKey(F3);
    return new A(F3, D2, N3, S2, 0, 0, 0);
  }
  function z4(F3, N3, j4, q3, S2) {
    const D2 = (0, p.getMLDSAConfig)(S2 || p.MLDSASecurityLevel.LEVEL2, q3 || d.BITCOIN);
    if (F3.length !== D2.privateKeySize)
      throw new TypeError(`Invalid private key length for ML-DSA-${S2}: expected ${D2.privateKeySize}, got ${F3.length}`);
    if (N3.length !== D2.publicKeySize)
      throw new TypeError(`Invalid public key length for ML-DSA-${S2}: expected ${D2.publicKeySize}, got ${N3.length}`);
    if (j4.length !== u)
      throw new TypeError(`Invalid chain code length: expected ${u}, got ${j4.length}`);
    return new A(F3, N3, j4, D2, 0, 0, 0);
  }
  function O(F3, N3, j4, q3, S2, D2, $4, m) {
    const U = (0, p.getMLDSAConfig)(m || p.MLDSASecurityLevel.LEVEL2, $4 || d.BITCOIN);
    return new A(F3, N3, j4, U, q3, S2, D2);
  }
  return fr.QuantumBIP32Factory = {
    fromSeed: E2,
    fromBase58: x,
    fromPublicKey: I2,
    fromPrivateKey: B2,
    fromKeyPair: z4,
    fromPrecomputed: O
  }, fr;
}
var Il;
function Db() {
  return Il || (Il = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.getMLDSAConfig = e.DEFAULT_SECURITY_LEVEL = e.MLDSASecurityLevel = e.QuantumBIP32Factory = void 0;
    var t = qb();
    Object.defineProperty(e, "QuantumBIP32Factory", { enumerable: true, get: function() {
      return t.QuantumBIP32Factory;
    } });
    var r = Wf();
    Object.defineProperty(e, "MLDSASecurityLevel", { enumerable: true, get: function() {
      return r.MLDSASecurityLevel;
    } }), Object.defineProperty(e, "DEFAULT_SECURITY_LEVEL", { enumerable: true, get: function() {
      return r.DEFAULT_SECURITY_LEVEL;
    } }), Object.defineProperty(e, "getMLDSAConfig", { enumerable: true, get: function() {
      return r.getMLDSAConfig;
    } });
  })(Gi)), Gi;
}
var Rr = {};
var Tl;
function Mb() {
  if (Tl) return Rr;
  Tl = 1, Object.defineProperty(Rr, "__esModule", { value: true }), Rr.QuantumDerivationPath = Rr.DerivationPath = void 0, Rr.getQuantumPath = r, Rr.getBitcoinPath = a;
  var e;
  (function(i) {
    i.BIP44 = "m/44'/0'/0'/0/0", i.BIP49 = "m/49'/0'/0'/0/0", i.BIP84 = "m/84'/0'/0'/0/0", i.BIP86 = "m/86'/0'/0'/0/0", i.BIP360 = "m/360'/0'/0'/0/0";
  })(e || (Rr.DerivationPath = e = {}));
  var t;
  (function(i) {
    i.STANDARD = "m/360'/0'/0'/0/0", i.CHANGE = "m/360'/0'/0'/1/0", i.ACCOUNT_0_ADDRESS_0 = "m/360'/0'/0'/0/0", i.ACCOUNT_0_ADDRESS_1 = "m/360'/0'/0'/0/1", i.ACCOUNT_1_ADDRESS_0 = "m/360'/1'/0'/0/0";
  })(t || (Rr.QuantumDerivationPath = t = {}));
  function r(i = 0, o = 0, s = false) {
    return `m/360'/${i}'/${s ? 1 : 0}'/${o}`;
  }
  function a(i, o = 0, s = 0, n = false) {
    return `m/${i}'/0'/${o}'/${n ? 1 : 0}/${s}`;
  }
  return Rr;
}
var jl;
function Fb() {
  return jl || (jl = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.getBitcoinPath = e.getQuantumPath = e.QuantumDerivationPath = e.DerivationPath = e.getMLDSAConfig = e.DEFAULT_SECURITY_LEVEL = e.MLDSASecurityLevel = e.QuantumBIP32Factory = e.REGTEST = e.TESTNET = e.BITCOIN = e.BIP32Factory = e.default = void 0;
    var t = xb();
    Object.defineProperty(e, "default", { enumerable: true, get: function() {
      return t.BIP32Factory;
    } }), Object.defineProperty(e, "BIP32Factory", { enumerable: true, get: function() {
      return t.BIP32Factory;
    } });
    var r = yi();
    Object.defineProperty(e, "BITCOIN", { enumerable: true, get: function() {
      return r.BITCOIN;
    } }), Object.defineProperty(e, "TESTNET", { enumerable: true, get: function() {
      return r.TESTNET;
    } }), Object.defineProperty(e, "REGTEST", { enumerable: true, get: function() {
      return r.REGTEST;
    } });
    var a = Db();
    Object.defineProperty(e, "QuantumBIP32Factory", { enumerable: true, get: function() {
      return a.QuantumBIP32Factory;
    } }), Object.defineProperty(e, "MLDSASecurityLevel", { enumerable: true, get: function() {
      return a.MLDSASecurityLevel;
    } }), Object.defineProperty(e, "DEFAULT_SECURITY_LEVEL", { enumerable: true, get: function() {
      return a.DEFAULT_SECURITY_LEVEL;
    } }), Object.defineProperty(e, "getMLDSAConfig", { enumerable: true, get: function() {
      return a.getMLDSAConfig;
    } });
    var i = Mb();
    Object.defineProperty(e, "DerivationPath", { enumerable: true, get: function() {
      return i.DerivationPath;
    } }), Object.defineProperty(e, "QuantumDerivationPath", { enumerable: true, get: function() {
      return i.QuantumDerivationPath;
    } }), Object.defineProperty(e, "getQuantumPath", { enumerable: true, get: function() {
      return i.getQuantumPath;
    } }), Object.defineProperty(e, "getBitcoinPath", { enumerable: true, get: function() {
      return i.getBitcoinPath;
    } });
  })(Hi)), Hi;
}
var $b = Fb();
var _y = k0($b);
function yr(e, t) {
  e = e.replace("#", "");
  const r = parseInt(e, 16), a = Math.round(2.55 * t), i = (r >> 16) + a, o = (r >> 8 & 255) + a, s = (r & 255) + a;
  return (16777216 + (i < 255 ? i < 1 ? 0 : i : 255) * 65536 + (o < 255 ? o < 1 ? 0 : o : 255) * 256 + (s < 255 ? s < 1 ? 0 : s : 255)).toString(16).slice(1);
}
var Vi = 10;
var Ol = (e = 0) => (t) => `\x1B[${t + e}m`;
var Rl = (e = 0) => (t) => `\x1B[${38 + e};5;${t}m`;
var Pl = (e = 0) => (t, r, a) => `\x1B[${38 + e};2;${t};${r};${a}m`;
var Ce3 = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(Ce3.modifier);
var Kb = Object.keys(Ce3.color);
var Hb = Object.keys(Ce3.bgColor);
[...Kb, ...Hb];
function Zb() {
  const e = /* @__PURE__ */ new Map();
  for (const [t, r] of Object.entries(Ce3)) {
    for (const [a, i] of Object.entries(r))
      Ce3[a] = {
        open: `\x1B[${i[0]}m`,
        close: `\x1B[${i[1]}m`
      }, r[a] = Ce3[a], e.set(i[0], i[1]);
    Object.defineProperty(Ce3, t, {
      value: r,
      enumerable: false
    });
  }
  return Object.defineProperty(Ce3, "codes", {
    value: e,
    enumerable: false
  }), Ce3.color.close = "\x1B[39m", Ce3.bgColor.close = "\x1B[49m", Ce3.color.ansi = Ol(), Ce3.color.ansi256 = Rl(), Ce3.color.ansi16m = Pl(), Ce3.bgColor.ansi = Ol(Vi), Ce3.bgColor.ansi256 = Rl(Vi), Ce3.bgColor.ansi16m = Pl(Vi), Object.defineProperties(Ce3, {
    rgbToAnsi256: {
      value(t, r, a) {
        return t === r && r === a ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(a / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(t) {
        const r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [a] = r;
        a.length === 3 && (a = [...a].map((o) => o + o).join(""));
        const i = Number.parseInt(a, 16);
        return [
          /* eslint-disable no-bitwise */
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (t) => Ce3.rgbToAnsi256(...Ce3.hexToRgb(t)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(t) {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, a, i;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, a = r, i = r;
        else {
          t -= 16;
          const n = t % 36;
          r = Math.floor(t / 36) / 5, a = Math.floor(n / 6) / 5, i = n % 6 / 5;
        }
        const o = Math.max(r, a, i) * 2;
        if (o === 0)
          return 30;
        let s = 30 + (Math.round(i) << 2 | Math.round(a) << 1 | Math.round(r));
        return o === 2 && (s += 60), s;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (t, r, a) => Ce3.ansi256ToAnsi(Ce3.rgbToAnsi256(t, r, a)),
      enumerable: false
    },
    hexToAnsi: {
      value: (t) => Ce3.ansi256ToAnsi(Ce3.hexToAnsi256(t)),
      enumerable: false
    }
  }), Ce3;
}
var wr = Zb();
var Ul = (() => {
  if (!("navigator" in globalThis))
    return 0;
  if (globalThis.navigator.userAgentData) {
    const e = navigator.userAgentData.brands.find(({ brand: t }) => t === "Chromium");
    if (e && e.version > 93)
      return 3;
  }
  return /\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent) ? 1 : 0;
})();
var Cl = Ul !== 0 && {
  level: Ul
};
var Gb = {
  stdout: Cl,
  stderr: Cl
};
function Vb(e, t, r) {
  let a = e.indexOf(t);
  if (a === -1)
    return e;
  const i = t.length;
  let o = 0, s = "";
  do
    s += e.slice(o, a) + t + r, o = a + i, a = e.indexOf(t, o);
  while (a !== -1);
  return s += e.slice(o), s;
}
function Wb(e, t, r, a) {
  let i = 0, o = "";
  do {
    const s = e[a - 1] === "\r";
    o += e.slice(i, s ? a - 1 : a) + t + (s ? `\r
` : `
`) + r, i = a + 1, a = e.indexOf(`
`, i);
  } while (a !== -1);
  return o += e.slice(i), o;
}
var { stdout: Ll, stderr: Nl } = Gb;
var Tn = Symbol("GENERATOR");
var Ut3 = Symbol("STYLER");
var ha = Symbol("IS_EMPTY");
var ql = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var Ct3 = /* @__PURE__ */ Object.create(null);
var Yb = (e, t = {}) => {
  if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  const r = Ll ? Ll.level : 0;
  e.level = t.level === void 0 ? r : t.level;
};
var Xb = class {
  constructor(t) {
    return Yf(t);
  }
};
var Yf = (e) => {
  const t = (...r) => r.join(" ");
  return Yb(t, e), Object.setPrototypeOf(t, _a2.prototype), t;
};
function _a2(e) {
  return Yf(e);
}
Object.setPrototypeOf(_a2.prototype, Function.prototype);
for (const [e, t] of Object.entries(wr))
  Ct3[e] = {
    get() {
      const r = ci(this, On(t.open, t.close, this[Ut3]), this[ha]);
      return Object.defineProperty(this, e, { value: r }), r;
    }
  };
Ct3.visible = {
  get() {
    const e = ci(this, this[Ut3], true);
    return Object.defineProperty(this, "visible", { value: e }), e;
  }
};
var jn = (e, t, r, ...a) => e === "rgb" ? t === "ansi16m" ? wr[r].ansi16m(...a) : t === "ansi256" ? wr[r].ansi256(wr.rgbToAnsi256(...a)) : wr[r].ansi(wr.rgbToAnsi(...a)) : e === "hex" ? jn("rgb", t, r, ...wr.hexToRgb(...a)) : wr[r][e](...a);
var Jb = ["rgb", "hex", "ansi256"];
for (const e of Jb) {
  Ct3[e] = {
    get() {
      const { level: r } = this;
      return function(...a) {
        const i = On(jn(e, ql[r], "color", ...a), wr.color.close, this[Ut3]);
        return ci(this, i, this[ha]);
      };
    }
  };
  const t = "bg" + e[0].toUpperCase() + e.slice(1);
  Ct3[t] = {
    get() {
      const { level: r } = this;
      return function(...a) {
        const i = On(jn(e, ql[r], "bgColor", ...a), wr.bgColor.close, this[Ut3]);
        return ci(this, i, this[ha]);
      };
    }
  };
}
var Qb = Object.defineProperties(() => {
}, {
  ...Ct3,
  level: {
    enumerable: true,
    get() {
      return this[Tn].level;
    },
    set(e) {
      this[Tn].level = e;
    }
  }
});
var On = (e, t, r) => {
  let a, i;
  return r === void 0 ? (a = e, i = t) : (a = r.openAll + e, i = t + r.closeAll), {
    open: e,
    close: t,
    openAll: a,
    closeAll: i,
    parent: r
  };
};
var ci = (e, t, r) => {
  const a = (...i) => em(a, i.length === 1 ? "" + i[0] : i.join(" "));
  return Object.setPrototypeOf(a, Qb), a[Tn] = e, a[Ut3] = t, a[ha] = r, a;
};
var em = (e, t) => {
  if (e.level <= 0 || !t)
    return e[ha] ? "" : t;
  let r = e[Ut3];
  if (r === void 0)
    return t;
  const { openAll: a, closeAll: i } = r;
  if (t.includes("\x1B"))
    for (; r !== void 0; )
      t = Vb(t, r.close, r.open), r = r.parent;
  const o = t.indexOf(`
`);
  return o !== -1 && (t = Wb(t, i, a, o)), a + t + i;
};
Object.defineProperties(_a2.prototype, Ct3);
_a2();
_a2({ level: Nl ? Nl.level : 0 });
var we3 = function(e, t, r, a) {
  if (r === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !a : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? a : r === "a" ? a.call(e) : a ? a.value : t.get(e);
};
var St2;
var Rn;
var Da;
var Ma;
var Pn;
var Fa;
var Un;
var $a;
var Cn;
var Ka;
var Jt3;
var Qt3;
var Ha;
var Hr;
var Ln;
var Za;
var Nn;
var rm = class {
  constructor(t = new Xb()) {
    this.chalk = t, this.moduleName = "", this.logColor = "#00bfff", this.enableLogs = true, this.hideLogs = false, St2.set(this, "#ff00ff"), Rn.set(this, yr(we3(this, St2, "f"), 75)), Da.set(this, "#9400d3"), Ma.set(this, yr(we3(this, Da, "f"), 15)), Pn.set(this, yr(we3(this, Ma, "f"), 15)), Fa.set(this, "#7cfc00"), Un.set(this, yr(we3(this, Fa, "f"), 15)), $a.set(this, "#ffdead"), Cn.set(this, yr(we3(this, $a, "f"), 15)), Ka.set(this, "#ff8c00"), Jt3.set(this, yr(we3(this, Ka, "f"), 15)), Qt3.set(this, "#ff4500"), Ha.set(this, yr(we3(this, Qt3, "f"), 15)), Hr.set(this, "#ffffff"), Ln.set(this, yr(we3(this, Hr, "f"), 15)), Za.set(this, "#8b0000"), Nn.set(this, yr(we3(this, Za, "f"), 15)), this.prefix = "", this.moduleName = this.constructor.name;
  }
  setLogPrefix(t) {
    this.prefix = t;
  }
  getStartPrefix() {
    return this.prefix;
  }
  disable() {
    this.enableLogs = false;
  }
  enable() {
    this.enableLogs = true;
  }
  fancyLog(t, r, a, i, o) {
    this.enableLogs && console.log(this.chalk.hex(we3(this, St2, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) + this.chalk.hex(we3(this, Hr, "f"))(t) + " " + this.chalk.hex(we3(this, Jt3, "f"))(r) + " " + this.chalk.hex(we3(this, Hr, "f"))(a) + " " + this.chalk.hex(we3(this, Pn, "f"))(i) + " " + this.chalk.hex(we3(this, Hr, "f"))(o));
  }
  log(...t) {
    if (this.enableLogs && !this.hideLogs) {
      const r = yr(this.logColor, 15);
      console.log(this.chalk.hex(this.logColor)(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(r)(...t));
    }
  }
  lightOrangeLog(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we3(this, Jt3, "f"))(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(we3(this, Hr, "f"))(...t)));
  }
  error(...t) {
    this.enableLogs && console.log(this.chalk.hex(we3(this, Qt3, "f"))(`${this.getStartPrefix()}[${this.moduleName} ERROR]: `) + this.chalk.hex(we3(this, Ha, "f"))(...t));
  }
  warn(...t) {
    this.enableLogs && console.log(this.chalk.hex(we3(this, Ka, "f"))(`${this.getStartPrefix()}[${this.moduleName} WARN]: `) + this.chalk.hex(we3(this, Jt3, "f"))(...t));
  }
  debug(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we3(this, $a, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(we3(this, Cn, "f"))(...t)));
  }
  success(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we3(this, Fa, "f"))(`${this.getStartPrefix()}[${this.moduleName} SUCCESS]: `) + this.chalk.hex(we3(this, Un, "f"))(...t)));
  }
  fail(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we3(this, Qt3, "f"))(`${this.getStartPrefix()}[${this.moduleName} FAIL]: `) + this.chalk.hex(we3(this, Ha, "f"))(...t)));
  }
  debugBright(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we3(this, Da, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(we3(this, Ma, "f"))(...t)));
  }
  important(...t) {
    this.enableLogs && console.log(this.chalk.hex(we3(this, St2, "f"))(`${this.getStartPrefix()}[${this.moduleName} IMPORTANT]: `) + this.chalk.hex(we3(this, Rn, "f"))(...t));
  }
  panic(...t) {
    this.enableLogs && console.log(this.chalk.hex(we3(this, Za, "f"))(`${this.getStartPrefix()}[${this.moduleName} HELP PANIC]: `) + this.chalk.hex(we3(this, Nn, "f"))(...t));
  }
  info(...t) {
    this.enableLogs && console.log(this.chalk.hex(we3(this, St2, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) + this.chalk.hex(we3(this, Hr, "f"))(...t));
  }
  securityNotice(...t) {
    this.enableLogs && console.log(this.chalk.hex("#22d8e6")(`${this.getStartPrefix()}[${this.moduleName} SECURITY NOTICE]: `) + this.chalk.hex("#22e3e6")(...t));
  }
  traceLog(...t) {
    this.enableLogs && console.log(this.chalk.hex("#ffffff")(`${this.getStartPrefix()}[${this.moduleName} TRACE LOG]: `) + this.chalk.hex(we3(this, Ln, "f"))(...t));
  }
};
St2 = /* @__PURE__ */ new WeakMap(), Rn = /* @__PURE__ */ new WeakMap(), Da = /* @__PURE__ */ new WeakMap(), Ma = /* @__PURE__ */ new WeakMap(), Pn = /* @__PURE__ */ new WeakMap(), Fa = /* @__PURE__ */ new WeakMap(), Un = /* @__PURE__ */ new WeakMap(), $a = /* @__PURE__ */ new WeakMap(), Cn = /* @__PURE__ */ new WeakMap(), Ka = /* @__PURE__ */ new WeakMap(), Jt3 = /* @__PURE__ */ new WeakMap(), Qt3 = /* @__PURE__ */ new WeakMap(), Ha = /* @__PURE__ */ new WeakMap(), Hr = /* @__PURE__ */ new WeakMap(), Ln = /* @__PURE__ */ new WeakMap(), Za = /* @__PURE__ */ new WeakMap(), Nn = /* @__PURE__ */ new WeakMap();
var ky = class extends rm {
  constructor() {
    super();
  }
};
var Dl;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.ERROR = 1] = "ERROR", e[e.WARN = 2] = "WARN", e[e.INFO = 3] = "INFO", e[e.DEBUG = 4] = "DEBUG", e[e.TRACE = 5] = "TRACE", e[e.ALL = 6] = "ALL";
})(Dl || (Dl = {}));
var tt2 = {};
var Ml;
function tm() {
  if (Ml) return tt2;
  Ml = 1, Object.defineProperty(tt2, "__esModule", { value: true }), tt2.bech32m = tt2.bech32 = void 0;
  const e = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", t = {};
  for (let d = 0; d < e.length; d++) {
    const u = e.charAt(d);
    t[u] = d;
  }
  function r(d) {
    const u = d >> 25;
    return (d & 33554431) << 5 ^ -(u >> 0 & 1) & 996825010 ^ -(u >> 1 & 1) & 642813549 ^ -(u >> 2 & 1) & 513874426 ^ -(u >> 3 & 1) & 1027748829 ^ -(u >> 4 & 1) & 705979059;
  }
  function a(d) {
    let u = 1;
    for (let w = 0; w < d.length; ++w) {
      const y = d.charCodeAt(w);
      if (y < 33 || y > 126)
        return "Invalid prefix (" + d + ")";
      u = r(u) ^ y >> 5;
    }
    u = r(u);
    for (let w = 0; w < d.length; ++w) {
      const y = d.charCodeAt(w);
      u = r(u) ^ y & 31;
    }
    return u;
  }
  function i(d, u, w, y) {
    let k2 = 0, A = 0;
    const E2 = (1 << w) - 1, x = [];
    for (let I2 = 0; I2 < d.length; ++I2)
      for (k2 = k2 << u | d[I2], A += u; A >= w; )
        A -= w, x.push(k2 >> A & E2);
    if (y)
      A > 0 && x.push(k2 << w - A & E2);
    else {
      if (A >= u)
        return "Excess padding";
      if (k2 << w - A & E2)
        return "Non-zero padding";
    }
    return x;
  }
  function o(d) {
    return i(d, 8, 5, true);
  }
  function s(d) {
    const u = i(d, 5, 8, false);
    if (Array.isArray(u))
      return u;
  }
  function n(d) {
    const u = i(d, 5, 8, false);
    if (Array.isArray(u))
      return u;
    throw new Error(u);
  }
  function p(d) {
    let u;
    d === "bech32" ? u = 1 : u = 734539939;
    function w(E2, x, I2) {
      if (I2 = I2 || 90, E2.length + 7 + x.length > I2)
        throw new TypeError("Exceeds length limit");
      E2 = E2.toLowerCase();
      let B2 = a(E2);
      if (typeof B2 == "string")
        throw new Error(B2);
      let z4 = E2 + "1";
      for (let O = 0; O < x.length; ++O) {
        const F3 = x[O];
        if (F3 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        B2 = r(B2) ^ F3, z4 += e.charAt(F3);
      }
      for (let O = 0; O < 6; ++O)
        B2 = r(B2);
      B2 ^= u;
      for (let O = 0; O < 6; ++O) {
        const F3 = B2 >> (5 - O) * 5 & 31;
        z4 += e.charAt(F3);
      }
      return z4;
    }
    function y(E2, x) {
      if (x = x || 90, E2.length < 8)
        return E2 + " too short";
      if (E2.length > x)
        return "Exceeds length limit";
      const I2 = E2.toLowerCase(), B2 = E2.toUpperCase();
      if (E2 !== I2 && E2 !== B2)
        return "Mixed-case string " + E2;
      E2 = I2;
      const z4 = E2.lastIndexOf("1");
      if (z4 === -1)
        return "No separator character for " + E2;
      if (z4 === 0)
        return "Missing prefix for " + E2;
      const O = E2.slice(0, z4), F3 = E2.slice(z4 + 1);
      if (F3.length < 6)
        return "Data too short";
      let N3 = a(O);
      if (typeof N3 == "string")
        return N3;
      const j4 = [];
      for (let q3 = 0; q3 < F3.length; ++q3) {
        const S2 = F3.charAt(q3), D2 = t[S2];
        if (D2 === void 0)
          return "Unknown character " + S2;
        N3 = r(N3) ^ D2, !(q3 + 6 >= F3.length) && j4.push(D2);
      }
      return N3 !== u ? "Invalid checksum for " + E2 : { prefix: O, words: j4 };
    }
    function k2(E2, x) {
      const I2 = y(E2, x);
      if (typeof I2 == "object")
        return I2;
    }
    function A(E2, x) {
      const I2 = y(E2, x);
      if (typeof I2 == "object")
        return I2;
      throw new Error(I2);
    }
    return {
      decodeUnsafe: k2,
      decode: A,
      encode: w,
      toWords: o,
      fromWordsUnsafe: s,
      fromWords: n
    };
  }
  return tt2.bech32 = p("bech32"), tt2.bech32m = p("bech32m"), tt2;
}
var Ey = tm();
var Xf = {};
var wi = {};
wi.byteLength = om;
wi.toByteArray = sm;
wi.fromByteArray = um;
var xr = [];
var sr = [];
var am = typeof Uint8Array < "u" ? Uint8Array : Array;
var Wi = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (At5 = 0, im = Wi.length; At5 < im; ++At5)
  xr[At5] = Wi[At5], sr[Wi.charCodeAt(At5)] = At5;
var At5;
var im;
sr[45] = 62;
sr[95] = 63;
function Jf(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var a = r === t ? 0 : 4 - r % 4;
  return [r, a];
}
function om(e) {
  var t = Jf(e), r = t[0], a = t[1];
  return (r + a) * 3 / 4 - a;
}
function nm(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function sm(e) {
  var t, r = Jf(e), a = r[0], i = r[1], o = new am(nm(e, a, i)), s = 0, n = i > 0 ? a - 4 : a, p;
  for (p = 0; p < n; p += 4)
    t = sr[e.charCodeAt(p)] << 18 | sr[e.charCodeAt(p + 1)] << 12 | sr[e.charCodeAt(p + 2)] << 6 | sr[e.charCodeAt(p + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
  return i === 2 && (t = sr[e.charCodeAt(p)] << 2 | sr[e.charCodeAt(p + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = sr[e.charCodeAt(p)] << 10 | sr[e.charCodeAt(p + 1)] << 4 | sr[e.charCodeAt(p + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function lm(e) {
  return xr[e >> 18 & 63] + xr[e >> 12 & 63] + xr[e >> 6 & 63] + xr[e & 63];
}
function cm(e, t, r) {
  for (var a, i = [], o = t; o < r; o += 3)
    a = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(lm(a));
  return i.join("");
}
function um(e) {
  for (var t, r = e.length, a = r % 3, i = [], o = 16383, s = 0, n = r - a; s < n; s += o)
    i.push(cm(e, s, s + o > n ? n : s + o));
  return a === 1 ? (t = e[r - 1], i.push(
    xr[t >> 2] + xr[t << 4 & 63] + "=="
  )) : a === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(
    xr[t >> 10] + xr[t >> 4 & 63] + xr[t << 2 & 63] + "="
  )), i.join("");
}
var hs = {};
hs.read = function(e, t, r, a, i) {
  var o, s, n = i * 8 - a - 1, p = (1 << n) - 1, d = p >> 1, u = -7, w = r ? i - 1 : 0, y = r ? -1 : 1, k2 = e[t + w];
  for (w += y, o = k2 & (1 << -u) - 1, k2 >>= -u, u += n; u > 0; o = o * 256 + e[t + w], w += y, u -= 8)
    ;
  for (s = o & (1 << -u) - 1, o >>= -u, u += a; u > 0; s = s * 256 + e[t + w], w += y, u -= 8)
    ;
  if (o === 0)
    o = 1 - d;
  else {
    if (o === p)
      return s ? NaN : (k2 ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, a), o = o - d;
  }
  return (k2 ? -1 : 1) * s * Math.pow(2, o - a);
};
hs.write = function(e, t, r, a, i, o) {
  var s, n, p, d = o * 8 - i - 1, u = (1 << d) - 1, w = u >> 1, y = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, k2 = a ? 0 : o - 1, A = a ? 1 : -1, E2 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (n = isNaN(t) ? 1 : 0, s = u) : (s = Math.floor(Math.log(t) / Math.LN2), t * (p = Math.pow(2, -s)) < 1 && (s--, p *= 2), s + w >= 1 ? t += y / p : t += y * Math.pow(2, 1 - w), t * p >= 2 && (s++, p /= 2), s + w >= u ? (n = 0, s = u) : s + w >= 1 ? (n = (t * p - 1) * Math.pow(2, i), s = s + w) : (n = t * Math.pow(2, w - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + k2] = n & 255, k2 += A, n /= 256, i -= 8)
    ;
  for (s = s << i | n, d += i; d > 0; e[r + k2] = s & 255, k2 += A, s /= 256, d -= 8)
    ;
  e[r + k2 - A] |= E2 * 128;
};
(function(e) {
  const t = wi, r = hs, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = F3, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i;
  const { Uint8Array: o, ArrayBuffer: s, SharedArrayBuffer: n } = globalThis;
  u.TYPED_ARRAY_SUPPORT = p(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function p() {
    try {
      const g = new o(1), l = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(l, o.prototype), Object.setPrototypeOf(g, l), g.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function d(g) {
    if (g > i)
      throw new RangeError('The value "' + g + '" is invalid for option "size"');
    const l = new o(g);
    return Object.setPrototypeOf(l, u.prototype), l;
  }
  function u(g, l, f) {
    if (typeof g == "number") {
      if (typeof l == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return A(g);
    }
    return w(g, l, f);
  }
  u.poolSize = 8192;
  function w(g, l, f) {
    if (typeof g == "string")
      return E2(g, l);
    if (s.isView(g))
      return I2(g);
    if (g == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g
      );
    if (Oe5(g, s) || g && Oe5(g.buffer, s) || typeof n < "u" && (Oe5(g, n) || g && Oe5(g.buffer, n)))
      return B2(g, l, f);
    if (typeof g == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const v = g.valueOf && g.valueOf();
    if (v != null && v !== g)
      return u.from(v, l, f);
    const R3 = z4(g);
    if (R3) return R3;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof g[Symbol.toPrimitive] == "function")
      return u.from(g[Symbol.toPrimitive]("string"), l, f);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g
    );
  }
  u.from = function(g, l, f) {
    return w(g, l, f);
  }, Object.setPrototypeOf(u.prototype, o.prototype), Object.setPrototypeOf(u, o);
  function y(g) {
    if (typeof g != "number")
      throw new TypeError('"size" argument must be of type number');
    if (g < 0)
      throw new RangeError('The value "' + g + '" is invalid for option "size"');
  }
  function k2(g, l, f) {
    return y(g), g <= 0 ? d(g) : l !== void 0 ? typeof f == "string" ? d(g).fill(l, f) : d(g).fill(l) : d(g);
  }
  u.alloc = function(g, l, f) {
    return k2(g, l, f);
  };
  function A(g) {
    return y(g), d(g < 0 ? 0 : O(g) | 0);
  }
  u.allocUnsafe = function(g) {
    return A(g);
  }, u.allocUnsafeSlow = function(g) {
    return A(g);
  };
  function E2(g, l) {
    if ((typeof l != "string" || l === "") && (l = "utf8"), !u.isEncoding(l))
      throw new TypeError("Unknown encoding: " + l);
    const f = N3(g, l) | 0;
    let v = d(f);
    const R3 = v.write(g, l);
    return R3 !== f && (v = v.slice(0, R3)), v;
  }
  function x(g) {
    const l = g.length < 0 ? 0 : O(g.length) | 0, f = d(l);
    for (let v = 0; v < l; v += 1)
      f[v] = g[v] & 255;
    return f;
  }
  function I2(g) {
    if (Oe5(g, o)) {
      const l = new o(g);
      return B2(l.buffer, l.byteOffset, l.byteLength);
    }
    return x(g);
  }
  function B2(g, l, f) {
    if (l < 0 || g.byteLength < l)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (g.byteLength < l + (f || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let v;
    return l === void 0 && f === void 0 ? v = new o(g) : f === void 0 ? v = new o(g, l) : v = new o(g, l, f), Object.setPrototypeOf(v, u.prototype), v;
  }
  function z4(g) {
    if (u.isBuffer(g)) {
      const l = O(g.length) | 0, f = d(l);
      return f.length === 0 || g.copy(f, 0, 0, l), f;
    }
    if (g.length !== void 0)
      return typeof g.length != "number" || ar2(g.length) ? d(0) : x(g);
    if (g.type === "Buffer" && Array.isArray(g.data))
      return x(g.data);
  }
  function O(g) {
    if (g >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return g | 0;
  }
  function F3(g) {
    return +g != g && (g = 0), u.alloc(+g);
  }
  u.isBuffer = function(l) {
    return l != null && l._isBuffer === true && l !== u.prototype;
  }, u.compare = function(l, f) {
    if (Oe5(l, o) && (l = u.from(l, l.offset, l.byteLength)), Oe5(f, o) && (f = u.from(f, f.offset, f.byteLength)), !u.isBuffer(l) || !u.isBuffer(f))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (l === f) return 0;
    let v = l.length, R3 = f.length;
    for (let H3 = 0, J4 = Math.min(v, R3); H3 < J4; ++H3)
      if (l[H3] !== f[H3]) {
        v = l[H3], R3 = f[H3];
        break;
      }
    return v < R3 ? -1 : R3 < v ? 1 : 0;
  }, u.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, u.concat = function(l, f) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return u.alloc(0);
    let v;
    if (f === void 0)
      for (f = 0, v = 0; v < l.length; ++v)
        f += l[v].length;
    const R3 = u.allocUnsafe(f);
    let H3 = 0;
    for (v = 0; v < l.length; ++v) {
      let J4 = l[v];
      if (Oe5(J4, o))
        H3 + J4.length > R3.length ? (u.isBuffer(J4) || (J4 = u.from(J4)), J4.copy(R3, H3)) : o.prototype.set.call(
          R3,
          J4,
          H3
        );
      else if (u.isBuffer(J4))
        J4.copy(R3, H3);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      H3 += J4.length;
    }
    return R3;
  };
  function N3(g, l) {
    if (u.isBuffer(g))
      return g.length;
    if (s.isView(g) || Oe5(g, s))
      return g.byteLength;
    if (typeof g != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof g
      );
    const f = g.length, v = arguments.length > 2 && arguments[2] === true;
    if (!v && f === 0) return 0;
    let R3 = false;
    for (; ; )
      switch (l) {
        case "ascii":
        case "latin1":
        case "binary":
          return f;
        case "utf8":
        case "utf-8":
          return Ne4(g).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return f * 2;
        case "hex":
          return f >>> 1;
        case "base64":
          return be4(g).length;
        default:
          if (R3)
            return v ? -1 : Ne4(g).length;
          l = ("" + l).toLowerCase(), R3 = true;
      }
  }
  u.byteLength = N3;
  function j4(g, l, f) {
    let v = false;
    if ((l === void 0 || l < 0) && (l = 0), l > this.length || ((f === void 0 || f > this.length) && (f = this.length), f <= 0) || (f >>>= 0, l >>>= 0, f <= l))
      return "";
    for (g || (g = "utf8"); ; )
      switch (g) {
        case "hex":
          return P3(this, l, f);
        case "utf8":
        case "utf-8":
          return te5(this, l, f);
        case "ascii":
          return ne3(this, l, f);
        case "latin1":
        case "binary":
          return le4(this, l, f);
        case "base64":
          return V2(this, l, f);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Z3(this, l, f);
        default:
          if (v) throw new TypeError("Unknown encoding: " + g);
          g = (g + "").toLowerCase(), v = true;
      }
  }
  u.prototype._isBuffer = true;
  function q3(g, l, f) {
    const v = g[l];
    g[l] = g[f], g[f] = v;
  }
  u.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let f = 0; f < l; f += 2)
      q3(this, f, f + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let f = 0; f < l; f += 4)
      q3(this, f, f + 3), q3(this, f + 1, f + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let f = 0; f < l; f += 8)
      q3(this, f, f + 7), q3(this, f + 1, f + 6), q3(this, f + 2, f + 5), q3(this, f + 3, f + 4);
    return this;
  }, u.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? te5(this, 0, l) : j4.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(l) {
    if (!u.isBuffer(l)) throw new TypeError("Argument must be a Buffer");
    return this === l ? true : u.compare(this, l) === 0;
  }, u.prototype.inspect = function() {
    let l = "";
    const f = e.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, f).replace(/(.{2})/g, "$1 ").trim(), this.length > f && (l += " ... "), "<Buffer " + l + ">";
  }, a && (u.prototype[a] = u.prototype.inspect), u.prototype.compare = function(l, f, v, R3, H3) {
    if (Oe5(l, o) && (l = u.from(l, l.offset, l.byteLength)), !u.isBuffer(l))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l
      );
    if (f === void 0 && (f = 0), v === void 0 && (v = l ? l.length : 0), R3 === void 0 && (R3 = 0), H3 === void 0 && (H3 = this.length), f < 0 || v > l.length || R3 < 0 || H3 > this.length)
      throw new RangeError("out of range index");
    if (R3 >= H3 && f >= v)
      return 0;
    if (R3 >= H3)
      return -1;
    if (f >= v)
      return 1;
    if (f >>>= 0, v >>>= 0, R3 >>>= 0, H3 >>>= 0, this === l) return 0;
    let J4 = H3 - R3, me5 = v - f;
    const Se5 = Math.min(J4, me5), Ie5 = this.slice(R3, H3), Re3 = l.slice(f, v);
    for (let xe5 = 0; xe5 < Se5; ++xe5)
      if (Ie5[xe5] !== Re3[xe5]) {
        J4 = Ie5[xe5], me5 = Re3[xe5];
        break;
      }
    return J4 < me5 ? -1 : me5 < J4 ? 1 : 0;
  };
  function S2(g, l, f, v, R3) {
    if (g.length === 0) return -1;
    if (typeof f == "string" ? (v = f, f = 0) : f > 2147483647 ? f = 2147483647 : f < -2147483648 && (f = -2147483648), f = +f, ar2(f) && (f = R3 ? 0 : g.length - 1), f < 0 && (f = g.length + f), f >= g.length) {
      if (R3) return -1;
      f = g.length - 1;
    } else if (f < 0)
      if (R3) f = 0;
      else return -1;
    if (typeof l == "string" && (l = u.from(l, v)), u.isBuffer(l))
      return l.length === 0 ? -1 : D2(g, l, f, v, R3);
    if (typeof l == "number")
      return l = l & 255, typeof o.prototype.indexOf == "function" ? R3 ? o.prototype.indexOf.call(g, l, f) : o.prototype.lastIndexOf.call(g, l, f) : D2(g, [l], f, v, R3);
    throw new TypeError("val must be string, number or Buffer");
  }
  function D2(g, l, f, v, R3) {
    let H3 = 1, J4 = g.length, me5 = l.length;
    if (v !== void 0 && (v = String(v).toLowerCase(), v === "ucs2" || v === "ucs-2" || v === "utf16le" || v === "utf-16le")) {
      if (g.length < 2 || l.length < 2)
        return -1;
      H3 = 2, J4 /= 2, me5 /= 2, f /= 2;
    }
    function Se5(Re3, xe5) {
      return H3 === 1 ? Re3[xe5] : Re3.readUInt16BE(xe5 * H3);
    }
    let Ie5;
    if (R3) {
      let Re3 = -1;
      for (Ie5 = f; Ie5 < J4; Ie5++)
        if (Se5(g, Ie5) === Se5(l, Re3 === -1 ? 0 : Ie5 - Re3)) {
          if (Re3 === -1 && (Re3 = Ie5), Ie5 - Re3 + 1 === me5) return Re3 * H3;
        } else
          Re3 !== -1 && (Ie5 -= Ie5 - Re3), Re3 = -1;
    } else
      for (f + me5 > J4 && (f = J4 - me5), Ie5 = f; Ie5 >= 0; Ie5--) {
        let Re3 = true;
        for (let xe5 = 0; xe5 < me5; xe5++)
          if (Se5(g, Ie5 + xe5) !== Se5(l, xe5)) {
            Re3 = false;
            break;
          }
        if (Re3) return Ie5;
      }
    return -1;
  }
  u.prototype.includes = function(l, f, v) {
    return this.indexOf(l, f, v) !== -1;
  }, u.prototype.indexOf = function(l, f, v) {
    return S2(this, l, f, v, true);
  }, u.prototype.lastIndexOf = function(l, f, v) {
    return S2(this, l, f, v, false);
  };
  function $4(g, l, f, v) {
    f = Number(f) || 0;
    const R3 = g.length - f;
    v ? (v = Number(v), v > R3 && (v = R3)) : v = R3;
    const H3 = l.length;
    v > H3 / 2 && (v = H3 / 2);
    let J4;
    for (J4 = 0; J4 < v; ++J4) {
      const me5 = parseInt(l.substr(J4 * 2, 2), 16);
      if (ar2(me5)) return J4;
      g[f + J4] = me5;
    }
    return J4;
  }
  function m(g, l, f, v) {
    return Be5(Ne4(l, g.length - f), g, f, v);
  }
  function U(g, l, f, v) {
    return Be5(se4(l), g, f, v);
  }
  function C(g, l, f, v) {
    return Be5(be4(l), g, f, v);
  }
  function M2(g, l, f, v) {
    return Be5(he4(l, g.length - f), g, f, v);
  }
  u.prototype.write = function(l, f, v, R3) {
    if (f === void 0)
      R3 = "utf8", v = this.length, f = 0;
    else if (v === void 0 && typeof f == "string")
      R3 = f, v = this.length, f = 0;
    else if (isFinite(f))
      f = f >>> 0, isFinite(v) ? (v = v >>> 0, R3 === void 0 && (R3 = "utf8")) : (R3 = v, v = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const H3 = this.length - f;
    if ((v === void 0 || v > H3) && (v = H3), l.length > 0 && (v < 0 || f < 0) || f > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    R3 || (R3 = "utf8");
    let J4 = false;
    for (; ; )
      switch (R3) {
        case "hex":
          return $4(this, l, f, v);
        case "utf8":
        case "utf-8":
          return m(this, l, f, v);
        case "ascii":
        case "latin1":
        case "binary":
          return U(this, l, f, v);
        case "base64":
          return C(this, l, f, v);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M2(this, l, f, v);
        default:
          if (J4) throw new TypeError("Unknown encoding: " + R3);
          R3 = ("" + R3).toLowerCase(), J4 = true;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function V2(g, l, f) {
    return l === 0 && f === g.length ? t.fromByteArray(g) : t.fromByteArray(g.slice(l, f));
  }
  function te5(g, l, f) {
    f = Math.min(g.length, f);
    const v = [];
    let R3 = l;
    for (; R3 < f; ) {
      const H3 = g[R3];
      let J4 = null, me5 = H3 > 239 ? 4 : H3 > 223 ? 3 : H3 > 191 ? 2 : 1;
      if (R3 + me5 <= f) {
        let Se5, Ie5, Re3, xe5;
        switch (me5) {
          case 1:
            H3 < 128 && (J4 = H3);
            break;
          case 2:
            Se5 = g[R3 + 1], (Se5 & 192) === 128 && (xe5 = (H3 & 31) << 6 | Se5 & 63, xe5 > 127 && (J4 = xe5));
            break;
          case 3:
            Se5 = g[R3 + 1], Ie5 = g[R3 + 2], (Se5 & 192) === 128 && (Ie5 & 192) === 128 && (xe5 = (H3 & 15) << 12 | (Se5 & 63) << 6 | Ie5 & 63, xe5 > 2047 && (xe5 < 55296 || xe5 > 57343) && (J4 = xe5));
            break;
          case 4:
            Se5 = g[R3 + 1], Ie5 = g[R3 + 2], Re3 = g[R3 + 3], (Se5 & 192) === 128 && (Ie5 & 192) === 128 && (Re3 & 192) === 128 && (xe5 = (H3 & 15) << 18 | (Se5 & 63) << 12 | (Ie5 & 63) << 6 | Re3 & 63, xe5 > 65535 && xe5 < 1114112 && (J4 = xe5));
        }
      }
      J4 === null ? (J4 = 65533, me5 = 1) : J4 > 65535 && (J4 -= 65536, v.push(J4 >>> 10 & 1023 | 55296), J4 = 56320 | J4 & 1023), v.push(J4), R3 += me5;
    }
    return oe5(v);
  }
  const ie4 = 4096;
  function oe5(g) {
    const l = g.length;
    if (l <= ie4)
      return String.fromCharCode.apply(String, g);
    let f = "", v = 0;
    for (; v < l; )
      f += String.fromCharCode.apply(
        String,
        g.slice(v, v += ie4)
      );
    return f;
  }
  function ne3(g, l, f) {
    let v = "";
    f = Math.min(g.length, f);
    for (let R3 = l; R3 < f; ++R3)
      v += String.fromCharCode(g[R3] & 127);
    return v;
  }
  function le4(g, l, f) {
    let v = "";
    f = Math.min(g.length, f);
    for (let R3 = l; R3 < f; ++R3)
      v += String.fromCharCode(g[R3]);
    return v;
  }
  function P3(g, l, f) {
    const v = g.length;
    (!l || l < 0) && (l = 0), (!f || f < 0 || f > v) && (f = v);
    let R3 = "";
    for (let H3 = l; H3 < f; ++H3)
      R3 += Sr2[g[H3]];
    return R3;
  }
  function Z3(g, l, f) {
    const v = g.slice(l, f);
    let R3 = "";
    for (let H3 = 0; H3 < v.length - 1; H3 += 2)
      R3 += String.fromCharCode(v[H3] + v[H3 + 1] * 256);
    return R3;
  }
  u.prototype.slice = function(l, f) {
    const v = this.length;
    l = ~~l, f = f === void 0 ? v : ~~f, l < 0 ? (l += v, l < 0 && (l = 0)) : l > v && (l = v), f < 0 ? (f += v, f < 0 && (f = 0)) : f > v && (f = v), f < l && (f = l);
    const R3 = this.subarray(l, f);
    return Object.setPrototypeOf(R3, u.prototype), R3;
  };
  function T(g, l, f) {
    if (g % 1 !== 0 || g < 0) throw new RangeError("offset is not uint");
    if (g + l > f) throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(l, f, v) {
    l = l >>> 0, f = f >>> 0, v || T(l, f, this.length);
    let R3 = this[l], H3 = 1, J4 = 0;
    for (; ++J4 < f && (H3 *= 256); )
      R3 += this[l + J4] * H3;
    return R3;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(l, f, v) {
    l = l >>> 0, f = f >>> 0, v || T(l, f, this.length);
    let R3 = this[l + --f], H3 = 1;
    for (; f > 0 && (H3 *= 256); )
      R3 += this[l + --f] * H3;
    return R3;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(l, f) {
    return l = l >>> 0, f || T(l, 1, this.length), this[l];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(l, f) {
    return l = l >>> 0, f || T(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(l, f) {
    return l = l >>> 0, f || T(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + this[l + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), this[l] * 16777216 + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, u.prototype.readBigUInt64LE = He3(function(l) {
    l = l >>> 0, ge5(l, "offset");
    const f = this[l], v = this[l + 7];
    (f === void 0 || v === void 0) && ke3(l, this.length - 8);
    const R3 = f + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + this[++l] * 2 ** 24, H3 = this[++l] + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + v * 2 ** 24;
    return BigInt(R3) + (BigInt(H3) << BigInt(32));
  }), u.prototype.readBigUInt64BE = He3(function(l) {
    l = l >>> 0, ge5(l, "offset");
    const f = this[l], v = this[l + 7];
    (f === void 0 || v === void 0) && ke3(l, this.length - 8);
    const R3 = f * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + this[++l], H3 = this[++l] * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + v;
    return (BigInt(R3) << BigInt(32)) + BigInt(H3);
  }), u.prototype.readIntLE = function(l, f, v) {
    l = l >>> 0, f = f >>> 0, v || T(l, f, this.length);
    let R3 = this[l], H3 = 1, J4 = 0;
    for (; ++J4 < f && (H3 *= 256); )
      R3 += this[l + J4] * H3;
    return H3 *= 128, R3 >= H3 && (R3 -= Math.pow(2, 8 * f)), R3;
  }, u.prototype.readIntBE = function(l, f, v) {
    l = l >>> 0, f = f >>> 0, v || T(l, f, this.length);
    let R3 = f, H3 = 1, J4 = this[l + --R3];
    for (; R3 > 0 && (H3 *= 256); )
      J4 += this[l + --R3] * H3;
    return H3 *= 128, J4 >= H3 && (J4 -= Math.pow(2, 8 * f)), J4;
  }, u.prototype.readInt8 = function(l, f) {
    return l = l >>> 0, f || T(l, 1, this.length), this[l] & 128 ? (255 - this[l] + 1) * -1 : this[l];
  }, u.prototype.readInt16LE = function(l, f) {
    l = l >>> 0, f || T(l, 2, this.length);
    const v = this[l] | this[l + 1] << 8;
    return v & 32768 ? v | 4294901760 : v;
  }, u.prototype.readInt16BE = function(l, f) {
    l = l >>> 0, f || T(l, 2, this.length);
    const v = this[l + 1] | this[l] << 8;
    return v & 32768 ? v | 4294901760 : v;
  }, u.prototype.readInt32LE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, u.prototype.readInt32BE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, u.prototype.readBigInt64LE = He3(function(l) {
    l = l >>> 0, ge5(l, "offset");
    const f = this[l], v = this[l + 7];
    (f === void 0 || v === void 0) && ke3(l, this.length - 8);
    const R3 = this[l + 4] + this[l + 5] * 2 ** 8 + this[l + 6] * 2 ** 16 + (v << 24);
    return (BigInt(R3) << BigInt(32)) + BigInt(f + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + this[++l] * 2 ** 24);
  }), u.prototype.readBigInt64BE = He3(function(l) {
    l = l >>> 0, ge5(l, "offset");
    const f = this[l], v = this[l + 7];
    (f === void 0 || v === void 0) && ke3(l, this.length - 8);
    const R3 = (f << 24) + // Overflow
    this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + this[++l];
    return (BigInt(R3) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + v);
  }), u.prototype.readFloatLE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), r.read(this, l, true, 23, 4);
  }, u.prototype.readFloatBE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), r.read(this, l, false, 23, 4);
  }, u.prototype.readDoubleLE = function(l, f) {
    return l = l >>> 0, f || T(l, 8, this.length), r.read(this, l, true, 52, 8);
  }, u.prototype.readDoubleBE = function(l, f) {
    return l = l >>> 0, f || T(l, 8, this.length), r.read(this, l, false, 52, 8);
  };
  function K3(g, l, f, v, R3, H3) {
    if (!u.isBuffer(g)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (l > R3 || l < H3) throw new RangeError('"value" argument is out of bounds');
    if (f + v > g.length) throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(l, f, v, R3) {
    if (l = +l, f = f >>> 0, v = v >>> 0, !R3) {
      const me5 = Math.pow(2, 8 * v) - 1;
      K3(this, l, f, v, me5, 0);
    }
    let H3 = 1, J4 = 0;
    for (this[f] = l & 255; ++J4 < v && (H3 *= 256); )
      this[f + J4] = l / H3 & 255;
    return f + v;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(l, f, v, R3) {
    if (l = +l, f = f >>> 0, v = v >>> 0, !R3) {
      const me5 = Math.pow(2, 8 * v) - 1;
      K3(this, l, f, v, me5, 0);
    }
    let H3 = v - 1, J4 = 1;
    for (this[f + H3] = l & 255; --H3 >= 0 && (J4 *= 256); )
      this[f + H3] = l / J4 & 255;
    return f + v;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 1, 255, 0), this[f] = l & 255, f + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 2, 65535, 0), this[f] = l & 255, this[f + 1] = l >>> 8, f + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 2, 65535, 0), this[f] = l >>> 8, this[f + 1] = l & 255, f + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 4, 4294967295, 0), this[f + 3] = l >>> 24, this[f + 2] = l >>> 16, this[f + 1] = l >>> 8, this[f] = l & 255, f + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 4, 4294967295, 0), this[f] = l >>> 24, this[f + 1] = l >>> 16, this[f + 2] = l >>> 8, this[f + 3] = l & 255, f + 4;
  };
  function W3(g, l, f, v, R3) {
    ve5(l, v, R3, g, f, 7);
    let H3 = Number(l & BigInt(4294967295));
    g[f++] = H3, H3 = H3 >> 8, g[f++] = H3, H3 = H3 >> 8, g[f++] = H3, H3 = H3 >> 8, g[f++] = H3;
    let J4 = Number(l >> BigInt(32) & BigInt(4294967295));
    return g[f++] = J4, J4 = J4 >> 8, g[f++] = J4, J4 = J4 >> 8, g[f++] = J4, J4 = J4 >> 8, g[f++] = J4, f;
  }
  function X3(g, l, f, v, R3) {
    ve5(l, v, R3, g, f, 7);
    let H3 = Number(l & BigInt(4294967295));
    g[f + 7] = H3, H3 = H3 >> 8, g[f + 6] = H3, H3 = H3 >> 8, g[f + 5] = H3, H3 = H3 >> 8, g[f + 4] = H3;
    let J4 = Number(l >> BigInt(32) & BigInt(4294967295));
    return g[f + 3] = J4, J4 = J4 >> 8, g[f + 2] = J4, J4 = J4 >> 8, g[f + 1] = J4, J4 = J4 >> 8, g[f] = J4, f + 8;
  }
  u.prototype.writeBigUInt64LE = He3(function(l, f = 0) {
    return W3(this, l, f, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = He3(function(l, f = 0) {
    return X3(this, l, f, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(l, f, v, R3) {
    if (l = +l, f = f >>> 0, !R3) {
      const Se5 = Math.pow(2, 8 * v - 1);
      K3(this, l, f, v, Se5 - 1, -Se5);
    }
    let H3 = 0, J4 = 1, me5 = 0;
    for (this[f] = l & 255; ++H3 < v && (J4 *= 256); )
      l < 0 && me5 === 0 && this[f + H3 - 1] !== 0 && (me5 = 1), this[f + H3] = (l / J4 >> 0) - me5 & 255;
    return f + v;
  }, u.prototype.writeIntBE = function(l, f, v, R3) {
    if (l = +l, f = f >>> 0, !R3) {
      const Se5 = Math.pow(2, 8 * v - 1);
      K3(this, l, f, v, Se5 - 1, -Se5);
    }
    let H3 = v - 1, J4 = 1, me5 = 0;
    for (this[f + H3] = l & 255; --H3 >= 0 && (J4 *= 256); )
      l < 0 && me5 === 0 && this[f + H3 + 1] !== 0 && (me5 = 1), this[f + H3] = (l / J4 >> 0) - me5 & 255;
    return f + v;
  }, u.prototype.writeInt8 = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[f] = l & 255, f + 1;
  }, u.prototype.writeInt16LE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 2, 32767, -32768), this[f] = l & 255, this[f + 1] = l >>> 8, f + 2;
  }, u.prototype.writeInt16BE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 2, 32767, -32768), this[f] = l >>> 8, this[f + 1] = l & 255, f + 2;
  }, u.prototype.writeInt32LE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 4, 2147483647, -2147483648), this[f] = l & 255, this[f + 1] = l >>> 8, this[f + 2] = l >>> 16, this[f + 3] = l >>> 24, f + 4;
  }, u.prototype.writeInt32BE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K3(this, l, f, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[f] = l >>> 24, this[f + 1] = l >>> 16, this[f + 2] = l >>> 8, this[f + 3] = l & 255, f + 4;
  }, u.prototype.writeBigInt64LE = He3(function(l, f = 0) {
    return W3(this, l, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = He3(function(l, f = 0) {
    return X3(this, l, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function re4(g, l, f, v, R3, H3) {
    if (f + v > g.length) throw new RangeError("Index out of range");
    if (f < 0) throw new RangeError("Index out of range");
  }
  function Q3(g, l, f, v, R3) {
    return l = +l, f = f >>> 0, R3 || re4(g, l, f, 4), r.write(g, l, f, v, 23, 4), f + 4;
  }
  u.prototype.writeFloatLE = function(l, f, v) {
    return Q3(this, l, f, true, v);
  }, u.prototype.writeFloatBE = function(l, f, v) {
    return Q3(this, l, f, false, v);
  };
  function ae4(g, l, f, v, R3) {
    return l = +l, f = f >>> 0, R3 || re4(g, l, f, 8), r.write(g, l, f, v, 52, 8), f + 8;
  }
  u.prototype.writeDoubleLE = function(l, f, v) {
    return ae4(this, l, f, true, v);
  }, u.prototype.writeDoubleBE = function(l, f, v) {
    return ae4(this, l, f, false, v);
  }, u.prototype.copy = function(l, f, v, R3) {
    if (!u.isBuffer(l)) throw new TypeError("argument should be a Buffer");
    if (v || (v = 0), !R3 && R3 !== 0 && (R3 = this.length), f >= l.length && (f = l.length), f || (f = 0), R3 > 0 && R3 < v && (R3 = v), R3 === v || l.length === 0 || this.length === 0) return 0;
    if (f < 0)
      throw new RangeError("targetStart out of bounds");
    if (v < 0 || v >= this.length) throw new RangeError("Index out of range");
    if (R3 < 0) throw new RangeError("sourceEnd out of bounds");
    R3 > this.length && (R3 = this.length), l.length - f < R3 - v && (R3 = l.length - f + v);
    const H3 = R3 - v;
    return this === l && typeof o.prototype.copyWithin == "function" ? this.copyWithin(f, v, R3) : o.prototype.set.call(
      l,
      this.subarray(v, R3),
      f
    ), H3;
  }, u.prototype.fill = function(l, f, v, R3) {
    if (typeof l == "string") {
      if (typeof f == "string" ? (R3 = f, f = 0, v = this.length) : typeof v == "string" && (R3 = v, v = this.length), R3 !== void 0 && typeof R3 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof R3 == "string" && !u.isEncoding(R3))
        throw new TypeError("Unknown encoding: " + R3);
      if (l.length === 1) {
        const J4 = l.charCodeAt(0);
        (R3 === "utf8" && J4 < 128 || R3 === "latin1") && (l = J4);
      }
    } else typeof l == "number" ? l = l & 255 : typeof l == "boolean" && (l = Number(l));
    if (f < 0 || this.length < f || this.length < v)
      throw new RangeError("Out of range index");
    if (v <= f)
      return this;
    f = f >>> 0, v = v === void 0 ? this.length : v >>> 0, l || (l = 0);
    let H3;
    if (typeof l == "number")
      for (H3 = f; H3 < v; ++H3)
        this[H3] = l;
    else {
      const J4 = u.isBuffer(l) ? l : u.from(l, R3), me5 = J4.length;
      if (me5 === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (H3 = 0; H3 < v - f; ++H3)
        this[H3 + f] = J4[H3 % me5];
    }
    return this;
  };
  const ce5 = {};
  function ue5(g, l, f) {
    ce5[g] = class extends f {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: l.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${g}]`, this.stack, delete this.name;
      }
      get code() {
        return g;
      }
      set code(R3) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: R3,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${g}]: ${this.message}`;
      }
    };
  }
  ue5(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(g) {
      return g ? `${g} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ue5(
    "ERR_INVALID_ARG_TYPE",
    function(g, l) {
      return `The "${g}" argument must be of type number. Received type ${typeof l}`;
    },
    TypeError
  ), ue5(
    "ERR_OUT_OF_RANGE",
    function(g, l, f) {
      let v = `The value of "${g}" is out of range.`, R3 = f;
      return Number.isInteger(f) && Math.abs(f) > 2 ** 32 ? R3 = de3(String(f)) : typeof f == "bigint" && (R3 = String(f), (f > BigInt(2) ** BigInt(32) || f < -(BigInt(2) ** BigInt(32))) && (R3 = de3(R3)), R3 += "n"), v += ` It must be ${l}. Received ${R3}`, v;
    },
    RangeError
  );
  function de3(g) {
    let l = "", f = g.length;
    const v = g[0] === "-" ? 1 : 0;
    for (; f >= v + 4; f -= 3)
      l = `_${g.slice(f - 3, f)}${l}`;
    return `${g.slice(0, f)}${l}`;
  }
  function pe5(g, l, f) {
    ge5(l, "offset"), (g[l] === void 0 || g[l + f] === void 0) && ke3(l, g.length - (f + 1));
  }
  function ve5(g, l, f, v, R3, H3) {
    if (g > f || g < l) {
      const J4 = typeof l == "bigint" ? "n" : "";
      let me5;
      throw l === 0 || l === BigInt(0) ? me5 = `>= 0${J4} and < 2${J4} ** ${(H3 + 1) * 8}${J4}` : me5 = `>= -(2${J4} ** ${(H3 + 1) * 8 - 1}${J4}) and < 2 ** ${(H3 + 1) * 8 - 1}${J4}`, new ce5.ERR_OUT_OF_RANGE("value", me5, g);
    }
    pe5(v, R3, H3);
  }
  function ge5(g, l) {
    if (typeof g != "number")
      throw new ce5.ERR_INVALID_ARG_TYPE(l, "number", g);
  }
  function ke3(g, l, f) {
    throw Math.floor(g) !== g ? (ge5(g, f), new ce5.ERR_OUT_OF_RANGE("offset", "an integer", g)) : l < 0 ? new ce5.ERR_BUFFER_OUT_OF_BOUNDS() : new ce5.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${l}`,
      g
    );
  }
  const Le4 = /[^+/0-9A-Za-z-_]/g;
  function Y2(g) {
    if (g = g.split("=")[0], g = g.trim().replace(Le4, ""), g.length < 2) return "";
    for (; g.length % 4 !== 0; )
      g = g + "=";
    return g;
  }
  function Ne4(g, l) {
    l = l || 1 / 0;
    let f;
    const v = g.length;
    let R3 = null;
    const H3 = [];
    for (let J4 = 0; J4 < v; ++J4) {
      if (f = g.charCodeAt(J4), f > 55295 && f < 57344) {
        if (!R3) {
          if (f > 56319) {
            (l -= 3) > -1 && H3.push(239, 191, 189);
            continue;
          } else if (J4 + 1 === v) {
            (l -= 3) > -1 && H3.push(239, 191, 189);
            continue;
          }
          R3 = f;
          continue;
        }
        if (f < 56320) {
          (l -= 3) > -1 && H3.push(239, 191, 189), R3 = f;
          continue;
        }
        f = (R3 - 55296 << 10 | f - 56320) + 65536;
      } else R3 && (l -= 3) > -1 && H3.push(239, 191, 189);
      if (R3 = null, f < 128) {
        if ((l -= 1) < 0) break;
        H3.push(f);
      } else if (f < 2048) {
        if ((l -= 2) < 0) break;
        H3.push(
          f >> 6 | 192,
          f & 63 | 128
        );
      } else if (f < 65536) {
        if ((l -= 3) < 0) break;
        H3.push(
          f >> 12 | 224,
          f >> 6 & 63 | 128,
          f & 63 | 128
        );
      } else if (f < 1114112) {
        if ((l -= 4) < 0) break;
        H3.push(
          f >> 18 | 240,
          f >> 12 & 63 | 128,
          f >> 6 & 63 | 128,
          f & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return H3;
  }
  function se4(g) {
    const l = [];
    for (let f = 0; f < g.length; ++f)
      l.push(g.charCodeAt(f) & 255);
    return l;
  }
  function he4(g, l) {
    let f, v, R3;
    const H3 = [];
    for (let J4 = 0; J4 < g.length && !((l -= 2) < 0); ++J4)
      f = g.charCodeAt(J4), v = f >> 8, R3 = f % 256, H3.push(R3), H3.push(v);
    return H3;
  }
  function be4(g) {
    return t.toByteArray(Y2(g));
  }
  function Be5(g, l, f, v) {
    let R3;
    for (R3 = 0; R3 < v && !(R3 + f >= l.length || R3 >= g.length); ++R3)
      l[R3 + f] = g[R3];
    return R3;
  }
  function Oe5(g, l) {
    return g instanceof l || g != null && g.constructor != null && g.constructor.name != null && g.constructor.name === l.name;
  }
  function ar2(g) {
    return g !== g;
  }
  const Sr2 = (function() {
    const g = "0123456789abcdef", l = new Array(256);
    for (let f = 0; f < 16; ++f) {
      const v = f * 16;
      for (let R3 = 0; R3 < 16; ++R3)
        l[v + R3] = g[f] + g[R3];
    }
    return l;
  })();
  function He3(g) {
    return typeof BigInt > "u" ? ur3 : g;
  }
  function ur3() {
    throw new Error("BigInt not supported");
  }
})(Xf);
var dr = Xf.Buffer;
var or = {};
var Ze3 = {};
var fm = JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]');
var dm = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
var hm = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
var pm = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
var gm = JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","academie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquerir","acronyme","acteur","actif","actuel","adepte","adequat","adhesif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aerer","aeronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agreable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algebre","algue","aliener","aliment","alleger","alliage","allouer","allumer","alourdir","alpaga","altesse","alveole","amateur","ambigu","ambre","amenager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","aneantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","aperitif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","arteriel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","banniere","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","belier","belote","benefice","berceau","berger","berline","bermuda","besace","besogne","betail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","breche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","cafeine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","camera","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cedille","ceinture","celeste","cellule","cendrier","censurer","central","cercle","cerebral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chequier","chercher","cheval","chien","chiffre","chignon","chimere","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinema","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohesion","coiffer","coincer","colere","colibri","colline","colmater","colonel","combat","comedie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortege","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","creature","crediter","cremeux","creuser","crevette","cribler","crier","cristal","critere","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillere","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","debattre","debiter","deborder","debrider","debutant","decaler","decembre","dechirer","decider","declarer","decorer","decrire","decupler","dedale","deductif","deesse","defensif","defiler","defrayer","degager","degivrer","deglutir","degrafer","dejeuner","delice","deloger","demander","demeurer","demolir","denicher","denouer","dentelle","denuder","depart","depenser","dephaser","deplacer","deposer","deranger","derober","desastre","descente","desert","designer","desobeir","dessiner","destrier","detacher","detester","detourer","detresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","differer","digerer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","eblouir","ecarter","echarpe","echelle","eclairer","eclipse","eclore","ecluse","ecole","economie","ecorce","ecouter","ecraser","ecremer","ecrivain","ecrou","ecume","ecureuil","edifier","eduquer","effacer","effectif","effigie","effort","effrayer","effusion","egaliser","egarer","ejecter","elaborer","elargir","electron","elegant","elephant","eleve","eligible","elitisme","eloge","elucider","eluder","emballer","embellir","embryon","emeraude","emission","emmener","emotion","emouvoir","empereur","employer","emporter","emprise","emulsion","encadrer","enchere","enclave","encoche","endiguer","endosser","endroit","enduire","energie","enfance","enfermer","enfouir","engager","engin","englober","enigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","enumerer","envahir","enviable","envoyer","enzyme","eolien","epaissir","epargne","epatant","epaule","epicerie","epidemie","epier","epilogue","epine","episode","epitaphe","epoque","epreuve","eprouver","epuisant","equerre","equipe","eriger","erosion","erreur","eruption","escalier","espadon","espece","espiegle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","etagere","etaler","etanche","etatique","eteindre","etendoir","eternel","ethanol","ethique","ethnie","etirer","etoffer","etoile","etonnant","etourdir","etrange","etroit","etude","euphorie","evaluer","evasion","eventail","evidence","eviter","evolutif","evoquer","exact","exagerer","exaucer","exceller","excitant","exclusif","excuse","executer","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expedier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","febrile","feconder","federer","felin","femme","femur","fendoir","feodal","fermer","feroce","ferveur","festival","feuille","feutre","fevrier","fiasco","ficeler","fictif","fidele","figure","filature","filetage","filiere","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fleau","fleche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougere","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","fregate","freiner","frelon","fremir","frenesie","frere","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","geant","gelatine","gelule","gendarme","general","genie","genou","gentil","geologie","geometre","geranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyere","guepard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","helium","hematome","herbe","herisson","hermine","heron","hesiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogene","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiene","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","imperial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inedit","ineptie","inexact","infini","infliger","informer","infusion","ingerer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irreel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvenile","kayak","kimono","kiosque","label","labial","labourer","lacerer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","legal","leger","legume","lessive","lettre","levier","lexique","lezard","liasse","liberer","libre","licence","licorne","liege","lievre","ligature","ligoter","ligue","limer","limite","limonade","limpide","lineaire","lingot","lionceau","liquide","lisiere","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumiere","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","malefice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","materiel","matiere","matraque","maudire","maussade","mauve","maximal","mechant","meconnu","medaille","medecin","mediter","meduse","meilleur","melange","melodie","membre","memoire","menacer","mener","menhir","mensonge","mentor","mercredi","merite","merle","messager","mesure","metal","meteore","methode","metier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","mineral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murene","murmure","muscle","museum","musicien","mutation","muter","mutuel","myriade","myrtille","mystere","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nebuleux","nectar","nefaste","negation","negliger","negocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numero","nuptial","nuque","nutritif","obeir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","ocean","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onereux","onirique","opale","opaque","operer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygene","ozone","paisible","palace","palmares","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pasteque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pelican","pelle","pelouse","peluche","pendule","penetrer","penible","pensif","penurie","pepite","peplum","perdrix","perforer","periode","permuter","perplexe","persil","perte","peser","petale","petit","petrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","piece","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poesie","poete","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","ponderer","poney","portique","position","posseder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","precieux","predire","prefixe","prelude","prenom","presence","pretexte","prevoir","primitif","prince","prison","priver","probleme","proceder","prodige","profond","progres","proie","projeter","prologue","promener","propre","prospere","proteger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quietude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","reactif","reagir","realiser","reanimer","recevoir","reciter","reclamer","recolter","recruter","reculer","recycler","rediger","redouter","refaire","reflexe","reformer","refrain","refuge","regalien","region","reglage","regulier","reiterer","rejeter","rejouer","relatif","relever","relief","remarque","remede","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","reserve","resineux","resoudre","respect","rester","resultat","retablir","retenir","reticule","retomber","retracer","reunion","reussir","revanche","revivre","revolte","revulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","riviere","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scelerat","scenario","sceptre","schema","science","scinder","score","scrutin","sculpter","seance","secable","secher","secouer","secreter","sedatif","seduire","seigneur","sejour","selectif","semaine","sembler","semence","seminal","senateur","sensible","sentence","separer","sequence","serein","sergent","serieux","serrure","serum","service","sesame","sevir","sevrage","sextuple","sideral","siecle","sieger","siffler","sigle","signal","silence","silicium","simple","sincere","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","special","sphere","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succes","sucre","suffixe","suggerer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symetrie","synapse","syntaxe","systeme","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","temoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tetine","texte","theme","theorie","therapie","thorax","tibia","tiede","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolerant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trefle","tremper","tresor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","vegetal","vehicule","veinard","veloce","vendredi","venerer","venger","venimeux","ventouse","verdure","verin","vernir","verrou","verser","vertu","veston","veteran","vetuste","vexant","vexer","viaduc","viande","victoire","vidange","video","vignette","vigueur","vilain","village","vinaigre","violon","vipere","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xenon","yacht","zebre","zenith","zeste","zoologie"]');
var bm = JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]');
var mm = JSON.parse('["abaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","accion","aceite","acelga","acento","aceptar","acido","aclarar","acne","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aereo","afectar","aficion","afinar","afirmar","agil","agitar","agonia","agosto","agotar","agregar","agrio","agua","agudo","aguila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacran","alambre","alarma","alba","album","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodon","aliado","aliento","alivio","alma","almeja","almibar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ambar","ambito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","anden","anemia","angulo","anillo","animo","anis","anotar","antena","antiguo","antojo","anual","anular","anuncio","anadir","anejo","ano","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","arana","arar","arbitro","arbol","arbusto","archivo","arco","arder","ardilla","arduo","area","arido","aries","armonia","arnes","aroma","arpa","arpon","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","aspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","atico","atleta","atomo","atraer","atroz","atun","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avion","aviso","ayer","ayuda","ayuno","azafran","azar","azote","azucar","azufre","azul","baba","babor","bache","bahia","baile","bajar","balanza","balcon","balde","bambu","banco","banda","bano","barba","barco","barniz","barro","bascula","baston","basura","batalla","bateria","batir","batuta","baul","bazar","bebe","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsai","borde","borrar","bosque","bote","botin","boveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufon","buho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzon","caballo","cabeza","cabina","cabra","cacao","cadaver","cadena","caer","cafe","caida","caiman","caja","cajon","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cancer","candil","canela","canguro","canica","canto","cana","canon","caoba","caos","capaz","capitan","capote","captar","capucha","cara","carbon","carcel","careta","carga","carino","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","celebre","celoso","celula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","cesped","cetro","chacal","chaleco","champu","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclon","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","cipres","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clinica","cobre","coccion","cochino","cocina","coco","codigo","codo","cofre","coger","cohete","cojin","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","comodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazon","corbata","corcho","cordon","corona","correr","coser","cosmos","costa","craneo","crater","crear","crecer","creido","crema","cria","crimen","cripta","crisis","cromo","cronica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupon","cupula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","datil","deber","debil","decada","decir","dedo","defensa","definir","dejar","delfin","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvio","detalle","detener","deuda","dia","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","dificil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseno","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragon","droga","ducha","duda","duelo","dueno","dulce","duo","duque","durar","dureza","duro","ebano","ebrio","echar","eco","ecuador","edad","edicion","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","elite","elixir","elogio","eludir","embudo","emitir","emocion","empate","empeno","empleo","empresa","enano","encargo","enchufe","encia","enemigo","enero","enfado","enfermo","engano","enigma","enlace","enorme","enredo","ensayo","ensenar","entero","entrar","envase","envio","epoca","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espia","esposa","espuma","esqui","estar","este","estilo","estufa","etapa","eterno","etica","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","exito","experto","explicar","exponer","extremo","fabrica","fabula","fachada","facil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraon","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fertil","fervor","festin","fiable","fianza","fiar","fibra","ficcion","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","fluor","fobia","foca","fogata","fogon","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","fragil","franja","frase","fraude","freir","freno","fresa","frio","frito","fruta","fuego","fuente","fuerza","fuga","fumar","funcion","funda","furgon","furia","fusil","futbol","futuro","gacela","gafas","gaita","gajo","gala","galeria","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilan","gemelo","gemir","gen","genero","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","grafico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grua","grueso","grumo","grupo","guante","guapo","guardia","guerra","guia","guino","guion","guiso","guitarra","gusano","gustar","haber","habil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazana","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","heroe","hervir","hielo","hierro","higado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","humedo","humilde","humo","hundir","huracan","hurto","icono","ideal","idioma","idolo","iglesia","iglu","igual","ilegal","ilusion","imagen","iman","imitar","impar","imperio","imponer","impulso","incapaz","indice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interes","intimo","intuir","inutil","invierno","ira","iris","ironia","isla","islote","jabali","jabon","jamon","jarabe","jardin","jarra","jaula","jazmin","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","jupiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladron","lagarto","lagrima","laguna","laico","lamer","lamina","lampara","lana","lancha","langosta","lanza","lapiz","largo","larva","lastima","lata","latex","latir","laurel","lavar","lazo","leal","leccion","leche","lector","leer","legion","legumbre","lejano","lengua","lento","lena","leon","leopardo","lesion","letal","letra","leve","leyenda","libertad","libro","licor","lider","lidiar","lienzo","liga","ligero","lima","limite","limon","limpio","lince","lindo","linea","lingote","lino","linterna","liquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","locion","loco","locura","logica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maiz","maldad","maleta","malla","malo","mama","mambo","mamut","manco","mando","manejar","manga","maniqui","manjar","mano","manso","manta","manana","mapa","maquina","mar","marco","marea","marfil","margen","marido","marmol","marron","martes","marzo","masa","mascara","masivo","matar","materia","matiz","matriz","maximo","mayor","mazorca","mecha","medalla","medio","medula","mejilla","mejor","melena","melon","memoria","menor","mensaje","mente","menu","mercado","merengue","merito","mes","meson","meta","meter","metodo","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millon","mimo","mina","minero","minimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","mocion","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","mono","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","movil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muneca","mural","muro","musculo","museo","musgo","musica","muslo","nacar","nacion","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","nausea","naval","nave","navidad","necio","nectar","negar","negocio","negro","neon","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","ninez","nino","nitido","nivel","nobleza","noche","nomina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","nucleo","nudillo","nudo","nuera","nueve","nuez","nulo","numero","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","oceano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oido","oir","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opcion","opera","opinar","oponer","optar","optica","opuesto","oracion","orador","oral","orbita","orca","orden","oreja","organo","orgia","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadia","oscuro","osezno","oso","ostra","otono","otro","oveja","ovulo","oxido","oxigeno","oyente","ozono","pacto","padre","paella","pagina","pago","pais","pajaro","palabra","palco","paleta","palido","palma","paloma","palpar","pan","panal","panico","pantera","panuelo","papa","papel","papilla","paquete","parar","parcela","pared","parir","paro","parpado","parque","parrafo","parte","pasar","paseo","pasion","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peaton","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldano","pelea","peligro","pellejo","pelo","peluca","pena","pensar","penon","peon","peor","pepino","pequeno","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pesimo","pestana","petalo","petroleo","pez","pezuna","picar","pichon","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","pina","piojo","pipa","pirata","pisar","piscina","piso","pista","piton","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesia","poeta","polen","policia","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porcion","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","principe","prision","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","proximo","prueba","publico","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmon","pulpo","pulso","puma","punto","punal","puno","pupa","pupila","pure","quedar","queja","quemar","querer","queso","quieto","quimica","quince","quitar","rabano","rabia","rabo","racion","radical","raiz","rama","rampa","rancho","rango","rapaz","rapido","rapto","rasgo","raspa","rato","rayo","raza","razon","reaccion","realidad","rebano","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refran","refugio","regalo","regir","regla","regreso","rehen","reino","reir","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","reves","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rigido","rigor","rincon","rinon","rio","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubi","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sabado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmon","salon","salsa","salto","salud","salvar","samba","sancion","sandia","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sarten","sastre","satan","sauna","saxofon","seccion","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","senal","senor","separar","sepia","sequia","ser","serie","sermon","servir","sesenta","sesion","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","silaba","silbar","silencio","silla","simbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","solido","soltar","solucion","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sosten","sotano","suave","subir","suceso","sudor","suegra","suelo","sueno","suerte","sufrir","sujeto","sultan","sumar","superar","suplir","suponer","supremo","sur","surco","sureno","surgir","susto","sutil","tabaco","tabique","tabla","tabu","taco","tacto","tajo","talar","talco","talento","talla","talon","tamano","tambor","tango","tanque","tapa","tapete","tapia","tapon","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazon","teatro","techo","tecla","tecnica","tejado","tejer","tejido","tela","telefono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoria","terapia","terco","termino","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburon","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","timido","timo","tinta","tio","tipico","tipo","tira","tiron","titan","titere","titulo","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","torax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","toxico","trabajo","tractor","traer","trafico","trago","traje","tramo","trance","trato","trauma","trazar","trebol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tuberia","tubo","tuerto","tumba","tumor","tunel","tunica","turbina","turismo","turno","tutor","ubicar","ulcera","umbral","unidad","unir","universo","uno","untar","una","urbano","urbe","urgente","urna","usar","usuario","util","utopia","uva","vaca","vacio","vacuna","vagar","vago","vaina","vajilla","vale","valido","valle","valor","valvula","vampiro","vara","variar","varon","vaso","vecino","vector","vehiculo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","via","viaje","vibrar","vicio","victima","vida","video","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","vinedo","violin","viral","virgo","virtud","visor","vispera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcan","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]');
var ym = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
var vm = JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]');
var wm = JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');
var Fl;
function $l() {
  if (Fl) return Ze3;
  Fl = 1, Object.defineProperty(Ze3, "__esModule", { value: true });
  const e = {};
  Ze3.wordlists = e;
  let t;
  Ze3._default = t;
  try {
    Ze3._default = t = fm, e.czech = t;
  } catch {
  }
  try {
    Ze3._default = t = dm, e.chinese_simplified = t;
  } catch {
  }
  try {
    Ze3._default = t = hm, e.chinese_traditional = t;
  } catch {
  }
  try {
    Ze3._default = t = pm, e.korean = t;
  } catch {
  }
  try {
    Ze3._default = t = gm, e.french = t;
  } catch {
  }
  try {
    Ze3._default = t = bm, e.italian = t;
  } catch {
  }
  try {
    Ze3._default = t = mm, e.spanish = t;
  } catch {
  }
  try {
    Ze3._default = t = ym, e.japanese = t, e.JA = t;
  } catch {
  }
  try {
    Ze3._default = t = vm, e.portuguese = t;
  } catch {
  }
  try {
    Ze3._default = t = wm, e.english = t, e.EN = t;
  } catch {
  }
  return Ze3;
}
var Kl;
function _m() {
  if (Kl) return or;
  Kl = 1, Object.defineProperty(or, "__esModule", { value: true });
  const e = R0(), t = W0(), r = q0(), a = Ct(), i = $l();
  let o = i._default;
  const s = "Invalid mnemonic", n = "Invalid entropy", p = "Invalid mnemonic checksum", d = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
  function u(S2) {
    return (S2 || "").normalize("NFKD");
  }
  function w(S2, D2, $4) {
    for (; S2.length < $4; )
      S2 = D2 + S2;
    return S2;
  }
  function y(S2) {
    return parseInt(S2, 2);
  }
  function k2(S2) {
    return S2.map((D2) => w(D2.toString(2), "0", 8)).join("");
  }
  function A(S2) {
    const $4 = S2.length * 8 / 32, m = e.sha256(Uint8Array.from(S2));
    return k2(Array.from(m)).slice(0, $4);
  }
  function E2(S2) {
    return "mnemonic" + (S2 || "");
  }
  function x(S2, D2) {
    const $4 = Uint8Array.from(dr.from(u(S2), "utf8")), m = Uint8Array.from(dr.from(E2(u(D2)), "utf8")), U = r.pbkdf2(t.sha512, $4, m, {
      c: 2048,
      dkLen: 64
    });
    return dr.from(U);
  }
  or.mnemonicToSeedSync = x;
  function I2(S2, D2) {
    const $4 = Uint8Array.from(dr.from(u(S2), "utf8")), m = Uint8Array.from(dr.from(E2(u(D2)), "utf8"));
    return r.pbkdf2Async(t.sha512, $4, m, {
      c: 2048,
      dkLen: 64
    }).then((U) => dr.from(U));
  }
  or.mnemonicToSeed = I2;
  function B2(S2, D2) {
    if (D2 = D2 || o, !D2)
      throw new Error(d);
    const $4 = u(S2).split(" ");
    if ($4.length % 3 !== 0)
      throw new Error(s);
    const m = $4.map((oe5) => {
      const ne3 = D2.indexOf(oe5);
      if (ne3 === -1)
        throw new Error(s);
      return w(ne3.toString(2), "0", 11);
    }).join(""), U = Math.floor(m.length / 33) * 32, C = m.slice(0, U), M2 = m.slice(U), V2 = C.match(/(.{1,8})/g).map(y);
    if (V2.length < 16)
      throw new Error(n);
    if (V2.length > 32)
      throw new Error(n);
    if (V2.length % 4 !== 0)
      throw new Error(n);
    const te5 = dr.from(V2);
    if (A(te5) !== M2)
      throw new Error(p);
    return te5.toString("hex");
  }
  or.mnemonicToEntropy = B2;
  function z4(S2, D2) {
    if (dr.isBuffer(S2) || (S2 = dr.from(S2, "hex")), D2 = D2 || o, !D2)
      throw new Error(d);
    if (S2.length < 16)
      throw new TypeError(n);
    if (S2.length > 32)
      throw new TypeError(n);
    if (S2.length % 4 !== 0)
      throw new TypeError(n);
    const $4 = k2(Array.from(S2)), m = A(S2), M2 = ($4 + m).match(/(.{1,11})/g).map((V2) => {
      const te5 = y(V2);
      return D2[te5];
    });
    return D2[0] === "" ? M2.join("") : M2.join(" ");
  }
  or.entropyToMnemonic = z4;
  function O(S2, D2, $4) {
    if (S2 = S2 || 128, S2 % 32 !== 0)
      throw new TypeError(n);
    return D2 = D2 || ((m) => dr.from(a.randomBytes(m))), z4(D2(S2 / 8), $4);
  }
  or.generateMnemonic = O;
  function F3(S2, D2) {
    try {
      B2(S2, D2);
    } catch {
      return false;
    }
    return true;
  }
  or.validateMnemonic = F3;
  function N3(S2) {
    const D2 = i.wordlists[S2];
    if (D2)
      o = D2;
    else
      throw new Error('Could not find wordlist for language "' + S2 + '"');
  }
  or.setDefaultWordlist = N3;
  function j4() {
    if (!o)
      throw new Error("No Default Wordlist set");
    return Object.keys(i.wordlists).filter((S2) => S2 === "JA" || S2 === "EN" ? false : i.wordlists[S2].every((D2, $4) => D2 === o[$4]))[0];
  }
  or.getDefaultWordlist = j4;
  var q3 = $l();
  return or.wordlists = q3.wordlists, or;
}
var Ay = _m();
var Yi = { exports: {} };
var Ra = { exports: {} };
function km(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Qf = { exports: {} };
var Me3 = Qf.exports = {};
var _r2;
var kr;
function qn() {
  throw new Error("setTimeout has not been defined");
}
function Dn() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? _r2 = setTimeout : _r2 = qn;
  } catch {
    _r2 = qn;
  }
  try {
    typeof clearTimeout == "function" ? kr = clearTimeout : kr = Dn;
  } catch {
    kr = Dn;
  }
})();
function ed(e) {
  if (_r2 === setTimeout)
    return setTimeout(e, 0);
  if ((_r2 === qn || !_r2) && setTimeout)
    return _r2 = setTimeout, setTimeout(e, 0);
  try {
    return _r2(e, 0);
  } catch {
    try {
      return _r2.call(null, e, 0);
    } catch {
      return _r2.call(this, e, 0);
    }
  }
}
function Em(e) {
  if (kr === clearTimeout)
    return clearTimeout(e);
  if ((kr === Dn || !kr) && clearTimeout)
    return kr = clearTimeout, clearTimeout(e);
  try {
    return kr(e);
  } catch {
    try {
      return kr.call(null, e);
    } catch {
      return kr.call(this, e);
    }
  }
}
var Nr = [];
var jt3 = false;
var dt3;
var Ga = -1;
function xm() {
  !jt3 || !dt3 || (jt3 = false, dt3.length ? Nr = dt3.concat(Nr) : Ga = -1, Nr.length && rd());
}
function rd() {
  if (!jt3) {
    var e = ed(xm);
    jt3 = true;
    for (var t = Nr.length; t; ) {
      for (dt3 = Nr, Nr = []; ++Ga < t; )
        dt3 && dt3[Ga].run();
      Ga = -1, t = Nr.length;
    }
    dt3 = null, jt3 = false, Em(e);
  }
}
Me3.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  Nr.push(new td(e, t)), Nr.length === 1 && !jt3 && ed(rd);
};
function td(e, t) {
  this.fun = e, this.array = t;
}
td.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Me3.title = "browser";
Me3.browser = true;
Me3.env = {};
Me3.argv = [];
Me3.version = "";
Me3.versions = {};
function qr() {
}
Me3.on = qr;
Me3.addListener = qr;
Me3.once = qr;
Me3.off = qr;
Me3.removeListener = qr;
Me3.removeAllListeners = qr;
Me3.emit = qr;
Me3.prependListener = qr;
Me3.prependOnceListener = qr;
Me3.listeners = function(e) {
  return [];
};
Me3.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Me3.cwd = function() {
  return "/";
};
Me3.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Me3.umask = function() {
  return 0;
};
var Am = Qf.exports;
var vr = km(Am);
var Xi = {};
var Ji = {};
var Qi;
var Hl;
function ad() {
  return Hl || (Hl = 1, Qi = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return false;
    if (typeof Symbol.iterator == "symbol")
      return true;
    var t = {}, r = Symbol("test"), a = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
      return false;
    var i = 42;
    t[r] = i;
    for (var o in t)
      return false;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return false;
    var s = Object.getOwnPropertySymbols(t);
    if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var n = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, r)
      );
      if (n.value !== i || n.enumerable !== true)
        return false;
    }
    return true;
  }), Qi;
}
var eo;
var Zl;
function _i2() {
  if (Zl) return eo;
  Zl = 1;
  var e = ad();
  return eo = function() {
    return e() && !!Symbol.toStringTag;
  }, eo;
}
var ro;
var Gl;
function id() {
  return Gl || (Gl = 1, ro = Object), ro;
}
var to;
var Vl;
function Bm() {
  return Vl || (Vl = 1, to = Error), to;
}
var ao;
var Wl;
function zm() {
  return Wl || (Wl = 1, ao = EvalError), ao;
}
var io;
var Yl;
function Sm() {
  return Yl || (Yl = 1, io = RangeError), io;
}
var oo;
var Xl;
function Im() {
  return Xl || (Xl = 1, oo = ReferenceError), oo;
}
var no;
var Jl;
function od() {
  return Jl || (Jl = 1, no = SyntaxError), no;
}
var so;
var Ql;
function Mt2() {
  return Ql || (Ql = 1, so = TypeError), so;
}
var lo;
var ec;
function Tm() {
  return ec || (ec = 1, lo = URIError), lo;
}
var co;
var rc;
function jm() {
  return rc || (rc = 1, co = Math.abs), co;
}
var uo;
var tc;
function Om() {
  return tc || (tc = 1, uo = Math.floor), uo;
}
var fo;
var ac;
function Rm() {
  return ac || (ac = 1, fo = Math.max), fo;
}
var ho;
var ic;
function Pm() {
  return ic || (ic = 1, ho = Math.min), ho;
}
var po;
var oc;
function Um() {
  return oc || (oc = 1, po = Math.pow), po;
}
var go;
var nc;
function Cm() {
  return nc || (nc = 1, go = Math.round), go;
}
var bo;
var sc;
function Lm() {
  return sc || (sc = 1, bo = Number.isNaN || function(t) {
    return t !== t;
  }), bo;
}
var mo;
var lc;
function Nm() {
  if (lc) return mo;
  lc = 1;
  var e = Lm();
  return mo = function(r) {
    return e(r) || r === 0 ? r : r < 0 ? -1 : 1;
  }, mo;
}
var yo;
var cc;
function qm() {
  return cc || (cc = 1, yo = Object.getOwnPropertyDescriptor), yo;
}
var vo;
var uc;
function Ft3() {
  if (uc) return vo;
  uc = 1;
  var e = qm();
  if (e)
    try {
      e([], "length");
    } catch {
      e = null;
    }
  return vo = e, vo;
}
var wo;
var fc;
function ki() {
  if (fc) return wo;
  fc = 1;
  var e = Object.defineProperty || false;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = false;
    }
  return wo = e, wo;
}
var _o2;
var dc;
function Dm() {
  if (dc) return _o2;
  dc = 1;
  var e = typeof Symbol < "u" && Symbol, t = ad();
  return _o2 = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : t();
  }, _o2;
}
var ko;
var hc;
function nd() {
  return hc || (hc = 1, ko = typeof Reflect < "u" && Reflect.getPrototypeOf || null), ko;
}
var Eo;
var pc;
function sd() {
  if (pc) return Eo;
  pc = 1;
  var e = id();
  return Eo = e.getPrototypeOf || null, Eo;
}
var xo;
var gc;
function Mm() {
  if (gc) return xo;
  gc = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, a = "[object Function]", i = function(p, d) {
    for (var u = [], w = 0; w < p.length; w += 1)
      u[w] = p[w];
    for (var y = 0; y < d.length; y += 1)
      u[y + p.length] = d[y];
    return u;
  }, o = function(p, d) {
    for (var u = [], w = d, y = 0; w < p.length; w += 1, y += 1)
      u[y] = p[w];
    return u;
  }, s = function(n, p) {
    for (var d = "", u = 0; u < n.length; u += 1)
      d += n[u], u + 1 < n.length && (d += p);
    return d;
  };
  return xo = function(p) {
    var d = this;
    if (typeof d != "function" || t.apply(d) !== a)
      throw new TypeError(e + d);
    for (var u = o(arguments, 1), w, y = function() {
      if (this instanceof w) {
        var I2 = d.apply(
          this,
          i(u, arguments)
        );
        return Object(I2) === I2 ? I2 : this;
      }
      return d.apply(
        p,
        i(u, arguments)
      );
    }, k2 = r(0, d.length - u.length), A = [], E2 = 0; E2 < k2; E2++)
      A[E2] = "$" + E2;
    if (w = Function("binder", "return function (" + s(A, ",") + "){ return binder.apply(this,arguments); }")(y), d.prototype) {
      var x = function() {
      };
      x.prototype = d.prototype, w.prototype = new x(), x.prototype = null;
    }
    return w;
  }, xo;
}
var Ao;
var bc;
function ka() {
  if (bc) return Ao;
  bc = 1;
  var e = Mm();
  return Ao = Function.prototype.bind || e, Ao;
}
var Bo;
var mc;
function ps() {
  return mc || (mc = 1, Bo = Function.prototype.call), Bo;
}
var zo;
var yc;
function gs() {
  return yc || (yc = 1, zo = Function.prototype.apply), zo;
}
var So;
var vc;
function Fm() {
  return vc || (vc = 1, So = typeof Reflect < "u" && Reflect && Reflect.apply), So;
}
var Io;
var wc;
function ld() {
  if (wc) return Io;
  wc = 1;
  var e = ka(), t = gs(), r = ps(), a = Fm();
  return Io = a || e.call(r, t), Io;
}
var To;
var _c;
function bs() {
  if (_c) return To;
  _c = 1;
  var e = ka(), t = Mt2(), r = ps(), a = ld();
  return To = function(o) {
    if (o.length < 1 || typeof o[0] != "function")
      throw new t("a function is required");
    return a(e, r, o);
  }, To;
}
var jo;
var kc;
function $m() {
  if (kc) return jo;
  kc = 1;
  var e = bs(), t = Ft3(), r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (s) {
    if (!s || typeof s != "object" || !("code" in s) || s.code !== "ERR_PROTO_ACCESS")
      throw s;
  }
  var a = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, o = i.getPrototypeOf;
  return jo = a && typeof a.get == "function" ? e([a.get]) : typeof o == "function" ? (
    /** @type {import('./get')} */
    (function(n) {
      return o(n == null ? n : i(n));
    })
  ) : false, jo;
}
var Oo;
var Ec;
function ms() {
  if (Ec) return Oo;
  Ec = 1;
  var e = nd(), t = sd(), r = $m();
  return Oo = e ? function(i) {
    return e(i);
  } : t ? function(i) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new TypeError("getProto: not an object");
    return t(i);
  } : r ? function(i) {
    return r(i);
  } : null, Oo;
}
var Ro;
var xc;
function cd() {
  if (xc) return Ro;
  xc = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = ka();
  return Ro = r.call(e, t), Ro;
}
var Po;
var Ac;
function ud() {
  if (Ac) return Po;
  Ac = 1;
  var e, t = id(), r = Bm(), a = zm(), i = Sm(), o = Im(), s = od(), n = Mt2(), p = Tm(), d = jm(), u = Om(), w = Rm(), y = Pm(), k2 = Um(), A = Cm(), E2 = Nm(), x = Function, I2 = function(Q3) {
    try {
      return x('"use strict"; return (' + Q3 + ").constructor;")();
    } catch {
    }
  }, B2 = Ft3(), z4 = ki(), O = function() {
    throw new n();
  }, F3 = B2 ? (function() {
    try {
      return arguments.callee, O;
    } catch {
      try {
        return B2(arguments, "callee").get;
      } catch {
        return O;
      }
    }
  })() : O, N3 = Dm()(), j4 = ms(), q3 = sd(), S2 = nd(), D2 = gs(), $4 = ps(), m = {}, U = typeof Uint8Array > "u" || !j4 ? e : j4(Uint8Array), C = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": N3 && j4 ? j4([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": m,
    "%AsyncGenerator%": m,
    "%AsyncGeneratorFunction%": m,
    "%AsyncIteratorPrototype%": m,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": r,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": a,
    "%Float16Array%": typeof Float16Array > "u" ? e : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": x,
    "%GeneratorFunction%": m,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": N3 && j4 ? j4(j4([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !N3 || !j4 ? e : j4((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": t,
    "%Object.getOwnPropertyDescriptor%": B2,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": i,
    "%ReferenceError%": o,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !N3 || !j4 ? e : j4((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": N3 && j4 ? j4(""[Symbol.iterator]()) : e,
    "%Symbol%": N3 ? Symbol : e,
    "%SyntaxError%": s,
    "%ThrowTypeError%": F3,
    "%TypedArray%": U,
    "%TypeError%": n,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": p,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet,
    "%Function.prototype.call%": $4,
    "%Function.prototype.apply%": D2,
    "%Object.defineProperty%": z4,
    "%Object.getPrototypeOf%": q3,
    "%Math.abs%": d,
    "%Math.floor%": u,
    "%Math.max%": w,
    "%Math.min%": y,
    "%Math.pow%": k2,
    "%Math.round%": A,
    "%Math.sign%": E2,
    "%Reflect.getPrototypeOf%": S2
  };
  if (j4)
    try {
      null.error;
    } catch (Q3) {
      var M2 = j4(j4(Q3));
      C["%Error.prototype%"] = M2;
    }
  var V2 = function Q3(ae4) {
    var ce5;
    if (ae4 === "%AsyncFunction%")
      ce5 = I2("async function () {}");
    else if (ae4 === "%GeneratorFunction%")
      ce5 = I2("function* () {}");
    else if (ae4 === "%AsyncGeneratorFunction%")
      ce5 = I2("async function* () {}");
    else if (ae4 === "%AsyncGenerator%") {
      var ue5 = Q3("%AsyncGeneratorFunction%");
      ue5 && (ce5 = ue5.prototype);
    } else if (ae4 === "%AsyncIteratorPrototype%") {
      var de3 = Q3("%AsyncGenerator%");
      de3 && j4 && (ce5 = j4(de3.prototype));
    }
    return C[ae4] = ce5, ce5;
  }, te5 = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, ie4 = ka(), oe5 = cd(), ne3 = ie4.call($4, Array.prototype.concat), le4 = ie4.call(D2, Array.prototype.splice), P3 = ie4.call($4, String.prototype.replace), Z3 = ie4.call($4, String.prototype.slice), T = ie4.call($4, RegExp.prototype.exec), K3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, W3 = /\\(\\)?/g, X3 = function(ae4) {
    var ce5 = Z3(ae4, 0, 1), ue5 = Z3(ae4, -1);
    if (ce5 === "%" && ue5 !== "%")
      throw new s("invalid intrinsic syntax, expected closing `%`");
    if (ue5 === "%" && ce5 !== "%")
      throw new s("invalid intrinsic syntax, expected opening `%`");
    var de3 = [];
    return P3(ae4, K3, function(pe5, ve5, ge5, ke3) {
      de3[de3.length] = ge5 ? P3(ke3, W3, "$1") : ve5 || pe5;
    }), de3;
  }, re4 = function(ae4, ce5) {
    var ue5 = ae4, de3;
    if (oe5(te5, ue5) && (de3 = te5[ue5], ue5 = "%" + de3[0] + "%"), oe5(C, ue5)) {
      var pe5 = C[ue5];
      if (pe5 === m && (pe5 = V2(ue5)), typeof pe5 > "u" && !ce5)
        throw new n("intrinsic " + ae4 + " exists, but is not available. Please file an issue!");
      return {
        alias: de3,
        name: ue5,
        value: pe5
      };
    }
    throw new s("intrinsic " + ae4 + " does not exist!");
  };
  return Po = function(ae4, ce5) {
    if (typeof ae4 != "string" || ae4.length === 0)
      throw new n("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof ce5 != "boolean")
      throw new n('"allowMissing" argument must be a boolean');
    if (T(/^%?[^%]*%?$/, ae4) === null)
      throw new s("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ue5 = X3(ae4), de3 = ue5.length > 0 ? ue5[0] : "", pe5 = re4("%" + de3 + "%", ce5), ve5 = pe5.name, ge5 = pe5.value, ke3 = false, Le4 = pe5.alias;
    Le4 && (de3 = Le4[0], le4(ue5, ne3([0, 1], Le4)));
    for (var Y2 = 1, Ne4 = true; Y2 < ue5.length; Y2 += 1) {
      var se4 = ue5[Y2], he4 = Z3(se4, 0, 1), be4 = Z3(se4, -1);
      if ((he4 === '"' || he4 === "'" || he4 === "`" || be4 === '"' || be4 === "'" || be4 === "`") && he4 !== be4)
        throw new s("property names with quotes must have matching quotes");
      if ((se4 === "constructor" || !Ne4) && (ke3 = true), de3 += "." + se4, ve5 = "%" + de3 + "%", oe5(C, ve5))
        ge5 = C[ve5];
      else if (ge5 != null) {
        if (!(se4 in ge5)) {
          if (!ce5)
            throw new n("base intrinsic for " + ae4 + " exists, but the property is not available.");
          return;
        }
        if (B2 && Y2 + 1 >= ue5.length) {
          var Be5 = B2(ge5, se4);
          Ne4 = !!Be5, Ne4 && "get" in Be5 && !("originalValue" in Be5.get) ? ge5 = Be5.get : ge5 = ge5[se4];
        } else
          Ne4 = oe5(ge5, se4), ge5 = ge5[se4];
        Ne4 && !ke3 && (C[ve5] = ge5);
      }
    }
    return ge5;
  }, Po;
}
var Uo;
var Bc;
function $t3() {
  if (Bc) return Uo;
  Bc = 1;
  var e = ud(), t = bs(), r = t([e("%String.prototype.indexOf%")]);
  return Uo = function(i, o) {
    var s = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      e(i, !!o)
    );
    return typeof s == "function" && r(i, ".prototype.") > -1 ? t(
      /** @type {const} */
      [s]
    ) : s;
  }, Uo;
}
var Co;
var zc;
function Km() {
  if (zc) return Co;
  zc = 1;
  var e = _i2()(), t = $t3(), r = t("Object.prototype.toString"), a = function(n) {
    return e && n && typeof n == "object" && Symbol.toStringTag in n ? false : r(n) === "[object Arguments]";
  }, i = function(n) {
    return a(n) ? true : n !== null && typeof n == "object" && "length" in n && typeof n.length == "number" && n.length >= 0 && r(n) !== "[object Array]" && "callee" in n && r(n.callee) === "[object Function]";
  }, o = (function() {
    return a(arguments);
  })();
  return a.isLegacyArguments = i, Co = o ? a : i, Co;
}
var Lo;
var Sc;
function Hm() {
  if (Sc) return Lo;
  Sc = 1;
  var e = $t3(), t = _i2()(), r = cd(), a = Ft3(), i;
  if (t) {
    var o = e("RegExp.prototype.exec"), s = {}, n = function() {
      throw s;
    }, p = {
      toString: n,
      valueOf: n
    };
    typeof Symbol.toPrimitive == "symbol" && (p[Symbol.toPrimitive] = n), i = function(y) {
      if (!y || typeof y != "object")
        return false;
      var k2 = (
        /** @type {NonNullable<typeof gOPD>} */
        a(
          /** @type {{ lastIndex?: unknown }} */
          y,
          "lastIndex"
        )
      ), A = k2 && r(k2, "value");
      if (!A)
        return false;
      try {
        o(
          y,
          /** @type {string} */
          /** @type {unknown} */
          p
        );
      } catch (E2) {
        return E2 === s;
      }
    };
  } else {
    var d = e("Object.prototype.toString"), u = "[object RegExp]";
    i = function(y) {
      return !y || typeof y != "object" && typeof y != "function" ? false : d(y) === u;
    };
  }
  return Lo = i, Lo;
}
var No;
var Ic;
function Zm() {
  if (Ic) return No;
  Ic = 1;
  var e = $t3(), t = Hm(), r = e("RegExp.prototype.exec"), a = Mt2();
  return No = function(o) {
    if (!t(o))
      throw new a("`regex` must be a RegExp");
    return function(n) {
      return r(o, n) !== null;
    };
  }, No;
}
var qo;
var Tc;
function Gm() {
  if (Tc) return qo;
  Tc = 1;
  const e = (
    /** @type {GeneratorFunctionConstructor} */
    (function* () {
    }).constructor
  );
  return qo = () => e, qo;
}
var Do;
var jc;
function Vm() {
  if (jc) return Do;
  jc = 1;
  var e = $t3(), t = Zm(), r = t(/^\s*(?:function)?\*/), a = _i2()(), i = ms(), o = e("Object.prototype.toString"), s = e("Function.prototype.toString"), n = Gm();
  return Do = function(d) {
    if (typeof d != "function")
      return false;
    if (r(s(d)))
      return true;
    if (!a) {
      var u = o(d);
      return u === "[object GeneratorFunction]";
    }
    if (!i)
      return false;
    var w = n();
    return w && i(d) === w.prototype;
  }, Do;
}
var Mo;
var Oc;
function Wm() {
  if (Oc) return Mo;
  Oc = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, a;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw a;
        }
      }), a = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (B2) {
      B2 !== a && (t = null);
    }
  else
    t = null;
  var i = /^\s*class\b/, o = function(z4) {
    try {
      var O = e.call(z4);
      return i.test(O);
    } catch {
      return false;
    }
  }, s = function(z4) {
    try {
      return o(z4) ? false : (e.call(z4), true);
    } catch {
      return false;
    }
  }, n = Object.prototype.toString, p = "[object Object]", d = "[object Function]", u = "[object GeneratorFunction]", w = "[object HTMLAllCollection]", y = "[object HTML document.all class]", k2 = "[object HTMLCollection]", A = typeof Symbol == "function" && !!Symbol.toStringTag, E2 = !(0 in [,]), x = function() {
    return false;
  };
  if (typeof document == "object") {
    var I2 = document.all;
    n.call(I2) === n.call(document.all) && (x = function(z4) {
      if ((E2 || !z4) && (typeof z4 > "u" || typeof z4 == "object"))
        try {
          var O = n.call(z4);
          return (O === w || O === y || O === k2 || O === p) && z4("") == null;
        } catch {
        }
      return false;
    });
  }
  return Mo = t ? function(z4) {
    if (x(z4))
      return true;
    if (!z4 || typeof z4 != "function" && typeof z4 != "object")
      return false;
    try {
      t(z4, null, r);
    } catch (O) {
      if (O !== a)
        return false;
    }
    return !o(z4) && s(z4);
  } : function(z4) {
    if (x(z4))
      return true;
    if (!z4 || typeof z4 != "function" && typeof z4 != "object")
      return false;
    if (A)
      return s(z4);
    if (o(z4))
      return false;
    var O = n.call(z4);
    return O !== d && O !== u && !/^\[object HTML/.test(O) ? false : s(z4);
  }, Mo;
}
var Fo;
var Rc;
function Ym() {
  if (Rc) return Fo;
  Rc = 1;
  var e = Wm(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, a = function(p, d, u) {
    for (var w = 0, y = p.length; w < y; w++)
      r.call(p, w) && (u == null ? d(p[w], w, p) : d.call(u, p[w], w, p));
  }, i = function(p, d, u) {
    for (var w = 0, y = p.length; w < y; w++)
      u == null ? d(p.charAt(w), w, p) : d.call(u, p.charAt(w), w, p);
  }, o = function(p, d, u) {
    for (var w in p)
      r.call(p, w) && (u == null ? d(p[w], w, p) : d.call(u, p[w], w, p));
  };
  function s(n) {
    return t.call(n) === "[object Array]";
  }
  return Fo = function(p, d, u) {
    if (!e(d))
      throw new TypeError("iterator must be a function");
    var w;
    arguments.length >= 3 && (w = u), s(p) ? a(p, d, w) : typeof p == "string" ? i(p, d, w) : o(p, d, w);
  }, Fo;
}
var $o;
var Pc;
function Xm() {
  return Pc || (Pc = 1, $o = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), $o;
}
var Ko;
var Uc;
function Jm() {
  if (Uc) return Ko;
  Uc = 1;
  var e = Xm(), t = globalThis;
  return Ko = function() {
    for (var a = [], i = 0; i < e.length; i++)
      typeof t[e[i]] == "function" && (a[a.length] = e[i]);
    return a;
  }, Ko;
}
var Ho = { exports: {} };
var Zo;
var Cc;
function Qm() {
  if (Cc) return Zo;
  Cc = 1;
  var e = ki(), t = od(), r = Mt2(), a = Ft3();
  return Zo = function(o, s, n) {
    if (!o || typeof o != "object" && typeof o != "function")
      throw new r("`obj` must be an object or a function`");
    if (typeof s != "string" && typeof s != "symbol")
      throw new r("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new r("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new r("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new r("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new r("`loose`, if provided, must be a boolean");
    var p = arguments.length > 3 ? arguments[3] : null, d = arguments.length > 4 ? arguments[4] : null, u = arguments.length > 5 ? arguments[5] : null, w = arguments.length > 6 ? arguments[6] : false, y = !!a && a(o, s);
    if (e)
      e(o, s, {
        configurable: u === null && y ? y.configurable : !u,
        enumerable: p === null && y ? y.enumerable : !p,
        value: n,
        writable: d === null && y ? y.writable : !d
      });
    else if (w || !p && !d && !u)
      o[s] = n;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, Zo;
}
var Go;
var Lc;
function ey() {
  if (Lc) return Go;
  Lc = 1;
  var e = ki(), t = function() {
    return !!e;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return true;
    }
  }, Go = t, Go;
}
var Vo;
var Nc;
function ry() {
  if (Nc) return Vo;
  Nc = 1;
  var e = ud(), t = Qm(), r = ey()(), a = Ft3(), i = Mt2(), o = e("%Math.floor%");
  return Vo = function(n, p) {
    if (typeof n != "function")
      throw new i("`fn` is not a function");
    if (typeof p != "number" || p < 0 || p > 4294967295 || o(p) !== p)
      throw new i("`length` must be a positive 32-bit integer");
    var d = arguments.length > 2 && !!arguments[2], u = true, w = true;
    if ("length" in n && a) {
      var y = a(n, "length");
      y && !y.configurable && (u = false), y && !y.writable && (w = false);
    }
    return (u || w || !d) && (r ? t(
      /** @type {Parameters<define>[0]} */
      n,
      "length",
      p,
      true,
      true
    ) : t(
      /** @type {Parameters<define>[0]} */
      n,
      "length",
      p
    )), n;
  }, Vo;
}
var Wo;
var qc;
function ty() {
  if (qc) return Wo;
  qc = 1;
  var e = ka(), t = gs(), r = ld();
  return Wo = function() {
    return r(e, t, arguments);
  }, Wo;
}
var Dc;
function ay() {
  return Dc || (Dc = 1, (function(e) {
    var t = ry(), r = ki(), a = bs(), i = ty();
    e.exports = function(s) {
      var n = a(arguments), p = s.length - (arguments.length - 1);
      return t(
        n,
        1 + (p > 0 ? p : 0),
        true
      );
    }, r ? r(e.exports, "apply", { value: i }) : e.exports.apply = i;
  })(Ho)), Ho.exports;
}
var Yo;
var Mc;
function fd() {
  if (Mc) return Yo;
  Mc = 1;
  var e = Ym(), t = Jm(), r = ay(), a = $t3(), i = Ft3(), o = ms(), s = a("Object.prototype.toString"), n = _i2()(), p = globalThis, d = t(), u = a("String.prototype.slice"), w = a("Array.prototype.indexOf", true) || function(x, I2) {
    for (var B2 = 0; B2 < x.length; B2 += 1)
      if (x[B2] === I2)
        return B2;
    return -1;
  }, y = { __proto__: null };
  n && i && o ? e(d, function(E2) {
    var x = new p[E2]();
    if (Symbol.toStringTag in x && o) {
      var I2 = o(x), B2 = i(I2, Symbol.toStringTag);
      if (!B2 && I2) {
        var z4 = o(I2);
        B2 = i(z4, Symbol.toStringTag);
      }
      if (B2 && B2.get) {
        var O = r(B2.get);
        y[
          /** @type {`$${import('.').TypedArrayName}`} */
          "$" + E2
        ] = O;
      }
    }
  }) : e(d, function(E2) {
    var x = new p[E2](), I2 = x.slice || x.set;
    if (I2) {
      var B2 = (
        /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
        // @ts-expect-error TODO FIXME
        r(I2)
      );
      y[
        /** @type {`$${import('.').TypedArrayName}`} */
        "$" + E2
      ] = B2;
    }
  });
  var k2 = function(x) {
    var I2 = false;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      y,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(B2, z4) {
        if (!I2)
          try {
            "$" + B2(x) === z4 && (I2 = /** @type {import('.').TypedArrayName} */
            u(z4, 1));
          } catch {
          }
      }
    ), I2;
  }, A = function(x) {
    var I2 = false;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      y,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(B2, z4) {
        if (!I2)
          try {
            B2(x), I2 = /** @type {import('.').TypedArrayName} */
            u(z4, 1);
          } catch {
          }
      }
    ), I2;
  };
  return Yo = function(x) {
    if (!x || typeof x != "object")
      return false;
    if (!n) {
      var I2 = u(s(x), 8, -1);
      return w(d, I2) > -1 ? I2 : I2 !== "Object" ? false : A(x);
    }
    return i ? k2(x) : null;
  }, Yo;
}
var Xo;
var Fc;
function dd() {
  if (Fc) return Xo;
  Fc = 1;
  var e = fd();
  return Xo = function(r) {
    return !!e(r);
  }, Xo;
}
var $c;
function iy() {
  return $c || ($c = 1, (function(e) {
    var t = Km(), r = Vm(), a = fd(), i = dd();
    function o(Y2) {
      return Y2.call.bind(Y2);
    }
    var s = typeof BigInt < "u", n = typeof Symbol < "u", p = o(Object.prototype.toString), d = o(Number.prototype.valueOf), u = o(String.prototype.valueOf), w = o(Boolean.prototype.valueOf);
    if (s)
      var y = o(BigInt.prototype.valueOf);
    if (n)
      var k2 = o(Symbol.prototype.valueOf);
    function A(Y2, Ne4) {
      if (typeof Y2 != "object")
        return false;
      try {
        return Ne4(Y2), true;
      } catch {
        return false;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = i;
    function E2(Y2) {
      return typeof Promise < "u" && Y2 instanceof Promise || Y2 !== null && typeof Y2 == "object" && typeof Y2.then == "function" && typeof Y2.catch == "function";
    }
    e.isPromise = E2;
    function x(Y2) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Y2) : i(Y2) || Z3(Y2);
    }
    e.isArrayBufferView = x;
    function I2(Y2) {
      return a(Y2) === "Uint8Array";
    }
    e.isUint8Array = I2;
    function B2(Y2) {
      return a(Y2) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = B2;
    function z4(Y2) {
      return a(Y2) === "Uint16Array";
    }
    e.isUint16Array = z4;
    function O(Y2) {
      return a(Y2) === "Uint32Array";
    }
    e.isUint32Array = O;
    function F3(Y2) {
      return a(Y2) === "Int8Array";
    }
    e.isInt8Array = F3;
    function N3(Y2) {
      return a(Y2) === "Int16Array";
    }
    e.isInt16Array = N3;
    function j4(Y2) {
      return a(Y2) === "Int32Array";
    }
    e.isInt32Array = j4;
    function q3(Y2) {
      return a(Y2) === "Float32Array";
    }
    e.isFloat32Array = q3;
    function S2(Y2) {
      return a(Y2) === "Float64Array";
    }
    e.isFloat64Array = S2;
    function D2(Y2) {
      return a(Y2) === "BigInt64Array";
    }
    e.isBigInt64Array = D2;
    function $4(Y2) {
      return a(Y2) === "BigUint64Array";
    }
    e.isBigUint64Array = $4;
    function m(Y2) {
      return p(Y2) === "[object Map]";
    }
    m.working = typeof Map < "u" && m(/* @__PURE__ */ new Map());
    function U(Y2) {
      return typeof Map > "u" ? false : m.working ? m(Y2) : Y2 instanceof Map;
    }
    e.isMap = U;
    function C(Y2) {
      return p(Y2) === "[object Set]";
    }
    C.working = typeof Set < "u" && C(/* @__PURE__ */ new Set());
    function M2(Y2) {
      return typeof Set > "u" ? false : C.working ? C(Y2) : Y2 instanceof Set;
    }
    e.isSet = M2;
    function V2(Y2) {
      return p(Y2) === "[object WeakMap]";
    }
    V2.working = typeof WeakMap < "u" && V2(/* @__PURE__ */ new WeakMap());
    function te5(Y2) {
      return typeof WeakMap > "u" ? false : V2.working ? V2(Y2) : Y2 instanceof WeakMap;
    }
    e.isWeakMap = te5;
    function ie4(Y2) {
      return p(Y2) === "[object WeakSet]";
    }
    ie4.working = typeof WeakSet < "u" && ie4(/* @__PURE__ */ new WeakSet());
    function oe5(Y2) {
      return ie4(Y2);
    }
    e.isWeakSet = oe5;
    function ne3(Y2) {
      return p(Y2) === "[object ArrayBuffer]";
    }
    ne3.working = typeof ArrayBuffer < "u" && ne3(new ArrayBuffer());
    function le4(Y2) {
      return typeof ArrayBuffer > "u" ? false : ne3.working ? ne3(Y2) : Y2 instanceof ArrayBuffer;
    }
    e.isArrayBuffer = le4;
    function P3(Y2) {
      return p(Y2) === "[object DataView]";
    }
    P3.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && P3(new DataView(new ArrayBuffer(1), 0, 1));
    function Z3(Y2) {
      return typeof DataView > "u" ? false : P3.working ? P3(Y2) : Y2 instanceof DataView;
    }
    e.isDataView = Z3;
    var T = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function K3(Y2) {
      return p(Y2) === "[object SharedArrayBuffer]";
    }
    function W3(Y2) {
      return typeof T > "u" ? false : (typeof K3.working > "u" && (K3.working = K3(new T())), K3.working ? K3(Y2) : Y2 instanceof T);
    }
    e.isSharedArrayBuffer = W3;
    function X3(Y2) {
      return p(Y2) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = X3;
    function re4(Y2) {
      return p(Y2) === "[object Map Iterator]";
    }
    e.isMapIterator = re4;
    function Q3(Y2) {
      return p(Y2) === "[object Set Iterator]";
    }
    e.isSetIterator = Q3;
    function ae4(Y2) {
      return p(Y2) === "[object Generator]";
    }
    e.isGeneratorObject = ae4;
    function ce5(Y2) {
      return p(Y2) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = ce5;
    function ue5(Y2) {
      return A(Y2, d);
    }
    e.isNumberObject = ue5;
    function de3(Y2) {
      return A(Y2, u);
    }
    e.isStringObject = de3;
    function pe5(Y2) {
      return A(Y2, w);
    }
    e.isBooleanObject = pe5;
    function ve5(Y2) {
      return s && A(Y2, y);
    }
    e.isBigIntObject = ve5;
    function ge5(Y2) {
      return n && A(Y2, k2);
    }
    e.isSymbolObject = ge5;
    function ke3(Y2) {
      return ue5(Y2) || de3(Y2) || pe5(Y2) || ve5(Y2) || ge5(Y2);
    }
    e.isBoxedPrimitive = ke3;
    function Le4(Y2) {
      return typeof Uint8Array < "u" && (le4(Y2) || W3(Y2));
    }
    e.isAnyArrayBuffer = Le4, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Y2) {
      Object.defineProperty(e, Y2, {
        enumerable: false,
        value: function() {
          throw new Error(Y2 + " is not supported in userland");
        }
      });
    });
  })(Ji)), Ji;
}
var Jo;
var Kc;
function oy() {
  return Kc || (Kc = 1, Jo = function(t) {
    return t instanceof dr;
  }), Jo;
}
var Hc;
function ny() {
  return Hc || (Hc = 1, (function(e) {
    var t = Object.getOwnPropertyDescriptors || function(Z3) {
      for (var T = Object.keys(Z3), K3 = {}, W3 = 0; W3 < T.length; W3++)
        K3[T[W3]] = Object.getOwnPropertyDescriptor(Z3, T[W3]);
      return K3;
    }, r = /%[sdj%]/g;
    e.format = function(P3) {
      if (!F3(P3)) {
        for (var Z3 = [], T = 0; T < arguments.length; T++)
          Z3.push(s(arguments[T]));
        return Z3.join(" ");
      }
      for (var T = 1, K3 = arguments, W3 = K3.length, X3 = String(P3).replace(r, function(Q3) {
        if (Q3 === "%%") return "%";
        if (T >= W3) return Q3;
        switch (Q3) {
          case "%s":
            return String(K3[T++]);
          case "%d":
            return Number(K3[T++]);
          case "%j":
            try {
              return JSON.stringify(K3[T++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Q3;
        }
      }), re4 = K3[T]; T < W3; re4 = K3[++T])
        B2(re4) || !S2(re4) ? X3 += " " + re4 : X3 += " " + s(re4);
      return X3;
    }, e.deprecate = function(P3, Z3) {
      if (typeof vr < "u" && vr.noDeprecation === true)
        return P3;
      if (typeof vr > "u")
        return function() {
          return e.deprecate(P3, Z3).apply(this, arguments);
        };
      var T = false;
      function K3() {
        if (!T) {
          if (vr.throwDeprecation)
            throw new Error(Z3);
          vr.traceDeprecation ? console.trace(Z3) : console.error(Z3), T = true;
        }
        return P3.apply(this, arguments);
      }
      return K3;
    };
    var a = {}, i = /^$/;
    if (vr.env.NODE_DEBUG) {
      var o = vr.env.NODE_DEBUG;
      o = o.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + o + "$", "i");
    }
    e.debuglog = function(P3) {
      if (P3 = P3.toUpperCase(), !a[P3])
        if (i.test(P3)) {
          var Z3 = vr.pid;
          a[P3] = function() {
            var T = e.format.apply(e, arguments);
            console.error("%s %d: %s", P3, Z3, T);
          };
        } else
          a[P3] = function() {
          };
      return a[P3];
    };
    function s(P3, Z3) {
      var T = {
        seen: [],
        stylize: p
      };
      return arguments.length >= 3 && (T.depth = arguments[2]), arguments.length >= 4 && (T.colors = arguments[3]), I2(Z3) ? T.showHidden = Z3 : Z3 && e._extend(T, Z3), j4(T.showHidden) && (T.showHidden = false), j4(T.depth) && (T.depth = 2), j4(T.colors) && (T.colors = false), j4(T.customInspect) && (T.customInspect = true), T.colors && (T.stylize = n), u(T, P3, T.depth);
    }
    e.inspect = s, s.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, s.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function n(P3, Z3) {
      var T = s.styles[Z3];
      return T ? "\x1B[" + s.colors[T][0] + "m" + P3 + "\x1B[" + s.colors[T][1] + "m" : P3;
    }
    function p(P3, Z3) {
      return P3;
    }
    function d(P3) {
      var Z3 = {};
      return P3.forEach(function(T, K3) {
        Z3[T] = true;
      }), Z3;
    }
    function u(P3, Z3, T) {
      if (P3.customInspect && Z3 && m(Z3.inspect) && // Filter out the util module, it's inspect function is special
      Z3.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(Z3.constructor && Z3.constructor.prototype === Z3)) {
        var K3 = Z3.inspect(T, P3);
        return F3(K3) || (K3 = u(P3, K3, T)), K3;
      }
      var W3 = w(P3, Z3);
      if (W3)
        return W3;
      var X3 = Object.keys(Z3), re4 = d(X3);
      if (P3.showHidden && (X3 = Object.getOwnPropertyNames(Z3)), $4(Z3) && (X3.indexOf("message") >= 0 || X3.indexOf("description") >= 0))
        return y(Z3);
      if (X3.length === 0) {
        if (m(Z3)) {
          var Q3 = Z3.name ? ": " + Z3.name : "";
          return P3.stylize("[Function" + Q3 + "]", "special");
        }
        if (q3(Z3))
          return P3.stylize(RegExp.prototype.toString.call(Z3), "regexp");
        if (D2(Z3))
          return P3.stylize(Date.prototype.toString.call(Z3), "date");
        if ($4(Z3))
          return y(Z3);
      }
      var ae4 = "", ce5 = false, ue5 = ["{", "}"];
      if (x(Z3) && (ce5 = true, ue5 = ["[", "]"]), m(Z3)) {
        var de3 = Z3.name ? ": " + Z3.name : "";
        ae4 = " [Function" + de3 + "]";
      }
      if (q3(Z3) && (ae4 = " " + RegExp.prototype.toString.call(Z3)), D2(Z3) && (ae4 = " " + Date.prototype.toUTCString.call(Z3)), $4(Z3) && (ae4 = " " + y(Z3)), X3.length === 0 && (!ce5 || Z3.length == 0))
        return ue5[0] + ae4 + ue5[1];
      if (T < 0)
        return q3(Z3) ? P3.stylize(RegExp.prototype.toString.call(Z3), "regexp") : P3.stylize("[Object]", "special");
      P3.seen.push(Z3);
      var pe5;
      return ce5 ? pe5 = k2(P3, Z3, T, re4, X3) : pe5 = X3.map(function(ve5) {
        return A(P3, Z3, T, re4, ve5, ce5);
      }), P3.seen.pop(), E2(pe5, ae4, ue5);
    }
    function w(P3, Z3) {
      if (j4(Z3))
        return P3.stylize("undefined", "undefined");
      if (F3(Z3)) {
        var T = "'" + JSON.stringify(Z3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return P3.stylize(T, "string");
      }
      if (O(Z3))
        return P3.stylize("" + Z3, "number");
      if (I2(Z3))
        return P3.stylize("" + Z3, "boolean");
      if (B2(Z3))
        return P3.stylize("null", "null");
    }
    function y(P3) {
      return "[" + Error.prototype.toString.call(P3) + "]";
    }
    function k2(P3, Z3, T, K3, W3) {
      for (var X3 = [], re4 = 0, Q3 = Z3.length; re4 < Q3; ++re4)
        ie4(Z3, String(re4)) ? X3.push(A(
          P3,
          Z3,
          T,
          K3,
          String(re4),
          true
        )) : X3.push("");
      return W3.forEach(function(ae4) {
        ae4.match(/^\d+$/) || X3.push(A(
          P3,
          Z3,
          T,
          K3,
          ae4,
          true
        ));
      }), X3;
    }
    function A(P3, Z3, T, K3, W3, X3) {
      var re4, Q3, ae4;
      if (ae4 = Object.getOwnPropertyDescriptor(Z3, W3) || { value: Z3[W3] }, ae4.get ? ae4.set ? Q3 = P3.stylize("[Getter/Setter]", "special") : Q3 = P3.stylize("[Getter]", "special") : ae4.set && (Q3 = P3.stylize("[Setter]", "special")), ie4(K3, W3) || (re4 = "[" + W3 + "]"), Q3 || (P3.seen.indexOf(ae4.value) < 0 ? (B2(T) ? Q3 = u(P3, ae4.value, null) : Q3 = u(P3, ae4.value, T - 1), Q3.indexOf(`
`) > -1 && (X3 ? Q3 = Q3.split(`
`).map(function(ce5) {
        return "  " + ce5;
      }).join(`
`).slice(2) : Q3 = `
` + Q3.split(`
`).map(function(ce5) {
        return "   " + ce5;
      }).join(`
`))) : Q3 = P3.stylize("[Circular]", "special")), j4(re4)) {
        if (X3 && W3.match(/^\d+$/))
          return Q3;
        re4 = JSON.stringify("" + W3), re4.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (re4 = re4.slice(1, -1), re4 = P3.stylize(re4, "name")) : (re4 = re4.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), re4 = P3.stylize(re4, "string"));
      }
      return re4 + ": " + Q3;
    }
    function E2(P3, Z3, T) {
      var K3 = P3.reduce(function(W3, X3) {
        return X3.indexOf(`
`) >= 0, W3 + X3.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return K3 > 60 ? T[0] + (Z3 === "" ? "" : Z3 + `
 `) + " " + P3.join(`,
  `) + " " + T[1] : T[0] + Z3 + " " + P3.join(", ") + " " + T[1];
    }
    e.types = iy();
    function x(P3) {
      return Array.isArray(P3);
    }
    e.isArray = x;
    function I2(P3) {
      return typeof P3 == "boolean";
    }
    e.isBoolean = I2;
    function B2(P3) {
      return P3 === null;
    }
    e.isNull = B2;
    function z4(P3) {
      return P3 == null;
    }
    e.isNullOrUndefined = z4;
    function O(P3) {
      return typeof P3 == "number";
    }
    e.isNumber = O;
    function F3(P3) {
      return typeof P3 == "string";
    }
    e.isString = F3;
    function N3(P3) {
      return typeof P3 == "symbol";
    }
    e.isSymbol = N3;
    function j4(P3) {
      return P3 === void 0;
    }
    e.isUndefined = j4;
    function q3(P3) {
      return S2(P3) && C(P3) === "[object RegExp]";
    }
    e.isRegExp = q3, e.types.isRegExp = q3;
    function S2(P3) {
      return typeof P3 == "object" && P3 !== null;
    }
    e.isObject = S2;
    function D2(P3) {
      return S2(P3) && C(P3) === "[object Date]";
    }
    e.isDate = D2, e.types.isDate = D2;
    function $4(P3) {
      return S2(P3) && (C(P3) === "[object Error]" || P3 instanceof Error);
    }
    e.isError = $4, e.types.isNativeError = $4;
    function m(P3) {
      return typeof P3 == "function";
    }
    e.isFunction = m;
    function U(P3) {
      return P3 === null || typeof P3 == "boolean" || typeof P3 == "number" || typeof P3 == "string" || typeof P3 == "symbol" || // ES6 symbol
      typeof P3 > "u";
    }
    e.isPrimitive = U, e.isBuffer = oy();
    function C(P3) {
      return Object.prototype.toString.call(P3);
    }
    function M2(P3) {
      return P3 < 10 ? "0" + P3.toString(10) : P3.toString(10);
    }
    var V2 = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function te5() {
      var P3 = /* @__PURE__ */ new Date(), Z3 = [
        M2(P3.getHours()),
        M2(P3.getMinutes()),
        M2(P3.getSeconds())
      ].join(":");
      return [P3.getDate(), V2[P3.getMonth()], Z3].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", te5(), e.format.apply(e, arguments));
    }, e.inherits = wt3(), e._extend = function(P3, Z3) {
      if (!Z3 || !S2(Z3)) return P3;
      for (var T = Object.keys(Z3), K3 = T.length; K3--; )
        P3[T[K3]] = Z3[T[K3]];
      return P3;
    };
    function ie4(P3, Z3) {
      return Object.prototype.hasOwnProperty.call(P3, Z3);
    }
    var oe5 = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(Z3) {
      if (typeof Z3 != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (oe5 && Z3[oe5]) {
        var T = Z3[oe5];
        if (typeof T != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(T, oe5, {
          value: T,
          enumerable: false,
          writable: false,
          configurable: true
        }), T;
      }
      function T() {
        for (var K3, W3, X3 = new Promise(function(ae4, ce5) {
          K3 = ae4, W3 = ce5;
        }), re4 = [], Q3 = 0; Q3 < arguments.length; Q3++)
          re4.push(arguments[Q3]);
        re4.push(function(ae4, ce5) {
          ae4 ? W3(ae4) : K3(ce5);
        });
        try {
          Z3.apply(this, re4);
        } catch (ae4) {
          W3(ae4);
        }
        return X3;
      }
      return Object.setPrototypeOf(T, Object.getPrototypeOf(Z3)), oe5 && Object.defineProperty(T, oe5, {
        value: T,
        enumerable: false,
        writable: false,
        configurable: true
      }), Object.defineProperties(
        T,
        t(Z3)
      );
    }, e.promisify.custom = oe5;
    function ne3(P3, Z3) {
      if (!P3) {
        var T = new Error("Promise was rejected with a falsy value");
        T.reason = P3, P3 = T;
      }
      return Z3(P3);
    }
    function le4(P3) {
      if (typeof P3 != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Z3() {
        for (var T = [], K3 = 0; K3 < arguments.length; K3++)
          T.push(arguments[K3]);
        var W3 = T.pop();
        if (typeof W3 != "function")
          throw new TypeError("The last argument must be of type Function");
        var X3 = this, re4 = function() {
          return W3.apply(X3, arguments);
        };
        P3.apply(this, T).then(
          function(Q3) {
            vr.nextTick(re4.bind(null, null, Q3));
          },
          function(Q3) {
            vr.nextTick(ne3.bind(null, Q3, re4));
          }
        );
      }
      return Object.setPrototypeOf(Z3, Object.getPrototypeOf(P3)), Object.defineProperties(
        Z3,
        t(P3)
      ), Z3;
    }
    e.callbackify = le4;
  })(Xi)), Xi;
}
var Pa = { exports: {} };
var Zc;
function sy() {
  return Zc || (Zc = 1, typeof Object.create == "function" ? Pa.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }));
  } : Pa.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var a = function() {
      };
      a.prototype = r.prototype, t.prototype = new a(), t.prototype.constructor = t;
    }
  }), Pa.exports;
}
var Gc;
function wt3() {
  if (Gc) return Ra.exports;
  Gc = 1;
  try {
    var e = ny();
    if (typeof e.inherits != "function") throw "";
    Ra.exports = e.inherits;
  } catch {
    Ra.exports = sy();
  }
  return Ra.exports;
}
var Ua = { exports: {} };
var Qo = {};
var Vc;
function ly() {
  return Vc || (Vc = 1, (function(e) {
    Object.defineProperties(e, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    var t = {}, r = {};
    r.byteLength = u, r.toByteArray = y, r.fromByteArray = E2;
    for (var a = [], i = [], o = typeof Uint8Array < "u" ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0, p = s.length; n < p; ++n)
      a[n] = s[n], i[s.charCodeAt(n)] = n;
    i[45] = 62, i[95] = 63;
    function d(B2) {
      var z4 = B2.length;
      if (z4 % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var O = B2.indexOf("=");
      O === -1 && (O = z4);
      var F3 = O === z4 ? 0 : 4 - O % 4;
      return [O, F3];
    }
    function u(B2) {
      var z4 = d(B2), O = z4[0], F3 = z4[1];
      return (O + F3) * 3 / 4 - F3;
    }
    function w(B2, z4, O) {
      return (z4 + O) * 3 / 4 - O;
    }
    function y(B2) {
      var z4, O = d(B2), F3 = O[0], N3 = O[1], j4 = new o(w(B2, F3, N3)), q3 = 0, S2 = N3 > 0 ? F3 - 4 : F3, D2;
      for (D2 = 0; D2 < S2; D2 += 4)
        z4 = i[B2.charCodeAt(D2)] << 18 | i[B2.charCodeAt(D2 + 1)] << 12 | i[B2.charCodeAt(D2 + 2)] << 6 | i[B2.charCodeAt(D2 + 3)], j4[q3++] = z4 >> 16 & 255, j4[q3++] = z4 >> 8 & 255, j4[q3++] = z4 & 255;
      return N3 === 2 && (z4 = i[B2.charCodeAt(D2)] << 2 | i[B2.charCodeAt(D2 + 1)] >> 4, j4[q3++] = z4 & 255), N3 === 1 && (z4 = i[B2.charCodeAt(D2)] << 10 | i[B2.charCodeAt(D2 + 1)] << 4 | i[B2.charCodeAt(D2 + 2)] >> 2, j4[q3++] = z4 >> 8 & 255, j4[q3++] = z4 & 255), j4;
    }
    function k2(B2) {
      return a[B2 >> 18 & 63] + a[B2 >> 12 & 63] + a[B2 >> 6 & 63] + a[B2 & 63];
    }
    function A(B2, z4, O) {
      for (var F3, N3 = [], j4 = z4; j4 < O; j4 += 3)
        F3 = (B2[j4] << 16 & 16711680) + (B2[j4 + 1] << 8 & 65280) + (B2[j4 + 2] & 255), N3.push(k2(F3));
      return N3.join("");
    }
    function E2(B2) {
      for (var z4, O = B2.length, F3 = O % 3, N3 = [], j4 = 16383, q3 = 0, S2 = O - F3; q3 < S2; q3 += j4)
        N3.push(A(B2, q3, q3 + j4 > S2 ? S2 : q3 + j4));
      return F3 === 1 ? (z4 = B2[O - 1], N3.push(
        a[z4 >> 2] + a[z4 << 4 & 63] + "=="
      )) : F3 === 2 && (z4 = (B2[O - 2] << 8) + B2[O - 1], N3.push(
        a[z4 >> 10] + a[z4 >> 4 & 63] + a[z4 << 2 & 63] + "="
      )), N3.join("");
    }
    var x = {};
    x.read = function(B2, z4, O, F3, N3) {
      var j4, q3, S2 = N3 * 8 - F3 - 1, D2 = (1 << S2) - 1, $4 = D2 >> 1, m = -7, U = O ? N3 - 1 : 0, C = O ? -1 : 1, M2 = B2[z4 + U];
      for (U += C, j4 = M2 & (1 << -m) - 1, M2 >>= -m, m += S2; m > 0; j4 = j4 * 256 + B2[z4 + U], U += C, m -= 8)
        ;
      for (q3 = j4 & (1 << -m) - 1, j4 >>= -m, m += F3; m > 0; q3 = q3 * 256 + B2[z4 + U], U += C, m -= 8)
        ;
      if (j4 === 0)
        j4 = 1 - $4;
      else {
        if (j4 === D2)
          return q3 ? NaN : (M2 ? -1 : 1) * (1 / 0);
        q3 = q3 + Math.pow(2, F3), j4 = j4 - $4;
      }
      return (M2 ? -1 : 1) * q3 * Math.pow(2, j4 - F3);
    }, x.write = function(B2, z4, O, F3, N3, j4) {
      var q3, S2, D2, $4 = j4 * 8 - N3 - 1, m = (1 << $4) - 1, U = m >> 1, C = N3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, M2 = F3 ? 0 : j4 - 1, V2 = F3 ? 1 : -1, te5 = z4 < 0 || z4 === 0 && 1 / z4 < 0 ? 1 : 0;
      for (z4 = Math.abs(z4), isNaN(z4) || z4 === 1 / 0 ? (S2 = isNaN(z4) ? 1 : 0, q3 = m) : (q3 = Math.floor(Math.log(z4) / Math.LN2), z4 * (D2 = Math.pow(2, -q3)) < 1 && (q3--, D2 *= 2), q3 + U >= 1 ? z4 += C / D2 : z4 += C * Math.pow(2, 1 - U), z4 * D2 >= 2 && (q3++, D2 /= 2), q3 + U >= m ? (S2 = 0, q3 = m) : q3 + U >= 1 ? (S2 = (z4 * D2 - 1) * Math.pow(2, N3), q3 = q3 + U) : (S2 = z4 * Math.pow(2, U - 1) * Math.pow(2, N3), q3 = 0)); N3 >= 8; B2[O + M2] = S2 & 255, M2 += V2, S2 /= 256, N3 -= 8)
        ;
      for (q3 = q3 << N3 | S2, $4 += N3; $4 > 0; B2[O + M2] = q3 & 255, M2 += V2, q3 /= 256, $4 -= 8)
        ;
      B2[O + M2 - V2] |= te5 * 128;
    };
    (function(B2) {
      const z4 = r, O = x, F3 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      B2.Buffer = m, B2.SlowBuffer = Z3, B2.INSPECT_MAX_BYTES = 50;
      const N3 = 2147483647;
      B2.kMaxLength = N3;
      const { Uint8Array: j4, ArrayBuffer: q3, SharedArrayBuffer: S2 } = globalThis;
      m.TYPED_ARRAY_SUPPORT = D2(), !m.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function D2() {
        try {
          const b2 = new j4(1), c = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(c, j4.prototype), Object.setPrototypeOf(b2, c), b2.foo() === 42;
        } catch {
          return false;
        }
      }
      Object.defineProperty(m.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (m.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(m.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (m.isBuffer(this))
            return this.byteOffset;
        }
      });
      function $4(b2) {
        if (b2 > N3)
          throw new RangeError('The value "' + b2 + '" is invalid for option "size"');
        const c = new j4(b2);
        return Object.setPrototypeOf(c, m.prototype), c;
      }
      function m(b2, c, h) {
        if (typeof b2 == "number") {
          if (typeof c == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return V2(b2);
        }
        return U(b2, c, h);
      }
      m.poolSize = 8192;
      function U(b2, c, h) {
        if (typeof b2 == "string")
          return te5(b2, c);
        if (q3.isView(b2))
          return oe5(b2);
        if (b2 == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof b2
          );
        if (hr3(b2, q3) || b2 && hr3(b2.buffer, q3) || typeof S2 < "u" && (hr3(b2, S2) || b2 && hr3(b2.buffer, S2)))
          return ne3(b2, c, h);
        if (typeof b2 == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const _ = b2.valueOf && b2.valueOf();
        if (_ != null && _ !== b2)
          return m.from(_, c, h);
        const L = le4(b2);
        if (L) return L;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof b2[Symbol.toPrimitive] == "function")
          return m.from(b2[Symbol.toPrimitive]("string"), c, h);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof b2
        );
      }
      m.from = function(b2, c, h) {
        return U(b2, c, h);
      }, Object.setPrototypeOf(m.prototype, j4.prototype), Object.setPrototypeOf(m, j4);
      function C(b2) {
        if (typeof b2 != "number")
          throw new TypeError('"size" argument must be of type number');
        if (b2 < 0)
          throw new RangeError('The value "' + b2 + '" is invalid for option "size"');
      }
      function M2(b2, c, h) {
        return C(b2), b2 <= 0 ? $4(b2) : c !== void 0 ? typeof h == "string" ? $4(b2).fill(c, h) : $4(b2).fill(c) : $4(b2);
      }
      m.alloc = function(b2, c, h) {
        return M2(b2, c, h);
      };
      function V2(b2) {
        return C(b2), $4(b2 < 0 ? 0 : P3(b2) | 0);
      }
      m.allocUnsafe = function(b2) {
        return V2(b2);
      }, m.allocUnsafeSlow = function(b2) {
        return V2(b2);
      };
      function te5(b2, c) {
        if ((typeof c != "string" || c === "") && (c = "utf8"), !m.isEncoding(c))
          throw new TypeError("Unknown encoding: " + c);
        const h = T(b2, c) | 0;
        let _ = $4(h);
        const L = _.write(b2, c);
        return L !== h && (_ = _.slice(0, L)), _;
      }
      function ie4(b2) {
        const c = b2.length < 0 ? 0 : P3(b2.length) | 0, h = $4(c);
        for (let _ = 0; _ < c; _ += 1)
          h[_] = b2[_] & 255;
        return h;
      }
      function oe5(b2) {
        if (hr3(b2, j4)) {
          const c = new j4(b2);
          return ne3(c.buffer, c.byteOffset, c.byteLength);
        }
        return ie4(b2);
      }
      function ne3(b2, c, h) {
        if (c < 0 || b2.byteLength < c)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (b2.byteLength < c + (h || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let _;
        return c === void 0 && h === void 0 ? _ = new j4(b2) : h === void 0 ? _ = new j4(b2, c) : _ = new j4(b2, c, h), Object.setPrototypeOf(_, m.prototype), _;
      }
      function le4(b2) {
        if (m.isBuffer(b2)) {
          const c = P3(b2.length) | 0, h = $4(c);
          return h.length === 0 || b2.copy(h, 0, 0, c), h;
        }
        if (b2.length !== void 0)
          return typeof b2.length != "number" || Ei3(b2.length) ? $4(0) : ie4(b2);
        if (b2.type === "Buffer" && Array.isArray(b2.data))
          return ie4(b2.data);
      }
      function P3(b2) {
        if (b2 >= N3)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N3.toString(16) + " bytes");
        return b2 | 0;
      }
      function Z3(b2) {
        return +b2 != b2 && (b2 = 0), m.alloc(+b2);
      }
      m.isBuffer = function(c) {
        return c != null && c._isBuffer === true && c !== m.prototype;
      }, m.compare = function(c, h) {
        if (hr3(c, j4) && (c = m.from(c, c.offset, c.byteLength)), hr3(h, j4) && (h = m.from(h, h.offset, h.byteLength)), !m.isBuffer(c) || !m.isBuffer(h))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (c === h) return 0;
        let _ = c.length, L = h.length;
        for (let G3 = 0, ee4 = Math.min(_, L); G3 < ee4; ++G3)
          if (c[G3] !== h[G3]) {
            _ = c[G3], L = h[G3];
            break;
          }
        return _ < L ? -1 : L < _ ? 1 : 0;
      }, m.isEncoding = function(c) {
        switch (String(c).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, m.concat = function(c, h) {
        if (!Array.isArray(c))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (c.length === 0)
          return m.alloc(0);
        let _;
        if (h === void 0)
          for (h = 0, _ = 0; _ < c.length; ++_)
            h += c[_].length;
        const L = m.allocUnsafe(h);
        let G3 = 0;
        for (_ = 0; _ < c.length; ++_) {
          let ee4 = c[_];
          if (hr3(ee4, j4))
            G3 + ee4.length > L.length ? (m.isBuffer(ee4) || (ee4 = m.from(ee4)), ee4.copy(L, G3)) : j4.prototype.set.call(
              L,
              ee4,
              G3
            );
          else if (m.isBuffer(ee4))
            ee4.copy(L, G3);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          G3 += ee4.length;
        }
        return L;
      };
      function T(b2, c) {
        if (m.isBuffer(b2))
          return b2.length;
        if (q3.isView(b2) || hr3(b2, q3))
          return b2.byteLength;
        if (typeof b2 != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof b2
          );
        const h = b2.length, _ = arguments.length > 2 && arguments[2] === true;
        if (!_ && h === 0) return 0;
        let L = false;
        for (; ; )
          switch (c) {
            case "ascii":
            case "latin1":
            case "binary":
              return h;
            case "utf8":
            case "utf-8":
              return Se5(b2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return h * 2;
            case "hex":
              return h >>> 1;
            case "base64":
              return xe5(b2).length;
            default:
              if (L)
                return _ ? -1 : Se5(b2).length;
              c = ("" + c).toLowerCase(), L = true;
          }
      }
      m.byteLength = T;
      function K3(b2, c, h) {
        let _ = false;
        if ((c === void 0 || c < 0) && (c = 0), c > this.length || ((h === void 0 || h > this.length) && (h = this.length), h <= 0) || (h >>>= 0, c >>>= 0, h <= c))
          return "";
        for (b2 || (b2 = "utf8"); ; )
          switch (b2) {
            case "hex":
              return Ne4(this, c, h);
            case "utf8":
            case "utf-8":
              return ve5(this, c, h);
            case "ascii":
              return Le4(this, c, h);
            case "latin1":
            case "binary":
              return Y2(this, c, h);
            case "base64":
              return pe5(this, c, h);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return se4(this, c, h);
            default:
              if (_) throw new TypeError("Unknown encoding: " + b2);
              b2 = (b2 + "").toLowerCase(), _ = true;
          }
      }
      m.prototype._isBuffer = true;
      function W3(b2, c, h) {
        const _ = b2[c];
        b2[c] = b2[h], b2[h] = _;
      }
      m.prototype.swap16 = function() {
        const c = this.length;
        if (c % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let h = 0; h < c; h += 2)
          W3(this, h, h + 1);
        return this;
      }, m.prototype.swap32 = function() {
        const c = this.length;
        if (c % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let h = 0; h < c; h += 4)
          W3(this, h, h + 3), W3(this, h + 1, h + 2);
        return this;
      }, m.prototype.swap64 = function() {
        const c = this.length;
        if (c % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let h = 0; h < c; h += 8)
          W3(this, h, h + 7), W3(this, h + 1, h + 6), W3(this, h + 2, h + 5), W3(this, h + 3, h + 4);
        return this;
      }, m.prototype.toString = function() {
        const c = this.length;
        return c === 0 ? "" : arguments.length === 0 ? ve5(this, 0, c) : K3.apply(this, arguments);
      }, m.prototype.toLocaleString = m.prototype.toString, m.prototype.equals = function(c) {
        if (!m.isBuffer(c)) throw new TypeError("Argument must be a Buffer");
        return this === c ? true : m.compare(this, c) === 0;
      }, m.prototype.inspect = function() {
        let c = "";
        const h = B2.INSPECT_MAX_BYTES;
        return c = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (c += " ... "), "<Buffer " + c + ">";
      }, F3 && (m.prototype[F3] = m.prototype.inspect), m.prototype.compare = function(c, h, _, L, G3) {
        if (hr3(c, j4) && (c = m.from(c, c.offset, c.byteLength)), !m.isBuffer(c))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof c
          );
        if (h === void 0 && (h = 0), _ === void 0 && (_ = c ? c.length : 0), L === void 0 && (L = 0), G3 === void 0 && (G3 = this.length), h < 0 || _ > c.length || L < 0 || G3 > this.length)
          throw new RangeError("out of range index");
        if (L >= G3 && h >= _)
          return 0;
        if (L >= G3)
          return -1;
        if (h >= _)
          return 1;
        if (h >>>= 0, _ >>>= 0, L >>>= 0, G3 >>>= 0, this === c) return 0;
        let ee4 = G3 - L, ye5 = _ - h;
        const qe5 = Math.min(ee4, ye5), Pe4 = this.slice(L, G3), De5 = c.slice(h, _);
        for (let ze4 = 0; ze4 < qe5; ++ze4)
          if (Pe4[ze4] !== De5[ze4]) {
            ee4 = Pe4[ze4], ye5 = De5[ze4];
            break;
          }
        return ee4 < ye5 ? -1 : ye5 < ee4 ? 1 : 0;
      };
      function X3(b2, c, h, _, L) {
        if (b2.length === 0) return -1;
        if (typeof h == "string" ? (_ = h, h = 0) : h > 2147483647 ? h = 2147483647 : h < -2147483648 && (h = -2147483648), h = +h, Ei3(h) && (h = L ? 0 : b2.length - 1), h < 0 && (h = b2.length + h), h >= b2.length) {
          if (L) return -1;
          h = b2.length - 1;
        } else if (h < 0)
          if (L) h = 0;
          else return -1;
        if (typeof c == "string" && (c = m.from(c, _)), m.isBuffer(c))
          return c.length === 0 ? -1 : re4(b2, c, h, _, L);
        if (typeof c == "number")
          return c = c & 255, typeof j4.prototype.indexOf == "function" ? L ? j4.prototype.indexOf.call(b2, c, h) : j4.prototype.lastIndexOf.call(b2, c, h) : re4(b2, [c], h, _, L);
        throw new TypeError("val must be string, number or Buffer");
      }
      function re4(b2, c, h, _, L) {
        let G3 = 1, ee4 = b2.length, ye5 = c.length;
        if (_ !== void 0 && (_ = String(_).toLowerCase(), _ === "ucs2" || _ === "ucs-2" || _ === "utf16le" || _ === "utf-16le")) {
          if (b2.length < 2 || c.length < 2)
            return -1;
          G3 = 2, ee4 /= 2, ye5 /= 2, h /= 2;
        }
        function qe5(De5, ze4) {
          return G3 === 1 ? De5[ze4] : De5.readUInt16BE(ze4 * G3);
        }
        let Pe4;
        if (L) {
          let De5 = -1;
          for (Pe4 = h; Pe4 < ee4; Pe4++)
            if (qe5(b2, Pe4) === qe5(c, De5 === -1 ? 0 : Pe4 - De5)) {
              if (De5 === -1 && (De5 = Pe4), Pe4 - De5 + 1 === ye5) return De5 * G3;
            } else
              De5 !== -1 && (Pe4 -= Pe4 - De5), De5 = -1;
        } else
          for (h + ye5 > ee4 && (h = ee4 - ye5), Pe4 = h; Pe4 >= 0; Pe4--) {
            let De5 = true;
            for (let ze4 = 0; ze4 < ye5; ze4++)
              if (qe5(b2, Pe4 + ze4) !== qe5(c, ze4)) {
                De5 = false;
                break;
              }
            if (De5) return Pe4;
          }
        return -1;
      }
      m.prototype.includes = function(c, h, _) {
        return this.indexOf(c, h, _) !== -1;
      }, m.prototype.indexOf = function(c, h, _) {
        return X3(this, c, h, _, true);
      }, m.prototype.lastIndexOf = function(c, h, _) {
        return X3(this, c, h, _, false);
      };
      function Q3(b2, c, h, _) {
        h = Number(h) || 0;
        const L = b2.length - h;
        _ ? (_ = Number(_), _ > L && (_ = L)) : _ = L;
        const G3 = c.length;
        _ > G3 / 2 && (_ = G3 / 2);
        let ee4;
        for (ee4 = 0; ee4 < _; ++ee4) {
          const ye5 = parseInt(c.substr(ee4 * 2, 2), 16);
          if (Ei3(ye5)) return ee4;
          b2[h + ee4] = ye5;
        }
        return ee4;
      }
      function ae4(b2, c, h, _) {
        return Ea2(Se5(c, b2.length - h), b2, h, _);
      }
      function ce5(b2, c, h, _) {
        return Ea2(Ie5(c), b2, h, _);
      }
      function ue5(b2, c, h, _) {
        return Ea2(xe5(c), b2, h, _);
      }
      function de3(b2, c, h, _) {
        return Ea2(Re3(c, b2.length - h), b2, h, _);
      }
      m.prototype.write = function(c, h, _, L) {
        if (h === void 0)
          L = "utf8", _ = this.length, h = 0;
        else if (_ === void 0 && typeof h == "string")
          L = h, _ = this.length, h = 0;
        else if (isFinite(h))
          h = h >>> 0, isFinite(_) ? (_ = _ >>> 0, L === void 0 && (L = "utf8")) : (L = _, _ = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const G3 = this.length - h;
        if ((_ === void 0 || _ > G3) && (_ = G3), c.length > 0 && (_ < 0 || h < 0) || h > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        L || (L = "utf8");
        let ee4 = false;
        for (; ; )
          switch (L) {
            case "hex":
              return Q3(this, c, h, _);
            case "utf8":
            case "utf-8":
              return ae4(this, c, h, _);
            case "ascii":
            case "latin1":
            case "binary":
              return ce5(this, c, h, _);
            case "base64":
              return ue5(this, c, h, _);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return de3(this, c, h, _);
            default:
              if (ee4) throw new TypeError("Unknown encoding: " + L);
              L = ("" + L).toLowerCase(), ee4 = true;
          }
      }, m.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function pe5(b2, c, h) {
        return c === 0 && h === b2.length ? z4.fromByteArray(b2) : z4.fromByteArray(b2.slice(c, h));
      }
      function ve5(b2, c, h) {
        h = Math.min(b2.length, h);
        const _ = [];
        let L = c;
        for (; L < h; ) {
          const G3 = b2[L];
          let ee4 = null, ye5 = G3 > 239 ? 4 : G3 > 223 ? 3 : G3 > 191 ? 2 : 1;
          if (L + ye5 <= h) {
            let qe5, Pe4, De5, ze4;
            switch (ye5) {
              case 1:
                G3 < 128 && (ee4 = G3);
                break;
              case 2:
                qe5 = b2[L + 1], (qe5 & 192) === 128 && (ze4 = (G3 & 31) << 6 | qe5 & 63, ze4 > 127 && (ee4 = ze4));
                break;
              case 3:
                qe5 = b2[L + 1], Pe4 = b2[L + 2], (qe5 & 192) === 128 && (Pe4 & 192) === 128 && (ze4 = (G3 & 15) << 12 | (qe5 & 63) << 6 | Pe4 & 63, ze4 > 2047 && (ze4 < 55296 || ze4 > 57343) && (ee4 = ze4));
                break;
              case 4:
                qe5 = b2[L + 1], Pe4 = b2[L + 2], De5 = b2[L + 3], (qe5 & 192) === 128 && (Pe4 & 192) === 128 && (De5 & 192) === 128 && (ze4 = (G3 & 15) << 18 | (qe5 & 63) << 12 | (Pe4 & 63) << 6 | De5 & 63, ze4 > 65535 && ze4 < 1114112 && (ee4 = ze4));
            }
          }
          ee4 === null ? (ee4 = 65533, ye5 = 1) : ee4 > 65535 && (ee4 -= 65536, _.push(ee4 >>> 10 & 1023 | 55296), ee4 = 56320 | ee4 & 1023), _.push(ee4), L += ye5;
        }
        return ke3(_);
      }
      const ge5 = 4096;
      function ke3(b2) {
        const c = b2.length;
        if (c <= ge5)
          return String.fromCharCode.apply(String, b2);
        let h = "", _ = 0;
        for (; _ < c; )
          h += String.fromCharCode.apply(
            String,
            b2.slice(_, _ += ge5)
          );
        return h;
      }
      function Le4(b2, c, h) {
        let _ = "";
        h = Math.min(b2.length, h);
        for (let L = c; L < h; ++L)
          _ += String.fromCharCode(b2[L] & 127);
        return _;
      }
      function Y2(b2, c, h) {
        let _ = "";
        h = Math.min(b2.length, h);
        for (let L = c; L < h; ++L)
          _ += String.fromCharCode(b2[L]);
        return _;
      }
      function Ne4(b2, c, h) {
        const _ = b2.length;
        (!c || c < 0) && (c = 0), (!h || h < 0 || h > _) && (h = _);
        let L = "";
        for (let G3 = c; G3 < h; ++G3)
          L += gd[b2[G3]];
        return L;
      }
      function se4(b2, c, h) {
        const _ = b2.slice(c, h);
        let L = "";
        for (let G3 = 0; G3 < _.length - 1; G3 += 2)
          L += String.fromCharCode(_[G3] + _[G3 + 1] * 256);
        return L;
      }
      m.prototype.slice = function(c, h) {
        const _ = this.length;
        c = ~~c, h = h === void 0 ? _ : ~~h, c < 0 ? (c += _, c < 0 && (c = 0)) : c > _ && (c = _), h < 0 ? (h += _, h < 0 && (h = 0)) : h > _ && (h = _), h < c && (h = c);
        const L = this.subarray(c, h);
        return Object.setPrototypeOf(L, m.prototype), L;
      };
      function he4(b2, c, h) {
        if (b2 % 1 !== 0 || b2 < 0) throw new RangeError("offset is not uint");
        if (b2 + c > h) throw new RangeError("Trying to access beyond buffer length");
      }
      m.prototype.readUintLE = m.prototype.readUIntLE = function(c, h, _) {
        c = c >>> 0, h = h >>> 0, _ || he4(c, h, this.length);
        let L = this[c], G3 = 1, ee4 = 0;
        for (; ++ee4 < h && (G3 *= 256); )
          L += this[c + ee4] * G3;
        return L;
      }, m.prototype.readUintBE = m.prototype.readUIntBE = function(c, h, _) {
        c = c >>> 0, h = h >>> 0, _ || he4(c, h, this.length);
        let L = this[c + --h], G3 = 1;
        for (; h > 0 && (G3 *= 256); )
          L += this[c + --h] * G3;
        return L;
      }, m.prototype.readUint8 = m.prototype.readUInt8 = function(c, h) {
        return c = c >>> 0, h || he4(c, 1, this.length), this[c];
      }, m.prototype.readUint16LE = m.prototype.readUInt16LE = function(c, h) {
        return c = c >>> 0, h || he4(c, 2, this.length), this[c] | this[c + 1] << 8;
      }, m.prototype.readUint16BE = m.prototype.readUInt16BE = function(c, h) {
        return c = c >>> 0, h || he4(c, 2, this.length), this[c] << 8 | this[c + 1];
      }, m.prototype.readUint32LE = m.prototype.readUInt32LE = function(c, h) {
        return c = c >>> 0, h || he4(c, 4, this.length), (this[c] | this[c + 1] << 8 | this[c + 2] << 16) + this[c + 3] * 16777216;
      }, m.prototype.readUint32BE = m.prototype.readUInt32BE = function(c, h) {
        return c = c >>> 0, h || he4(c, 4, this.length), this[c] * 16777216 + (this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3]);
      }, m.prototype.readBigUInt64LE = Dr2(function(c) {
        c = c >>> 0, R3(c, "offset");
        const h = this[c], _ = this[c + 7];
        (h === void 0 || _ === void 0) && H3(c, this.length - 8);
        const L = h + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + this[++c] * 2 ** 24, G3 = this[++c] + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + _ * 2 ** 24;
        return BigInt(L) + (BigInt(G3) << BigInt(32));
      }), m.prototype.readBigUInt64BE = Dr2(function(c) {
        c = c >>> 0, R3(c, "offset");
        const h = this[c], _ = this[c + 7];
        (h === void 0 || _ === void 0) && H3(c, this.length - 8);
        const L = h * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + this[++c], G3 = this[++c] * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + _;
        return (BigInt(L) << BigInt(32)) + BigInt(G3);
      }), m.prototype.readIntLE = function(c, h, _) {
        c = c >>> 0, h = h >>> 0, _ || he4(c, h, this.length);
        let L = this[c], G3 = 1, ee4 = 0;
        for (; ++ee4 < h && (G3 *= 256); )
          L += this[c + ee4] * G3;
        return G3 *= 128, L >= G3 && (L -= Math.pow(2, 8 * h)), L;
      }, m.prototype.readIntBE = function(c, h, _) {
        c = c >>> 0, h = h >>> 0, _ || he4(c, h, this.length);
        let L = h, G3 = 1, ee4 = this[c + --L];
        for (; L > 0 && (G3 *= 256); )
          ee4 += this[c + --L] * G3;
        return G3 *= 128, ee4 >= G3 && (ee4 -= Math.pow(2, 8 * h)), ee4;
      }, m.prototype.readInt8 = function(c, h) {
        return c = c >>> 0, h || he4(c, 1, this.length), this[c] & 128 ? (255 - this[c] + 1) * -1 : this[c];
      }, m.prototype.readInt16LE = function(c, h) {
        c = c >>> 0, h || he4(c, 2, this.length);
        const _ = this[c] | this[c + 1] << 8;
        return _ & 32768 ? _ | 4294901760 : _;
      }, m.prototype.readInt16BE = function(c, h) {
        c = c >>> 0, h || he4(c, 2, this.length);
        const _ = this[c + 1] | this[c] << 8;
        return _ & 32768 ? _ | 4294901760 : _;
      }, m.prototype.readInt32LE = function(c, h) {
        return c = c >>> 0, h || he4(c, 4, this.length), this[c] | this[c + 1] << 8 | this[c + 2] << 16 | this[c + 3] << 24;
      }, m.prototype.readInt32BE = function(c, h) {
        return c = c >>> 0, h || he4(c, 4, this.length), this[c] << 24 | this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3];
      }, m.prototype.readBigInt64LE = Dr2(function(c) {
        c = c >>> 0, R3(c, "offset");
        const h = this[c], _ = this[c + 7];
        (h === void 0 || _ === void 0) && H3(c, this.length - 8);
        const L = this[c + 4] + this[c + 5] * 2 ** 8 + this[c + 6] * 2 ** 16 + (_ << 24);
        return (BigInt(L) << BigInt(32)) + BigInt(h + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + this[++c] * 2 ** 24);
      }), m.prototype.readBigInt64BE = Dr2(function(c) {
        c = c >>> 0, R3(c, "offset");
        const h = this[c], _ = this[c + 7];
        (h === void 0 || _ === void 0) && H3(c, this.length - 8);
        const L = (h << 24) + // Overflow
        this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + this[++c];
        return (BigInt(L) << BigInt(32)) + BigInt(this[++c] * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + _);
      }), m.prototype.readFloatLE = function(c, h) {
        return c = c >>> 0, h || he4(c, 4, this.length), O.read(this, c, true, 23, 4);
      }, m.prototype.readFloatBE = function(c, h) {
        return c = c >>> 0, h || he4(c, 4, this.length), O.read(this, c, false, 23, 4);
      }, m.prototype.readDoubleLE = function(c, h) {
        return c = c >>> 0, h || he4(c, 8, this.length), O.read(this, c, true, 52, 8);
      }, m.prototype.readDoubleBE = function(c, h) {
        return c = c >>> 0, h || he4(c, 8, this.length), O.read(this, c, false, 52, 8);
      };
      function be4(b2, c, h, _, L, G3) {
        if (!m.isBuffer(b2)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (c > L || c < G3) throw new RangeError('"value" argument is out of bounds');
        if (h + _ > b2.length) throw new RangeError("Index out of range");
      }
      m.prototype.writeUintLE = m.prototype.writeUIntLE = function(c, h, _, L) {
        if (c = +c, h = h >>> 0, _ = _ >>> 0, !L) {
          const ye5 = Math.pow(2, 8 * _) - 1;
          be4(this, c, h, _, ye5, 0);
        }
        let G3 = 1, ee4 = 0;
        for (this[h] = c & 255; ++ee4 < _ && (G3 *= 256); )
          this[h + ee4] = c / G3 & 255;
        return h + _;
      }, m.prototype.writeUintBE = m.prototype.writeUIntBE = function(c, h, _, L) {
        if (c = +c, h = h >>> 0, _ = _ >>> 0, !L) {
          const ye5 = Math.pow(2, 8 * _) - 1;
          be4(this, c, h, _, ye5, 0);
        }
        let G3 = _ - 1, ee4 = 1;
        for (this[h + G3] = c & 255; --G3 >= 0 && (ee4 *= 256); )
          this[h + G3] = c / ee4 & 255;
        return h + _;
      }, m.prototype.writeUint8 = m.prototype.writeUInt8 = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 1, 255, 0), this[h] = c & 255, h + 1;
      }, m.prototype.writeUint16LE = m.prototype.writeUInt16LE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 2, 65535, 0), this[h] = c & 255, this[h + 1] = c >>> 8, h + 2;
      }, m.prototype.writeUint16BE = m.prototype.writeUInt16BE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 2, 65535, 0), this[h] = c >>> 8, this[h + 1] = c & 255, h + 2;
      }, m.prototype.writeUint32LE = m.prototype.writeUInt32LE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 4, 4294967295, 0), this[h + 3] = c >>> 24, this[h + 2] = c >>> 16, this[h + 1] = c >>> 8, this[h] = c & 255, h + 4;
      }, m.prototype.writeUint32BE = m.prototype.writeUInt32BE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 4, 4294967295, 0), this[h] = c >>> 24, this[h + 1] = c >>> 16, this[h + 2] = c >>> 8, this[h + 3] = c & 255, h + 4;
      };
      function Be5(b2, c, h, _, L) {
        v(c, _, L, b2, h, 7);
        let G3 = Number(c & BigInt(4294967295));
        b2[h++] = G3, G3 = G3 >> 8, b2[h++] = G3, G3 = G3 >> 8, b2[h++] = G3, G3 = G3 >> 8, b2[h++] = G3;
        let ee4 = Number(c >> BigInt(32) & BigInt(4294967295));
        return b2[h++] = ee4, ee4 = ee4 >> 8, b2[h++] = ee4, ee4 = ee4 >> 8, b2[h++] = ee4, ee4 = ee4 >> 8, b2[h++] = ee4, h;
      }
      function Oe5(b2, c, h, _, L) {
        v(c, _, L, b2, h, 7);
        let G3 = Number(c & BigInt(4294967295));
        b2[h + 7] = G3, G3 = G3 >> 8, b2[h + 6] = G3, G3 = G3 >> 8, b2[h + 5] = G3, G3 = G3 >> 8, b2[h + 4] = G3;
        let ee4 = Number(c >> BigInt(32) & BigInt(4294967295));
        return b2[h + 3] = ee4, ee4 = ee4 >> 8, b2[h + 2] = ee4, ee4 = ee4 >> 8, b2[h + 1] = ee4, ee4 = ee4 >> 8, b2[h] = ee4, h + 8;
      }
      m.prototype.writeBigUInt64LE = Dr2(function(c, h = 0) {
        return Be5(this, c, h, BigInt(0), BigInt("0xffffffffffffffff"));
      }), m.prototype.writeBigUInt64BE = Dr2(function(c, h = 0) {
        return Oe5(this, c, h, BigInt(0), BigInt("0xffffffffffffffff"));
      }), m.prototype.writeIntLE = function(c, h, _, L) {
        if (c = +c, h = h >>> 0, !L) {
          const qe5 = Math.pow(2, 8 * _ - 1);
          be4(this, c, h, _, qe5 - 1, -qe5);
        }
        let G3 = 0, ee4 = 1, ye5 = 0;
        for (this[h] = c & 255; ++G3 < _ && (ee4 *= 256); )
          c < 0 && ye5 === 0 && this[h + G3 - 1] !== 0 && (ye5 = 1), this[h + G3] = (c / ee4 >> 0) - ye5 & 255;
        return h + _;
      }, m.prototype.writeIntBE = function(c, h, _, L) {
        if (c = +c, h = h >>> 0, !L) {
          const qe5 = Math.pow(2, 8 * _ - 1);
          be4(this, c, h, _, qe5 - 1, -qe5);
        }
        let G3 = _ - 1, ee4 = 1, ye5 = 0;
        for (this[h + G3] = c & 255; --G3 >= 0 && (ee4 *= 256); )
          c < 0 && ye5 === 0 && this[h + G3 + 1] !== 0 && (ye5 = 1), this[h + G3] = (c / ee4 >> 0) - ye5 & 255;
        return h + _;
      }, m.prototype.writeInt8 = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 1, 127, -128), c < 0 && (c = 255 + c + 1), this[h] = c & 255, h + 1;
      }, m.prototype.writeInt16LE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 2, 32767, -32768), this[h] = c & 255, this[h + 1] = c >>> 8, h + 2;
      }, m.prototype.writeInt16BE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 2, 32767, -32768), this[h] = c >>> 8, this[h + 1] = c & 255, h + 2;
      }, m.prototype.writeInt32LE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 4, 2147483647, -2147483648), this[h] = c & 255, this[h + 1] = c >>> 8, this[h + 2] = c >>> 16, this[h + 3] = c >>> 24, h + 4;
      }, m.prototype.writeInt32BE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be4(this, c, h, 4, 2147483647, -2147483648), c < 0 && (c = 4294967295 + c + 1), this[h] = c >>> 24, this[h + 1] = c >>> 16, this[h + 2] = c >>> 8, this[h + 3] = c & 255, h + 4;
      }, m.prototype.writeBigInt64LE = Dr2(function(c, h = 0) {
        return Be5(this, c, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), m.prototype.writeBigInt64BE = Dr2(function(c, h = 0) {
        return Oe5(this, c, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function ar2(b2, c, h, _, L, G3) {
        if (h + _ > b2.length) throw new RangeError("Index out of range");
        if (h < 0) throw new RangeError("Index out of range");
      }
      function Sr2(b2, c, h, _, L) {
        return c = +c, h = h >>> 0, L || ar2(b2, c, h, 4), O.write(b2, c, h, _, 23, 4), h + 4;
      }
      m.prototype.writeFloatLE = function(c, h, _) {
        return Sr2(this, c, h, true, _);
      }, m.prototype.writeFloatBE = function(c, h, _) {
        return Sr2(this, c, h, false, _);
      };
      function He3(b2, c, h, _, L) {
        return c = +c, h = h >>> 0, L || ar2(b2, c, h, 8), O.write(b2, c, h, _, 52, 8), h + 8;
      }
      m.prototype.writeDoubleLE = function(c, h, _) {
        return He3(this, c, h, true, _);
      }, m.prototype.writeDoubleBE = function(c, h, _) {
        return He3(this, c, h, false, _);
      }, m.prototype.copy = function(c, h, _, L) {
        if (!m.isBuffer(c)) throw new TypeError("argument should be a Buffer");
        if (_ || (_ = 0), !L && L !== 0 && (L = this.length), h >= c.length && (h = c.length), h || (h = 0), L > 0 && L < _ && (L = _), L === _ || c.length === 0 || this.length === 0) return 0;
        if (h < 0)
          throw new RangeError("targetStart out of bounds");
        if (_ < 0 || _ >= this.length) throw new RangeError("Index out of range");
        if (L < 0) throw new RangeError("sourceEnd out of bounds");
        L > this.length && (L = this.length), c.length - h < L - _ && (L = c.length - h + _);
        const G3 = L - _;
        return this === c && typeof j4.prototype.copyWithin == "function" ? this.copyWithin(h, _, L) : j4.prototype.set.call(
          c,
          this.subarray(_, L),
          h
        ), G3;
      }, m.prototype.fill = function(c, h, _, L) {
        if (typeof c == "string") {
          if (typeof h == "string" ? (L = h, h = 0, _ = this.length) : typeof _ == "string" && (L = _, _ = this.length), L !== void 0 && typeof L != "string")
            throw new TypeError("encoding must be a string");
          if (typeof L == "string" && !m.isEncoding(L))
            throw new TypeError("Unknown encoding: " + L);
          if (c.length === 1) {
            const ee4 = c.charCodeAt(0);
            (L === "utf8" && ee4 < 128 || L === "latin1") && (c = ee4);
          }
        } else typeof c == "number" ? c = c & 255 : typeof c == "boolean" && (c = Number(c));
        if (h < 0 || this.length < h || this.length < _)
          throw new RangeError("Out of range index");
        if (_ <= h)
          return this;
        h = h >>> 0, _ = _ === void 0 ? this.length : _ >>> 0, c || (c = 0);
        let G3;
        if (typeof c == "number")
          for (G3 = h; G3 < _; ++G3)
            this[G3] = c;
        else {
          const ee4 = m.isBuffer(c) ? c : m.from(c, L), ye5 = ee4.length;
          if (ye5 === 0)
            throw new TypeError('The value "' + c + '" is invalid for argument "value"');
          for (G3 = 0; G3 < _ - h; ++G3)
            this[G3 + h] = ee4[G3 % ye5];
        }
        return this;
      };
      const ur3 = {};
      function g(b2, c, h) {
        ur3[b2] = class extends h {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: c.apply(this, arguments),
              writable: true,
              configurable: true
            }), this.name = `${this.name} [${b2}]`, this.stack, delete this.name;
          }
          get code() {
            return b2;
          }
          set code(L) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value: L,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${b2}]: ${this.message}`;
          }
        };
      }
      g(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(b2) {
          return b2 ? `${b2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), g(
        "ERR_INVALID_ARG_TYPE",
        function(b2, c) {
          return `The "${b2}" argument must be of type number. Received type ${typeof c}`;
        },
        TypeError
      ), g(
        "ERR_OUT_OF_RANGE",
        function(b2, c, h) {
          let _ = `The value of "${b2}" is out of range.`, L = h;
          return Number.isInteger(h) && Math.abs(h) > 2 ** 32 ? L = l(String(h)) : typeof h == "bigint" && (L = String(h), (h > BigInt(2) ** BigInt(32) || h < -(BigInt(2) ** BigInt(32))) && (L = l(L)), L += "n"), _ += ` It must be ${c}. Received ${L}`, _;
        },
        RangeError
      );
      function l(b2) {
        let c = "", h = b2.length;
        const _ = b2[0] === "-" ? 1 : 0;
        for (; h >= _ + 4; h -= 3)
          c = `_${b2.slice(h - 3, h)}${c}`;
        return `${b2.slice(0, h)}${c}`;
      }
      function f(b2, c, h) {
        R3(c, "offset"), (b2[c] === void 0 || b2[c + h] === void 0) && H3(c, b2.length - (h + 1));
      }
      function v(b2, c, h, _, L, G3) {
        if (b2 > h || b2 < c) {
          const ee4 = typeof c == "bigint" ? "n" : "";
          let ye5;
          throw c === 0 || c === BigInt(0) ? ye5 = `>= 0${ee4} and < 2${ee4} ** ${(G3 + 1) * 8}${ee4}` : ye5 = `>= -(2${ee4} ** ${(G3 + 1) * 8 - 1}${ee4}) and < 2 ** ${(G3 + 1) * 8 - 1}${ee4}`, new ur3.ERR_OUT_OF_RANGE("value", ye5, b2);
        }
        f(_, L, G3);
      }
      function R3(b2, c) {
        if (typeof b2 != "number")
          throw new ur3.ERR_INVALID_ARG_TYPE(c, "number", b2);
      }
      function H3(b2, c, h) {
        throw Math.floor(b2) !== b2 ? (R3(b2, h), new ur3.ERR_OUT_OF_RANGE("offset", "an integer", b2)) : c < 0 ? new ur3.ERR_BUFFER_OUT_OF_BOUNDS() : new ur3.ERR_OUT_OF_RANGE(
          "offset",
          `>= 0 and <= ${c}`,
          b2
        );
      }
      const J4 = /[^+/0-9A-Za-z-_]/g;
      function me5(b2) {
        if (b2 = b2.split("=")[0], b2 = b2.trim().replace(J4, ""), b2.length < 2) return "";
        for (; b2.length % 4 !== 0; )
          b2 = b2 + "=";
        return b2;
      }
      function Se5(b2, c) {
        c = c || 1 / 0;
        let h;
        const _ = b2.length;
        let L = null;
        const G3 = [];
        for (let ee4 = 0; ee4 < _; ++ee4) {
          if (h = b2.charCodeAt(ee4), h > 55295 && h < 57344) {
            if (!L) {
              if (h > 56319) {
                (c -= 3) > -1 && G3.push(239, 191, 189);
                continue;
              } else if (ee4 + 1 === _) {
                (c -= 3) > -1 && G3.push(239, 191, 189);
                continue;
              }
              L = h;
              continue;
            }
            if (h < 56320) {
              (c -= 3) > -1 && G3.push(239, 191, 189), L = h;
              continue;
            }
            h = (L - 55296 << 10 | h - 56320) + 65536;
          } else L && (c -= 3) > -1 && G3.push(239, 191, 189);
          if (L = null, h < 128) {
            if ((c -= 1) < 0) break;
            G3.push(h);
          } else if (h < 2048) {
            if ((c -= 2) < 0) break;
            G3.push(
              h >> 6 | 192,
              h & 63 | 128
            );
          } else if (h < 65536) {
            if ((c -= 3) < 0) break;
            G3.push(
              h >> 12 | 224,
              h >> 6 & 63 | 128,
              h & 63 | 128
            );
          } else if (h < 1114112) {
            if ((c -= 4) < 0) break;
            G3.push(
              h >> 18 | 240,
              h >> 12 & 63 | 128,
              h >> 6 & 63 | 128,
              h & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return G3;
      }
      function Ie5(b2) {
        const c = [];
        for (let h = 0; h < b2.length; ++h)
          c.push(b2.charCodeAt(h) & 255);
        return c;
      }
      function Re3(b2, c) {
        let h, _, L;
        const G3 = [];
        for (let ee4 = 0; ee4 < b2.length && !((c -= 2) < 0); ++ee4)
          h = b2.charCodeAt(ee4), _ = h >> 8, L = h % 256, G3.push(L), G3.push(_);
        return G3;
      }
      function xe5(b2) {
        return z4.toByteArray(me5(b2));
      }
      function Ea2(b2, c, h, _) {
        let L;
        for (L = 0; L < _ && !(L + h >= c.length || L >= b2.length); ++L)
          c[L + h] = b2[L];
        return L;
      }
      function hr3(b2, c) {
        return b2 instanceof c || b2 != null && b2.constructor != null && b2.constructor.name != null && b2.constructor.name === c.name;
      }
      function Ei3(b2) {
        return b2 !== b2;
      }
      const gd = (function() {
        const b2 = "0123456789abcdef", c = new Array(256);
        for (let h = 0; h < 16; ++h) {
          const _ = h * 16;
          for (let L = 0; L < 16; ++L)
            c[_ + L] = b2[h] + b2[L];
        }
        return c;
      })();
      function Dr2(b2) {
        return typeof BigInt > "u" ? bd : b2;
      }
      function bd() {
        throw new Error("BigInt not supported");
      }
    })(t);
    const I2 = t.Buffer;
    e.Blob = t.Blob, e.BlobOptions = t.BlobOptions, e.Buffer = t.Buffer, e.File = t.File, e.FileOptions = t.FileOptions, e.INSPECT_MAX_BYTES = t.INSPECT_MAX_BYTES, e.SlowBuffer = t.SlowBuffer, e.TranscodeEncoding = t.TranscodeEncoding, e.atob = t.atob, e.btoa = t.btoa, e.constants = t.constants, e.default = I2, e.isAscii = t.isAscii, e.isUtf8 = t.isUtf8, e.kMaxLength = t.kMaxLength, e.kStringMaxLength = t.kStringMaxLength, e.resolveObjectURL = t.resolveObjectURL, e.transcode = t.transcode;
  })(Qo)), Qo;
}
var Wc;
function et3() {
  return Wc || (Wc = 1, (function(e, t) {
    var r = ly(), a = r.Buffer;
    function i(s, n) {
      for (var p in s)
        n[p] = s[p];
    }
    a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = o);
    function o(s, n, p) {
      return a(s, n, p);
    }
    o.prototype = Object.create(a.prototype), i(a, o), o.from = function(s, n, p) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return a(s, n, p);
    }, o.alloc = function(s, n, p) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var d = a(s);
      return n !== void 0 ? typeof p == "string" ? d.fill(n, p) : d.fill(n) : d.fill(0), d;
    }, o.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return a(s);
    }, o.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(s);
    };
  })(Ua, Ua.exports)), Ua.exports;
}
var en;
var Yc;
function cy() {
  if (Yc) return en;
  Yc = 1;
  var e = {}.toString;
  return en = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, en;
}
var rn;
var Xc;
function uy() {
  if (Xc) return rn;
  Xc = 1;
  var e = Mt2(), t = $t3(), r = t("TypedArray.prototype.buffer", true), a = dd();
  return rn = r || function(o) {
    if (!a(o))
      throw new e("Not a Typed Array");
    return o.buffer;
  }, rn;
}
var tn;
var Jc;
function fy() {
  if (Jc) return tn;
  Jc = 1;
  var e = et3().Buffer, t = cy(), r = uy(), a = ArrayBuffer.isView || function(p) {
    try {
      return r(p), true;
    } catch {
      return false;
    }
  }, i = typeof Uint8Array < "u", o = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", s = o && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
  return tn = function(p, d) {
    if (e.isBuffer(p))
      return p.constructor && !("isBuffer" in p) ? e.from(p) : p;
    if (typeof p == "string")
      return e.from(p, d);
    if (o && a(p)) {
      if (p.byteLength === 0)
        return e.alloc(0);
      if (s) {
        var u = e.from(p.buffer, p.byteOffset, p.byteLength);
        if (u.byteLength === p.byteLength)
          return u;
      }
      var w = p instanceof Uint8Array ? p : new Uint8Array(p.buffer, p.byteOffset, p.byteLength), y = e.from(w);
      if (y.length === p.byteLength)
        return y;
    }
    if (i && p instanceof Uint8Array)
      return e.from(p);
    var k2 = t(p);
    if (k2)
      for (var A = 0; A < p.length; A += 1) {
        var E2 = p[A];
        if (typeof E2 != "number" || E2 < 0 || E2 > 255 || ~~E2 !== E2)
          throw new RangeError("Array items must be numbers in the range 0-255.");
      }
    if (k2 || e.isBuffer(p) && p.constructor && typeof p.constructor.isBuffer == "function" && p.constructor.isBuffer(p))
      return e.from(p);
    throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
  }, tn;
}
var an;
var Qc;
function Kt2() {
  if (Qc) return an;
  Qc = 1;
  var e = et3().Buffer, t = fy();
  function r(a, i) {
    this._block = e.alloc(a), this._finalSize = i, this._blockSize = a, this._len = 0;
  }
  return r.prototype.update = function(a, i) {
    a = t(a, i || "utf8");
    for (var o = this._block, s = this._blockSize, n = a.length, p = this._len, d = 0; d < n; ) {
      for (var u = p % s, w = Math.min(n - d, s - u), y = 0; y < w; y++)
        o[u + y] = a[d + y];
      p += w, d += w, p % s === 0 && this._update(o);
    }
    return this._len += n, this;
  }, r.prototype.digest = function(a) {
    var i = this._len % this._blockSize;
    this._block[i] = 128, this._block.fill(0, i + 1), i >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var o = this._len * 8;
    if (o <= 4294967295)
      this._block.writeUInt32BE(o, this._blockSize - 4);
    else {
      var s = (o & 4294967295) >>> 0, n = (o - s) / 4294967296;
      this._block.writeUInt32BE(n, this._blockSize - 8), this._block.writeUInt32BE(s, this._blockSize - 4);
    }
    this._update(this._block);
    var p = this._hash();
    return a ? p.toString(a) : p;
  }, r.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, an = r, an;
}
var on;
var eu;
function dy() {
  if (eu) return on;
  eu = 1;
  var e = wt3(), t = Kt2(), r = et3().Buffer, a = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], i = new Array(80);
  function o() {
    this.init(), this._w = i, t.call(this, 64, 56);
  }
  e(o, t), o.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function s(d) {
    return d << 5 | d >>> 27;
  }
  function n(d) {
    return d << 30 | d >>> 2;
  }
  function p(d, u, w, y) {
    return d === 0 ? u & w | ~u & y : d === 2 ? u & w | u & y | w & y : u ^ w ^ y;
  }
  return o.prototype._update = function(d) {
    for (var u = this._w, w = this._a | 0, y = this._b | 0, k2 = this._c | 0, A = this._d | 0, E2 = this._e | 0, x = 0; x < 16; ++x)
      u[x] = d.readInt32BE(x * 4);
    for (; x < 80; ++x)
      u[x] = u[x - 3] ^ u[x - 8] ^ u[x - 14] ^ u[x - 16];
    for (var I2 = 0; I2 < 80; ++I2) {
      var B2 = ~~(I2 / 20), z4 = s(w) + p(B2, y, k2, A) + E2 + u[I2] + a[B2] | 0;
      E2 = A, A = k2, k2 = n(y), y = w, w = z4;
    }
    this._a = w + this._a | 0, this._b = y + this._b | 0, this._c = k2 + this._c | 0, this._d = A + this._d | 0, this._e = E2 + this._e | 0;
  }, o.prototype._hash = function() {
    var d = r.allocUnsafe(20);
    return d.writeInt32BE(this._a | 0, 0), d.writeInt32BE(this._b | 0, 4), d.writeInt32BE(this._c | 0, 8), d.writeInt32BE(this._d | 0, 12), d.writeInt32BE(this._e | 0, 16), d;
  }, on = o, on;
}
var nn;
var ru;
function hy() {
  if (ru) return nn;
  ru = 1;
  var e = wt3(), t = Kt2(), r = et3().Buffer, a = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], i = new Array(80);
  function o() {
    this.init(), this._w = i, t.call(this, 64, 56);
  }
  e(o, t), o.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function s(u) {
    return u << 1 | u >>> 31;
  }
  function n(u) {
    return u << 5 | u >>> 27;
  }
  function p(u) {
    return u << 30 | u >>> 2;
  }
  function d(u, w, y, k2) {
    return u === 0 ? w & y | ~w & k2 : u === 2 ? w & y | w & k2 | y & k2 : w ^ y ^ k2;
  }
  return o.prototype._update = function(u) {
    for (var w = this._w, y = this._a | 0, k2 = this._b | 0, A = this._c | 0, E2 = this._d | 0, x = this._e | 0, I2 = 0; I2 < 16; ++I2)
      w[I2] = u.readInt32BE(I2 * 4);
    for (; I2 < 80; ++I2)
      w[I2] = s(w[I2 - 3] ^ w[I2 - 8] ^ w[I2 - 14] ^ w[I2 - 16]);
    for (var B2 = 0; B2 < 80; ++B2) {
      var z4 = ~~(B2 / 20), O = n(y) + d(z4, k2, A, E2) + x + w[B2] + a[z4] | 0;
      x = E2, E2 = A, A = p(k2), k2 = y, y = O;
    }
    this._a = y + this._a | 0, this._b = k2 + this._b | 0, this._c = A + this._c | 0, this._d = E2 + this._d | 0, this._e = x + this._e | 0;
  }, o.prototype._hash = function() {
    var u = r.allocUnsafe(20);
    return u.writeInt32BE(this._a | 0, 0), u.writeInt32BE(this._b | 0, 4), u.writeInt32BE(this._c | 0, 8), u.writeInt32BE(this._d | 0, 12), u.writeInt32BE(this._e | 0, 16), u;
  }, nn = o, nn;
}
var sn;
var tu;
function hd() {
  if (tu) return sn;
  tu = 1;
  var e = wt3(), t = Kt2(), r = et3().Buffer, a = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], i = new Array(64);
  function o() {
    this.init(), this._w = i, t.call(this, 64, 56);
  }
  e(o, t), o.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function s(y, k2, A) {
    return A ^ y & (k2 ^ A);
  }
  function n(y, k2, A) {
    return y & k2 | A & (y | k2);
  }
  function p(y) {
    return (y >>> 2 | y << 30) ^ (y >>> 13 | y << 19) ^ (y >>> 22 | y << 10);
  }
  function d(y) {
    return (y >>> 6 | y << 26) ^ (y >>> 11 | y << 21) ^ (y >>> 25 | y << 7);
  }
  function u(y) {
    return (y >>> 7 | y << 25) ^ (y >>> 18 | y << 14) ^ y >>> 3;
  }
  function w(y) {
    return (y >>> 17 | y << 15) ^ (y >>> 19 | y << 13) ^ y >>> 10;
  }
  return o.prototype._update = function(y) {
    for (var k2 = this._w, A = this._a | 0, E2 = this._b | 0, x = this._c | 0, I2 = this._d | 0, B2 = this._e | 0, z4 = this._f | 0, O = this._g | 0, F3 = this._h | 0, N3 = 0; N3 < 16; ++N3)
      k2[N3] = y.readInt32BE(N3 * 4);
    for (; N3 < 64; ++N3)
      k2[N3] = w(k2[N3 - 2]) + k2[N3 - 7] + u(k2[N3 - 15]) + k2[N3 - 16] | 0;
    for (var j4 = 0; j4 < 64; ++j4) {
      var q3 = F3 + d(B2) + s(B2, z4, O) + a[j4] + k2[j4] | 0, S2 = p(A) + n(A, E2, x) | 0;
      F3 = O, O = z4, z4 = B2, B2 = I2 + q3 | 0, I2 = x, x = E2, E2 = A, A = q3 + S2 | 0;
    }
    this._a = A + this._a | 0, this._b = E2 + this._b | 0, this._c = x + this._c | 0, this._d = I2 + this._d | 0, this._e = B2 + this._e | 0, this._f = z4 + this._f | 0, this._g = O + this._g | 0, this._h = F3 + this._h | 0;
  }, o.prototype._hash = function() {
    var y = r.allocUnsafe(32);
    return y.writeInt32BE(this._a, 0), y.writeInt32BE(this._b, 4), y.writeInt32BE(this._c, 8), y.writeInt32BE(this._d, 12), y.writeInt32BE(this._e, 16), y.writeInt32BE(this._f, 20), y.writeInt32BE(this._g, 24), y.writeInt32BE(this._h, 28), y;
  }, sn = o, sn;
}
var ln;
var au;
function py() {
  if (au) return ln;
  au = 1;
  var e = wt3(), t = hd(), r = Kt2(), a = et3().Buffer, i = new Array(64);
  function o() {
    this.init(), this._w = i, r.call(this, 64, 56);
  }
  return e(o, t), o.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, o.prototype._hash = function() {
    var s = a.allocUnsafe(28);
    return s.writeInt32BE(this._a, 0), s.writeInt32BE(this._b, 4), s.writeInt32BE(this._c, 8), s.writeInt32BE(this._d, 12), s.writeInt32BE(this._e, 16), s.writeInt32BE(this._f, 20), s.writeInt32BE(this._g, 24), s;
  }, ln = o, ln;
}
var cn;
var iu;
function pd() {
  if (iu) return cn;
  iu = 1;
  var e = wt3(), t = Kt2(), r = et3().Buffer, a = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], i = new Array(160);
  function o() {
    this.init(), this._w = i, t.call(this, 128, 112);
  }
  e(o, t), o.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function s(E2, x, I2) {
    return I2 ^ E2 & (x ^ I2);
  }
  function n(E2, x, I2) {
    return E2 & x | I2 & (E2 | x);
  }
  function p(E2, x) {
    return (E2 >>> 28 | x << 4) ^ (x >>> 2 | E2 << 30) ^ (x >>> 7 | E2 << 25);
  }
  function d(E2, x) {
    return (E2 >>> 14 | x << 18) ^ (E2 >>> 18 | x << 14) ^ (x >>> 9 | E2 << 23);
  }
  function u(E2, x) {
    return (E2 >>> 1 | x << 31) ^ (E2 >>> 8 | x << 24) ^ E2 >>> 7;
  }
  function w(E2, x) {
    return (E2 >>> 1 | x << 31) ^ (E2 >>> 8 | x << 24) ^ (E2 >>> 7 | x << 25);
  }
  function y(E2, x) {
    return (E2 >>> 19 | x << 13) ^ (x >>> 29 | E2 << 3) ^ E2 >>> 6;
  }
  function k2(E2, x) {
    return (E2 >>> 19 | x << 13) ^ (x >>> 29 | E2 << 3) ^ (E2 >>> 6 | x << 26);
  }
  function A(E2, x) {
    return E2 >>> 0 < x >>> 0 ? 1 : 0;
  }
  return o.prototype._update = function(E2) {
    for (var x = this._w, I2 = this._ah | 0, B2 = this._bh | 0, z4 = this._ch | 0, O = this._dh | 0, F3 = this._eh | 0, N3 = this._fh | 0, j4 = this._gh | 0, q3 = this._hh | 0, S2 = this._al | 0, D2 = this._bl | 0, $4 = this._cl | 0, m = this._dl | 0, U = this._el | 0, C = this._fl | 0, M2 = this._gl | 0, V2 = this._hl | 0, te5 = 0; te5 < 32; te5 += 2)
      x[te5] = E2.readInt32BE(te5 * 4), x[te5 + 1] = E2.readInt32BE(te5 * 4 + 4);
    for (; te5 < 160; te5 += 2) {
      var ie4 = x[te5 - 30], oe5 = x[te5 - 30 + 1], ne3 = u(ie4, oe5), le4 = w(oe5, ie4);
      ie4 = x[te5 - 4], oe5 = x[te5 - 4 + 1];
      var P3 = y(ie4, oe5), Z3 = k2(oe5, ie4), T = x[te5 - 14], K3 = x[te5 - 14 + 1], W3 = x[te5 - 32], X3 = x[te5 - 32 + 1], re4 = le4 + K3 | 0, Q3 = ne3 + T + A(re4, le4) | 0;
      re4 = re4 + Z3 | 0, Q3 = Q3 + P3 + A(re4, Z3) | 0, re4 = re4 + X3 | 0, Q3 = Q3 + W3 + A(re4, X3) | 0, x[te5] = Q3, x[te5 + 1] = re4;
    }
    for (var ae4 = 0; ae4 < 160; ae4 += 2) {
      Q3 = x[ae4], re4 = x[ae4 + 1];
      var ce5 = n(I2, B2, z4), ue5 = n(S2, D2, $4), de3 = p(I2, S2), pe5 = p(S2, I2), ve5 = d(F3, U), ge5 = d(U, F3), ke3 = a[ae4], Le4 = a[ae4 + 1], Y2 = s(F3, N3, j4), Ne4 = s(U, C, M2), se4 = V2 + ge5 | 0, he4 = q3 + ve5 + A(se4, V2) | 0;
      se4 = se4 + Ne4 | 0, he4 = he4 + Y2 + A(se4, Ne4) | 0, se4 = se4 + Le4 | 0, he4 = he4 + ke3 + A(se4, Le4) | 0, se4 = se4 + re4 | 0, he4 = he4 + Q3 + A(se4, re4) | 0;
      var be4 = pe5 + ue5 | 0, Be5 = de3 + ce5 + A(be4, pe5) | 0;
      q3 = j4, V2 = M2, j4 = N3, M2 = C, N3 = F3, C = U, U = m + se4 | 0, F3 = O + he4 + A(U, m) | 0, O = z4, m = $4, z4 = B2, $4 = D2, B2 = I2, D2 = S2, S2 = se4 + be4 | 0, I2 = he4 + Be5 + A(S2, se4) | 0;
    }
    this._al = this._al + S2 | 0, this._bl = this._bl + D2 | 0, this._cl = this._cl + $4 | 0, this._dl = this._dl + m | 0, this._el = this._el + U | 0, this._fl = this._fl + C | 0, this._gl = this._gl + M2 | 0, this._hl = this._hl + V2 | 0, this._ah = this._ah + I2 + A(this._al, S2) | 0, this._bh = this._bh + B2 + A(this._bl, D2) | 0, this._ch = this._ch + z4 + A(this._cl, $4) | 0, this._dh = this._dh + O + A(this._dl, m) | 0, this._eh = this._eh + F3 + A(this._el, U) | 0, this._fh = this._fh + N3 + A(this._fl, C) | 0, this._gh = this._gh + j4 + A(this._gl, M2) | 0, this._hh = this._hh + q3 + A(this._hl, V2) | 0;
  }, o.prototype._hash = function() {
    var E2 = r.allocUnsafe(64);
    function x(I2, B2, z4) {
      E2.writeInt32BE(I2, z4), E2.writeInt32BE(B2, z4 + 4);
    }
    return x(this._ah, this._al, 0), x(this._bh, this._bl, 8), x(this._ch, this._cl, 16), x(this._dh, this._dl, 24), x(this._eh, this._el, 32), x(this._fh, this._fl, 40), x(this._gh, this._gl, 48), x(this._hh, this._hl, 56), E2;
  }, cn = o, cn;
}
var un;
var ou;
function gy() {
  if (ou) return un;
  ou = 1;
  var e = wt3(), t = pd(), r = Kt2(), a = et3().Buffer, i = new Array(160);
  function o() {
    this.init(), this._w = i, r.call(this, 128, 112);
  }
  return e(o, t), o.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, o.prototype._hash = function() {
    var s = a.allocUnsafe(48);
    function n(p, d, u) {
      s.writeInt32BE(p, u), s.writeInt32BE(d, u + 4);
    }
    return n(this._ah, this._al, 0), n(this._bh, this._bl, 8), n(this._ch, this._cl, 16), n(this._dh, this._dl, 24), n(this._eh, this._el, 32), n(this._fh, this._fl, 40), s;
  }, un = o, un;
}
var nu;
function by() {
  return nu || (nu = 1, (function(e) {
    e.exports = function(r) {
      var a = r.toLowerCase(), i = e.exports[a];
      if (!i)
        throw new Error(a + " is not supported (we accept pull requests)");
      return new i();
    }, e.exports.sha = dy(), e.exports.sha1 = hy(), e.exports.sha224 = py(), e.exports.sha256 = hd(), e.exports.sha384 = gy(), e.exports.sha512 = pd();
  })(Yi)), Yi.exports;
}
var my = by();
var zy = k0(my);

// node_modules/@btc-vision/transaction/browser/btc-vision-bitcoin.js
var kt3 = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  bech32Opnet: "op",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
var xa2 = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bech32Opnet: "opr",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var Oa2 = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bech32Opnet: "opt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var Pa2 = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "opt",
  bech32Opnet: "opt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var Ba2 = {
  messagePrefix: `Dogecoin Signed Message:
`,
  bech32: "",
  // Dogecoin does not currently use Bech32
  bech32Opnet: "",
  bip32: {
    public: 49990397,
    private: 49988504
  },
  pubKeyHash: 30,
  scriptHash: 22,
  wif: 158
};
var _a3 = {
  messagePrefix: `Dogecoin Signed Message:
`,
  bech32: "",
  // Dogecoin testnet does not currently use Bech32
  bech32Opnet: "",
  bip32: {
    public: 70429096,
    private: 70427203
  },
  pubKeyHash: 113,
  scriptHash: 196,
  wif: 241
};
var Ra2 = {
  messagePrefix: `Litecoin Signed Message:
`,
  bech32: "ltc",
  bech32Opnet: "opl",
  bip32: {
    public: 27108450,
    private: 27106558
  },
  pubKeyHash: 48,
  scriptHash: 50,
  wif: 176
};
var Na2 = {
  messagePrefix: `Litecoin Signed Message:
`,
  bech32: "tltc",
  bech32Opnet: "oplt",
  bip32: {
    public: 70709117,
    private: 70711009
  },
  pubKeyHash: 111,
  scriptHash: 58,
  wif: 239
};
var Ha2 = {
  messagePrefix: `Bitcoin Signed Message:
`,
  // Cashaddr prefix differs from bech32 for general usage, but we can set it similarly.
  // Actual cashaddr prefix is "bitcoincash", but this field is for bech32 which BCH doesn't fully use for segwit (it doesn't have segwit).
  bech32: "bitcoincash",
  bech32Opnet: "opbch",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
};
var La2 = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bchtest",
  bech32Opnet: "opbcht",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var Ca2 = {
  // Historically Dash used DarkCoin message prefix, and most implementations use this:
  // As of Dash Core 0.17, this has not changed in code.
  messagePrefix: `DarkCoin Signed Message:
`,
  bech32: "",
  // Dash does not use Bech32
  bech32Opnet: "",
  bip32: {
    public: 50221772,
    private: 50221816
  },
  pubKeyHash: 76,
  scriptHash: 16,
  wif: 204
};
var Va2 = {
  messagePrefix: `DarkCoin Signed Message:
`,
  bech32: "",
  // Dash testnet does not use Bech32
  bech32Opnet: "",
  bip32: {
    public: 981492128,
    private: 981489719
  },
  pubKeyHash: 140,
  scriptHash: 19,
  wif: 239
};
var ap2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  bitcoin: kt3,
  bitcoinCash: Ha2,
  bitcoinCashTestnet: La2,
  dash: Ca2,
  dashTestnet: Va2,
  dogecoin: Ba2,
  dogecoinTestnet: _a3,
  litecoin: Ra2,
  litecoinTestnet: Na2,
  opnetTestnet: Pa2,
  regtest: xa2,
  testnet: Oa2
}, Symbol.toStringTag, { value: "Module" }));
var ye3 = {};
var Ti2;
function $a2() {
  if (Ti2) return ye3;
  Ti2 = 1, Object.defineProperty(ye3, "__esModule", { value: true }), ye3.bech32m = ye3.bech32 = void 0;
  const e = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", t = {};
  for (let d = 0; d < e.length; d++) {
    const f = e.charAt(d);
    t[f] = d;
  }
  function r(d) {
    const f = d >> 25;
    return (d & 33554431) << 5 ^ -(f >> 0 & 1) & 996825010 ^ -(f >> 1 & 1) & 642813549 ^ -(f >> 2 & 1) & 513874426 ^ -(f >> 3 & 1) & 1027748829 ^ -(f >> 4 & 1) & 705979059;
  }
  function n(d) {
    let f = 1;
    for (let p = 0; p < d.length; ++p) {
      const w = d.charCodeAt(p);
      if (w < 33 || w > 126)
        return "Invalid prefix (" + d + ")";
      f = r(f) ^ w >> 5;
    }
    f = r(f);
    for (let p = 0; p < d.length; ++p) {
      const w = d.charCodeAt(p);
      f = r(f) ^ w & 31;
    }
    return f;
  }
  function i(d, f, p, w) {
    let y = 0, m = 0;
    const E2 = (1 << p) - 1, v = [];
    for (let x = 0; x < d.length; ++x)
      for (y = y << f | d[x], m += f; m >= p; )
        m -= p, v.push(y >> m & E2);
    if (w)
      m > 0 && v.push(y << p - m & E2);
    else {
      if (m >= f)
        return "Excess padding";
      if (y << p - m & E2)
        return "Non-zero padding";
    }
    return v;
  }
  function o(d) {
    return i(d, 8, 5, true);
  }
  function a(d) {
    const f = i(d, 5, 8, false);
    if (Array.isArray(f))
      return f;
  }
  function u(d) {
    const f = i(d, 5, 8, false);
    if (Array.isArray(f))
      return f;
    throw new Error(f);
  }
  function l(d) {
    let f;
    d === "bech32" ? f = 1 : f = 734539939;
    function p(E2, v, x) {
      if (x = x || 90, E2.length + 7 + v.length > x)
        throw new TypeError("Exceeds length limit");
      E2 = E2.toLowerCase();
      let O = n(E2);
      if (typeof O == "string")
        throw new Error(O);
      let T = E2 + "1";
      for (let _ = 0; _ < v.length; ++_) {
        const M2 = v[_];
        if (M2 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        O = r(O) ^ M2, T += e.charAt(M2);
      }
      for (let _ = 0; _ < 6; ++_)
        O = r(O);
      O ^= f;
      for (let _ = 0; _ < 6; ++_) {
        const M2 = O >> (5 - _) * 5 & 31;
        T += e.charAt(M2);
      }
      return T;
    }
    function w(E2, v) {
      if (v = v || 90, E2.length < 8)
        return E2 + " too short";
      if (E2.length > v)
        return "Exceeds length limit";
      const x = E2.toLowerCase(), O = E2.toUpperCase();
      if (E2 !== x && E2 !== O)
        return "Mixed-case string " + E2;
      E2 = x;
      const T = E2.lastIndexOf("1");
      if (T === -1)
        return "No separator character for " + E2;
      if (T === 0)
        return "Missing prefix for " + E2;
      const _ = E2.slice(0, T), M2 = E2.slice(T + 1);
      if (M2.length < 6)
        return "Data too short";
      let nt5 = n(_);
      if (typeof nt5 == "string")
        return nt5;
      const z4 = [];
      for (let Y2 = 0; Y2 < M2.length; ++Y2) {
        const F3 = M2.charAt(Y2), Rt5 = t[F3];
        if (Rt5 === void 0)
          return "Unknown character " + F3;
        nt5 = r(nt5) ^ Rt5, !(Y2 + 6 >= M2.length) && z4.push(Rt5);
      }
      return nt5 !== f ? "Invalid checksum for " + E2 : { prefix: _, words: z4 };
    }
    function y(E2, v) {
      const x = w(E2, v);
      if (typeof x == "object")
        return x;
    }
    function m(E2, v) {
      const x = w(E2, v);
      if (typeof x == "object")
        return x;
      throw new Error(x);
    }
    return {
      decodeUnsafe: y,
      decode: m,
      encode: p,
      toWords: o,
      fromWordsUnsafe: a,
      fromWords: u
    };
  }
  return ye3.bech32 = l("bech32"), ye3.bech32m = l("bech32m"), ye3;
}
var J2 = $a2();
function dr2(e) {
  let t, r;
  try {
    t = J2.bech32.decode(e);
  } catch {
  }
  if (t) {
    if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
  } else if (t = J2.bech32m.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
  const n = J2.bech32.fromWords(t.words.slice(1));
  return {
    version: r,
    prefix: t.prefix,
    data: new Uint8Array(n)
  };
}
var Os2 = "0123456789abcdefABCDEF";
Os2.split("").map((e) => e.codePointAt(0));
Array(256).fill(true).map((e, t) => {
  const r = String.fromCodePoint(t), n = Os2.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
});
new TextEncoder();
new TextDecoder();
function Ka2(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function Da2(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function Ma2(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function Fa2(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Wa2(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function Ga2(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
var ja2 = (e) => {
  if (e < 0 || e > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function za2(e) {
  if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function Ps2(e) {
  typeof e == "number" ? za2(e) : ja2(e);
}
function we4(e, t, r) {
  Ps2(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array($t4(e)));
  let n = 0;
  return e < 253 ? (t.set([Number(e)], r), n = 1) : e <= 65535 ? (t.set([253], r), Ka2(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([254], r), Da2(t, r + 1, Number(e), "LE"), n = 5) : (t.set([255], r), Ma2(t, r + 1, BigInt(e), "LE"), n = 9), { buffer: t, bytes: n };
}
function ze2(e, t) {
  t === void 0 && (t = 0);
  const r = e.at(t);
  if (r === void 0)
    throw new Error("buffer too small");
  if (r < 253)
    return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
  if (r === 253) {
    const n = Fa2(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 3
    };
  } else if (r === 254) {
    const n = Wa2(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 5
    };
  } else {
    const n = Ga2(e, t + 1, "LE");
    return { numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null, bigintValue: n, bytes: 9 };
  }
}
function $t4(e) {
  return Ps2(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
var hp2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: ze2,
  encode: we4,
  encodingLength: $t4
}, Symbol.toStringTag, { value: "Module" }));
var qa2 = Array.from(
  { length: 256 },
  (e, t) => t.toString(16).padStart(2, "0")
);
var ki2 = (() => {
  const e = new Array(128).fill(-1);
  for (let t = 0; t < 10; t++)
    e[48 + t] = t;
  for (let t = 0; t < 6; t++)
    e[65 + t] = 10 + t, e[97 + t] = 10 + t;
  return e;
})();
function Yt4(e) {
  let t = "";
  for (let r = 0; r < e.length; r++) {
    const n = qa2[e[r]];
    t += n;
  }
  return t;
}
function Mt3(e) {
  e.length >= 2 && e[0] === "0" && (e[1] === "x" || e[1] === "X") && (e = e.slice(2));
  const t = e.length;
  if (t % 2 !== 0)
    throw new TypeError("Invalid hex string: odd length");
  const r = t / 2, n = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const o = i * 2, a = e.charCodeAt(o), u = e.charCodeAt(o + 1);
    if (a >= 128 || u >= 128)
      throw new TypeError(`Invalid hex character at position ${o}`);
    const l = ki2[a], d = ki2[u];
    if (l === -1)
      throw new TypeError(`Invalid hex character at position ${o}`);
    if (d === -1)
      throw new TypeError(`Invalid hex character at position ${o + 1}`);
    n[i] = l << 4 | d;
  }
  return n;
}
var _t4, _a5, _e6, _a4;
var Ya2 = (_a4 = class {
  /**
   * Creates a new BinaryReader.
   *
   * @param data - The byte array to read from
   * @param offset - Initial read position (default 0)
   *
   * @example
   * ```typescript
   * import { BinaryReader, fromHex } from '@btc-vision/bitcoin';
   *
   * const data = fromHex('01020304');
   * const reader = new BinaryReader(data);
   * ```
   */
  constructor(t, r = 0) {
    /**
     * The underlying byte array.
     */
    __privateAdd(this, _t4);
    /**
     * Single DataView instance reused for all reads.
     */
    __privateAdd(this, _a5);
    /**
     * Current read position.
     */
    __privateAdd(this, _e6);
    __privateSet(this, _t4, t), __privateSet(this, _a5, new DataView(t.buffer, t.byteOffset, t.byteLength)), __privateSet(this, _e6, r);
  }
  /**
   * Current read position in the buffer.
   */
  get offset() {
    return __privateGet(this, _e6);
  }
  /**
   * Sets the read position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative or beyond buffer length
   */
  set offset(t) {
    if (t < 0 || t > __privateGet(this, _t4).length)
      throw new RangeError(`Offset ${t} is out of bounds [0, ${__privateGet(this, _t4).length}]`);
    __privateSet(this, _e6, t);
  }
  /**
   * Total length of the underlying buffer.
   */
  get length() {
    return __privateGet(this, _t4).length;
  }
  /**
   * Number of bytes remaining to be read.
   */
  get remaining() {
    return __privateGet(this, _t4).length - __privateGet(this, _e6);
  }
  /**
   * The underlying data buffer.
   */
  get data() {
    return __privateGet(this, _t4);
  }
  /**
   * Creates a BinaryReader from a hex string.
   *
   * @param hex - Hex string (with or without 0x prefix)
   * @returns A new BinaryReader instance
   *
   * @example
   * ```typescript
   * import { BinaryReader } from '@btc-vision/bitcoin';
   *
   * const reader = BinaryReader.fromHex('01000000');
   * const version = reader.readInt32LE(); // 1
   * ```
   */
  static fromHex(t) {
    return new _a4(Mt3(t));
  }
  /**
   * Reads an 8-bit unsigned integer.
   *
   * @returns The value (0-255)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('ff');
   * reader.readUInt8(); // 255
   * ```
   */
  readUInt8() {
    if (__privateGet(this, _e6) >= __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    return __privateGet(this, _t4)[__privateWrapper(this, _e6)._++];
  }
  /**
   * Reads an 8-bit signed integer.
   *
   * @returns The value (-128 to 127)
   * @throws RangeError if reading past end of buffer
   */
  readInt8() {
    const t = this.readUInt8();
    return t > 127 ? t - 256 : t;
  }
  /**
   * Reads a 16-bit unsigned integer in little-endian format.
   *
   * @returns The value (0-65535)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('0100'); // 1 in LE
   * reader.readUInt16LE(); // 1
   * ```
   */
  readUInt16LE() {
    if (__privateGet(this, _e6) + 2 > __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    const t = __privateGet(this, _a5).getUint16(__privateGet(this, _e6), true);
    return __privateSet(this, _e6, __privateGet(this, _e6) + 2), t;
  }
  /**
   * Reads a 16-bit signed integer in little-endian format.
   *
   * @returns The value (-32768 to 32767)
   * @throws RangeError if reading past end of buffer
   */
  readInt16LE() {
    if (__privateGet(this, _e6) + 2 > __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    const t = __privateGet(this, _a5).getInt16(__privateGet(this, _e6), true);
    return __privateSet(this, _e6, __privateGet(this, _e6) + 2), t;
  }
  /**
   * Reads a 32-bit unsigned integer in little-endian format.
   *
   * @returns The value (0 to 4294967295)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('01000000'); // 1 in LE
   * reader.readUInt32LE(); // 1
   * ```
   */
  readUInt32LE() {
    if (__privateGet(this, _e6) + 4 > __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    const t = __privateGet(this, _a5).getUint32(__privateGet(this, _e6), true);
    return __privateSet(this, _e6, __privateGet(this, _e6) + 4), t;
  }
  /**
   * Reads a 32-bit signed integer in little-endian format.
   *
   * @returns The value (-2147483648 to 2147483647)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('ffffffff'); // -1 in LE signed
   * reader.readInt32LE(); // -1
   * ```
   */
  readInt32LE() {
    if (__privateGet(this, _e6) + 4 > __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    const t = __privateGet(this, _a5).getInt32(__privateGet(this, _e6), true);
    return __privateSet(this, _e6, __privateGet(this, _e6) + 4), t;
  }
  /**
   * Reads a 64-bit unsigned integer in little-endian format as bigint.
   *
   * @returns The value as bigint
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('0100000000000000'); // 1 in LE 64-bit
   * reader.readUInt64LE(); // 1n
   * ```
   */
  readUInt64LE() {
    if (__privateGet(this, _e6) + 8 > __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    const t = __privateGet(this, _a5).getBigUint64(__privateGet(this, _e6), true);
    return __privateSet(this, _e6, __privateGet(this, _e6) + 8), t;
  }
  /**
   * Reads a 64-bit signed integer in little-endian format as bigint.
   *
   * @returns The value as bigint
   * @throws RangeError if reading past end of buffer
   */
  readInt64LE() {
    if (__privateGet(this, _e6) + 8 > __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    const t = __privateGet(this, _a5).getBigInt64(__privateGet(this, _e6), true);
    return __privateSet(this, _e6, __privateGet(this, _e6) + 8), t;
  }
  /**
   * Reads a specified number of bytes.
   *
   * Returns a subarray view (no copy) for performance.
   * Use readBytesCopy() if you need an independent copy.
   *
   * @param length - Number of bytes to read
   * @returns Uint8Array view into the buffer
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('deadbeefcafebabe');
   * const first4 = reader.readBytes(4); // deadbeef
   * const next4 = reader.readBytes(4); // cafebabe
   * ```
   */
  readBytes(t) {
    if (__privateGet(this, _e6) + t > __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    const r = __privateGet(this, _t4).subarray(__privateGet(this, _e6), __privateGet(this, _e6) + t);
    return __privateSet(this, _e6, __privateGet(this, _e6) + t), r;
  }
  /**
   * Reads a specified number of bytes as an independent copy.
   *
   * @param length - Number of bytes to read
   * @returns New Uint8Array with copied data
   * @throws RangeError if reading past end of buffer
   */
  readBytesCopy(t) {
    if (__privateGet(this, _e6) + t > __privateGet(this, _t4).length)
      throw new RangeError("Read past end of buffer");
    const r = __privateGet(this, _t4).slice(__privateGet(this, _e6), __privateGet(this, _e6) + t);
    return __privateSet(this, _e6, __privateGet(this, _e6) + t), r;
  }
  /**
   * Reads a Bitcoin CompactSize variable-length integer.
   *
   * CompactSize encoding:
   * - 0x00-0xFC: 1 byte (value as-is)
   * - 0xFD: 3 bytes (0xFD + 2-byte LE uint16)
   * - 0xFE: 5 bytes (0xFE + 4-byte LE uint32)
   * - 0xFF: 9 bytes (0xFF + 8-byte LE uint64)
   *
   * @returns The decoded integer value
   * @throws RangeError if reading past end of buffer
   * @throws RangeError if value exceeds MAX_SAFE_INTEGER
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('fd0302'); // 515 encoded
   * reader.readVarInt(); // 515
   * ```
   */
  readVarInt() {
    const t = this.readUInt8();
    if (t < 253)
      return t;
    if (t === 253)
      return this.readUInt16LE();
    if (t === 254)
      return this.readUInt32LE();
    const r = this.readUInt64LE();
    if (r > BigInt(Number.MAX_SAFE_INTEGER))
      throw new RangeError("VarInt value exceeds MAX_SAFE_INTEGER");
    return Number(r);
  }
  /**
   * Reads a Bitcoin CompactSize variable-length integer as bigint.
   *
   * Use this when you need the full 64-bit range.
   *
   * @returns The decoded integer value as bigint
   * @throws RangeError if reading past end of buffer
   */
  readVarIntBig() {
    const t = this.readUInt8();
    return t < 253 ? BigInt(t) : t === 253 ? BigInt(this.readUInt16LE()) : t === 254 ? BigInt(this.readUInt32LE()) : this.readUInt64LE();
  }
  /**
   * Reads a length-prefixed byte array (VarInt length + bytes).
   *
   * @returns Uint8Array view into the buffer
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('04deadbeef');
   * reader.readVarBytes(); // Uint8Array [0xde, 0xad, 0xbe, 0xef]
   * ```
   */
  readVarBytes() {
    const t = this.readVarInt();
    return this.readBytes(t);
  }
  /**
   * Reads an array of length-prefixed byte arrays.
   *
   * Format: VarInt count + (VarInt length + bytes) for each item.
   *
   * @returns Array of Uint8Array views
   * @throws RangeError if reading past end of buffer
   */
  readVector() {
    const t = this.readVarInt(), r = [];
    for (let n = 0; n < t; n++)
      r.push(this.readVarBytes());
    return r;
  }
  /**
   * Peeks at the next byte without advancing the position.
   *
   * @returns The next byte value, or undefined if at end
   */
  peek() {
    if (!(__privateGet(this, _e6) >= __privateGet(this, _t4).length))
      return __privateGet(this, _t4)[__privateGet(this, _e6)];
  }
  /**
   * Skips a specified number of bytes.
   *
   * @param length - Number of bytes to skip
   * @throws RangeError if skipping past end of buffer
   */
  skip(t) {
    if (__privateGet(this, _e6) + t > __privateGet(this, _t4).length)
      throw new RangeError("Skip past end of buffer");
    __privateSet(this, _e6, __privateGet(this, _e6) + t);
  }
  /**
   * Resets the read position to the beginning.
   */
  reset() {
    __privateSet(this, _e6, 0);
  }
  /**
   * Checks if there are more bytes to read.
   *
   * @returns True if there are remaining bytes
   */
  hasMore() {
    return __privateGet(this, _e6) < __privateGet(this, _t4).length;
  }
}, _t4 = new WeakMap(), _a5 = new WeakMap(), _e6 = new WeakMap(), _a4);
var _t5, _a6, _e7, _a7;
var dt4 = (_a7 = class {
  constructor(t, r = 0) {
    /**
     * The underlying byte array.
     */
    __privateAdd(this, _t5);
    /**
     * Single DataView instance reused for all writes.
     */
    __privateAdd(this, _a6);
    /**
     * Current write position.
     */
    __privateAdd(this, _e7);
    typeof t == "number" ? (__privateSet(this, _t5, new Uint8Array(t)), __privateSet(this, _e7, 0)) : (__privateSet(this, _t5, t), __privateSet(this, _e7, r)), __privateSet(this, _a6, new DataView(__privateGet(this, _t5).buffer, __privateGet(this, _t5).byteOffset, __privateGet(this, _t5).byteLength));
  }
  /**
   * Current write position in the buffer.
   */
  get offset() {
    return __privateGet(this, _e7);
  }
  /**
   * Sets the write position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative or beyond buffer length
   */
  set offset(t) {
    if (t < 0 || t > __privateGet(this, _t5).length)
      throw new RangeError(`Offset ${t} is out of bounds [0, ${__privateGet(this, _t5).length}]`);
    __privateSet(this, _e7, t);
  }
  /**
   * Total capacity of the underlying buffer.
   */
  get capacity() {
    return __privateGet(this, _t5).length;
  }
  /**
   * Number of bytes remaining in the buffer.
   */
  get remaining() {
    return __privateGet(this, _t5).length - __privateGet(this, _e7);
  }
  /**
   * The underlying data buffer.
   */
  get data() {
    return __privateGet(this, _t5);
  }
  /**
   * Creates a BinaryWriter with automatic capacity management.
   *
   * Initial capacity is 256 bytes, grows as needed.
   *
   * @returns A new GrowableBinaryWriter instance
   *
   * @example
   * ```typescript
   * import { BinaryWriter } from '@btc-vision/bitcoin';
   *
   * const writer = BinaryWriter.growable();
   * writer.writeUInt32LE(1);
   * writer.writeBytes(new Uint8Array(1000)); // Automatically grows
   * ```
   */
  static growable(t = 256) {
    return new Xa2(t);
  }
  /**
   * Writes an 8-bit unsigned integer.
   *
   * @param value - Value to write (0-255)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt8(255);
   * ```
   */
  writeUInt8(t) {
    if (__privateGet(this, _e7) >= __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _t5)[__privateWrapper(this, _e7)._++] = t & 255, this;
  }
  /**
   * Writes an 8-bit signed integer.
   *
   * @param value - Value to write (-128 to 127)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt8(t) {
    return this.writeUInt8(t < 0 ? t + 256 : t);
  }
  /**
   * Writes a 16-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write (0-65535)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt16LE(1); // Writes 01 00
   * ```
   */
  writeUInt16LE(t) {
    if (__privateGet(this, _e7) + 2 > __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _a6).setUint16(__privateGet(this, _e7), t, true), __privateSet(this, _e7, __privateGet(this, _e7) + 2), this;
  }
  /**
   * Writes a 16-bit signed integer in little-endian format.
   *
   * @param value - Value to write (-32768 to 32767)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt16LE(t) {
    if (__privateGet(this, _e7) + 2 > __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _a6).setInt16(__privateGet(this, _e7), t, true), __privateSet(this, _e7, __privateGet(this, _e7) + 2), this;
  }
  /**
   * Writes a 32-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write (0 to 4294967295)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt32LE(1); // Writes 01 00 00 00
   * ```
   */
  writeUInt32LE(t) {
    if (__privateGet(this, _e7) + 4 > __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _a6).setUint32(__privateGet(this, _e7), t, true), __privateSet(this, _e7, __privateGet(this, _e7) + 4), this;
  }
  /**
   * Writes a 32-bit signed integer in little-endian format.
   *
   * @param value - Value to write (-2147483648 to 2147483647)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeInt32LE(-1); // Writes ff ff ff ff
   * ```
   */
  writeInt32LE(t) {
    if (__privateGet(this, _e7) + 4 > __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _a6).setInt32(__privateGet(this, _e7), t, true), __privateSet(this, _e7, __privateGet(this, _e7) + 4), this;
  }
  /**
   * Writes a 64-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt64LE(50000n); // Writes 50 c3 00 00 00 00 00 00
   * ```
   */
  writeUInt64LE(t) {
    if (__privateGet(this, _e7) + 8 > __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _a6).setBigUint64(__privateGet(this, _e7), t, true), __privateSet(this, _e7, __privateGet(this, _e7) + 8), this;
  }
  /**
   * Writes a 64-bit signed integer in little-endian format.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt64LE(t) {
    if (__privateGet(this, _e7) + 8 > __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _a6).setBigInt64(__privateGet(this, _e7), t, true), __privateSet(this, _e7, __privateGet(this, _e7) + 8), this;
  }
  /**
   * Writes raw bytes.
   *
   * @param bytes - Bytes to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeBytes(new Uint8Array([0xde, 0xad, 0xbe, 0xef]));
   * ```
   */
  writeBytes(t) {
    if (__privateGet(this, _e7) + t.length > __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _t5).set(t, __privateGet(this, _e7)), __privateSet(this, _e7, __privateGet(this, _e7) + t.length), this;
  }
  /**
   * Writes a Bitcoin CompactSize variable-length integer.
   *
   * CompactSize encoding:
   * - 0x00-0xFC: 1 byte (value as-is)
   * - 0xFD-0xFFFF: 3 bytes (0xFD + 2-byte LE uint16)
   * - 0x10000-0xFFFFFFFF: 5 bytes (0xFE + 4-byte LE uint32)
   * - Larger: 9 bytes (0xFF + 8-byte LE uint64)
   *
   * @param value - Value to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeVarInt(252);    // Writes fc
   * writer.writeVarInt(253);    // Writes fd fd 00
   * writer.writeVarInt(65535);  // Writes fd ff ff
   * writer.writeVarInt(65536);  // Writes fe 00 00 01 00
   * ```
   */
  writeVarInt(t) {
    return t < 253 ? this.writeUInt8(t) : t <= 65535 ? (this.writeUInt8(253), this.writeUInt16LE(t)) : t <= 4294967295 ? (this.writeUInt8(254), this.writeUInt32LE(t)) : (this.writeUInt8(255), this.writeUInt64LE(BigInt(t)));
  }
  /**
   * Writes a Bitcoin CompactSize variable-length integer from bigint.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeVarIntBig(t) {
    return t < 0xfdn ? this.writeUInt8(Number(t)) : t <= 0xffffn ? (this.writeUInt8(253), this.writeUInt16LE(Number(t))) : t <= 0xffffffffn ? (this.writeUInt8(254), this.writeUInt32LE(Number(t))) : (this.writeUInt8(255), this.writeUInt64LE(t));
  }
  /**
   * Writes a length-prefixed byte array (VarInt length + bytes).
   *
   * @param bytes - Bytes to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeVarBytes(new Uint8Array([0xde, 0xad])); // Writes 02 de ad
   * ```
   */
  writeVarBytes(t) {
    return this.writeVarInt(t.length), this.writeBytes(t);
  }
  /**
   * Writes an array of length-prefixed byte arrays.
   *
   * Format: VarInt count + (VarInt length + bytes) for each item.
   *
   * @param vector - Array of byte arrays to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeVector(t) {
    this.writeVarInt(t.length);
    for (const r of t)
      this.writeVarBytes(r);
    return this;
  }
  /**
   * Fills a region with a specific byte value.
   *
   * @param value - Byte value to fill with
   * @param length - Number of bytes to fill
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  fill(t, r) {
    if (__privateGet(this, _e7) + r > __privateGet(this, _t5).length)
      throw new RangeError("Write past end of buffer");
    return __privateGet(this, _t5).fill(t, __privateGet(this, _e7), __privateGet(this, _e7) + r), __privateSet(this, _e7, __privateGet(this, _e7) + r), this;
  }
  /**
   * Skips a specified number of bytes (leaves them unchanged).
   *
   * @param length - Number of bytes to skip
   * @returns This writer for chaining
   * @throws RangeError if skipping past end of buffer
   */
  skip(t) {
    if (__privateGet(this, _e7) + t > __privateGet(this, _t5).length)
      throw new RangeError("Skip past end of buffer");
    return __privateSet(this, _e7, __privateGet(this, _e7) + t), this;
  }
  /**
   * Resets the write position to the beginning.
   *
   * @returns This writer for chaining
   */
  reset() {
    return __privateSet(this, _e7, 0), this;
  }
  /**
   * Verifies the buffer was fully written and returns it.
   *
   * Unlike {@link finish}, this method throws if the writer has not
   * written exactly to the end of the buffer.
   *
   * @returns The underlying buffer
   * @throws Error if the buffer was not fully written
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(8);
   * writer.writeUInt32LE(1);
   * writer.writeUInt32LE(2);
   * const bytes = writer.end(); // OK: wrote exactly 8 bytes
   *
   * const writer2 = new BinaryWriter(8);
   * writer2.writeUInt32LE(1);
   * writer2.end(); // throws: buffer size 8, offset 4
   * ```
   */
  end() {
    if (__privateGet(this, _e7) === __privateGet(this, _t5).length)
      return __privateGet(this, _t5);
    throw new Error(`buffer size ${__privateGet(this, _t5).length}, offset ${__privateGet(this, _e7)}`);
  }
  /**
   * Returns the written portion of the buffer.
   *
   * If the entire buffer was written, returns the buffer directly (no copy).
   * Otherwise, returns a subarray view.
   *
   * @returns Uint8Array containing the written data
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(100);
   * writer.writeUInt32LE(42);
   * const bytes = writer.finish(); // 4 bytes
   * ```
   */
  finish() {
    return __privateGet(this, _e7) === __privateGet(this, _t5).length ? __privateGet(this, _t5) : __privateGet(this, _t5).subarray(0, __privateGet(this, _e7));
  }
  /**
   * Returns the written portion as a hex string.
   *
   * @returns Hex string representation
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(4);
   * writer.writeUInt32LE(1);
   * writer.toHex(); // '01000000'
   * ```
   */
  toHex() {
    return Yt4(this.finish());
  }
}, _t5 = new WeakMap(), _a6 = new WeakMap(), _e7 = new WeakMap(), _a7);
var _t6, _a8, _e8, _Xa_instances, s_fn2, _a9;
var Xa2 = (_a9 = class {
  /**
   * Creates a new GrowableBinaryWriter.
   *
   * @param initialCapacity - Initial buffer size (default 256)
   */
  constructor(t = 256) {
    __privateAdd(this, _Xa_instances);
    __privateAdd(this, _t6);
    __privateAdd(this, _a8);
    __privateAdd(this, _e8, 0);
    __privateSet(this, _t6, new Uint8Array(t)), __privateSet(this, _a8, new DataView(__privateGet(this, _t6).buffer));
  }
  /**
   * Current write position.
   */
  get offset() {
    return __privateGet(this, _e8);
  }
  /**
   * Sets the write position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative
   */
  set offset(t) {
    if (t < 0)
      throw new RangeError(`Offset ${t} cannot be negative`);
    __privateSet(this, _e8, t);
  }
  /**
   * Current buffer capacity.
   */
  get capacity() {
    return __privateGet(this, _t6).length;
  }
  writeUInt8(t) {
    return __privateMethod(this, _Xa_instances, s_fn2).call(this, 1), __privateGet(this, _t6)[__privateWrapper(this, _e8)._++] = t & 255, this;
  }
  writeUInt16LE(t) {
    return __privateMethod(this, _Xa_instances, s_fn2).call(this, 2), __privateGet(this, _a8).setUint16(__privateGet(this, _e8), t, true), __privateSet(this, _e8, __privateGet(this, _e8) + 2), this;
  }
  writeUInt32LE(t) {
    return __privateMethod(this, _Xa_instances, s_fn2).call(this, 4), __privateGet(this, _a8).setUint32(__privateGet(this, _e8), t, true), __privateSet(this, _e8, __privateGet(this, _e8) + 4), this;
  }
  writeInt32LE(t) {
    return __privateMethod(this, _Xa_instances, s_fn2).call(this, 4), __privateGet(this, _a8).setInt32(__privateGet(this, _e8), t, true), __privateSet(this, _e8, __privateGet(this, _e8) + 4), this;
  }
  writeUInt64LE(t) {
    return __privateMethod(this, _Xa_instances, s_fn2).call(this, 8), __privateGet(this, _a8).setBigUint64(__privateGet(this, _e8), t, true), __privateSet(this, _e8, __privateGet(this, _e8) + 8), this;
  }
  writeBytes(t) {
    return __privateMethod(this, _Xa_instances, s_fn2).call(this, t.length), __privateGet(this, _t6).set(t, __privateGet(this, _e8)), __privateSet(this, _e8, __privateGet(this, _e8) + t.length), this;
  }
  writeVarInt(t) {
    return t < 253 ? this.writeUInt8(t) : t <= 65535 ? (this.writeUInt8(253), this.writeUInt16LE(t)) : t <= 4294967295 ? (this.writeUInt8(254), this.writeUInt32LE(t)) : (this.writeUInt8(255), this.writeUInt64LE(BigInt(t)));
  }
  writeVarBytes(t) {
    return this.writeVarInt(t.length), this.writeBytes(t);
  }
  writeVector(t) {
    this.writeVarInt(t.length);
    for (const r of t)
      this.writeVarBytes(r);
    return this;
  }
  /**
   * Returns the written data as a new Uint8Array.
   *
   * @returns Copy of the written data
   */
  finish() {
    return __privateGet(this, _t6).slice(0, __privateGet(this, _e8));
  }
  /**
   * Returns the written data as a hex string.
   *
   * @returns Hex string representation
   */
  toHex() {
    return Yt4(this.finish());
  }
}, _t6 = new WeakMap(), _a8 = new WeakMap(), _e8 = new WeakMap(), _Xa_instances = new WeakSet(), /**
 * Ensures the buffer has enough space for additional bytes.
 *
 * @param additionalBytes - Number of additional bytes needed
 */
s_fn2 = function(t) {
  const r = __privateGet(this, _e8) + t;
  if (r <= __privateGet(this, _t6).length)
    return;
  let n = __privateGet(this, _t6).length * 2;
  for (; n < r; )
    n *= 2;
  const i = new Uint8Array(n);
  i.set(__privateGet(this, _t6).subarray(0, __privateGet(this, _e8))), __privateSet(this, _t6, i), __privateSet(this, _a8, new DataView(__privateGet(this, _t6).buffer));
}, _a9);
function Za2(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function _s2(e, t, r = "") {
  const n = Za2(e), i = e == null ? void 0 : e.length;
  if (!n || t !== void 0) {
    const o = r && `"${r}" `, a = "", u = n ? `length=${i}` : `type=${typeof e}`;
    throw new Error(o + "expected Uint8Array" + a + ", got " + u);
  }
  return e;
}
function Ui2(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Qa2(e, t) {
  _s2(e, void 0, "digestInto() output");
  const r = t.outputLen;
  if (e.length < r)
    throw new Error('"digestInto() output" expected to be of length >=' + r);
}
function Ue4(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function mn2(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function Wt4(e, t) {
  return e << 32 - t | e >>> t;
}
function Ee4(e, t) {
  return e << t | e >>> 32 - t >>> 0;
}
function Zn2(e, t = {}) {
  const r = (i, o) => e(o).update(i).digest(), n = e(void 0);
  return r.outputLen = n.outputLen, r.blockLen = n.blockLen, r.create = (i) => e(i), Object.assign(r, t), Object.freeze(r);
}
var Ja2 = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function Rs2(e, t, r) {
  return e & t ^ ~e & r;
}
function Ns2(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
var Qn2 = class {
  constructor(t, r, n, i) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = mn2(this.buffer);
  }
  update(t) {
    Ui2(this), _s2(t);
    const { view: r, buffer: n, blockLen: i } = this, o = t.length;
    for (let a = 0; a < o; ) {
      const u = Math.min(i - this.pos, o - a);
      if (u === i) {
        const l = mn2(t);
        for (; i <= o - a; a += i)
          this.process(l, a);
        continue;
      }
      n.set(t.subarray(a, a + u), this.pos), this.pos += u, a += u, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Ui2(this), Qa2(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    r[a++] = 128, Ue4(this.buffer.subarray(a)), this.padOffset > i - a && (this.process(n, 0), a = 0);
    for (let p = a; p < i; p++)
      r[p] = 0;
    n.setBigUint64(i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const u = mn2(t), l = this.outputLen;
    if (l % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const d = l / 4, f = this.get();
    if (d > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let p = 0; p < d; p++)
      u.setUint32(4 * p, f[p], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: a, pos: u } = this;
    return t.destroyed = a, t.finished = o, t.length = i, t.pos = u, i % r && t.buffer.set(n), t;
  }
  clone() {
    return this._cloneInto();
  }
};
var ie3 = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var th2 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var se3 = new Uint32Array(64);
var eh2 = class extends Qn2 {
  constructor(t) {
    super(64, t, 8, false);
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: a, G: u, H: l } = this;
    return [t, r, n, i, o, a, u, l];
  }
  // prettier-ignore
  set(t, r, n, i, o, a, u, l) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = a | 0, this.G = u | 0, this.H = l | 0;
  }
  process(t, r) {
    for (let p = 0; p < 16; p++, r += 4)
      se3[p] = t.getUint32(r, false);
    for (let p = 16; p < 64; p++) {
      const w = se3[p - 15], y = se3[p - 2], m = Wt4(w, 7) ^ Wt4(w, 18) ^ w >>> 3, E2 = Wt4(y, 17) ^ Wt4(y, 19) ^ y >>> 10;
      se3[p] = E2 + se3[p - 7] + m + se3[p - 16] | 0;
    }
    let { A: n, B: i, C: o, D: a, E: u, F: l, G: d, H: f } = this;
    for (let p = 0; p < 64; p++) {
      const w = Wt4(u, 6) ^ Wt4(u, 11) ^ Wt4(u, 25), y = f + w + Rs2(u, l, d) + th2[p] + se3[p] | 0, m = (Wt4(n, 2) ^ Wt4(n, 13) ^ Wt4(n, 22)) + Ns2(n, i, o) | 0;
      f = d, d = l, l = u, u = a + y | 0, a = o, o = i, i = n, n = y + m | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, u = u + this.E | 0, l = l + this.F | 0, d = d + this.G | 0, f = f + this.H | 0, this.set(n, i, o, a, u, l, d, f);
  }
  roundClean() {
    Ue4(se3);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Ue4(this.buffer);
  }
};
var rh2 = class extends eh2 {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", ie3[0] | 0);
    __publicField(this, "B", ie3[1] | 0);
    __publicField(this, "C", ie3[2] | 0);
    __publicField(this, "D", ie3[3] | 0);
    __publicField(this, "E", ie3[4] | 0);
    __publicField(this, "F", ie3[5] | 0);
    __publicField(this, "G", ie3[6] | 0);
    __publicField(this, "H", ie3[7] | 0);
  }
};
var Me4 = Zn2(
  () => new rh2(),
  Ja2(1)
);
function nh2(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let d = 0; d < t.length; d++)
    t[d] = 255;
  for (let d = 0; d < e.length; d++) {
    const f = e.charAt(d), p = f.charCodeAt(0);
    if (t[p] !== 255)
      throw new TypeError(f + " is ambiguous");
    t[p] = d;
  }
  const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function a(d) {
    if (d instanceof Uint8Array || (ArrayBuffer.isView(d) ? d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength) : Array.isArray(d) && (d = Uint8Array.from(d))), !(d instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (d.length === 0)
      return "";
    let f = 0, p = 0, w = 0;
    const y = d.length;
    for (; w !== y && d[w] === 0; )
      w++, f++;
    const m = (y - w) * o + 1 >>> 0, E2 = new Uint8Array(m);
    for (; w !== y; ) {
      let O = d[w], T = 0;
      for (let _ = m - 1; (O !== 0 || T < p) && _ !== -1; _--, T++)
        O += 256 * E2[_] >>> 0, E2[_] = O % r >>> 0, O = O / r >>> 0;
      if (O !== 0)
        throw new Error("Non-zero carry");
      p = T, w++;
    }
    let v = m - p;
    for (; v !== m && E2[v] === 0; )
      v++;
    let x = n.repeat(f);
    for (; v < m; ++v)
      x += e.charAt(E2[v]);
    return x;
  }
  function u(d) {
    if (typeof d != "string")
      throw new TypeError("Expected String");
    if (d.length === 0)
      return new Uint8Array();
    let f = 0, p = 0, w = 0;
    for (; d[f] === n; )
      p++, f++;
    const y = (d.length - f) * i + 1 >>> 0, m = new Uint8Array(y);
    for (; f < d.length; ) {
      const O = d.charCodeAt(f);
      if (O > 255)
        return;
      let T = t[O];
      if (T === 255)
        return;
      let _ = 0;
      for (let M2 = y - 1; (T !== 0 || _ < w) && M2 !== -1; M2--, _++)
        T += r * m[M2] >>> 0, m[M2] = T % 256 >>> 0, T = T / 256 >>> 0;
      if (T !== 0)
        throw new Error("Non-zero carry");
      w = _, f++;
    }
    let E2 = y - w;
    for (; E2 !== y && m[E2] === 0; )
      E2++;
    const v = new Uint8Array(p + (y - E2));
    let x = p;
    for (; E2 !== y; )
      v[x++] = m[E2++];
    return v;
  }
  function l(d) {
    const f = u(d);
    if (f)
      return f;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: a,
    decodeUnsafe: u,
    decode: l
  };
}
var ih2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var En2 = nh2(ih2);
function sh2(e) {
  function t(o) {
    const a = e(o), u = o.length + 4, l = new Uint8Array(u);
    return l.set(o, 0), l.set(a.subarray(0, 4), o.length), En2.encode(l);
  }
  function r(o) {
    const a = o.slice(0, -4), u = o.slice(-4), l = e(a);
    if (!(u[0] ^ l[0] | u[1] ^ l[1] | u[2] ^ l[2] | u[3] ^ l[3]))
      return a;
  }
  function n(o) {
    const a = En2.decodeUnsafe(o);
    if (a !== void 0)
      return r(a);
  }
  function i(o) {
    const a = En2.decode(o), u = r(a);
    if (u === void 0)
      throw new Error("Invalid checksum");
    return u;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: n
  };
}
function oh2(e) {
  return Me4(Me4(e));
}
var { encode: Jn2, decode: ti2 } = sh2(oh2);
function _t7(e) {
  let t = 0;
  for (const i of e)
    t += i.length;
  const r = new Uint8Array(t);
  let n = 0;
  for (const i of e)
    r.set(i, n), n += i.length;
  return r;
}
function P(e, t) {
  if (e.length !== t.length)
    return false;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return false;
  return true;
}
function Fe3(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; n++) {
    const i = e[n] - t[n];
    if (i !== 0)
      return i;
  }
  return e.length - t.length;
}
function Ln2(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t] !== 0)
      return false;
  return true;
}
function xi2(e) {
  const t = new Uint8Array(e.length);
  return t.set(e), t;
}
function ei2(e) {
  return e.reverse(), e;
}
function Et4(e, t = 0) {
  const r = new Uint8Array(e);
  return t !== 0 && r.fill(t), r;
}
function pp2(e) {
  return new TextEncoder().encode(e);
}
function ah2(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return false;
  const t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return false;
  const r = e[5 + t];
  return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function hh2(e) {
  if (e.length < 8) throw new Error("DER sequence length is too short");
  if (e.length > 72) throw new Error("DER sequence length is too long");
  if (e[0] !== 48) throw new Error("Expected DER sequence");
  if (e[1] !== e.length - 2) throw new Error("DER sequence length is invalid");
  if (e[2] !== 2) throw new Error("Expected DER integer");
  const t = e[3];
  if (t === 0) throw new Error("R length is zero");
  if (5 + t >= e.length) throw new Error("R length is too long");
  if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
  const r = e[5 + t];
  if (r === 0) throw new Error("S length is zero");
  if (6 + t + r !== e.length) throw new Error("S length is invalid");
  if (e[4] & 128) throw new Error("R value is negative");
  if (t > 1 && e[4] === 0 && !(e[5] & 128))
    throw new Error("R value excessively padded");
  if (e[t + 6] & 128) throw new Error("S value is negative");
  if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: e.subarray(4, 4 + t),
    s: e.subarray(6 + t)
  };
}
function uh2(e, t) {
  const r = e.length, n = t.length;
  if (r === 0) throw new Error("R length is zero");
  if (n === 0) throw new Error("S length is zero");
  if (r > 33) throw new Error("R length is too long");
  if (n > 33) throw new Error("S length is too long");
  if (e[0] & 128) throw new Error("R value is negative");
  if (t[0] & 128) throw new Error("S value is negative");
  if (r > 1 && e[0] === 0 && !(e[1] & 128)) throw new Error("R value excessively padded");
  if (n > 1 && t[0] === 0 && !(t[1] & 128)) throw new Error("S value excessively padded");
  const i = Et4(6 + r + n);
  return i[0] = 48, i[1] = i.length - 2, i[2] = 2, i[3] = e.length, i.set(e, 4), i[4 + r] = 2, i[5 + r] = t.length, i.set(t, 6 + r), i;
}
var q2 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
var Tr2;
function Hs2() {
  if (!Tr2) {
    Tr2 = {};
    for (const e of Object.keys(q2)) {
      const t = q2[e];
      Tr2[t] = e;
    }
  }
  return Tr2;
}
Hs2();
function Ls2(e) {
  return e < q2.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function fh2(e, t, r) {
  const n = Ls2(t), i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n === 1 ? e[r] = t : n === 2 ? (e[r] = q2.OP_PUSHDATA1, e[r + 1] = t) : n === 3 ? (e[r] = q2.OP_PUSHDATA2, i.setUint16(r + 1, t, true)) : (e[r] = q2.OP_PUSHDATA4, i.setUint32(r + 1, t, true)), n;
}
function ch2(e, t) {
  const r = new DataView(e.buffer, e.byteOffset, e.byteLength), n = e[t];
  let i, o;
  if (n < q2.OP_PUSHDATA1)
    i = n, o = 1;
  else if (n === q2.OP_PUSHDATA1) {
    if (t + 2 > e.length) return null;
    i = e[t + 1], o = 2;
  } else if (n === q2.OP_PUSHDATA2) {
    if (t + 3 > e.length) return null;
    i = r.getUint16(t + 1, true), o = 3;
  } else {
    if (t + 5 > e.length) return null;
    if (n !== q2.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    i = r.getUint32(t + 1, true), o = 5;
  }
  return {
    opcode: n,
    number: i,
    size: o
  };
}
var Cs2 = {};
var sn2 = {};
sn2.byteLength = dh2;
sn2.toByteArray = gh2;
sn2.fromByteArray = mh2;
var zt4 = [];
var Ct4 = [];
var lh2 = typeof Uint8Array < "u" ? Uint8Array : Array;
var In2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (He3 = 0, ph2 = In2.length; He3 < ph2; ++He3)
  zt4[He3] = In2[He3], Ct4[In2.charCodeAt(He3)] = He3;
var He3;
var ph2;
Ct4[45] = 62;
Ct4[95] = 63;
function Vs2(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function dh2(e) {
  var t = Vs2(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function wh2(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function gh2(e) {
  var t, r = Vs2(e), n = r[0], i = r[1], o = new lh2(wh2(e, n, i)), a = 0, u = i > 0 ? n - 4 : n, l;
  for (l = 0; l < u; l += 4)
    t = Ct4[e.charCodeAt(l)] << 18 | Ct4[e.charCodeAt(l + 1)] << 12 | Ct4[e.charCodeAt(l + 2)] << 6 | Ct4[e.charCodeAt(l + 3)], o[a++] = t >> 16 & 255, o[a++] = t >> 8 & 255, o[a++] = t & 255;
  return i === 2 && (t = Ct4[e.charCodeAt(l)] << 2 | Ct4[e.charCodeAt(l + 1)] >> 4, o[a++] = t & 255), i === 1 && (t = Ct4[e.charCodeAt(l)] << 10 | Ct4[e.charCodeAt(l + 1)] << 4 | Ct4[e.charCodeAt(l + 2)] >> 2, o[a++] = t >> 8 & 255, o[a++] = t & 255), o;
}
function yh2(e) {
  return zt4[e >> 18 & 63] + zt4[e >> 12 & 63] + zt4[e >> 6 & 63] + zt4[e & 63];
}
function bh2(e, t, r) {
  for (var n, i = [], o = t; o < r; o += 3)
    n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(yh2(n));
  return i.join("");
}
function mh2(e) {
  for (var t, r = e.length, n = r % 3, i = [], o = 16383, a = 0, u = r - n; a < u; a += o)
    i.push(bh2(e, a, a + o > u ? u : a + o));
  return n === 1 ? (t = e[r - 1], i.push(
    zt4[t >> 2] + zt4[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(
    zt4[t >> 10] + zt4[t >> 4 & 63] + zt4[t << 2 & 63] + "="
  )), i.join("");
}
var ri2 = {};
ri2.read = function(e, t, r, n, i) {
  var o, a, u = i * 8 - n - 1, l = (1 << u) - 1, d = l >> 1, f = -7, p = r ? i - 1 : 0, w = r ? -1 : 1, y = e[t + p];
  for (p += w, o = y & (1 << -f) - 1, y >>= -f, f += u; f > 0; o = o * 256 + e[t + p], p += w, f -= 8)
    ;
  for (a = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; a = a * 256 + e[t + p], p += w, f -= 8)
    ;
  if (o === 0)
    o = 1 - d;
  else {
    if (o === l)
      return a ? NaN : (y ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, n), o = o - d;
  }
  return (y ? -1 : 1) * a * Math.pow(2, o - n);
};
ri2.write = function(e, t, r, n, i, o) {
  var a, u, l, d = o * 8 - i - 1, f = (1 << d) - 1, p = f >> 1, w = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : o - 1, m = n ? 1 : -1, E2 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, a = f) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + p >= 1 ? t += w / l : t += w * Math.pow(2, 1 - p), t * l >= 2 && (a++, l /= 2), a + p >= f ? (u = 0, a = f) : a + p >= 1 ? (u = (t * l - 1) * Math.pow(2, i), a = a + p) : (u = t * Math.pow(2, p - 1) * Math.pow(2, i), a = 0)); i >= 8; e[r + y] = u & 255, y += m, u /= 256, i -= 8)
    ;
  for (a = a << i | u, d += i; d > 0; e[r + y] = a & 255, y += m, a /= 256, d -= 8)
    ;
  e[r + y - m] |= E2 * 128;
};
(function(e) {
  const t = sn2, r = ri2, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = f, e.SlowBuffer = M2, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i;
  const { Uint8Array: o, ArrayBuffer: a, SharedArrayBuffer: u } = globalThis;
  f.TYPED_ARRAY_SUPPORT = l(), !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function l() {
    try {
      const s = new o(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, o.prototype), Object.setPrototypeOf(s, h), s.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(f.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (f.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(f.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (f.isBuffer(this))
        return this.byteOffset;
    }
  });
  function d(s) {
    if (s > i)
      throw new RangeError('The value "' + s + '" is invalid for option "size"');
    const h = new o(s);
    return Object.setPrototypeOf(h, f.prototype), h;
  }
  function f(s, h, c) {
    if (typeof s == "number") {
      if (typeof h == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(s);
    }
    return p(s, h, c);
  }
  f.poolSize = 8192;
  function p(s, h, c) {
    if (typeof s == "string")
      return E2(s, h);
    if (a.isView(s))
      return x(s);
    if (s == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof s
      );
    if (Ft5(s, a) || s && Ft5(s.buffer, a) || typeof u < "u" && (Ft5(s, u) || s && Ft5(s.buffer, u)))
      return O(s, h, c);
    if (typeof s == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const g = s.valueOf && s.valueOf();
    if (g != null && g !== s)
      return f.from(g, h, c);
    const b2 = T(s);
    if (b2) return b2;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof s[Symbol.toPrimitive] == "function")
      return f.from(s[Symbol.toPrimitive]("string"), h, c);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof s
    );
  }
  f.from = function(s, h, c) {
    return p(s, h, c);
  }, Object.setPrototypeOf(f.prototype, o.prototype), Object.setPrototypeOf(f, o);
  function w(s) {
    if (typeof s != "number")
      throw new TypeError('"size" argument must be of type number');
    if (s < 0)
      throw new RangeError('The value "' + s + '" is invalid for option "size"');
  }
  function y(s, h, c) {
    return w(s), s <= 0 ? d(s) : h !== void 0 ? typeof c == "string" ? d(s).fill(h, c) : d(s).fill(h) : d(s);
  }
  f.alloc = function(s, h, c) {
    return y(s, h, c);
  };
  function m(s) {
    return w(s), d(s < 0 ? 0 : _(s) | 0);
  }
  f.allocUnsafe = function(s) {
    return m(s);
  }, f.allocUnsafeSlow = function(s) {
    return m(s);
  };
  function E2(s, h) {
    if ((typeof h != "string" || h === "") && (h = "utf8"), !f.isEncoding(h))
      throw new TypeError("Unknown encoding: " + h);
    const c = nt5(s, h) | 0;
    let g = d(c);
    const b2 = g.write(s, h);
    return b2 !== c && (g = g.slice(0, b2)), g;
  }
  function v(s) {
    const h = s.length < 0 ? 0 : _(s.length) | 0, c = d(h);
    for (let g = 0; g < h; g += 1)
      c[g] = s[g] & 255;
    return c;
  }
  function x(s) {
    if (Ft5(s, o)) {
      const h = new o(s);
      return O(h.buffer, h.byteOffset, h.byteLength);
    }
    return v(s);
  }
  function O(s, h, c) {
    if (h < 0 || s.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (s.byteLength < h + (c || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let g;
    return h === void 0 && c === void 0 ? g = new o(s) : c === void 0 ? g = new o(s, h) : g = new o(s, h, c), Object.setPrototypeOf(g, f.prototype), g;
  }
  function T(s) {
    if (f.isBuffer(s)) {
      const h = _(s.length) | 0, c = d(h);
      return c.length === 0 || s.copy(c, 0, 0, h), c;
    }
    if (s.length !== void 0)
      return typeof s.length != "number" || bn2(s.length) ? d(0) : v(s);
    if (s.type === "Buffer" && Array.isArray(s.data))
      return v(s.data);
  }
  function _(s) {
    if (s >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return s | 0;
  }
  function M2(s) {
    return +s != s && (s = 0), f.alloc(+s);
  }
  f.isBuffer = function(s) {
    return s != null && s._isBuffer === true && s !== f.prototype;
  }, f.compare = function(s, h) {
    if (Ft5(s, o) && (s = f.from(s, s.offset, s.byteLength)), Ft5(h, o) && (h = f.from(h, h.offset, h.byteLength)), !f.isBuffer(s) || !f.isBuffer(h))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (s === h) return 0;
    let c = s.length, g = h.length;
    for (let b2 = 0, I2 = Math.min(c, g); b2 < I2; ++b2)
      if (s[b2] !== h[b2]) {
        c = s[b2], g = h[b2];
        break;
      }
    return c < g ? -1 : g < c ? 1 : 0;
  }, f.isEncoding = function(s) {
    switch (String(s).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, f.concat = function(s, h) {
    if (!Array.isArray(s))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (s.length === 0)
      return f.alloc(0);
    let c;
    if (h === void 0)
      for (h = 0, c = 0; c < s.length; ++c)
        h += s[c].length;
    const g = f.allocUnsafe(h);
    let b2 = 0;
    for (c = 0; c < s.length; ++c) {
      let I2 = s[c];
      if (Ft5(I2, o))
        b2 + I2.length > g.length ? (f.isBuffer(I2) || (I2 = f.from(I2)), I2.copy(g, b2)) : o.prototype.set.call(
          g,
          I2,
          b2
        );
      else if (f.isBuffer(I2))
        I2.copy(g, b2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      b2 += I2.length;
    }
    return g;
  };
  function nt5(s, h) {
    if (f.isBuffer(s))
      return s.length;
    if (a.isView(s) || Ft5(s, a))
      return s.byteLength;
    if (typeof s != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof s
      );
    const c = s.length, g = arguments.length > 2 && arguments[2] === true;
    if (!g && c === 0) return 0;
    let b2 = false;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return c;
        case "utf8":
        case "utf-8":
          return yn2(s).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return c * 2;
        case "hex":
          return c >>> 1;
        case "base64":
          return Si3(s).length;
        default:
          if (b2)
            return g ? -1 : yn2(s).length;
          h = ("" + h).toLowerCase(), b2 = true;
      }
  }
  f.byteLength = nt5;
  function z4(s, h, c) {
    let g = false;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((c === void 0 || c > this.length) && (c = this.length), c <= 0) || (c >>>= 0, h >>>= 0, c <= h))
      return "";
    for (s || (s = "utf8"); ; )
      switch (s) {
        case "hex":
          return W3(this, h, c);
        case "utf8":
        case "utf-8":
          return C(this, h, c);
        case "ascii":
          return L(this, h, c);
        case "latin1":
        case "binary":
          return D2(this, h, c);
        case "base64":
          return B2(this, h, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ct5(this, h, c);
        default:
          if (g) throw new TypeError("Unknown encoding: " + s);
          s = (s + "").toLowerCase(), g = true;
      }
  }
  f.prototype._isBuffer = true;
  function Y2(s, h, c) {
    const g = s[h];
    s[h] = s[c], s[c] = g;
  }
  f.prototype.swap16 = function() {
    const s = this.length;
    if (s % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < s; h += 2)
      Y2(this, h, h + 1);
    return this;
  }, f.prototype.swap32 = function() {
    const s = this.length;
    if (s % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < s; h += 4)
      Y2(this, h, h + 3), Y2(this, h + 1, h + 2);
    return this;
  }, f.prototype.swap64 = function() {
    const s = this.length;
    if (s % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < s; h += 8)
      Y2(this, h, h + 7), Y2(this, h + 1, h + 6), Y2(this, h + 2, h + 5), Y2(this, h + 3, h + 4);
    return this;
  }, f.prototype.toString = function() {
    const s = this.length;
    return s === 0 ? "" : arguments.length === 0 ? C(this, 0, s) : z4.apply(this, arguments);
  }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(s) {
    if (!f.isBuffer(s)) throw new TypeError("Argument must be a Buffer");
    return this === s ? true : f.compare(this, s) === 0;
  }, f.prototype.inspect = function() {
    let s = "";
    const h = e.INSPECT_MAX_BYTES;
    return s = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (s += " ... "), "<Buffer " + s + ">";
  }, n && (f.prototype[n] = f.prototype.inspect), f.prototype.compare = function(s, h, c, g, b2) {
    if (Ft5(s, o) && (s = f.from(s, s.offset, s.byteLength)), !f.isBuffer(s))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof s
      );
    if (h === void 0 && (h = 0), c === void 0 && (c = s ? s.length : 0), g === void 0 && (g = 0), b2 === void 0 && (b2 = this.length), h < 0 || c > s.length || g < 0 || b2 > this.length)
      throw new RangeError("out of range index");
    if (g >= b2 && h >= c)
      return 0;
    if (g >= b2)
      return -1;
    if (h >= c)
      return 1;
    if (h >>>= 0, c >>>= 0, g >>>= 0, b2 >>>= 0, this === s) return 0;
    let I2 = b2 - g, k2 = c - h;
    const ot5 = Math.min(I2, k2), bt5 = this.slice(g, b2), at4 = s.slice(h, c);
    for (let et5 = 0; et5 < ot5; ++et5)
      if (bt5[et5] !== at4[et5]) {
        I2 = bt5[et5], k2 = at4[et5];
        break;
      }
    return I2 < k2 ? -1 : k2 < I2 ? 1 : 0;
  };
  function F3(s, h, c, g, b2) {
    if (s.length === 0) return -1;
    if (typeof c == "string" ? (g = c, c = 0) : c > 2147483647 ? c = 2147483647 : c < -2147483648 && (c = -2147483648), c = +c, bn2(c) && (c = b2 ? 0 : s.length - 1), c < 0 && (c = s.length + c), c >= s.length) {
      if (b2) return -1;
      c = s.length - 1;
    } else if (c < 0)
      if (b2) c = 0;
      else return -1;
    if (typeof h == "string" && (h = f.from(h, g)), f.isBuffer(h))
      return h.length === 0 ? -1 : Rt5(s, h, c, g, b2);
    if (typeof h == "number")
      return h = h & 255, typeof o.prototype.indexOf == "function" ? b2 ? o.prototype.indexOf.call(s, h, c) : o.prototype.lastIndexOf.call(s, h, c) : Rt5(s, [h], c, g, b2);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Rt5(s, h, c, g, b2) {
    let I2 = 1, k2 = s.length, ot5 = h.length;
    if (g !== void 0 && (g = String(g).toLowerCase(), g === "ucs2" || g === "ucs-2" || g === "utf16le" || g === "utf-16le")) {
      if (s.length < 2 || h.length < 2)
        return -1;
      I2 = 2, k2 /= 2, ot5 /= 2, c /= 2;
    }
    function bt5(et5, pt5) {
      return I2 === 1 ? et5[pt5] : et5.readUInt16BE(pt5 * I2);
    }
    let at4;
    if (b2) {
      let et5 = -1;
      for (at4 = c; at4 < k2; at4++)
        if (bt5(s, at4) === bt5(h, et5 === -1 ? 0 : at4 - et5)) {
          if (et5 === -1 && (et5 = at4), at4 - et5 + 1 === ot5) return et5 * I2;
        } else
          et5 !== -1 && (at4 -= at4 - et5), et5 = -1;
    } else
      for (c + ot5 > k2 && (c = k2 - ot5), at4 = c; at4 >= 0; at4--) {
        let et5 = true;
        for (let pt5 = 0; pt5 < ot5; pt5++)
          if (bt5(s, at4 + pt5) !== bt5(h, pt5)) {
            et5 = false;
            break;
          }
        if (et5) return at4;
      }
    return -1;
  }
  f.prototype.includes = function(s, h, c) {
    return this.indexOf(s, h, c) !== -1;
  }, f.prototype.indexOf = function(s, h, c) {
    return F3(this, s, h, c, true);
  }, f.prototype.lastIndexOf = function(s, h, c) {
    return F3(this, s, h, c, false);
  };
  function Qt5(s, h, c, g) {
    c = Number(c) || 0;
    const b2 = s.length - c;
    g ? (g = Number(g), g > b2 && (g = b2)) : g = b2;
    const I2 = h.length;
    g > I2 / 2 && (g = I2 / 2);
    let k2;
    for (k2 = 0; k2 < g; ++k2) {
      const ot5 = parseInt(h.substr(k2 * 2, 2), 16);
      if (bn2(ot5)) return k2;
      s[c + k2] = ot5;
    }
    return k2;
  }
  function X3(s, h, c, g) {
    return Sr2(yn2(h, s.length - c), s, c, g);
  }
  function U(s, h, c, g) {
    return Sr2(Sa2(h), s, c, g);
  }
  function S2(s, h, c, g) {
    return Sr2(Si3(h), s, c, g);
  }
  function A(s, h, c, g) {
    return Sr2(Ta2(h, s.length - c), s, c, g);
  }
  f.prototype.write = function(s, h, c, g) {
    if (h === void 0)
      g = "utf8", c = this.length, h = 0;
    else if (c === void 0 && typeof h == "string")
      g = h, c = this.length, h = 0;
    else if (isFinite(h))
      h = h >>> 0, isFinite(c) ? (c = c >>> 0, g === void 0 && (g = "utf8")) : (g = c, c = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const b2 = this.length - h;
    if ((c === void 0 || c > b2) && (c = b2), s.length > 0 && (c < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    g || (g = "utf8");
    let I2 = false;
    for (; ; )
      switch (g) {
        case "hex":
          return Qt5(this, s, h, c);
        case "utf8":
        case "utf-8":
          return X3(this, s, h, c);
        case "ascii":
        case "latin1":
        case "binary":
          return U(this, s, h, c);
        case "base64":
          return S2(this, s, h, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return A(this, s, h, c);
        default:
          if (I2) throw new TypeError("Unknown encoding: " + g);
          g = ("" + g).toLowerCase(), I2 = true;
      }
  }, f.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function B2(s, h, c) {
    return h === 0 && c === s.length ? t.fromByteArray(s) : t.fromByteArray(s.slice(h, c));
  }
  function C(s, h, c) {
    c = Math.min(s.length, c);
    const g = [];
    let b2 = h;
    for (; b2 < c; ) {
      const I2 = s[b2];
      let k2 = null, ot5 = I2 > 239 ? 4 : I2 > 223 ? 3 : I2 > 191 ? 2 : 1;
      if (b2 + ot5 <= c) {
        let bt5, at4, et5, pt5;
        switch (ot5) {
          case 1:
            I2 < 128 && (k2 = I2);
            break;
          case 2:
            bt5 = s[b2 + 1], (bt5 & 192) === 128 && (pt5 = (I2 & 31) << 6 | bt5 & 63, pt5 > 127 && (k2 = pt5));
            break;
          case 3:
            bt5 = s[b2 + 1], at4 = s[b2 + 2], (bt5 & 192) === 128 && (at4 & 192) === 128 && (pt5 = (I2 & 15) << 12 | (bt5 & 63) << 6 | at4 & 63, pt5 > 2047 && (pt5 < 55296 || pt5 > 57343) && (k2 = pt5));
            break;
          case 4:
            bt5 = s[b2 + 1], at4 = s[b2 + 2], et5 = s[b2 + 3], (bt5 & 192) === 128 && (at4 & 192) === 128 && (et5 & 192) === 128 && (pt5 = (I2 & 15) << 18 | (bt5 & 63) << 12 | (at4 & 63) << 6 | et5 & 63, pt5 > 65535 && pt5 < 1114112 && (k2 = pt5));
        }
      }
      k2 === null ? (k2 = 65533, ot5 = 1) : k2 > 65535 && (k2 -= 65536, g.push(k2 >>> 10 & 1023 | 55296), k2 = 56320 | k2 & 1023), g.push(k2), b2 += ot5;
    }
    return $4(g);
  }
  const V2 = 4096;
  function $4(s) {
    const h = s.length;
    if (h <= V2)
      return String.fromCharCode.apply(String, s);
    let c = "", g = 0;
    for (; g < h; )
      c += String.fromCharCode.apply(
        String,
        s.slice(g, g += V2)
      );
    return c;
  }
  function L(s, h, c) {
    let g = "";
    c = Math.min(s.length, c);
    for (let b2 = h; b2 < c; ++b2)
      g += String.fromCharCode(s[b2] & 127);
    return g;
  }
  function D2(s, h, c) {
    let g = "";
    c = Math.min(s.length, c);
    for (let b2 = h; b2 < c; ++b2)
      g += String.fromCharCode(s[b2]);
    return g;
  }
  function W3(s, h, c) {
    const g = s.length;
    (!h || h < 0) && (h = 0), (!c || c < 0 || c > g) && (c = g);
    let b2 = "";
    for (let I2 = h; I2 < c; ++I2)
      b2 += ka2[s[I2]];
    return b2;
  }
  function ct5(s, h, c) {
    const g = s.slice(h, c);
    let b2 = "";
    for (let I2 = 0; I2 < g.length - 1; I2 += 2)
      b2 += String.fromCharCode(g[I2] + g[I2 + 1] * 256);
    return b2;
  }
  f.prototype.slice = function(s, h) {
    const c = this.length;
    s = ~~s, h = h === void 0 ? c : ~~h, s < 0 ? (s += c, s < 0 && (s = 0)) : s > c && (s = c), h < 0 ? (h += c, h < 0 && (h = 0)) : h > c && (h = c), h < s && (h = s);
    const g = this.subarray(s, h);
    return Object.setPrototypeOf(g, f.prototype), g;
  };
  function G3(s, h, c) {
    if (s % 1 !== 0 || s < 0) throw new RangeError("offset is not uint");
    if (s + h > c) throw new RangeError("Trying to access beyond buffer length");
  }
  f.prototype.readUintLE = f.prototype.readUIntLE = function(s, h, c) {
    s = s >>> 0, h = h >>> 0, c || G3(s, h, this.length);
    let g = this[s], b2 = 1, I2 = 0;
    for (; ++I2 < h && (b2 *= 256); )
      g += this[s + I2] * b2;
    return g;
  }, f.prototype.readUintBE = f.prototype.readUIntBE = function(s, h, c) {
    s = s >>> 0, h = h >>> 0, c || G3(s, h, this.length);
    let g = this[s + --h], b2 = 1;
    for (; h > 0 && (b2 *= 256); )
      g += this[s + --h] * b2;
    return g;
  }, f.prototype.readUint8 = f.prototype.readUInt8 = function(s, h) {
    return s = s >>> 0, h || G3(s, 1, this.length), this[s];
  }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(s, h) {
    return s = s >>> 0, h || G3(s, 2, this.length), this[s] | this[s + 1] << 8;
  }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(s, h) {
    return s = s >>> 0, h || G3(s, 2, this.length), this[s] << 8 | this[s + 1];
  }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(s, h) {
    return s = s >>> 0, h || G3(s, 4, this.length), (this[s] | this[s + 1] << 8 | this[s + 2] << 16) + this[s + 3] * 16777216;
  }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(s, h) {
    return s = s >>> 0, h || G3(s, 4, this.length), this[s] * 16777216 + (this[s + 1] << 16 | this[s + 2] << 8 | this[s + 3]);
  }, f.prototype.readBigUInt64LE = ne3(function(s) {
    s = s >>> 0, Ne4(s, "offset");
    const h = this[s], c = this[s + 7];
    (h === void 0 || c === void 0) && Xe4(s, this.length - 8);
    const g = h + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + this[++s] * 2 ** 24, b2 = this[++s] + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + c * 2 ** 24;
    return BigInt(g) + (BigInt(b2) << BigInt(32));
  }), f.prototype.readBigUInt64BE = ne3(function(s) {
    s = s >>> 0, Ne4(s, "offset");
    const h = this[s], c = this[s + 7];
    (h === void 0 || c === void 0) && Xe4(s, this.length - 8);
    const g = h * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + this[++s], b2 = this[++s] * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + c;
    return (BigInt(g) << BigInt(32)) + BigInt(b2);
  }), f.prototype.readIntLE = function(s, h, c) {
    s = s >>> 0, h = h >>> 0, c || G3(s, h, this.length);
    let g = this[s], b2 = 1, I2 = 0;
    for (; ++I2 < h && (b2 *= 256); )
      g += this[s + I2] * b2;
    return b2 *= 128, g >= b2 && (g -= Math.pow(2, 8 * h)), g;
  }, f.prototype.readIntBE = function(s, h, c) {
    s = s >>> 0, h = h >>> 0, c || G3(s, h, this.length);
    let g = h, b2 = 1, I2 = this[s + --g];
    for (; g > 0 && (b2 *= 256); )
      I2 += this[s + --g] * b2;
    return b2 *= 128, I2 >= b2 && (I2 -= Math.pow(2, 8 * h)), I2;
  }, f.prototype.readInt8 = function(s, h) {
    return s = s >>> 0, h || G3(s, 1, this.length), this[s] & 128 ? (255 - this[s] + 1) * -1 : this[s];
  }, f.prototype.readInt16LE = function(s, h) {
    s = s >>> 0, h || G3(s, 2, this.length);
    const c = this[s] | this[s + 1] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, f.prototype.readInt16BE = function(s, h) {
    s = s >>> 0, h || G3(s, 2, this.length);
    const c = this[s + 1] | this[s] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, f.prototype.readInt32LE = function(s, h) {
    return s = s >>> 0, h || G3(s, 4, this.length), this[s] | this[s + 1] << 8 | this[s + 2] << 16 | this[s + 3] << 24;
  }, f.prototype.readInt32BE = function(s, h) {
    return s = s >>> 0, h || G3(s, 4, this.length), this[s] << 24 | this[s + 1] << 16 | this[s + 2] << 8 | this[s + 3];
  }, f.prototype.readBigInt64LE = ne3(function(s) {
    s = s >>> 0, Ne4(s, "offset");
    const h = this[s], c = this[s + 7];
    (h === void 0 || c === void 0) && Xe4(s, this.length - 8);
    const g = this[s + 4] + this[s + 5] * 2 ** 8 + this[s + 6] * 2 ** 16 + (c << 24);
    return (BigInt(g) << BigInt(32)) + BigInt(h + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + this[++s] * 2 ** 24);
  }), f.prototype.readBigInt64BE = ne3(function(s) {
    s = s >>> 0, Ne4(s, "offset");
    const h = this[s], c = this[s + 7];
    (h === void 0 || c === void 0) && Xe4(s, this.length - 8);
    const g = (h << 24) + // Overflow
    this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + this[++s];
    return (BigInt(g) << BigInt(32)) + BigInt(this[++s] * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + c);
  }), f.prototype.readFloatLE = function(s, h) {
    return s = s >>> 0, h || G3(s, 4, this.length), r.read(this, s, true, 23, 4);
  }, f.prototype.readFloatBE = function(s, h) {
    return s = s >>> 0, h || G3(s, 4, this.length), r.read(this, s, false, 23, 4);
  }, f.prototype.readDoubleLE = function(s, h) {
    return s = s >>> 0, h || G3(s, 8, this.length), r.read(this, s, true, 52, 8);
  }, f.prototype.readDoubleBE = function(s, h) {
    return s = s >>> 0, h || G3(s, 8, this.length), r.read(this, s, false, 52, 8);
  };
  function K3(s, h, c, g, b2, I2) {
    if (!f.isBuffer(s)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > b2 || h < I2) throw new RangeError('"value" argument is out of bounds');
    if (c + g > s.length) throw new RangeError("Index out of range");
  }
  f.prototype.writeUintLE = f.prototype.writeUIntLE = function(s, h, c, g) {
    if (s = +s, h = h >>> 0, c = c >>> 0, !g) {
      const k2 = Math.pow(2, 8 * c) - 1;
      K3(this, s, h, c, k2, 0);
    }
    let b2 = 1, I2 = 0;
    for (this[h] = s & 255; ++I2 < c && (b2 *= 256); )
      this[h + I2] = s / b2 & 255;
    return h + c;
  }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(s, h, c, g) {
    if (s = +s, h = h >>> 0, c = c >>> 0, !g) {
      const k2 = Math.pow(2, 8 * c) - 1;
      K3(this, s, h, c, k2, 0);
    }
    let b2 = c - 1, I2 = 1;
    for (this[h + b2] = s & 255; --b2 >= 0 && (I2 *= 256); )
      this[h + b2] = s / I2 & 255;
    return h + c;
  }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 1, 255, 0), this[h] = s & 255, h + 1;
  }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 2, 65535, 0), this[h] = s & 255, this[h + 1] = s >>> 8, h + 2;
  }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 2, 65535, 0), this[h] = s >>> 8, this[h + 1] = s & 255, h + 2;
  }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 4, 4294967295, 0), this[h + 3] = s >>> 24, this[h + 2] = s >>> 16, this[h + 1] = s >>> 8, this[h] = s & 255, h + 4;
  }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 4, 4294967295, 0), this[h] = s >>> 24, this[h + 1] = s >>> 16, this[h + 2] = s >>> 8, this[h + 3] = s & 255, h + 4;
  };
  function it4(s, h, c, g, b2) {
    Ai3(h, g, b2, s, c, 7);
    let I2 = Number(h & BigInt(4294967295));
    s[c++] = I2, I2 = I2 >> 8, s[c++] = I2, I2 = I2 >> 8, s[c++] = I2, I2 = I2 >> 8, s[c++] = I2;
    let k2 = Number(h >> BigInt(32) & BigInt(4294967295));
    return s[c++] = k2, k2 = k2 >> 8, s[c++] = k2, k2 = k2 >> 8, s[c++] = k2, k2 = k2 >> 8, s[c++] = k2, c;
  }
  function lt3(s, h, c, g, b2) {
    Ai3(h, g, b2, s, c, 7);
    let I2 = Number(h & BigInt(4294967295));
    s[c + 7] = I2, I2 = I2 >> 8, s[c + 6] = I2, I2 = I2 >> 8, s[c + 5] = I2, I2 = I2 >> 8, s[c + 4] = I2;
    let k2 = Number(h >> BigInt(32) & BigInt(4294967295));
    return s[c + 3] = k2, k2 = k2 >> 8, s[c + 2] = k2, k2 = k2 >> 8, s[c + 1] = k2, k2 = k2 >> 8, s[c] = k2, c + 8;
  }
  f.prototype.writeBigUInt64LE = ne3(function(s, h = 0) {
    return it4(this, s, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeBigUInt64BE = ne3(function(s, h = 0) {
    return lt3(this, s, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeIntLE = function(s, h, c, g) {
    if (s = +s, h = h >>> 0, !g) {
      const ot5 = Math.pow(2, 8 * c - 1);
      K3(this, s, h, c, ot5 - 1, -ot5);
    }
    let b2 = 0, I2 = 1, k2 = 0;
    for (this[h] = s & 255; ++b2 < c && (I2 *= 256); )
      s < 0 && k2 === 0 && this[h + b2 - 1] !== 0 && (k2 = 1), this[h + b2] = (s / I2 >> 0) - k2 & 255;
    return h + c;
  }, f.prototype.writeIntBE = function(s, h, c, g) {
    if (s = +s, h = h >>> 0, !g) {
      const ot5 = Math.pow(2, 8 * c - 1);
      K3(this, s, h, c, ot5 - 1, -ot5);
    }
    let b2 = c - 1, I2 = 1, k2 = 0;
    for (this[h + b2] = s & 255; --b2 >= 0 && (I2 *= 256); )
      s < 0 && k2 === 0 && this[h + b2 + 1] !== 0 && (k2 = 1), this[h + b2] = (s / I2 >> 0) - k2 & 255;
    return h + c;
  }, f.prototype.writeInt8 = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 1, 127, -128), s < 0 && (s = 255 + s + 1), this[h] = s & 255, h + 1;
  }, f.prototype.writeInt16LE = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 2, 32767, -32768), this[h] = s & 255, this[h + 1] = s >>> 8, h + 2;
  }, f.prototype.writeInt16BE = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 2, 32767, -32768), this[h] = s >>> 8, this[h + 1] = s & 255, h + 2;
  }, f.prototype.writeInt32LE = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 4, 2147483647, -2147483648), this[h] = s & 255, this[h + 1] = s >>> 8, this[h + 2] = s >>> 16, this[h + 3] = s >>> 24, h + 4;
  }, f.prototype.writeInt32BE = function(s, h, c) {
    return s = +s, h = h >>> 0, c || K3(this, s, h, 4, 2147483647, -2147483648), s < 0 && (s = 4294967295 + s + 1), this[h] = s >>> 24, this[h + 1] = s >>> 16, this[h + 2] = s >>> 8, this[h + 3] = s & 255, h + 4;
  }, f.prototype.writeBigInt64LE = ne3(function(s, h = 0) {
    return it4(this, s, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), f.prototype.writeBigInt64BE = ne3(function(s, h = 0) {
    return lt3(this, s, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Nt5(s, h, c, g, b2, I2) {
    if (c + g > s.length) throw new RangeError("Index out of range");
    if (c < 0) throw new RangeError("Index out of range");
  }
  function st4(s, h, c, g, b2) {
    return h = +h, c = c >>> 0, b2 || Nt5(s, h, c, 4), r.write(s, h, c, g, 23, 4), c + 4;
  }
  f.prototype.writeFloatLE = function(s, h, c) {
    return st4(this, s, h, true, c);
  }, f.prototype.writeFloatBE = function(s, h, c) {
    return st4(this, s, h, false, c);
  };
  function yt5(s, h, c, g, b2) {
    return h = +h, c = c >>> 0, b2 || Nt5(s, h, c, 8), r.write(s, h, c, g, 52, 8), c + 8;
  }
  f.prototype.writeDoubleLE = function(s, h, c) {
    return yt5(this, s, h, true, c);
  }, f.prototype.writeDoubleBE = function(s, h, c) {
    return yt5(this, s, h, false, c);
  }, f.prototype.copy = function(s, h, c, g) {
    if (!f.isBuffer(s)) throw new TypeError("argument should be a Buffer");
    if (c || (c = 0), !g && g !== 0 && (g = this.length), h >= s.length && (h = s.length), h || (h = 0), g > 0 && g < c && (g = c), g === c || s.length === 0 || this.length === 0) return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (c < 0 || c >= this.length) throw new RangeError("Index out of range");
    if (g < 0) throw new RangeError("sourceEnd out of bounds");
    g > this.length && (g = this.length), s.length - h < g - c && (g = s.length - h + c);
    const b2 = g - c;
    return this === s && typeof o.prototype.copyWithin == "function" ? this.copyWithin(h, c, g) : o.prototype.set.call(
      s,
      this.subarray(c, g),
      h
    ), b2;
  }, f.prototype.fill = function(s, h, c, g) {
    if (typeof s == "string") {
      if (typeof h == "string" ? (g = h, h = 0, c = this.length) : typeof c == "string" && (g = c, c = this.length), g !== void 0 && typeof g != "string")
        throw new TypeError("encoding must be a string");
      if (typeof g == "string" && !f.isEncoding(g))
        throw new TypeError("Unknown encoding: " + g);
      if (s.length === 1) {
        const I2 = s.charCodeAt(0);
        (g === "utf8" && I2 < 128 || g === "latin1") && (s = I2);
      }
    } else typeof s == "number" ? s = s & 255 : typeof s == "boolean" && (s = Number(s));
    if (h < 0 || this.length < h || this.length < c)
      throw new RangeError("Out of range index");
    if (c <= h)
      return this;
    h = h >>> 0, c = c === void 0 ? this.length : c >>> 0, s || (s = 0);
    let b2;
    if (typeof s == "number")
      for (b2 = h; b2 < c; ++b2)
        this[b2] = s;
    else {
      const I2 = f.isBuffer(s) ? s : f.from(s, g), k2 = I2.length;
      if (k2 === 0)
        throw new TypeError('The value "' + s + '" is invalid for argument "value"');
      for (b2 = 0; b2 < c - h; ++b2)
        this[b2 + h] = I2[b2 % k2];
    }
    return this;
  };
  const Kt4 = {};
  function Re3(s, h, c) {
    Kt4[s] = class extends c {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: h.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${s}]`, this.stack, delete this.name;
      }
      get code() {
        return s;
      }
      set code(g) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: g,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${s}]: ${this.message}`;
      }
    };
  }
  Re3(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(s) {
      return s ? `${s} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Re3(
    "ERR_INVALID_ARG_TYPE",
    function(s, h) {
      return `The "${s}" argument must be of type number. Received type ${typeof h}`;
    },
    TypeError
  ), Re3(
    "ERR_OUT_OF_RANGE",
    function(s, h, c) {
      let g = `The value of "${s}" is out of range.`, b2 = c;
      return Number.isInteger(c) && Math.abs(c) > 2 ** 32 ? b2 = Ye5(String(c)) : typeof c == "bigint" && (b2 = String(c), (c > BigInt(2) ** BigInt(32) || c < -(BigInt(2) ** BigInt(32))) && (b2 = Ye5(b2)), b2 += "n"), g += ` It must be ${h}. Received ${b2}`, g;
    },
    RangeError
  );
  function Ye5(s) {
    let h = "", c = s.length;
    const g = s[0] === "-" ? 1 : 0;
    for (; c >= g + 4; c -= 3)
      h = `_${s.slice(c - 3, c)}${h}`;
    return `${s.slice(0, c)}${h}`;
  }
  function Ia2(s, h, c) {
    Ne4(h, "offset"), (s[h] === void 0 || s[h + c] === void 0) && Xe4(h, s.length - (c + 1));
  }
  function Ai3(s, h, c, g, b2, I2) {
    if (s > c || s < h) {
      const k2 = typeof h == "bigint" ? "n" : "";
      let ot5;
      throw h === 0 || h === BigInt(0) ? ot5 = `>= 0${k2} and < 2${k2} ** ${(I2 + 1) * 8}${k2}` : ot5 = `>= -(2${k2} ** ${(I2 + 1) * 8 - 1}${k2}) and < 2 ** ${(I2 + 1) * 8 - 1}${k2}`, new Kt4.ERR_OUT_OF_RANGE("value", ot5, s);
    }
    Ia2(g, b2, I2);
  }
  function Ne4(s, h) {
    if (typeof s != "number")
      throw new Kt4.ERR_INVALID_ARG_TYPE(h, "number", s);
  }
  function Xe4(s, h, c) {
    throw Math.floor(s) !== s ? (Ne4(s, c), new Kt4.ERR_OUT_OF_RANGE("offset", "an integer", s)) : h < 0 ? new Kt4.ERR_BUFFER_OUT_OF_BOUNDS() : new Kt4.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${h}`,
      s
    );
  }
  const va2 = /[^+/0-9A-Za-z-_]/g;
  function Aa2(s) {
    if (s = s.split("=")[0], s = s.trim().replace(va2, ""), s.length < 2) return "";
    for (; s.length % 4 !== 0; )
      s = s + "=";
    return s;
  }
  function yn2(s, h) {
    h = h || 1 / 0;
    let c;
    const g = s.length;
    let b2 = null;
    const I2 = [];
    for (let k2 = 0; k2 < g; ++k2) {
      if (c = s.charCodeAt(k2), c > 55295 && c < 57344) {
        if (!b2) {
          if (c > 56319) {
            (h -= 3) > -1 && I2.push(239, 191, 189);
            continue;
          } else if (k2 + 1 === g) {
            (h -= 3) > -1 && I2.push(239, 191, 189);
            continue;
          }
          b2 = c;
          continue;
        }
        if (c < 56320) {
          (h -= 3) > -1 && I2.push(239, 191, 189), b2 = c;
          continue;
        }
        c = (b2 - 55296 << 10 | c - 56320) + 65536;
      } else b2 && (h -= 3) > -1 && I2.push(239, 191, 189);
      if (b2 = null, c < 128) {
        if ((h -= 1) < 0) break;
        I2.push(c);
      } else if (c < 2048) {
        if ((h -= 2) < 0) break;
        I2.push(
          c >> 6 | 192,
          c & 63 | 128
        );
      } else if (c < 65536) {
        if ((h -= 3) < 0) break;
        I2.push(
          c >> 12 | 224,
          c >> 6 & 63 | 128,
          c & 63 | 128
        );
      } else if (c < 1114112) {
        if ((h -= 4) < 0) break;
        I2.push(
          c >> 18 | 240,
          c >> 12 & 63 | 128,
          c >> 6 & 63 | 128,
          c & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return I2;
  }
  function Sa2(s) {
    const h = [];
    for (let c = 0; c < s.length; ++c)
      h.push(s.charCodeAt(c) & 255);
    return h;
  }
  function Ta2(s, h) {
    let c, g, b2;
    const I2 = [];
    for (let k2 = 0; k2 < s.length && !((h -= 2) < 0); ++k2)
      c = s.charCodeAt(k2), g = c >> 8, b2 = c % 256, I2.push(b2), I2.push(g);
    return I2;
  }
  function Si3(s) {
    return t.toByteArray(Aa2(s));
  }
  function Sr2(s, h, c, g) {
    let b2;
    for (b2 = 0; b2 < g && !(b2 + c >= h.length || b2 >= s.length); ++b2)
      h[b2 + c] = s[b2];
    return b2;
  }
  function Ft5(s, h) {
    return s instanceof h || s != null && s.constructor != null && s.constructor.name != null && s.constructor.name === h.name;
  }
  function bn2(s) {
    return s !== s;
  }
  const ka2 = (function() {
    const s = "0123456789abcdef", h = new Array(256);
    for (let c = 0; c < 16; ++c) {
      const g = c * 16;
      for (let b2 = 0; b2 < 16; ++b2)
        h[g + b2] = s[c] + s[b2];
    }
    return h;
  })();
  function ne3(s) {
    return typeof BigInt > "u" ? Ua2 : s;
  }
  function Ua2() {
    throw new Error("BigInt not supported");
  }
})(Cs2);
var Eh2 = Cs2.Buffer;
function Ih2(e, t, r) {
  t = t || 4, r = r === void 0 ? true : r;
  const n = e.length;
  if (n === 0) return 0;
  if (n > t) throw new TypeError("Script number overflow");
  if (r && (e[n - 1] & 127) === 0 && (n <= 1 || (e[n - 2] & 128) === 0))
    throw new Error("Non-minimally encoded script number");
  if (n === 5) {
    const o = e.readUInt32LE(0), a = e.readUInt8(4);
    return a & 128 ? -((a & -129) * 4294967296 + o) : a * 4294967296 + o;
  }
  let i = 0;
  for (let o = 0; o < n; ++o)
    i |= e[o] << 8 * o;
  return e[n - 1] & 128 ? -(i & ~(128 << 8 * (n - 1))) : i;
}
function vh2(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function $s2(e) {
  let t = Math.abs(e);
  const r = vh2(t), n = Eh2.allocUnsafe(r), i = e < 0;
  for (let o = 0; o < r; ++o)
    n.writeUInt8(t & 255, o), t >>= 8;
  return n[r - 1] & 128 ? n.writeUInt8(i ? 128 : 0, r - 1) : i && (n[r - 1] = n[r - 1] | 128), n;
}
var Ah2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: Ih2,
  encode: $s2
}, Symbol.toStringTag, { value: "Module" }));
var Cn2 = Mt3("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
Mt3("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Oi2 = 21n * 10n ** 14n;
var Se3 = 254;
function Ks2(e) {
  return typeof e == "number" && Number.isInteger(e) && e >= 0 && e <= 255;
}
function Sh2(e) {
  return typeof e == "number" && Number.isFinite(e);
}
function Th2(e, t) {
  return e instanceof Uint8Array && e.length === t;
}
function ni2(e) {
  return Array.isArray(e);
}
function kh2(e) {
  return typeof e != "string" || e.length % 2 !== 0 ? false : /^[0-9a-fA-F]*$/.test(e);
}
function Uh2(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function Ds2(e) {
  return e instanceof Uint8Array && e.length === 20;
}
function xh2(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 || Ln2(e) ? false : Fe3(e, Cn2) < 0;
}
function xe3(e) {
  if (!(e instanceof Uint8Array) || e.length < 33) return false;
  const t = e[0], r = e.subarray(1, 33);
  if (Ln2(r) || Fe3(r, Cn2) >= 0) return false;
  if ((t === 2 || t === 3) && e.length === 33)
    return true;
  if (e.length !== 65) return false;
  const n = e.subarray(33);
  return Ln2(n) || Fe3(n, Cn2) >= 0 ? false : t === 4 || t === 6 || t === 7;
}
function Ms2(e) {
  if (!e || typeof e != "object") return false;
  const t = e;
  return !(!("output" in t) || !(t.output instanceof Uint8Array) || t.version !== void 0 && (typeof t.version != "number" || (t.version & Se3) !== t.version));
}
function Oe3(e, t) {
  return e.length !== t.length ? false : e.every((r, n) => P(r, t[n]));
}
function Pi2(e) {
  if (!Uh2(e))
    throw new TypeError(`Expected 32-byte Uint8Array, got ${e.length} bytes`);
  return e;
}
function Oh2(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function Nr2(e) {
  if (!Oh2(e))
    throw new TypeError(`Expected 32-byte Uint8Array, got ${e.length} bytes`);
  return e;
}
function Ph2(e) {
  if (!Ds2(e))
    throw new TypeError(`Expected 20-byte Uint8Array, got ${e.length} bytes`);
  return e;
}
function dp2(e) {
  if (e < 0n)
    throw new RangeError(`Satoshi cannot be negative, got ${e}`);
  if (e > Oi2)
    throw new RangeError(`Satoshi exceeds maximum supply (${Oi2}), got ${e}`);
  return e;
}
var Bi2 = new Uint8Array([0]);
function on2(e) {
  const t = e & -129;
  return t > 0 && t < 4;
}
function _i3(e) {
  let t = 0;
  for (; e[t] === 0; ) ++t;
  return t === e.length ? Bi2 : (e = e.subarray(t), e[0] & 128 ? _t7([Bi2, e]) : e);
}
function Ri2(e) {
  e[0] === 0 && (e = e.subarray(1));
  const t = Et4(32), r = Math.max(0, 32 - e.length);
  return t.set(e, r), t;
}
function Bh2(e) {
  const t = e[e.length - 1];
  if (!on2(t))
    throw new Error(`Invalid hashType ${t}`);
  const r = hh2(e.subarray(0, -1)), n = Ri2(r.r), i = Ri2(r.s);
  return { signature: _t7([n, i]), hashType: t };
}
function _h2(e, t) {
  if (!Th2(e, 64))
    throw new TypeError("Expected signature to be a 64-byte Uint8Array");
  if (!Ks2(t))
    throw new TypeError("Expected hashType to be a UInt8");
  if (!on2(t))
    throw new Error(`Invalid hashType ${t}`);
  const r = new Uint8Array([t]), n = _i3(e.subarray(0, 32)), i = _i3(e.subarray(32, 64));
  return _t7([uh2(n, i), r]);
}
var Rh2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: Bh2,
  encode: _h2,
  isDefinedHashType: on2
}, Symbol.toStringTag, { value: "Module" }));
var Fs2 = q2.OP_RESERVED;
function Nh2(e) {
  return Sh2(e) && (e === q2.OP_0 || e >= q2.OP_1 && e <= q2.OP_16 || e === q2.OP_1NEGATE);
}
function Ws2(e) {
  return e instanceof Uint8Array ? true : Nh2(e);
}
function an2(e) {
  return ni2(e) && e.every(Ws2);
}
function ii2(e) {
  return e.length - e.filter(Ws2).length;
}
function $r2(e) {
  if (e.length === 0) return q2.OP_0;
  if (e.length !== 1) return;
  const t = e[0];
  if (t >= 1 && t <= 16) return Fs2 + t;
  if (t === 129) return q2.OP_1NEGATE;
}
function si2(e) {
  return e instanceof Uint8Array;
}
function Hh2(e) {
  return ni2(e);
}
function Kr2(e) {
  return e instanceof Uint8Array;
}
function gt3(e) {
  if (si2(e)) return e;
  if (!ni2(e))
    throw new TypeError("Expected an array");
  const t = e.reduce((i, o) => Kr2(o) ? o.length === 1 && $r2(o) !== void 0 ? i + 1 : i + Ls2(o.length) + o.length : i + 1, 0), r = new Uint8Array(t);
  let n = 0;
  if (e.forEach((i) => {
    if (Kr2(i)) {
      const o = $r2(i);
      if (o !== void 0) {
        r[n] = o, n += 1;
        return;
      }
      n += fh2(r, i.length, n), r.set(i, n), n += i.length;
    } else
      r[n] = i, n += 1;
  }), n !== r.length) throw new Error("Could not decode chunks");
  return r;
}
function tt3(e) {
  if (Hh2(e)) return e;
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected a Uint8Array");
  const t = [];
  let r = 0;
  for (; r < e.length; ) {
    const n = e[r];
    if (n > q2.OP_0 && n <= q2.OP_PUSHDATA4) {
      const i = ch2(e, r);
      if (i === null || (r += i.size, r + i.number > e.length)) return null;
      const o = e.subarray(r, r + i.number);
      r += i.number;
      const a = $r2(o);
      a !== void 0 ? t.push(a) : t.push(o);
    } else
      t.push(n), r += 1;
  }
  return t;
}
function Gs2(e) {
  let t;
  if (si2(e)) {
    const r = tt3(e);
    if (!r)
      throw new Error("Could not convert invalid chunks to ASM");
    t = r;
  } else
    t = e;
  return t.map((r) => {
    if (Kr2(r)) {
      const n = $r2(r);
      if (n === void 0) return Yt4(r);
      r = n;
    }
    return Hs2()[r];
  }).join(" ");
}
function Lh2(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return gt3(
    e.split(" ").map((t) => {
      if (q2[t] !== void 0)
        return q2[t];
      if (!kh2(t))
        throw new TypeError("Expected hex string");
      return Mt3(t);
    })
  );
}
function js2(e) {
  const t = si2(e) ? tt3(e) : e;
  if (!t || !an2(t))
    throw new TypeError("Expected push-only script");
  return t.map((r) => Kr2(r) ? r : r === q2.OP_0 ? Et4(0) : $s2(r - Fs2));
}
function zs2(e) {
  return xe3(e);
}
function _e9(e) {
  return !(e instanceof Uint8Array) || !on2(e[e.length - 1]) ? false : ah2(e.subarray(0, -1));
}
var Ch2 = Ah2;
var Te4 = Rh2;
var Vh2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  compile: gt3,
  countNonPushOnlyOPs: ii2,
  decompile: tt3,
  fromASM: Lh2,
  isCanonicalPubKey: zs2,
  isCanonicalScriptSignature: _e9,
  isPushOnly: an2,
  number: Ch2,
  opcodes: q2,
  signature: Te4,
  toASM: Gs2,
  toStack: js2
}, Symbol.toStringTag, { value: "Module" }));
var ft4 = {
  P2PK: "p2pk",
  P2PKH: "p2pkh",
  P2SH: "p2sh",
  P2MS: "p2ms",
  P2WPKH: "p2wpkh",
  P2WSH: "p2wsh",
  P2TR: "p2tr",
  P2MR: "p2mr",
  P2OP: "p2op",
  Embed: "embed",
  ScriptRedeem: "scriptRedeem"
};
var Ni2 = q2;
var Hi2 = 16;
var Li2 = 2;
var Ci2 = 40;
var _a10, _t8, _a11, _e10, _s3, _r3, _n3, _i4, _o3, _h3, _f2, _u2, _c2, _p2, _l2, _d, _w, _g2, _y2, _m2, _er_instances, E_fn, I_fn, v_fn, b_fn, S_fn, A_fn, T_fn, k_fn;
var qs2 = (_a10 = class {
  /**
   * Creates a new P2OP payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded OPNet address
   * @param params.program - Witness program (2-40 bytes)
   * @param params.deploymentVersion - Deployment version (0-255)
   * @param params.hash160 - 20-byte hash
   * @param params.output - The scriptPubKey
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _er_instances);
    // Private instance fields
    __privateAdd(this, _t8);
    __privateAdd(this, _a11);
    // Input data (provided by user)
    __privateAdd(this, _e10);
    __privateAdd(this, _s3);
    __privateAdd(this, _r3);
    __privateAdd(this, _n3);
    __privateAdd(this, _i4);
    // Cached computed values
    __privateAdd(this, _o3);
    __privateAdd(this, _h3);
    __privateAdd(this, _f2);
    __privateAdd(this, _u2);
    __privateAdd(this, _c2);
    // Cache flags
    __privateAdd(this, _p2, false);
    __privateAdd(this, _l2, false);
    __privateAdd(this, _d, false);
    __privateAdd(this, _w, false);
    __privateAdd(this, _g2, false);
    // Decoded address cache
    __privateAdd(this, _y2);
    __privateAdd(this, _m2, false);
    __privateSet(this, _t8, t.network ?? kt3), __privateSet(this, _a11, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e10, t.address), __privateSet(this, _s3, t.program), __privateSet(this, _r3, t.deploymentVersion), __privateSet(this, _n3, t.hash160), __privateSet(this, _i4, t.output), __privateGet(this, _a11).validate && __privateMethod(this, _er_instances, k_fn).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ft4.P2OP;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t8);
  }
  /**
   * Bech32m encoded OPNet address.
   */
  get address() {
    return __privateGet(this, _p2) || (__privateSet(this, _o3, __privateMethod(this, _er_instances, v_fn).call(this)), __privateSet(this, _p2, true)), __privateGet(this, _o3);
  }
  /**
   * Witness program (2-40 bytes).
   * Format: `{deploymentVersion:uint8}{hash160:20-bytes|...}`
   */
  get program() {
    return __privateGet(this, _l2) || (__privateSet(this, _h3, __privateMethod(this, _er_instances, b_fn).call(this)), __privateSet(this, _l2, true)), __privateGet(this, _h3);
  }
  /**
   * Deployment version (first byte of program).
   */
  get deploymentVersion() {
    return __privateGet(this, _d) || (__privateSet(this, _f2, __privateMethod(this, _er_instances, S_fn).call(this)), __privateSet(this, _d, true)), __privateGet(this, _f2);
  }
  /**
   * Hash160 (remaining bytes of program).
   */
  get hash160() {
    return __privateGet(this, _w) || (__privateSet(this, _u2, __privateMethod(this, _er_instances, A_fn).call(this)), __privateSet(this, _w, true)), __privateGet(this, _u2);
  }
  /**
   * The scriptPubKey: `OP_16 {program}`
   */
  get output() {
    return __privateGet(this, _g2) || (__privateSet(this, _c2, __privateMethod(this, _er_instances, T_fn).call(this)), __privateSet(this, _g2, true)), __privateGet(this, _c2);
  }
  // Static factory methods
  /**
   * Creates a P2OP payment from a witness program.
   *
   * @param program - Witness program (2-40 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromProgram(t, r) {
    return new _a10({ program: t, network: r });
  }
  /**
   * Creates a P2OP payment from deployment version and hash160.
   *
   * @param deploymentVersion - Deployment version (0-255)
   * @param hash160 - 20-byte hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromParts(t, r, n) {
    return new _a10({ deploymentVersion: t, hash160: r, network: n });
  }
  /**
   * Creates a P2OP payment from an OPNet address.
   *
   * @param address - Bech32m encoded OPNet address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromAddress(t, r) {
    return new _a10({ address: t, network: r });
  }
  /**
   * Creates a P2OP payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromOutput(t, r) {
    return new _a10({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2OPPayment object for backwards compatibility.
   *
   * @returns A P2OPPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      program: this.program,
      deploymentVersion: this.deploymentVersion,
      hash160: this.hash160,
      output: this.output
    };
  }
}, _t8 = new WeakMap(), _a11 = new WeakMap(), _e10 = new WeakMap(), _s3 = new WeakMap(), _r3 = new WeakMap(), _n3 = new WeakMap(), _i4 = new WeakMap(), _o3 = new WeakMap(), _h3 = new WeakMap(), _f2 = new WeakMap(), _u2 = new WeakMap(), _c2 = new WeakMap(), _p2 = new WeakMap(), _l2 = new WeakMap(), _d = new WeakMap(), _w = new WeakMap(), _g2 = new WeakMap(), _y2 = new WeakMap(), _m2 = new WeakMap(), _er_instances = new WeakSet(), E_fn = function() {
  if (!__privateGet(this, _m2)) {
    if (__privateGet(this, _e10)) {
      const t = dr2(__privateGet(this, _e10));
      t && __privateSet(this, _y2, {
        version: t.version,
        prefix: t.prefix,
        data: t.data
      });
    }
    __privateSet(this, _m2, true);
  }
  return __privateGet(this, _y2);
}, // Private computation methods
I_fn = function() {
  if (typeof __privateGet(this, _r3) < "u" && typeof __privateGet(this, _n3) < "u") {
    if (__privateGet(this, _n3).length !== 20)
      throw new TypeError("hash160 must be exactly 20 bytes");
    if (__privateGet(this, _r3) < 0 || __privateGet(this, _r3) > 255)
      throw new TypeError("deploymentVersion must fit in one byte");
    return _t7([new Uint8Array([__privateGet(this, _r3)]), __privateGet(this, _n3)]);
  }
}, v_fn = function() {
  if (__privateGet(this, _e10))
    return __privateGet(this, _e10);
  const t = this.program;
  if (!t) return;
  if (!__privateGet(this, _t8).bech32Opnet)
    throw new TypeError("Network does not support opnet");
  const r = J2.bech32m.toWords(t);
  return r.unshift(Hi2), J2.bech32m.encode(__privateGet(this, _t8).bech32Opnet, r);
}, b_fn = function() {
  var _a37;
  if (__privateGet(this, _s3))
    return __privateGet(this, _s3);
  const t = __privateMethod(this, _er_instances, I_fn).call(this);
  if (t)
    return t;
  if (__privateGet(this, _i4)) {
    if (__privateGet(this, _i4)[0] !== Ni2.OP_16)
      throw new TypeError("Invalid P2OP script");
    let r = 1, n;
    const i = __privateGet(this, _i4)[1], o = __privateGet(this, _i4)[2];
    if (i !== void 0 && i < 76)
      n = i, r = 2;
    else if (i === 76 && o !== void 0)
      n = o, r = 3;
    else
      throw new TypeError("Unsupported push opcode in P2OP script");
    return __privateGet(this, _i4).subarray(r, r + n);
  }
  if (__privateGet(this, _e10))
    return (_a37 = __privateMethod(this, _er_instances, E_fn).call(this)) == null ? void 0 : _a37.data;
}, S_fn = function() {
  if (__privateGet(this, _r3) !== void 0)
    return __privateGet(this, _r3);
  const t = this.program;
  if (t)
    return t[0];
}, A_fn = function() {
  if (__privateGet(this, _n3))
    return __privateGet(this, _n3);
  const t = this.program;
  if (t)
    return t.subarray(1);
}, // Validation
T_fn = function() {
  if (__privateGet(this, _i4))
    return __privateGet(this, _i4);
  const t = this.program;
  if (t)
    return gt3([Ni2.OP_16, t]);
}, k_fn = function() {
  let t = Et4(0);
  if (__privateGet(this, _e10)) {
    const r = __privateMethod(this, _er_instances, E_fn).call(this);
    if (!r)
      throw new TypeError("Invalid address");
    if (__privateGet(this, _t8).bech32Opnet !== r.prefix)
      throw new TypeError("Invalid prefix or network mismatch");
    if (r.version !== Hi2)
      throw new TypeError("Invalid witness version for p2op");
    if (r.data.length < Li2 || r.data.length > Ci2)
      throw new TypeError("Invalid witness program length");
    t = r.data;
  }
  if (__privateGet(this, _s3)) {
    if (t.length > 0 && !P(t, __privateGet(this, _s3)))
      throw new TypeError("Program mismatch");
    t = __privateGet(this, _s3);
  }
  if (!t.length && __privateGet(this, _r3) !== void 0 && __privateGet(this, _n3)) {
    const r = __privateMethod(this, _er_instances, I_fn).call(this);
    r && (t = r);
  }
  if (__privateGet(this, _i4)) {
    const r = this.program;
    if (!r)
      throw new TypeError("Output program is required");
    if (t.length > 0 && !P(t, r))
      throw new TypeError("Program mismatch (output vs other source)");
    t = r;
  }
  if (t.length < Li2 || t.length > Ci2)
    throw new TypeError(`Witness program must be 240 bytes. Was ${t.length} bytes`);
  if (__privateGet(this, _r3) !== void 0 && __privateGet(this, _r3) !== t[0])
    throw new TypeError("deploymentVersion mismatch");
  if (__privateGet(this, _n3) && !P(__privateGet(this, _n3), t.subarray(1)))
    throw new TypeError("hash160 mismatch");
}, // Static public fields
__publicField(_a10, "NAME", ft4.P2OP), _a10);
function Ys2(e, t) {
  if (!e.address && !e.output && !e.program && (typeof e.deploymentVersion > "u" || !e.hash160))
    throw new TypeError("At least one of address, output or program must be provided");
  const r = new qs2(
    {
      address: e.address,
      program: e.program,
      deploymentVersion: e.deploymentVersion,
      hash160: e.hash160,
      output: e.output,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
var Ze4 = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var oe3 = new Uint32Array(80);
var $h2 = class extends Qn2 {
  constructor() {
    super(64, 20, 8, false);
    __publicField(this, "A", Ze4[0] | 0);
    __publicField(this, "B", Ze4[1] | 0);
    __publicField(this, "C", Ze4[2] | 0);
    __publicField(this, "D", Ze4[3] | 0);
    __publicField(this, "E", Ze4[4] | 0);
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o } = this;
    return [t, r, n, i, o];
  }
  set(t, r, n, i, o) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0;
  }
  process(t, r) {
    for (let l = 0; l < 16; l++, r += 4)
      oe3[l] = t.getUint32(r, false);
    for (let l = 16; l < 80; l++)
      oe3[l] = Ee4(oe3[l - 3] ^ oe3[l - 8] ^ oe3[l - 14] ^ oe3[l - 16], 1);
    let { A: n, B: i, C: o, D: a, E: u } = this;
    for (let l = 0; l < 80; l++) {
      let d, f;
      l < 20 ? (d = Rs2(i, o, a), f = 1518500249) : l < 40 ? (d = i ^ o ^ a, f = 1859775393) : l < 60 ? (d = Ns2(i, o, a), f = 2400959708) : (d = i ^ o ^ a, f = 3395469782);
      const p = Ee4(n, 5) + d + u + f + oe3[l] | 0;
      u = a, a = o, o = Ee4(i, 30), i = n, n = p;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, u = u + this.E | 0, this.set(n, i, o, a, u);
  }
  roundClean() {
    Ue4(oe3);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), Ue4(this.buffer);
  }
};
var Kh2 = Zn2(() => new $h2());
var Dh2 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Xs2 = Uint8Array.from(new Array(16).fill(0).map((e, t) => t));
var Mh2 = Xs2.map((e) => (9 * e + 5) % 16);
var Zs2 = (() => {
  const e = [[Xs2], [Mh2]];
  for (let t = 0; t < 4; t++)
    for (let r of e)
      r.push(r[t].map((n) => Dh2[n]));
  return e;
})();
var Qs2 = Zs2[0];
var Js2 = Zs2[1];
var to2 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => Uint8Array.from(e));
var Fh2 = Qs2.map((e, t) => e.map((r) => to2[t][r]));
var Wh2 = Js2.map((e, t) => e.map((r) => to2[t][r]));
var Gh2 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var jh2 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function Vi2(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
var kr2 = new Uint32Array(16);
var zh2 = class extends Qn2 {
  constructor() {
    super(64, 20, 8, true);
    __publicField(this, "h0", 1732584193);
    __publicField(this, "h1", -271733879);
    __publicField(this, "h2", -1732584194);
    __publicField(this, "h3", 271733878);
    __publicField(this, "h4", -1009589776);
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
    return [t, r, n, i, o];
  }
  set(t, r, n, i, o) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
  }
  process(t, r) {
    for (let y = 0; y < 16; y++, r += 4)
      kr2[y] = t.getUint32(r, true);
    let n = this.h0 | 0, i = n, o = this.h1 | 0, a = o, u = this.h2 | 0, l = u, d = this.h3 | 0, f = d, p = this.h4 | 0, w = p;
    for (let y = 0; y < 5; y++) {
      const m = 4 - y, E2 = Gh2[y], v = jh2[y], x = Qs2[y], O = Js2[y], T = Fh2[y], _ = Wh2[y];
      for (let M2 = 0; M2 < 16; M2++) {
        const nt5 = Ee4(n + Vi2(y, o, u, d) + kr2[x[M2]] + E2, T[M2]) + p | 0;
        n = p, p = d, d = Ee4(u, 10) | 0, u = o, o = nt5;
      }
      for (let M2 = 0; M2 < 16; M2++) {
        const nt5 = Ee4(i + Vi2(m, a, l, f) + kr2[O[M2]] + v, _[M2]) + w | 0;
        i = w, w = f, f = Ee4(l, 10) | 0, l = a, a = nt5;
      }
    }
    this.set(this.h1 + u + f | 0, this.h2 + d + w | 0, this.h3 + p + i | 0, this.h4 + n + a | 0, this.h0 + o + l | 0);
  }
  roundClean() {
    Ue4(kr2);
  }
  destroy() {
    this.destroyed = true, Ue4(this.buffer), this.set(0, 0, 0, 0, 0);
  }
};
var eo2 = Zn2(() => new zh2());
function qh2(e) {
  return eo2(e);
}
function Yh2(e) {
  return Kh2(e);
}
function vt4(e) {
  return Me4(e);
}
function St3(e) {
  return eo2(Me4(e));
}
function ce3(e) {
  return Me4(Me4(e));
}
var Xh2 = [
  "BIP0340/challenge",
  "BIP0340/aux",
  "BIP0340/nonce",
  "TapLeaf",
  "TapBranch",
  "TapSighash",
  "TapTweak",
  "KeyAgg list",
  "KeyAgg coefficient"
];
var ro2 = {
  "BIP0340/challenge": new Uint8Array([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": new Uint8Array([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": new Uint8Array([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: new Uint8Array([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: new Uint8Array([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: new Uint8Array([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: new Uint8Array([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": new Uint8Array([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": new Uint8Array([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function wr2(e, t) {
  return vt4(_t7([ro2[e], t]));
}
var Zh2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  TAGGED_HASH_PREFIXES: ro2,
  TAGS: Xh2,
  hash160: St3,
  hash256: ce3,
  ripemd160: qh2,
  sha1: Yh2,
  sha256: vt4,
  taggedHash: wr2
}, Symbol.toStringTag, { value: "Module" }));
var no2 = {
  p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
  n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,
  h: 1n,
  a: 0n,
  b: 7n,
  Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
  Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
};
var { p: ke2, n: Qh2, Gx: Jh2, Gy: tu2, b: io2 } = no2;
var Vn2 = 32;
var oi2 = 64;
var eu2 = {
  publicKey: Vn2 + 1,
  publicKeyUncompressed: oi2 + 1
};
var ru2 = (...e) => {
  "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(...e);
};
var Bt4 = (e = "") => {
  const t = new Error(e);
  throw ru2(t, Bt4), t;
};
var nu2 = (e) => typeof e == "bigint";
var iu2 = (e) => typeof e == "string";
var su = (e) => e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
var ai2 = (e, t, r = "") => {
  const n = su(e), i = e == null ? void 0 : e.length;
  if (!n || t !== void 0) {
    const a = r && `"${r}" `, u = "", l = n ? `length=${i}` : `type=${typeof e}`;
    Bt4(a + "expected Uint8Array" + u + ", got " + l);
  }
  return e;
};
var so2 = (e) => new Uint8Array(e);
var oo2 = (e, t) => e.toString(16).padStart(t, "0");
var ao2 = (e) => Array.from(ai2(e)).map((t) => oo2(t, 2)).join("");
var Jt4 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
var $i2 = (e) => {
  if (e >= Jt4._0 && e <= Jt4._9)
    return e - Jt4._0;
  if (e >= Jt4.A && e <= Jt4.F)
    return e - (Jt4.A - 10);
  if (e >= Jt4.a && e <= Jt4.f)
    return e - (Jt4.a - 10);
};
var ho2 = (e) => {
  const t = "hex invalid";
  if (!iu2(e))
    return Bt4(t);
  const r = e.length, n = r / 2;
  if (r % 2)
    return Bt4(t);
  const i = so2(n);
  for (let o = 0, a = 0; o < n; o++, a += 2) {
    const u = $i2(e.charCodeAt(a)), l = $i2(e.charCodeAt(a + 1));
    if (u === void 0 || l === void 0)
      return Bt4(t);
    i[o] = u * 16 + l;
  }
  return i;
};
var Ki2 = (...e) => {
  const t = so2(e.reduce((n, i) => n + ai2(i).length, 0));
  let r = 0;
  return e.forEach((n) => {
    t.set(n, r), r += n.length;
  }), t;
};
var Dr = BigInt;
var hn2 = (e, t, r, n = "bad number: out of range") => nu2(e) && t <= e && e < r ? e : Bt4(n);
var N2 = (e, t = ke2) => {
  const r = e % t;
  return r >= 0n ? r : t + r;
};
var ou2 = (e, t) => {
  (e === 0n || t <= 0n) && Bt4("no inverse n=" + e + " mod=" + t);
  let r = N2(e, t), n = t, i = 0n, o = 1n;
  for (; r !== 0n; ) {
    const a = n / r, u = n % r, l = i - o * a;
    n = r, r = u, i = o, o = l;
  }
  return n === 1n ? N2(i, t) : Bt4("no inverse");
};
var vn2 = (e) => e instanceof qe3 ? e : Bt4("Point expected");
var uo2 = (e) => N2(N2(e * e) * e + io2);
var Di2 = (e) => hn2(e, 0n, ke2);
var Hr2 = (e) => hn2(e, 1n, ke2);
var au2 = (e) => hn2(e, 1n, Qh2);
var $n2 = (e) => (e & 1n) === 0n;
var fo2 = (e) => Uint8Array.of(e);
var hu2 = (e) => fo2($n2(e) ? 2 : 3);
var uu2 = (e) => {
  const t = uo2(Hr2(e));
  let r = 1n;
  for (let n = t, i = (ke2 + 1n) / 4n; i > 0n; i >>= 1n)
    i & 1n && (r = r * n % ke2), n = n * n % ke2;
  return N2(r * r) === t ? r : Bt4("sqrt invalid");
};
var _a12;
var qe3 = (_a12 = class {
  constructor(t, r, n) {
    __publicField(this, "X");
    __publicField(this, "Y");
    __publicField(this, "Z");
    this.X = Di2(t), this.Y = Hr2(r), this.Z = Di2(n), Object.freeze(this);
  }
  static CURVE() {
    return no2;
  }
  /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */
  static fromAffine(t) {
    const { x: r, y: n } = t;
    return r === 0n && n === 0n ? me3 : new _a12(r, n, 1n);
  }
  /** Convert Uint8Array or hex string to Point. */
  static fromBytes(t) {
    ai2(t);
    const { publicKey: r, publicKeyUncompressed: n } = eu2;
    let i;
    const o = t.length, a = t[0], u = t.subarray(1), l = Mi2(u, 0, Vn2);
    if (o === r && (a === 2 || a === 3)) {
      let d = uu2(l);
      const f = $n2(d);
      $n2(Dr(a)) !== f && (d = N2(-d)), i = new _a12(l, d, 1n);
    }
    return o === n && a === 4 && (i = new _a12(l, Mi2(u, Vn2, oi2), 1n)), i ? i.assertValidity() : Bt4("bad point: not on curve");
  }
  static fromHex(t) {
    return _a12.fromBytes(ho2(t));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  /** Equality check: compare points P&Q. */
  equals(t) {
    const { X: r, Y: n, Z: i } = this, { X: o, Y: a, Z: u } = vn2(t), l = N2(r * u), d = N2(o * i), f = N2(n * u), p = N2(a * i);
    return l === d && f === p;
  }
  is0() {
    return this.equals(me3);
  }
  /** Flip point over y coordinate. */
  negate() {
    return new _a12(this.X, N2(-this.Y), this.Z);
  }
  /** Point doubling: P+P, complete formula. */
  double() {
    return this.add(this);
  }
  /**
   * Point addition: P+Q, complete, exception-free formula
   * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).
   * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.
   */
  // prettier-ignore
  add(t) {
    const { X: r, Y: n, Z: i } = this, { X: o, Y: a, Z: u } = vn2(t), l = 0n, d = io2;
    let f = 0n, p = 0n, w = 0n;
    const y = N2(d * 3n);
    let m = N2(r * o), E2 = N2(n * a), v = N2(i * u), x = N2(r + n), O = N2(o + a);
    x = N2(x * O), O = N2(m + E2), x = N2(x - O), O = N2(r + i);
    let T = N2(o + u);
    return O = N2(O * T), T = N2(m + v), O = N2(O - T), T = N2(n + i), f = N2(a + u), T = N2(T * f), f = N2(E2 + v), T = N2(T - f), w = N2(l * O), f = N2(y * v), w = N2(f + w), f = N2(E2 - w), w = N2(E2 + w), p = N2(f * w), E2 = N2(m + m), E2 = N2(E2 + m), v = N2(l * v), O = N2(y * O), E2 = N2(E2 + v), v = N2(m - v), v = N2(l * v), O = N2(O + v), m = N2(E2 * O), p = N2(p + m), m = N2(T * O), f = N2(x * f), f = N2(f - m), m = N2(x * E2), w = N2(T * w), w = N2(w + m), new _a12(f, p, w);
  }
  subtract(t) {
    return this.add(vn2(t).negate());
  }
  /**
   * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
   * Uses {@link wNAF} for base point.
   * Uses fake point to mitigate side-channel leakage.
   * @param n scalar by which point is multiplied
   * @param safe safe mode guards against timing attacks; unsafe mode is faster
   */
  multiply(t, r = true) {
    if (!r && t === 0n)
      return me3;
    if (au2(t), t === 1n)
      return this;
    if (this.equals(ur))
      return du2(t).p;
    let n = me3, i = ur;
    for (let o = this; t > 0n; o = o.double(), t >>= 1n)
      t & 1n ? n = n.add(o) : r && (i = i.add(o));
    return n;
  }
  multiplyUnsafe(t) {
    return this.multiply(t, false);
  }
  /** Convert point to 2d xy affine point. (X, Y, Z)  (x=X/Z, y=Y/Z) */
  toAffine() {
    const { X: t, Y: r, Z: n } = this;
    if (this.equals(me3))
      return { x: 0n, y: 0n };
    if (n === 1n)
      return { x: t, y: r };
    const i = ou2(n, ke2);
    return N2(n * i) !== 1n && Bt4("inverse invalid"), { x: N2(t * i), y: N2(r * i) };
  }
  /** Checks if the point is valid and on-curve. */
  assertValidity() {
    const { x: t, y: r } = this.toAffine();
    return Hr2(t), Hr2(r), N2(r * r) === uo2(t) ? this : Bt4("bad point: not on curve");
  }
  /** Converts point to 33/65-byte Uint8Array. */
  toBytes(t = true) {
    const { x: r, y: n } = this.assertValidity().toAffine(), i = Fi2(r);
    return t ? Ki2(hu2(n), i) : Ki2(fo2(4), i, Fi2(n));
  }
  toHex(t) {
    return ao2(this.toBytes(t));
  }
}, __publicField(_a12, "BASE"), __publicField(_a12, "ZERO"), _a12);
var ur = new qe3(Jh2, tu2, 1n);
var me3 = new qe3(0n, 1n, 0n);
qe3.BASE = ur;
qe3.ZERO = me3;
var fu2 = (e) => Dr("0x" + (ao2(e) || "0"));
var Mi2 = (e, t, r) => fu2(e.subarray(t, r));
var cu2 = 2n ** 256n;
var Fi2 = (e) => ho2(oo2(hn2(e, 0n, cu2), oi2));
var Mr2 = 8;
var lu2 = 256;
var co2 = Math.ceil(lu2 / Mr2) + 1;
var Kn2 = 2 ** (Mr2 - 1);
var pu2 = () => {
  const e = [];
  let t = ur, r = t;
  for (let n = 0; n < co2; n++) {
    r = t, e.push(r);
    for (let i = 1; i < Kn2; i++)
      r = r.add(t), e.push(r);
    t = r.double();
  }
  return e;
};
var Wi2;
var Gi2 = (e, t) => {
  const r = t.negate();
  return e ? r : t;
};
var du2 = (e) => {
  const t = Wi2 || (Wi2 = pu2());
  let r = me3, n = ur;
  const i = 2 ** Mr2, o = i, a = Dr(i - 1), u = Dr(Mr2);
  for (let l = 0; l < co2; l++) {
    let d = Number(e & a);
    e >>= u, d > Kn2 && (d -= o, e += 1n);
    const f = l * Kn2, p = f, w = f + Math.abs(d) - 1, y = l % 2 !== 0, m = d < 0;
    d === 0 ? n = n.add(Gi2(y, t[p])) : r = r.add(Gi2(m, t[w]));
  }
  return e !== 0n && Bt4("invalid wnaf"), { p: r, f: n };
};
var $e4 = (e) => e.length === 32 ? e : e.subarray(1, 33);
function ji2(e) {
  let t = e.toString(16);
  return t = t.padStart(64, "0"), t.length > 64 && (t = t.slice(-64)), Mt3(t);
}
function Dn2(e) {
  if (e.length === 32)
    return;
  if (![33, 65].includes(e.length)) {
    console.warn(
      `Unsupported key length=${e.length}. Must be 33 (compressed) or 65 (uncompressed).`
    );
    return;
  }
  let t;
  try {
    t = qe3.fromHex(Yt4(e));
  } catch (u) {
    throw new Error("Invalid secp256k1 public key bytes. Cannot parse.", { cause: u });
  }
  const r = ji2(t.x), n = ji2(t.y), i = t.y % 2n === 0n ? 6 : 7, o = Et4(65);
  o[0] = i, o.set(r, 1), o.set(n, 33);
  const a = _t7([new Uint8Array([4]), r, n]);
  return {
    hybrid: o,
    uncompressed: a
  };
}
function Ur2(e, t) {
  if (P(e, t)) return true;
  if (e.length === 65 && t.length === 65) {
    const r = new Uint8Array(e), n = new Uint8Array(t);
    return (r[0] === 6 || r[0] === 7) && (r[0] = 4), (n[0] === 6 || n[0] === 7) && (n[0] = 4), P(r, n);
  }
  return false;
}
var ae2 = q2;
var _a13, _t9, _a14, _e11, _s4, _r4, _n4, _i5, _o4, _h4, _f3, _u3, _c3, _p3, _l3, _d2, _w2, _g3, _y3, _m3, _E, _I, _v, _b2, _S, _A, _T, _k, _O, _rr_instances, U_fn, x_fn, P_fn, B_fn, __fn, R_fn, N_fn, H_fn, L_fn, C_fn;
var lo2 = (_a13 = class {
  /**
   * Creates a new P2PKH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Base58Check encoded address
   * @param params.hash - 20-byte pubkey hash (RIPEMD160(SHA256(pubkey)))
   * @param params.pubkey - The public key (33 or 65 bytes)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _rr_instances);
    // Private instance fields
    __privateAdd(this, _t9);
    __privateAdd(this, _a14);
    // Input data (provided by user)
    __privateAdd(this, _e11);
    __privateAdd(this, _s4);
    __privateAdd(this, _r4);
    __privateAdd(this, _n4);
    __privateAdd(this, _i5);
    __privateAdd(this, _o4);
    // Hybrid/uncompressed key flags
    __privateAdd(this, _h4, false);
    __privateAdd(this, _f3, false);
    // Cached computed values
    __privateAdd(this, _u3);
    __privateAdd(this, _c3);
    __privateAdd(this, _p3);
    __privateAdd(this, _l3);
    __privateAdd(this, _d2);
    __privateAdd(this, _w2);
    __privateAdd(this, _g3);
    // Cache flags
    __privateAdd(this, _y3, false);
    __privateAdd(this, _m3, false);
    __privateAdd(this, _E, false);
    __privateAdd(this, _I, false);
    __privateAdd(this, _v, false);
    __privateAdd(this, _b2, false);
    __privateAdd(this, _S, false);
    // Decoded address cache
    __privateAdd(this, _A);
    __privateAdd(this, _T, false);
    // Decoded input chunks cache
    __privateAdd(this, _k);
    __privateAdd(this, _O, false);
    __privateSet(this, _t9, t.network ?? kt3), __privateSet(this, _a14, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e11, t.address), __privateSet(this, _s4, t.hash), __privateSet(this, _r4, t.pubkey), __privateSet(this, _n4, t.signature), __privateSet(this, _i5, t.output), __privateSet(this, _o4, t.input), __privateSet(this, _h4, t.useHybrid ?? false), __privateSet(this, _f3, t.useUncompressed ?? false), __privateGet(this, _a14).validate && __privateMethod(this, _rr_instances, C_fn).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ft4.P2PKH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t9);
  }
  /**
   * Base58Check encoded Bitcoin address.
   */
  get address() {
    return __privateGet(this, _y3) || (__privateSet(this, _u3, __privateMethod(this, _rr_instances, P_fn).call(this)), __privateSet(this, _y3, true)), __privateGet(this, _u3);
  }
  /**
   * 20-byte pubkey hash (RIPEMD160(SHA256(pubkey))).
   */
  get hash() {
    return __privateGet(this, _m3) || (__privateSet(this, _c3, __privateMethod(this, _rr_instances, B_fn).call(this)), __privateSet(this, _m3, true)), __privateGet(this, _c3);
  }
  /**
   * The public key (33 or 65 bytes).
   */
  get pubkey() {
    return __privateGet(this, _E) || (__privateSet(this, _p3, __privateMethod(this, _rr_instances, __fn).call(this)), __privateSet(this, _E, true)), __privateGet(this, _p3);
  }
  /**
   * The DER-encoded signature.
   */
  get signature() {
    return __privateGet(this, _I) || (__privateSet(this, _l3, __privateMethod(this, _rr_instances, R_fn).call(this)), __privateSet(this, _I, true)), __privateGet(this, _l3);
  }
  /**
   * The scriptPubKey:
   * `OP_DUP OP_HASH160 {hash} OP_EQUALVERIFY OP_CHECKSIG`
   */
  get output() {
    return __privateGet(this, _v) || (__privateSet(this, _d2, __privateMethod(this, _rr_instances, N_fn).call(this)), __privateSet(this, _v, true)), __privateGet(this, _d2);
  }
  /**
   * The scriptSig: `{signature} {pubkey}`
   */
  get input() {
    return __privateGet(this, _b2) || (__privateSet(this, _w2, __privateMethod(this, _rr_instances, H_fn).call(this)), __privateSet(this, _b2, true)), __privateGet(this, _w2);
  }
  /**
   * Witness stack (empty for P2PKH as it's not a SegWit type).
   */
  get witness() {
    return __privateGet(this, _S) || (__privateSet(this, _g3, __privateMethod(this, _rr_instances, L_fn).call(this)), __privateSet(this, _S, true)), __privateGet(this, _g3);
  }
  // Static factory methods
  /**
   * Creates a P2PKH payment from a public key.
   *
   * @param pubkey - The public key (33 or 65 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromPubkey(pubkey);
   * const address = payment.address;
   * ```
   */
  static fromPubkey(t, r) {
    return new _a13({ pubkey: t, network: r });
  }
  /**
   * Creates a P2PKH payment from a Base58Check address.
   *
   * @param address - Base58Check encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromAddress('1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2');
   * const hash = payment.hash;
   * ```
   */
  static fromAddress(t, r) {
    return new _a13({ address: t, network: r });
  }
  /**
   * Creates a P2PKH payment from a 20-byte pubkey hash.
   *
   * @param hash - 20-byte pubkey hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromHash(hash160);
   * const address = payment.address;
   * ```
   */
  static fromHash(t, r) {
    return new _a13({ hash: t, network: r });
  }
  /**
   * Creates a P2PKH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   */
  static fromOutput(t, r) {
    return new _a13({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2PKHPayment object for backwards compatibility.
   *
   * @returns A P2PKHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
}, _t9 = new WeakMap(), _a14 = new WeakMap(), _e11 = new WeakMap(), _s4 = new WeakMap(), _r4 = new WeakMap(), _n4 = new WeakMap(), _i5 = new WeakMap(), _o4 = new WeakMap(), _h4 = new WeakMap(), _f3 = new WeakMap(), _u3 = new WeakMap(), _c3 = new WeakMap(), _p3 = new WeakMap(), _l3 = new WeakMap(), _d2 = new WeakMap(), _w2 = new WeakMap(), _g3 = new WeakMap(), _y3 = new WeakMap(), _m3 = new WeakMap(), _E = new WeakMap(), _I = new WeakMap(), _v = new WeakMap(), _b2 = new WeakMap(), _S = new WeakMap(), _A = new WeakMap(), _T = new WeakMap(), _k = new WeakMap(), _O = new WeakMap(), _rr_instances = new WeakSet(), U_fn = function() {
  if (!__privateGet(this, _T)) {
    if (__privateGet(this, _e11)) {
      const t = new Uint8Array(ti2(__privateGet(this, _e11)));
      __privateSet(this, _A, {
        version: t[0],
        hash: t.subarray(1)
      });
    }
    __privateSet(this, _T, true);
  }
  return __privateGet(this, _A);
}, // Private computation methods
x_fn = function() {
  return __privateGet(this, _O) || (__privateGet(this, _o4) && __privateSet(this, _k, tt3(__privateGet(this, _o4)) ?? void 0), __privateSet(this, _O, true)), __privateGet(this, _k);
}, P_fn = function() {
  if (__privateGet(this, _e11))
    return __privateGet(this, _e11);
  const t = this.hash;
  if (!t) return;
  const r = Et4(21);
  return r[0] = __privateGet(this, _t9).pubKeyHash, r.set(t, 1), Jn2(r);
}, B_fn = function() {
  var _a37;
  if (__privateGet(this, _s4))
    return __privateGet(this, _s4);
  if (__privateGet(this, _i5))
    return __privateGet(this, _i5).subarray(3, 23);
  if (__privateGet(this, _e11))
    return (_a37 = __privateMethod(this, _rr_instances, U_fn).call(this)) == null ? void 0 : _a37.hash;
  const t = this.pubkey;
  if (t)
    return St3(t);
}, __fn = function() {
  if (__privateGet(this, _r4))
    return __privateGet(this, _r4);
  if (__privateGet(this, _o4)) {
    const t = __privateMethod(this, _rr_instances, x_fn).call(this);
    if (t && t.length >= 2)
      return t[1];
  }
}, R_fn = function() {
  if (__privateGet(this, _n4))
    return __privateGet(this, _n4);
  if (__privateGet(this, _o4)) {
    const t = __privateMethod(this, _rr_instances, x_fn).call(this);
    if (t && t.length >= 1)
      return t[0];
  }
}, N_fn = function() {
  if (__privateGet(this, _i5))
    return __privateGet(this, _i5);
  const t = this.hash;
  if (t)
    return gt3([
      ae2.OP_DUP,
      ae2.OP_HASH160,
      t,
      ae2.OP_EQUALVERIFY,
      ae2.OP_CHECKSIG
    ]);
}, H_fn = function() {
  if (__privateGet(this, _o4))
    return __privateGet(this, _o4);
  if (!__privateGet(this, _r4) || !__privateGet(this, _n4))
    return;
  let t = __privateGet(this, _r4);
  if (__privateGet(this, _h4) || __privateGet(this, _f3)) {
    const r = Dn2(__privateGet(this, _r4));
    r && (__privateGet(this, _f3) ? t = r.uncompressed : t = r.hybrid);
  }
  return gt3([__privateGet(this, _n4), t]);
}, // Validation
L_fn = function() {
  if (this.input)
    return [];
}, C_fn = function() {
  let t = new Uint8Array(0);
  if (__privateGet(this, _e11)) {
    const r = __privateMethod(this, _rr_instances, U_fn).call(this);
    if (!r)
      throw new TypeError("Invalid address");
    if (r.version !== __privateGet(this, _t9).pubKeyHash)
      throw new TypeError("Invalid version or Network mismatch");
    if (r.hash.length !== 20)
      throw new TypeError("Invalid address");
    t = r.hash;
  }
  if (__privateGet(this, _s4)) {
    if (t.length > 0 && !P(t, __privateGet(this, _s4)))
      throw new TypeError("Hash mismatch");
    t = __privateGet(this, _s4);
  }
  if (__privateGet(this, _i5)) {
    if (__privateGet(this, _i5).length !== 25 || __privateGet(this, _i5)[0] !== ae2.OP_DUP || __privateGet(this, _i5)[1] !== ae2.OP_HASH160 || __privateGet(this, _i5)[2] !== 20 || __privateGet(this, _i5)[23] !== ae2.OP_EQUALVERIFY || __privateGet(this, _i5)[24] !== ae2.OP_CHECKSIG)
      throw new TypeError("Output is invalid");
    const r = __privateGet(this, _i5).subarray(3, 23);
    if (t.length > 0 && !P(t, r))
      throw new TypeError("Hash mismatch");
    t = r;
  }
  if (__privateGet(this, _r4)) {
    const r = St3(__privateGet(this, _r4));
    let n = t.length > 0 && !P(t, r);
    if (n && (__privateGet(this, _r4).length === 33 && (__privateGet(this, _r4)[0] === 2 || __privateGet(this, _r4)[0] === 3) || __privateGet(this, _r4).length === 65 && __privateGet(this, _r4)[0] === 4)) {
      const i = Dn2(__privateGet(this, _r4));
      if (i) {
        const o = St3(i.uncompressed);
        if (P(t, o))
          n = false, __privateSet(this, _f3, true);
        else {
          const a = St3(i.hybrid);
          n = !P(t, a), n || __privateSet(this, _h4, true);
        }
      }
    }
    if (n)
      throw new TypeError("Hash mismatch");
    t = r;
  }
  if (__privateGet(this, _o4)) {
    const r = __privateMethod(this, _rr_instances, x_fn).call(this);
    if (!r || r.length !== 2)
      throw new TypeError("Input is invalid");
    if (!_e9(r[0]))
      throw new TypeError("Input has invalid signature");
    if (!xe3(r[1]))
      throw new TypeError("Input has invalid pubkey");
    if (__privateGet(this, _n4) && !P(__privateGet(this, _n4), r[0]))
      throw new TypeError("Signature mismatch");
    if (__privateGet(this, _r4) && !P(__privateGet(this, _r4), r[1]))
      throw new TypeError("Pubkey mismatch");
    const n = St3(r[1]);
    if (t.length > 0 && !P(t, n))
      throw new TypeError("Hash mismatch (input)");
  }
}, // Static public fields
__publicField(_a13, "NAME", ft4.P2PKH), _a13);
function gr2(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  const r = new lo2(
    {
      address: e.address,
      hash: e.hash,
      pubkey: e.pubkey,
      signature: e.signature,
      output: e.output,
      input: e.input,
      network: e.network,
      useHybrid: e.useHybrid,
      useUncompressed: e.useUncompressed
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
var Qe3 = q2;
var _a15, _t10, _a16, _e12, _s5, _r5, _n5, _i6, _o5, _h5, _f4, _u4, _c4, _p4, _l4, _d3, _w3, _g4, _y4, _m4, _E2, _I2, _v2, _b3, _S2, _A2, _T2, _nr_instances, k_fn2, O_fn, U_fn2, x_fn2, P_fn2, B_fn2, __fn2, R_fn2, N_fn2, H_fn2, L_fn2;
var po2 = (_a15 = class {
  /**
   * Creates a new P2SH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Base58Check encoded address (3...)
   * @param params.hash - 20-byte script hash
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.redeem - The redeem script information
   * @param params.witness - The witness stack (for wrapped SegWit)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _nr_instances);
    // Private instance fields
    __privateAdd(this, _t10);
    __privateAdd(this, _a16);
    // Input data (provided by user)
    __privateAdd(this, _e12);
    __privateAdd(this, _s5);
    __privateAdd(this, _r5);
    __privateAdd(this, _n5);
    __privateAdd(this, _i6);
    __privateAdd(this, _o5);
    // Cached computed values
    __privateAdd(this, _h5);
    __privateAdd(this, _f4);
    __privateAdd(this, _u4);
    __privateAdd(this, _c4);
    __privateAdd(this, _p4);
    __privateAdd(this, _l4);
    // Cache flags
    __privateAdd(this, _d3, false);
    __privateAdd(this, _w3, false);
    __privateAdd(this, _g4, false);
    __privateAdd(this, _y4, false);
    __privateAdd(this, _m4, false);
    __privateAdd(this, _E2, false);
    // Decoded address cache
    __privateAdd(this, _I2);
    __privateAdd(this, _v2, false);
    // Decoded input chunks cache
    __privateAdd(this, _b3);
    __privateAdd(this, _S2, false);
    // Derived redeem from input
    __privateAdd(this, _A2);
    __privateAdd(this, _T2, false);
    let n = t.network;
    n || (n = t.redeem && t.redeem.network || kt3), __privateSet(this, _t10, n), __privateSet(this, _a16, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e12, t.address), __privateSet(this, _s5, t.hash), __privateSet(this, _r5, t.output), __privateSet(this, _n5, t.input), __privateSet(this, _i6, t.redeem), __privateSet(this, _o5, t.witness), __privateGet(this, _a16).validate && __privateMethod(this, _nr_instances, L_fn2).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const t = this.redeem;
    return t !== void 0 && t.name !== void 0 ? `p2sh-${t.name}` : ft4.P2SH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t10);
  }
  /**
   * Base58Check encoded address (3... for mainnet).
   */
  get address() {
    return __privateGet(this, _d3) || (__privateSet(this, _h5, __privateMethod(this, _nr_instances, x_fn2).call(this)), __privateSet(this, _d3, true)), __privateGet(this, _h5);
  }
  /**
   * 20-byte script hash (HASH160 of redeem script).
   */
  get hash() {
    return __privateGet(this, _w3) || (__privateSet(this, _f4, __privateMethod(this, _nr_instances, P_fn2).call(this)), __privateSet(this, _w3, true)), __privateGet(this, _f4);
  }
  /**
   * The scriptPubKey: `OP_HASH160 {hash} OP_EQUAL`
   */
  get output() {
    return __privateGet(this, _g4) || (__privateSet(this, _u4, __privateMethod(this, _nr_instances, B_fn2).call(this)), __privateSet(this, _g4, true)), __privateGet(this, _u4);
  }
  /**
   * The scriptSig: `{redeemScriptSig...} {redeemScript}`
   */
  get input() {
    return __privateGet(this, _y4) || (__privateSet(this, _c4, __privateMethod(this, _nr_instances, __fn2).call(this)), __privateSet(this, _y4, true)), __privateGet(this, _c4);
  }
  /**
   * The redeem script information.
   */
  get redeem() {
    return __privateGet(this, _m4) || (__privateSet(this, _p4, __privateMethod(this, _nr_instances, R_fn2).call(this)), __privateSet(this, _m4, true)), __privateGet(this, _p4);
  }
  /**
   * The witness stack (for wrapped SegWit).
   */
  get witness() {
    return __privateGet(this, _E2) || (__privateSet(this, _l4, __privateMethod(this, _nr_instances, N_fn2).call(this)), __privateSet(this, _E2, true)), __privateGet(this, _l4);
  }
  // Static factory methods
  /**
   * Creates a P2SH payment from a redeem script.
   *
   * @param redeem - The redeem script information
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   *
   * @example
   * ```typescript
   * const p2sh = P2SH.fromRedeem({ output: redeemScript });
   * ```
   */
  static fromRedeem(t, r) {
    return new _a15({ redeem: t, network: r });
  }
  /**
   * Creates a P2SH payment from a Base58Check address.
   *
   * @param address - Base58Check encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromAddress(t, r) {
    return new _a15({ address: t, network: r });
  }
  /**
   * Creates a P2SH payment from a 20-byte script hash.
   *
   * @param hash - 20-byte script hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromHash(t, r) {
    return new _a15({ hash: t, network: r });
  }
  /**
   * Creates a P2SH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromOutput(t, r) {
    return new _a15({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2SHPayment object for backwards compatibility.
   *
   * @returns A P2SHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      output: this.output,
      input: this.input,
      redeem: this.redeem,
      witness: this.witness
    };
  }
}, _t10 = new WeakMap(), _a16 = new WeakMap(), _e12 = new WeakMap(), _s5 = new WeakMap(), _r5 = new WeakMap(), _n5 = new WeakMap(), _i6 = new WeakMap(), _o5 = new WeakMap(), _h5 = new WeakMap(), _f4 = new WeakMap(), _u4 = new WeakMap(), _c4 = new WeakMap(), _p4 = new WeakMap(), _l4 = new WeakMap(), _d3 = new WeakMap(), _w3 = new WeakMap(), _g4 = new WeakMap(), _y4 = new WeakMap(), _m4 = new WeakMap(), _E2 = new WeakMap(), _I2 = new WeakMap(), _v2 = new WeakMap(), _b3 = new WeakMap(), _S2 = new WeakMap(), _A2 = new WeakMap(), _T2 = new WeakMap(), _nr_instances = new WeakSet(), k_fn2 = function() {
  if (!__privateGet(this, _v2)) {
    if (__privateGet(this, _e12)) {
      const t = new Uint8Array(ti2(__privateGet(this, _e12)));
      __privateSet(this, _I2, {
        version: t[0],
        hash: t.subarray(1)
      });
    }
    __privateSet(this, _v2, true);
  }
  return __privateGet(this, _I2);
}, O_fn = function() {
  return __privateGet(this, _S2) || (__privateGet(this, _n5) && __privateSet(this, _b3, tt3(__privateGet(this, _n5)) ?? void 0), __privateSet(this, _S2, true)), __privateGet(this, _b3);
}, // Private computation methods
U_fn2 = function() {
  if (!__privateGet(this, _T2)) {
    const t = __privateMethod(this, _nr_instances, O_fn).call(this);
    if (t) {
      const r = t[t.length - 1];
      __privateSet(this, _A2, {
        network: __privateGet(this, _t10),
        output: r === Qe3.OP_FALSE ? new Uint8Array(0) : r,
        input: gt3(t.slice(0, -1)),
        witness: __privateGet(this, _o5) || []
      });
    }
    __privateSet(this, _T2, true);
  }
  return __privateGet(this, _A2);
}, x_fn2 = function() {
  if (__privateGet(this, _e12))
    return __privateGet(this, _e12);
  const t = this.hash;
  if (!t) return;
  const r = Et4(21);
  return r[0] = __privateGet(this, _t10).scriptHash, r.set(t, 1), Jn2(r);
}, P_fn2 = function() {
  var _a37;
  if (__privateGet(this, _s5))
    return __privateGet(this, _s5);
  if (__privateGet(this, _r5))
    return __privateGet(this, _r5).subarray(2, 22);
  if (__privateGet(this, _e12))
    return (_a37 = __privateMethod(this, _nr_instances, k_fn2).call(this)) == null ? void 0 : _a37.hash;
  const t = this.redeem;
  if (t && t.output)
    return St3(t.output);
}, B_fn2 = function() {
  if (__privateGet(this, _r5))
    return __privateGet(this, _r5);
  const t = this.hash;
  if (t)
    return gt3([Qe3.OP_HASH160, t, Qe3.OP_EQUAL]);
}, __fn2 = function() {
  if (__privateGet(this, _n5))
    return __privateGet(this, _n5);
  const t = __privateGet(this, _i6);
  if (!(!t || !t.input || !t.output))
    return gt3(
      [].concat(tt3(t.input), t.output)
    );
}, R_fn2 = function() {
  if (__privateGet(this, _i6))
    return __privateGet(this, _i6);
  if (__privateGet(this, _n5))
    return __privateMethod(this, _nr_instances, U_fn2).call(this);
}, // Validation
N_fn2 = function() {
  if (__privateGet(this, _o5))
    return __privateGet(this, _o5);
  const t = this.redeem;
  if (t && t.witness)
    return t.witness;
  if (this.input)
    return [];
}, H_fn2 = function(t) {
  if (t.output) {
    const r = tt3(t.output);
    if (!r || r.length < 1)
      throw new TypeError("Redeem.output too short");
    if (t.output.byteLength > 520)
      throw new TypeError("Redeem.output unspendable if larger than 520 bytes");
    if (ii2(r) > 201)
      throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
  }
  if (t.input) {
    const r = t.input.length > 0, n = t.witness && t.witness.length > 0;
    if (!r && !n)
      throw new TypeError("Empty input");
    if (r && n)
      throw new TypeError("Input and witness provided");
    if (r) {
      const i = tt3(t.input);
      if (!an2(i))
        throw new TypeError("Non push-only scriptSig");
    }
  }
}, L_fn2 = function() {
  let t = new Uint8Array(0);
  if (__privateGet(this, _e12)) {
    const r = __privateMethod(this, _nr_instances, k_fn2).call(this);
    if (!r)
      throw new TypeError("Invalid address");
    if (r.version !== __privateGet(this, _t10).scriptHash)
      throw new TypeError("Invalid version or Network mismatch");
    if (r.hash.length !== 20)
      throw new TypeError("Invalid address");
    t = r.hash;
  }
  if (__privateGet(this, _s5)) {
    if (t.length > 0 && !P(t, __privateGet(this, _s5)))
      throw new TypeError("Hash mismatch");
    t = __privateGet(this, _s5);
  }
  if (__privateGet(this, _r5)) {
    if (__privateGet(this, _r5).length !== 23 || __privateGet(this, _r5)[0] !== Qe3.OP_HASH160 || __privateGet(this, _r5)[1] !== 20 || __privateGet(this, _r5)[22] !== Qe3.OP_EQUAL)
      throw new TypeError("Output is invalid");
    const r = __privateGet(this, _r5).subarray(2, 22);
    if (t.length > 0 && !P(t, r))
      throw new TypeError("Hash mismatch");
    t = r;
  }
  if (__privateGet(this, _n5)) {
    const r = __privateMethod(this, _nr_instances, O_fn).call(this);
    if (!r || r.length < 1)
      throw new TypeError("Input too short");
    const n = __privateMethod(this, _nr_instances, U_fn2).call(this);
    if (!n || !(n.output instanceof Uint8Array))
      throw new TypeError("Input is invalid");
    if (__privateMethod(this, _nr_instances, H_fn2).call(this, n), n.output) {
      const i = St3(n.output);
      if (t.length > 0 && !P(t, i))
        throw new TypeError("Hash mismatch");
      t = i;
    }
  }
  if (__privateGet(this, _i6)) {
    if (__privateGet(this, _i6).network && __privateGet(this, _i6).network !== __privateGet(this, _t10))
      throw new TypeError("Network mismatch");
    if (__privateGet(this, _n5)) {
      const r = __privateMethod(this, _nr_instances, U_fn2).call(this);
      if (r) {
        if (__privateGet(this, _i6).output && r.output && !P(__privateGet(this, _i6).output, r.output))
          throw new TypeError("Redeem.output mismatch");
        if (__privateGet(this, _i6).input && r.input && !P(__privateGet(this, _i6).input, r.input))
          throw new TypeError("Redeem.input mismatch");
      }
    }
    if (__privateMethod(this, _nr_instances, H_fn2).call(this, __privateGet(this, _i6)), __privateGet(this, _i6).output) {
      const r = St3(__privateGet(this, _i6).output);
      if (t.length > 0 && !P(t, r))
        throw new TypeError("Hash mismatch");
    }
  }
  if (__privateGet(this, _o5) && __privateGet(this, _i6) && __privateGet(this, _i6).witness && !Oe3(__privateGet(this, _i6).witness, __privateGet(this, _o5)))
    throw new TypeError("Witness and redeem.witness mismatch");
}, // Static public fields
__publicField(_a15, "NAME", ft4.P2SH), _a15);
function yr2(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  const r = new po2(
    {
      address: e.address,
      hash: e.hash,
      output: e.output,
      input: e.input,
      redeem: e.redeem,
      witness: e.witness,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
function wu2(e) {
  const t = e.length;
  if (t % 2 !== 0) throw new TypeError("fromHexInternal: odd-length hex string");
  const r = new Uint8Array(t / 2);
  for (let n = 0; n < t; n += 2) {
    const i = zi2(e.charCodeAt(n)), o = zi2(e.charCodeAt(n + 1));
    if (i === -1 || o === -1) throw new TypeError("fromHexInternal: invalid hex character");
    r[n >> 1] = i << 4 | o;
  }
  return r;
}
function zi2(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function Ut4(e, t) {
  if (e.length !== t.length) return false;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r]) return false;
  return true;
}
function hi2(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function Pe2(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const r = t && `"${t}" `;
    throw new Error(`${r}expected integer >= 0, got ${e}`);
  }
}
function ut3(e, t, r = "") {
  const n = hi2(e), i = e == null ? void 0 : e.length, o = t !== void 0;
  if (!n || o && i !== t) {
    const a = r && `"${r}" `, u = o ? ` of length ${t}` : "", l = n ? `length=${i}` : `type=${typeof e}`;
    throw new Error(a + "expected Uint8Array" + u + ", got " + l);
  }
  return e;
}
function wo2(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  Pe2(e.outputLen), Pe2(e.blockLen);
}
function Fr2(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function gu2(e, t) {
  ut3(e, void 0, "digestInto() output");
  const r = t.outputLen;
  if (e.length < r)
    throw new Error('"digestInto() output" expected to be of length >=' + r);
}
function Wr2(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function An2(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function Gt4(e, t) {
  return e << 32 - t | e >>> t;
}
var go2 = (
  /* @ts-ignore */
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
);
var yu2 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function un2(e) {
  if (ut3(e), go2)
    return e.toHex();
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += yu2[e[r]];
  return t;
}
var te3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function qi2(e) {
  if (e >= te3._0 && e <= te3._9)
    return e - te3._0;
  if (e >= te3.A && e <= te3.F)
    return e - (te3.A - 10);
  if (e >= te3.a && e <= te3.f)
    return e - (te3.a - 10);
}
function Gr2(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (go2)
    return Uint8Array.fromHex(e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let i = 0, o = 0; i < r; i++, o += 2) {
    const a = qi2(e.charCodeAt(o)), u = qi2(e.charCodeAt(o + 1));
    if (a === void 0 || u === void 0) {
      const l = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + l + '" at index ' + o);
    }
    n[i] = a * 16 + u;
  }
  return n;
}
function de2(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    ut3(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, i = 0; n < e.length; n++) {
    const o = e[n];
    r.set(o, i), i += o.length;
  }
  return r;
}
function bu2(e, t = {}) {
  const r = (i, o) => e(o).update(i).digest(), n = e(void 0);
  return r.outputLen = n.outputLen, r.blockLen = n.blockLen, r.create = (i) => e(i), Object.assign(r, t), Object.freeze(r);
}
function yo2(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof (t == null ? void 0 : t.getRandomValues) != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
var mu2 = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function Eu2(e, t, r) {
  return e & t ^ ~e & r;
}
function Iu2(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
var vu2 = class {
  constructor(t, r, n, i) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = An2(this.buffer);
  }
  update(t) {
    Fr2(this), ut3(t);
    const { view: r, buffer: n, blockLen: i } = this, o = t.length;
    for (let a = 0; a < o; ) {
      const u = Math.min(i - this.pos, o - a);
      if (u === i) {
        const l = An2(t);
        for (; i <= o - a; a += i)
          this.process(l, a);
        continue;
      }
      n.set(t.subarray(a, a + u), this.pos), this.pos += u, a += u, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Fr2(this), gu2(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: a } = this;
    r[a++] = 128, Wr2(this.buffer.subarray(a)), this.padOffset > i - a && (this.process(n, 0), a = 0);
    for (let p = a; p < i; p++)
      r[p] = 0;
    n.setBigUint64(i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const u = An2(t), l = this.outputLen;
    if (l % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const d = l / 4, f = this.get();
    if (d > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let p = 0; p < d; p++)
      u.setUint32(4 * p, f[p], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: a, pos: u } = this;
    return t.destroyed = a, t.finished = o, t.length = i, t.pos = u, i % r && t.buffer.set(n), t;
  }
  clone() {
    return this._cloneInto();
  }
};
var he2 = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Au2 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var ue3 = new Uint32Array(64);
var Su2 = class extends vu2 {
  constructor(t) {
    super(64, t, 8, false);
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: a, G: u, H: l } = this;
    return [t, r, n, i, o, a, u, l];
  }
  // prettier-ignore
  set(t, r, n, i, o, a, u, l) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = a | 0, this.G = u | 0, this.H = l | 0;
  }
  process(t, r) {
    for (let p = 0; p < 16; p++, r += 4)
      ue3[p] = t.getUint32(r, false);
    for (let p = 16; p < 64; p++) {
      const w = ue3[p - 15], y = ue3[p - 2], m = Gt4(w, 7) ^ Gt4(w, 18) ^ w >>> 3, E2 = Gt4(y, 17) ^ Gt4(y, 19) ^ y >>> 10;
      ue3[p] = E2 + ue3[p - 7] + m + ue3[p - 16] | 0;
    }
    let { A: n, B: i, C: o, D: a, E: u, F: l, G: d, H: f } = this;
    for (let p = 0; p < 64; p++) {
      const w = Gt4(u, 6) ^ Gt4(u, 11) ^ Gt4(u, 25), y = f + w + Eu2(u, l, d) + Au2[p] + ue3[p] | 0, m = (Gt4(n, 2) ^ Gt4(n, 13) ^ Gt4(n, 22)) + Iu2(n, i, o) | 0;
      f = d, d = l, l = u, u = a + y | 0, a = o, o = i, i = n, n = y + m | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, a = a + this.D | 0, u = u + this.E | 0, l = l + this.F | 0, d = d + this.G | 0, f = f + this.H | 0, this.set(n, i, o, a, u, l, d, f);
  }
  roundClean() {
    Wr2(ue3);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Wr2(this.buffer);
  }
};
var Tu2 = class extends Su2 {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", he2[0] | 0);
    __publicField(this, "B", he2[1] | 0);
    __publicField(this, "C", he2[2] | 0);
    __publicField(this, "D", he2[3] | 0);
    __publicField(this, "E", he2[4] | 0);
    __publicField(this, "F", he2[5] | 0);
    __publicField(this, "G", he2[6] | 0);
    __publicField(this, "H", he2[7] | 0);
  }
};
var ku2 = bu2(
  () => new Tu2(),
  mu2(1)
);
function Uu2(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let d = 0; d < t.length; d++)
    t[d] = 255;
  for (let d = 0; d < e.length; d++) {
    const f = e.charAt(d), p = f.charCodeAt(0);
    if (t[p] !== 255)
      throw new TypeError(f + " is ambiguous");
    t[p] = d;
  }
  const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function a(d) {
    if (d instanceof Uint8Array || (ArrayBuffer.isView(d) ? d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength) : Array.isArray(d) && (d = Uint8Array.from(d))), !(d instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (d.length === 0)
      return "";
    let f = 0, p = 0, w = 0;
    const y = d.length;
    for (; w !== y && d[w] === 0; )
      w++, f++;
    const m = (y - w) * o + 1 >>> 0, E2 = new Uint8Array(m);
    for (; w !== y; ) {
      let O = d[w], T = 0;
      for (let _ = m - 1; (O !== 0 || T < p) && _ !== -1; _--, T++)
        O += 256 * E2[_] >>> 0, E2[_] = O % r >>> 0, O = O / r >>> 0;
      if (O !== 0)
        throw new Error("Non-zero carry");
      p = T, w++;
    }
    let v = m - p;
    for (; v !== m && E2[v] === 0; )
      v++;
    let x = n.repeat(f);
    for (; v < m; ++v)
      x += e.charAt(E2[v]);
    return x;
  }
  function u(d) {
    if (typeof d != "string")
      throw new TypeError("Expected String");
    if (d.length === 0)
      return new Uint8Array();
    let f = 0, p = 0, w = 0;
    for (; d[f] === n; )
      p++, f++;
    const y = (d.length - f) * i + 1 >>> 0, m = new Uint8Array(y);
    for (; f < d.length; ) {
      const O = d.charCodeAt(f);
      if (O > 255)
        return;
      let T = t[O];
      if (T === 255)
        return;
      let _ = 0;
      for (let M2 = y - 1; (T !== 0 || _ < w) && M2 !== -1; M2--, _++)
        T += r * m[M2] >>> 0, m[M2] = T % 256 >>> 0, T = T / 256 >>> 0;
      if (T !== 0)
        throw new Error("Non-zero carry");
      w = _, f++;
    }
    let E2 = y - w;
    for (; E2 !== y && m[E2] === 0; )
      E2++;
    const v = new Uint8Array(p + (y - E2));
    let x = p;
    for (; E2 !== y; )
      v[x++] = m[E2++];
    return v;
  }
  function l(d) {
    const f = u(d);
    if (f)
      return f;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: a,
    decodeUnsafe: u,
    decode: l
  };
}
var xu2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
Uu2(xu2);
var ui2 = BigInt(0);
var Mn = BigInt(1);
function jr2(e, t = "") {
  if (typeof e != "boolean") {
    const r = t && `"${t}" `;
    throw new Error(r + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function bo2(e) {
  if (typeof e == "bigint") {
    if (!Lr2(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    Pe2(e);
  return e;
}
function xr2(e) {
  const t = bo2(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function mo2(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? ui2 : BigInt("0x" + e);
}
function fn2(e) {
  return mo2(un2(e));
}
function Eo2(e) {
  return mo2(un2(Ou2(ut3(e)).reverse()));
}
function fi2(e, t) {
  Pe2(t), e = bo2(e);
  const r = Gr2(e.toString(16).padStart(t * 2, "0"));
  if (r.length !== t)
    throw new Error("number too large");
  return r;
}
function Io2(e, t) {
  return fi2(e, t).reverse();
}
function Ou2(e) {
  return Uint8Array.from(e);
}
var Lr2 = (e) => typeof e == "bigint" && ui2 <= e;
function Pu2(e, t, r) {
  return Lr2(e) && Lr2(t) && Lr2(r) && t <= e && e < r;
}
function Bu2(e, t, r, n) {
  if (!Pu2(t, r, n))
    throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t);
}
function _u5(e) {
  let t;
  for (t = 0; e > ui2; e >>= Mn, t += 1)
    ;
  return t;
}
var ci2 = (e) => (Mn << BigInt(e)) - Mn;
function Ru2(e, t, r) {
  if (Pe2(e, "hashLen"), Pe2(t, "qByteLen"), typeof r != "function")
    throw new Error("hmacFn must be a function");
  const n = (E2) => new Uint8Array(E2), i = Uint8Array.of(), o = Uint8Array.of(0), a = Uint8Array.of(1), u = 1e3;
  let l = n(e), d = n(e), f = 0;
  const p = () => {
    l.fill(1), d.fill(0), f = 0;
  }, w = (...E2) => r(d, de2(l, ...E2)), y = (E2 = i) => {
    d = w(o, E2), l = w(), E2.length !== 0 && (d = w(a, E2), l = w());
  }, m = () => {
    if (f++ >= u)
      throw new Error("drbg: tried max amount of iterations");
    let E2 = 0;
    const v = [];
    for (; E2 < t; ) {
      l = w();
      const x = l.slice();
      v.push(x), E2 += l.length;
    }
    return de2(...v);
  };
  return (E2, v) => {
    p(), y(E2);
    let x;
    for (; !(x = v(m())); )
      y();
    return p(), x;
  };
}
function li2(e, t = {}, r = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function n(o, a, u) {
    const l = e[o];
    if (u && l === void 0)
      return;
    const d = typeof l;
    if (d !== a || l === null)
      throw new Error(`param "${o}" is invalid: expected ${a}, got ${d}`);
  }
  const i = (o, a) => Object.entries(o).forEach(([u, l]) => n(u, l, a));
  i(t, false), i(r, true);
}
function Yi2(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const i = t.get(r);
    if (i !== void 0)
      return i;
    const o = e(r, ...n);
    return t.set(r, o), o;
  };
}
var Ot3 = BigInt(0);
var Tt4 = BigInt(1);
var Ie3 = BigInt(2);
var vo2 = BigInt(3);
var Ao2 = BigInt(4);
var So2 = BigInt(5);
var Nu2 = BigInt(7);
var To2 = BigInt(8);
var Hu2 = BigInt(9);
var ko2 = BigInt(16);
function Dt4(e, t) {
  const r = e % t;
  return r >= Ot3 ? r : t + r;
}
function Ht4(e, t, r) {
  let n = e;
  for (; t-- > Ot3; )
    n *= n, n %= r;
  return n;
}
function Xi2(e, t) {
  if (e === Ot3)
    throw new Error("invert: expected non-zero number");
  if (t <= Ot3)
    throw new Error("invert: expected positive modulus, got " + t);
  let r = Dt4(e, t), n = t, i = Ot3, o = Tt4;
  for (; r !== Ot3; ) {
    const a = n / r, u = n % r, l = i - o * a;
    n = r, r = u, i = o, o = l;
  }
  if (n !== Tt4)
    throw new Error("invert: does not exist");
  return Dt4(i, t);
}
function pi2(e, t, r) {
  if (!e.eql(e.sqr(t), r))
    throw new Error("Cannot find square root");
}
function Uo2(e, t) {
  const r = (e.ORDER + Tt4) / Ao2, n = e.pow(t, r);
  return pi2(e, n, t), n;
}
function Lu2(e, t) {
  const r = (e.ORDER - So2) / To2, n = e.mul(t, Ie3), i = e.pow(n, r), o = e.mul(t, i), a = e.mul(e.mul(o, Ie3), i), u = e.mul(o, e.sub(a, e.ONE));
  return pi2(e, u, t), u;
}
function Cu2(e) {
  const t = cn2(e), r = xo2(e), n = r(t, t.neg(t.ONE)), i = r(t, n), o = r(t, t.neg(n)), a = (e + Nu2) / ko2;
  return (u, l) => {
    let d = u.pow(l, a), f = u.mul(d, n);
    const p = u.mul(d, i), w = u.mul(d, o), y = u.eql(u.sqr(f), l), m = u.eql(u.sqr(p), l);
    d = u.cmov(d, f, y), f = u.cmov(w, p, m);
    const E2 = u.eql(u.sqr(f), l), v = u.cmov(d, f, E2);
    return pi2(u, v, l), v;
  };
}
function xo2(e) {
  if (e < vo2)
    throw new Error("sqrt is not defined for small field");
  let t = e - Tt4, r = 0;
  for (; t % Ie3 === Ot3; )
    t /= Ie3, r++;
  let n = Ie3;
  const i = cn2(e);
  for (; Zi2(i, n) === 1; )
    if (n++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r === 1)
    return Uo2;
  let o = i.pow(n, t);
  const a = (t + Tt4) / Ie3;
  return function(u, l) {
    if (u.is0(l))
      return l;
    if (Zi2(u, l) !== 1)
      throw new Error("Cannot find square root");
    let d = r, f = u.mul(u.ONE, o), p = u.pow(l, t), w = u.pow(l, a);
    for (; !u.eql(p, u.ONE); ) {
      if (u.is0(p))
        return u.ZERO;
      let y = 1, m = u.sqr(p);
      for (; !u.eql(m, u.ONE); )
        if (y++, m = u.sqr(m), y === d)
          throw new Error("Cannot find square root");
      const E2 = Tt4 << BigInt(d - y - 1), v = u.pow(f, E2);
      d = y, f = u.sqr(v), p = u.mul(p, f), w = u.mul(w, v);
    }
    return w;
  };
}
function Vu2(e) {
  return e % Ao2 === vo2 ? Uo2 : e % To2 === So2 ? Lu2 : e % ko2 === Hu2 ? Cu2(e) : xo2(e);
}
var $u2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Ku2(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r = $u2.reduce((n, i) => (n[i] = "function", n), t);
  return li2(e, r), e;
}
function Du2(e, t, r) {
  if (r < Ot3)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === Ot3)
    return e.ONE;
  if (r === Tt4)
    return t;
  let n = e.ONE, i = t;
  for (; r > Ot3; )
    r & Tt4 && (n = e.mul(n, i)), i = e.sqr(i), r >>= Tt4;
  return n;
}
function Oo2(e, t, r = false) {
  const n = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((a, u, l) => e.is0(u) ? a : (n[l] = a, e.mul(a, u)), e.ONE), o = e.inv(i);
  return t.reduceRight((a, u, l) => e.is0(u) ? a : (n[l] = e.mul(a, n[l]), e.mul(a, u)), o), n;
}
function Zi2(e, t) {
  const r = (e.ORDER - Tt4) / Ie3, n = e.pow(t, r), i = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), a = e.eql(n, e.neg(e.ONE));
  if (!i && !o && !a)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : o ? 0 : -1;
}
function Mu2(e, t) {
  t !== void 0 && Pe2(t);
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
var Fu2 = class {
  constructor(t, r = {}) {
    __publicField(this, "ORDER");
    __publicField(this, "BITS");
    __publicField(this, "BYTES");
    __publicField(this, "isLE");
    __publicField(this, "ZERO", Ot3);
    __publicField(this, "ONE", Tt4);
    __publicField(this, "_lengths");
    __publicField(this, "_sqrt");
    // cached sqrt
    __publicField(this, "_mod");
    var _a37;
    if (t <= Ot3)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let n;
    this.isLE = false, r != null && typeof r == "object" && (typeof r.BITS == "number" && (n = r.BITS), typeof r.sqrt == "function" && (this.sqrt = r.sqrt), typeof r.isLE == "boolean" && (this.isLE = r.isLE), r.allowedLengths && (this._lengths = (_a37 = r.allowedLengths) == null ? void 0 : _a37.slice()), typeof r.modFromBytes == "boolean" && (this._mod = r.modFromBytes));
    const { nBitLength: i, nByteLength: o } = Mu2(t, n);
    if (o > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = o, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return Dt4(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return Ot3 <= t && t < this.ORDER;
  }
  is0(t) {
    return t === Ot3;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & Tt4) === Tt4;
  }
  neg(t) {
    return Dt4(-t, this.ORDER);
  }
  eql(t, r) {
    return t === r;
  }
  sqr(t) {
    return Dt4(t * t, this.ORDER);
  }
  add(t, r) {
    return Dt4(t + r, this.ORDER);
  }
  sub(t, r) {
    return Dt4(t - r, this.ORDER);
  }
  mul(t, r) {
    return Dt4(t * r, this.ORDER);
  }
  pow(t, r) {
    return Du2(this, t, r);
  }
  div(t, r) {
    return Dt4(t * Xi2(r, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, r) {
    return t + r;
  }
  subN(t, r) {
    return t - r;
  }
  mulN(t, r) {
    return t * r;
  }
  inv(t) {
    return Xi2(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = Vu2(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? Io2(t, this.BYTES) : fi2(t, this.BYTES);
  }
  fromBytes(t, r = false) {
    ut3(t);
    const { _lengths: n, BYTES: i, isLE: o, ORDER: a, _mod: u } = this;
    if (n) {
      if (!n.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + n + " bytes, got " + t.length);
      const d = new Uint8Array(i);
      d.set(t, o ? 0 : d.length - t.length), t = d;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let l = o ? Eo2(t) : fn2(t);
    if (u && (l = Dt4(l, a)), !r && !this.isValid(l))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return l;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return Oo2(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, r, n) {
    return n ? r : t;
  }
};
function cn2(e, t = {}) {
  return new Fu2(e, t);
}
function Po2(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function Bo2(e) {
  const t = Po2(e);
  return t + Math.ceil(t / 2);
}
function Wu2(e, t, r = false) {
  ut3(e);
  const n = e.length, i = Po2(t), o = Bo2(t);
  if (n < 16 || n < o || n > 1024)
    throw new Error("expected " + o + "-1024 bytes of input, got " + n);
  const a = r ? Eo2(e) : fn2(e), u = Dt4(a, t - Tt4) + Tt4;
  return r ? Io2(u, i) : fi2(u, i);
}
var We3 = BigInt(0);
var ve3 = BigInt(1);
function zr2(e, t) {
  const r = t.negate();
  return e ? r : t;
}
function Qi2(e, t) {
  const r = Oo2(e.Fp, t.map((n) => n.Z));
  return t.map((n, i) => e.fromAffine(n.toAffine(r[i])));
}
function _o6(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function Sn2(e, t) {
  _o6(e, t);
  const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i = 2 ** e, o = ci2(e), a = BigInt(e);
  return { windows: r, windowSize: n, mask: o, maxNumber: i, shiftBy: a };
}
function Ji2(e, t, r) {
  const { windowSize: n, mask: i, maxNumber: o, shiftBy: a } = r;
  let u = Number(e & i), l = e >> a;
  u > n && (u -= o, l += ve3);
  const d = t * n, f = d + Math.abs(u) - 1, p = u === 0, w = u < 0, y = t % 2 !== 0;
  return { nextN: l, offset: f, isZero: p, isNeg: w, isNegF: y, offsetF: d };
}
var Tn2 = /* @__PURE__ */ new WeakMap();
var Ro2 = /* @__PURE__ */ new WeakMap();
function kn2(e) {
  return Ro2.get(e) || 1;
}
function ts2(e) {
  if (e !== We3)
    throw new Error("invalid wNAF");
}
var Gu2 = class {
  // Parametrized with a given Point class (not individual point)
  constructor(t, r) {
    __publicField(this, "BASE");
    __publicField(this, "ZERO");
    __publicField(this, "Fn");
    __publicField(this, "bits");
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = r;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, r, n = this.ZERO) {
    let i = t;
    for (; r > We3; )
      r & ve3 && (n = n.add(i)), i = i.double(), r >>= ve3;
    return n;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, r) {
    const { windows: n, windowSize: i } = Sn2(r, this.bits), o = [];
    let a = t, u = a;
    for (let l = 0; l < n; l++) {
      u = a, o.push(u);
      for (let d = 1; d < i; d++)
        u = u.add(a), o.push(u);
      a = u.double();
    }
    return o;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, r, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let i = this.ZERO, o = this.BASE;
    const a = Sn2(t, this.bits);
    for (let u = 0; u < a.windows; u++) {
      const { nextN: l, offset: d, isZero: f, isNeg: p, isNegF: w, offsetF: y } = Ji2(n, u, a);
      n = l, f ? o = o.add(zr2(w, r[y])) : i = i.add(zr2(p, r[d]));
    }
    return ts2(n), { p: i, f: o };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, r, n, i = this.ZERO) {
    const o = Sn2(t, this.bits);
    for (let a = 0; a < o.windows && n !== We3; a++) {
      const { nextN: u, offset: l, isZero: d, isNeg: f } = Ji2(n, a, o);
      if (n = u, !d) {
        const p = r[l];
        i = i.add(f ? p.negate() : p);
      }
    }
    return ts2(n), i;
  }
  getPrecomputes(t, r, n) {
    let i = Tn2.get(r);
    return i || (i = this.precomputeWindow(r, t), t !== 1 && (typeof n == "function" && (i = n(i)), Tn2.set(r, i))), i;
  }
  cached(t, r, n) {
    const i = kn2(t);
    return this.wNAF(i, this.getPrecomputes(i, t, n), r);
  }
  unsafe(t, r, n, i) {
    const o = kn2(t);
    return o === 1 ? this._unsafeLadder(t, r, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, n), r, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, r) {
    _o6(r, this.bits), Ro2.set(t, r), Tn2.delete(t);
  }
  hasCache(t) {
    return kn2(t) !== 1;
  }
};
function ju2(e, t, r, n) {
  let i = t, o = e.ZERO, a = e.ZERO;
  for (; r > We3 || n > We3; )
    r & ve3 && (o = o.add(i)), n & ve3 && (a = a.add(i)), i = i.double(), r >>= ve3, n >>= ve3;
  return { p1: o, p2: a };
}
function es2(e, t, r) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Ku2(t), t;
  } else
    return cn2(e, { isLE: r });
}
function zu2(e, t, r = {}, n) {
  if (n === void 0 && (n = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const u of ["p", "n", "h"]) {
    const l = t[u];
    if (!(typeof l == "bigint" && l > We3))
      throw new Error(`CURVE.${u} must be positive bigint`);
  }
  const i = es2(t.p, r.Fp, n), o = es2(t.n, r.Fn, n), a = ["Gx", "Gy", "a", "b"];
  for (const u of a)
    if (!i.isValid(t[u]))
      throw new Error(`CURVE.${u} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: o };
}
function qu2(e, t) {
  return function(r) {
    const n = e(r);
    return { secretKey: n, publicKey: t(n) };
  };
}
var No2 = class {
  constructor(t, r) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    if (wo2(t), ut3(r, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, i = new Uint8Array(n);
    i.set(r.length > n ? t.create().update(r).digest() : r);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), Wr2(i);
  }
  update(t) {
    return Fr2(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Fr2(this), ut3(t, this.outputLen, "output"), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: a, outputLen: u } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = a, t.outputLen = u, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var Ho2 = (e, t, r) => new No2(e, t).update(r).digest();
Ho2.create = (e, t) => new No2(e, t);
var rs2 = (e, t) => (e + (e >= 0 ? t : -t) / Lo2) / t;
function Yu2(e, t, r) {
  const [[n, i], [o, a]] = t, u = rs2(a * e, r), l = rs2(-i * e, r);
  let d = e - u * n - l * o, f = -u * i - l * a;
  const p = d < re3, w = f < re3;
  p && (d = -d), w && (f = -f);
  const y = ci2(Math.ceil(_u5(r) / 2)) + Ke4;
  if (d < re3 || d >= y || f < re3 || f >= y)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: p, k1: d, k2neg: w, k2: f };
}
function Fn2(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function Un2(e, t) {
  const r = {};
  for (let n of Object.keys(t))
    r[n] = e[n] === void 0 ? t[n] : e[n];
  return jr2(r.lowS, "lowS"), jr2(r.prehash, "prehash"), r.format !== void 0 && Fn2(r.format), r;
}
var Xu2 = class extends Error {
  constructor(t = "") {
    super(t);
  }
};
var pe3 = {
  // asn.1 DER encoding utils
  Err: Xu2,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = pe3;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, i = xr2(n);
      if (i.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const o = n > 127 ? xr2(i.length / 2 | 128) : "";
      return xr2(e) + o + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = pe3;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const i = t[n++], o = !!(i & 128);
      let a = 0;
      if (!o)
        a = i;
      else {
        const l = i & 127;
        if (!l)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (l > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const d = t.subarray(n, n + l);
        if (d.length !== l)
          throw new r("tlv.decode: length bytes not complete");
        if (d[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const f of d)
          a = a << 8 | f;
        if (n += l, a < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const u = t.subarray(n, n + a);
      if (u.length !== a)
        throw new r("tlv.decode: wrong value length");
      return { v: u, l: t.subarray(n + a) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = pe3;
      if (e < re3)
        throw new t("integer: negative integers are not allowed");
      let r = xr2(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(e) {
      const { Err: t } = pe3;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return fn2(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = pe3, i = ut3(e, void 0, "signature"), { v: o, l: a } = n.decode(48, i);
    if (a.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: u, l } = n.decode(2, o), { v: d, l: f } = n.decode(2, l);
    if (f.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: r.decode(u), s: r.decode(d) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = pe3, n = t.encode(2, r.encode(e.r)), i = t.encode(2, r.encode(e.s)), o = n + i;
    return t.encode(48, o);
  }
};
var re3 = BigInt(0);
var Ke4 = BigInt(1);
var Lo2 = BigInt(2);
var Or2 = BigInt(3);
var Zu2 = BigInt(4);
function Qu2(e, t = {}) {
  const r = zu2("weierstrass", e, t), { Fp: n, Fn: i } = r;
  let o = r.CURVE;
  const { h: a, n: u } = o;
  li2(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: l } = t;
  if (l && (!n.is0(o.a) || typeof l.beta != "bigint" || !Array.isArray(l.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const d = Vo2(n, i);
  function f() {
    if (!n.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function p(X3, U, S2) {
    const { x: A, y: B2 } = U.toAffine(), C = n.toBytes(A);
    if (jr2(S2, "isCompressed"), S2) {
      f();
      const V2 = !n.isOdd(B2);
      return de2(Co2(V2), C);
    } else
      return de2(Uint8Array.of(4), C, n.toBytes(B2));
  }
  function w(X3) {
    ut3(X3, void 0, "Point");
    const { publicKey: U, publicKeyUncompressed: S2 } = d, A = X3.length, B2 = X3[0], C = X3.subarray(1);
    if (A === U && (B2 === 2 || B2 === 3)) {
      const V2 = n.fromBytes(C);
      if (!n.isValid(V2))
        throw new Error("bad point: is not on curve, wrong x");
      const $4 = E2(V2);
      let L;
      try {
        L = n.sqrt($4);
      } catch (W3) {
        const ct5 = W3 instanceof Error ? ": " + W3.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + ct5);
      }
      f();
      const D2 = n.isOdd(L);
      return (B2 & 1) === 1 !== D2 && (L = n.neg(L)), { x: V2, y: L };
    } else if (A === S2 && B2 === 4) {
      const V2 = n.BYTES, $4 = n.fromBytes(C.subarray(0, V2)), L = n.fromBytes(C.subarray(V2, V2 * 2));
      if (!v($4, L))
        throw new Error("bad point: is not on curve");
      return { x: $4, y: L };
    } else
      throw new Error(`bad point: got length ${A}, expected compressed=${U} or uncompressed=${S2}`);
  }
  const y = t.toBytes || p, m = t.fromBytes || w;
  function E2(X3) {
    const U = n.sqr(X3), S2 = n.mul(U, X3);
    return n.add(n.add(S2, n.mul(X3, o.a)), o.b);
  }
  function v(X3, U) {
    const S2 = n.sqr(U), A = E2(X3);
    return n.eql(S2, A);
  }
  if (!v(o.Gx, o.Gy))
    throw new Error("bad curve params: generator point");
  const x = n.mul(n.pow(o.a, Or2), Zu2), O = n.mul(n.sqr(o.b), BigInt(27));
  if (n.is0(n.add(x, O)))
    throw new Error("bad curve params: a or b");
  function T(X3, U, S2 = false) {
    if (!n.isValid(U) || S2 && n.is0(U))
      throw new Error(`bad point coordinate ${X3}`);
    return U;
  }
  function _(X3) {
    if (!(X3 instanceof F3))
      throw new Error("Weierstrass Point expected");
  }
  function M2(X3) {
    if (!l || !l.basises)
      throw new Error("no endo");
    return Yu2(X3, l.basises, i.ORDER);
  }
  const nt5 = Yi2((X3, U) => {
    const { X: S2, Y: A, Z: B2 } = X3;
    if (n.eql(B2, n.ONE))
      return { x: S2, y: A };
    const C = X3.is0();
    U == null && (U = C ? n.ONE : n.inv(B2));
    const V2 = n.mul(S2, U), $4 = n.mul(A, U), L = n.mul(B2, U);
    if (C)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(L, n.ONE))
      throw new Error("invZ was invalid");
    return { x: V2, y: $4 };
  }), z4 = Yi2((X3) => {
    if (X3.is0()) {
      if (t.allowInfinityPoint && !n.is0(X3.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: U, y: S2 } = X3.toAffine();
    if (!n.isValid(U) || !n.isValid(S2))
      throw new Error("bad point: x or y not field elements");
    if (!v(U, S2))
      throw new Error("bad point: equation left != right");
    if (!X3.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function Y2(X3, U, S2, A, B2) {
    return S2 = new F3(n.mul(S2.X, X3), S2.Y, S2.Z), U = zr2(A, U), S2 = zr2(B2, S2), U.add(S2);
  }
  const _F = class _F {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(U, S2, A) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      this.X = T("x", U), this.Y = T("y", S2, true), this.Z = T("z", A), Object.freeze(this);
    }
    static CURVE() {
      return o;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(U) {
      const { x: S2, y: A } = U || {};
      if (!U || !n.isValid(S2) || !n.isValid(A))
        throw new Error("invalid affine point");
      if (U instanceof _F)
        throw new Error("projective point not allowed");
      return n.is0(S2) && n.is0(A) ? _F.ZERO : new _F(S2, A, n.ONE);
    }
    static fromBytes(U) {
      const S2 = _F.fromAffine(m(ut3(U, void 0, "point")));
      return S2.assertValidity(), S2;
    }
    static fromHex(U) {
      return _F.fromBytes(Gr2(U));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(U = 8, S2 = true) {
      return Qt5.createCache(this, U), S2 || this.multiply(Or2), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      z4(this);
    }
    hasEvenY() {
      const { y: U } = this.toAffine();
      if (!n.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n.isOdd(U);
    }
    /** Compare one point to another. */
    equals(U) {
      _(U);
      const { X: S2, Y: A, Z: B2 } = this, { X: C, Y: V2, Z: $4 } = U, L = n.eql(n.mul(S2, $4), n.mul(C, B2)), D2 = n.eql(n.mul(A, $4), n.mul(V2, B2));
      return L && D2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _F(this.X, n.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: U, b: S2 } = o, A = n.mul(S2, Or2), { X: B2, Y: C, Z: V2 } = this;
      let $4 = n.ZERO, L = n.ZERO, D2 = n.ZERO, W3 = n.mul(B2, B2), ct5 = n.mul(C, C), G3 = n.mul(V2, V2), K3 = n.mul(B2, C);
      return K3 = n.add(K3, K3), D2 = n.mul(B2, V2), D2 = n.add(D2, D2), $4 = n.mul(U, D2), L = n.mul(A, G3), L = n.add($4, L), $4 = n.sub(ct5, L), L = n.add(ct5, L), L = n.mul($4, L), $4 = n.mul(K3, $4), D2 = n.mul(A, D2), G3 = n.mul(U, G3), K3 = n.sub(W3, G3), K3 = n.mul(U, K3), K3 = n.add(K3, D2), D2 = n.add(W3, W3), W3 = n.add(D2, W3), W3 = n.add(W3, G3), W3 = n.mul(W3, K3), L = n.add(L, W3), G3 = n.mul(C, V2), G3 = n.add(G3, G3), W3 = n.mul(G3, K3), $4 = n.sub($4, W3), D2 = n.mul(G3, ct5), D2 = n.add(D2, D2), D2 = n.add(D2, D2), new _F($4, L, D2);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(U) {
      _(U);
      const { X: S2, Y: A, Z: B2 } = this, { X: C, Y: V2, Z: $4 } = U;
      let L = n.ZERO, D2 = n.ZERO, W3 = n.ZERO;
      const ct5 = o.a, G3 = n.mul(o.b, Or2);
      let K3 = n.mul(S2, C), it4 = n.mul(A, V2), lt3 = n.mul(B2, $4), Nt5 = n.add(S2, A), st4 = n.add(C, V2);
      Nt5 = n.mul(Nt5, st4), st4 = n.add(K3, it4), Nt5 = n.sub(Nt5, st4), st4 = n.add(S2, B2);
      let yt5 = n.add(C, $4);
      return st4 = n.mul(st4, yt5), yt5 = n.add(K3, lt3), st4 = n.sub(st4, yt5), yt5 = n.add(A, B2), L = n.add(V2, $4), yt5 = n.mul(yt5, L), L = n.add(it4, lt3), yt5 = n.sub(yt5, L), W3 = n.mul(ct5, st4), L = n.mul(G3, lt3), W3 = n.add(L, W3), L = n.sub(it4, W3), W3 = n.add(it4, W3), D2 = n.mul(L, W3), it4 = n.add(K3, K3), it4 = n.add(it4, K3), lt3 = n.mul(ct5, lt3), st4 = n.mul(G3, st4), it4 = n.add(it4, lt3), lt3 = n.sub(K3, lt3), lt3 = n.mul(ct5, lt3), st4 = n.add(st4, lt3), K3 = n.mul(it4, st4), D2 = n.add(D2, K3), K3 = n.mul(yt5, st4), L = n.mul(Nt5, L), L = n.sub(L, K3), K3 = n.mul(Nt5, it4), W3 = n.mul(yt5, W3), W3 = n.add(W3, K3), new _F(L, D2, W3);
    }
    subtract(U) {
      return this.add(U.negate());
    }
    is0() {
      return this.equals(_F.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(U) {
      const { endo: S2 } = t;
      if (!i.isValidNot0(U))
        throw new Error("invalid scalar: out of range");
      let A, B2;
      const C = (V2) => Qt5.cached(this, V2, ($4) => Qi2(_F, $4));
      if (S2) {
        const { k1neg: V2, k1: $4, k2neg: L, k2: D2 } = M2(U), { p: W3, f: ct5 } = C($4), { p: G3, f: K3 } = C(D2);
        B2 = ct5.add(K3), A = Y2(S2.beta, W3, G3, V2, L);
      } else {
        const { p: V2, f: $4 } = C(U);
        A = V2, B2 = $4;
      }
      return Qi2(_F, [A, B2])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(U) {
      const { endo: S2 } = t, A = this;
      if (!i.isValid(U))
        throw new Error("invalid scalar: out of range");
      if (U === re3 || A.is0())
        return _F.ZERO;
      if (U === Ke4)
        return A;
      if (Qt5.hasCache(this))
        return this.multiply(U);
      if (S2) {
        const { k1neg: B2, k1: C, k2neg: V2, k2: $4 } = M2(U), { p1: L, p2: D2 } = ju2(_F, A, C, $4);
        return Y2(S2.beta, L, D2, B2, V2);
      } else
        return Qt5.unsafe(A, U);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(U) {
      return nt5(this, U);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: U } = t;
      return a === Ke4 ? true : U ? U(_F, this) : Qt5.unsafe(this, u).is0();
    }
    clearCofactor() {
      const { clearCofactor: U } = t;
      return a === Ke4 ? this : U ? U(_F, this) : this.multiplyUnsafe(a);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(a).is0();
    }
    toBytes(U = true) {
      return jr2(U, "isCompressed"), this.assertValidity(), y(_F, this, U);
    }
    toHex(U = true) {
      return un2(this.toBytes(U));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_F, "BASE", new _F(o.Gx, o.Gy, n.ONE));
  // zero / infinity / identity point
  __publicField(_F, "ZERO", new _F(n.ZERO, n.ONE, n.ZERO));
  // 0, 1, 0
  // math field
  __publicField(_F, "Fp", n);
  // scalar field
  __publicField(_F, "Fn", i);
  let F3 = _F;
  const Rt5 = i.BITS, Qt5 = new Gu2(F3, t.endo ? Math.ceil(Rt5 / 2) : Rt5);
  return F3.BASE.precompute(8), F3;
}
function Co2(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function Vo2(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * t.BYTES
  };
}
function Ju2(e, t = {}) {
  const { Fn: r } = e, n = t.randomBytes || yo2, i = Object.assign(Vo2(e.Fp, r), { seed: Bo2(r.ORDER) });
  function o(y) {
    try {
      const m = r.fromBytes(y);
      return r.isValidNot0(m);
    } catch {
      return false;
    }
  }
  function a(y, m) {
    const { publicKey: E2, publicKeyUncompressed: v } = i;
    try {
      const x = y.length;
      return m === true && x !== E2 || m === false && x !== v ? false : !!e.fromBytes(y);
    } catch {
      return false;
    }
  }
  function u(y = n(i.seed)) {
    return Wu2(ut3(y, i.seed, "seed"), r.ORDER);
  }
  function l(y, m = true) {
    return e.BASE.multiply(r.fromBytes(y)).toBytes(m);
  }
  function d(y) {
    const { secretKey: m, publicKey: E2, publicKeyUncompressed: v } = i;
    if (!hi2(y) || "_lengths" in r && r._lengths || m === E2)
      return;
    const x = ut3(y, void 0, "key").length;
    return x === E2 || x === v;
  }
  function f(y, m, E2 = true) {
    if (d(y) === true)
      throw new Error("first arg must be private key");
    if (d(m) === false)
      throw new Error("second arg must be public key");
    const v = r.fromBytes(y);
    return e.fromBytes(m).multiply(v).toBytes(E2);
  }
  const p = {
    isValidSecretKey: o,
    isValidPublicKey: a,
    randomSecretKey: u
  }, w = qu2(u, l);
  return Object.freeze({ getPublicKey: l, getSharedSecret: f, keygen: w, Point: e, utils: p, lengths: i });
}
function tf2(e, t, r = {}) {
  wo2(t), li2(r, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r = Object.assign({}, r);
  const n = r.randomBytes || yo2, i = r.hmac || ((S2, A) => Ho2(t, S2, A)), { Fp: o, Fn: a } = e, { ORDER: u, BITS: l } = a, { keygen: d, getPublicKey: f, getSharedSecret: p, utils: w, lengths: y } = Ju2(e, r), m = {
    prehash: true,
    lowS: typeof r.lowS == "boolean" ? r.lowS : true,
    format: "compact",
    extraEntropy: false
  }, E2 = u * Lo2 < o.ORDER;
  function v(S2) {
    const A = u >> Ke4;
    return S2 > A;
  }
  function x(S2, A) {
    if (!a.isValidNot0(A))
      throw new Error(`invalid signature ${S2}: out of range 1..Point.Fn.ORDER`);
    return A;
  }
  function O() {
    if (E2)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function T(S2, A) {
    Fn2(A);
    const B2 = y.signature, C = A === "compact" ? B2 : A === "recovered" ? B2 + 1 : void 0;
    return ut3(S2, C);
  }
  class _ {
    constructor(A, B2, C) {
      __publicField(this, "r");
      __publicField(this, "s");
      __publicField(this, "recovery");
      if (this.r = x("r", A), this.s = x("s", B2), C != null) {
        if (O(), ![0, 1, 2, 3].includes(C))
          throw new Error("invalid recovery id");
        this.recovery = C;
      }
      Object.freeze(this);
    }
    static fromBytes(A, B2 = m.format) {
      T(A, B2);
      let C;
      if (B2 === "der") {
        const { r: D2, s: W3 } = pe3.toSig(ut3(A));
        return new _(D2, W3);
      }
      B2 === "recovered" && (C = A[0], B2 = "compact", A = A.subarray(1));
      const V2 = y.signature / 2, $4 = A.subarray(0, V2), L = A.subarray(V2, V2 * 2);
      return new _(a.fromBytes($4), a.fromBytes(L), C);
    }
    static fromHex(A, B2) {
      return this.fromBytes(Gr2(A), B2);
    }
    assertRecovery() {
      const { recovery: A } = this;
      if (A == null)
        throw new Error("invalid recovery id: must be present");
      return A;
    }
    addRecoveryBit(A) {
      return new _(this.r, this.s, A);
    }
    recoverPublicKey(A) {
      const { r: B2, s: C } = this, V2 = this.assertRecovery(), $4 = V2 === 2 || V2 === 3 ? B2 + u : B2;
      if (!o.isValid($4))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const L = o.toBytes($4), D2 = e.fromBytes(de2(Co2((V2 & 1) === 0), L)), W3 = a.inv($4), ct5 = nt5(ut3(A, void 0, "msgHash")), G3 = a.create(-ct5 * W3), K3 = a.create(C * W3), it4 = e.BASE.multiplyUnsafe(G3).add(D2.multiplyUnsafe(K3));
      if (it4.is0())
        throw new Error("invalid recovery: point at infinify");
      return it4.assertValidity(), it4;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return v(this.s);
    }
    toBytes(A = m.format) {
      if (Fn2(A), A === "der")
        return Gr2(pe3.hexFromSig(this));
      const { r: B2, s: C } = this, V2 = a.toBytes(B2), $4 = a.toBytes(C);
      return A === "recovered" ? (O(), de2(Uint8Array.of(this.assertRecovery()), V2, $4)) : de2(V2, $4);
    }
    toHex(A) {
      return un2(this.toBytes(A));
    }
  }
  const M2 = r.bits2int || function(S2) {
    if (S2.length > 8192)
      throw new Error("input is too large");
    const A = fn2(S2), B2 = S2.length * 8 - l;
    return B2 > 0 ? A >> BigInt(B2) : A;
  }, nt5 = r.bits2int_modN || function(S2) {
    return a.create(M2(S2));
  }, z4 = ci2(l);
  function Y2(S2) {
    return Bu2("num < 2^" + l, S2, re3, z4), a.toBytes(S2);
  }
  function F3(S2, A) {
    return ut3(S2, void 0, "message"), A ? ut3(t(S2), void 0, "prehashed message") : S2;
  }
  function Rt5(S2, A, B2) {
    const { lowS: C, prehash: V2, extraEntropy: $4 } = Un2(B2, m);
    S2 = F3(S2, V2);
    const L = nt5(S2), D2 = a.fromBytes(A);
    if (!a.isValidNot0(D2))
      throw new Error("invalid private key");
    const W3 = [Y2(D2), Y2(L)];
    if ($4 != null && $4 !== false) {
      const it4 = $4 === true ? n(y.secretKey) : $4;
      W3.push(ut3(it4, void 0, "extraEntropy"));
    }
    const ct5 = de2(...W3), G3 = L;
    function K3(it4) {
      const lt3 = M2(it4);
      if (!a.isValidNot0(lt3))
        return;
      const Nt5 = a.inv(lt3), st4 = e.BASE.multiply(lt3).toAffine(), yt5 = a.create(st4.x);
      if (yt5 === re3)
        return;
      const Kt4 = a.create(Nt5 * a.create(G3 + yt5 * D2));
      if (Kt4 === re3)
        return;
      let Re3 = (st4.x === yt5 ? 0 : 2) | Number(st4.y & Ke4), Ye5 = Kt4;
      return C && v(Kt4) && (Ye5 = a.neg(Kt4), Re3 ^= 1), new _(yt5, Ye5, E2 ? void 0 : Re3);
    }
    return { seed: ct5, k2sig: K3 };
  }
  function Qt5(S2, A, B2 = {}) {
    const { seed: C, k2sig: V2 } = Rt5(S2, A, B2);
    return Ru2(t.outputLen, a.BYTES, i)(C, V2).toBytes(B2.format);
  }
  function X3(S2, A, B2, C = {}) {
    const { lowS: V2, prehash: $4, format: L } = Un2(C, m);
    if (B2 = ut3(B2, void 0, "publicKey"), A = F3(A, $4), !hi2(S2)) {
      const D2 = S2 instanceof _ ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + D2);
    }
    T(S2, L);
    try {
      const D2 = _.fromBytes(S2, L), W3 = e.fromBytes(B2);
      if (V2 && D2.hasHighS())
        return false;
      const { r: ct5, s: G3 } = D2, K3 = nt5(A), it4 = a.inv(G3), lt3 = a.create(K3 * it4), Nt5 = a.create(ct5 * it4), st4 = e.BASE.multiplyUnsafe(lt3).add(W3.multiplyUnsafe(Nt5));
      return st4.is0() ? false : a.create(st4.x) === ct5;
    } catch {
      return false;
    }
  }
  function U(S2, A, B2 = {}) {
    const { prehash: C } = Un2(B2, m);
    return A = F3(A, C), _.fromBytes(S2, "recovered").recoverPublicKey(A).toBytes();
  }
  return Object.freeze({
    keygen: d,
    getPublicKey: f,
    getSharedSecret: p,
    utils: w,
    lengths: y,
    Point: e,
    sign: Qt5,
    verify: X3,
    recoverPublicKey: U,
    Signature: _,
    hash: t
  });
}
var di2 = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var ef2 = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var ns2 = BigInt(2);
function rf2(e) {
  const t = di2.p, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), a = BigInt(23), u = BigInt(44), l = BigInt(88), d = e * e * e % t, f = d * d * e % t, p = Ht4(f, r, t) * f % t, w = Ht4(p, r, t) * f % t, y = Ht4(w, ns2, t) * d % t, m = Ht4(y, i, t) * y % t, E2 = Ht4(m, o, t) * m % t, v = Ht4(E2, u, t) * E2 % t, x = Ht4(v, l, t) * v % t, O = Ht4(x, u, t) * E2 % t, T = Ht4(O, r, t) * f % t, _ = Ht4(T, a, t) * m % t, M2 = Ht4(_, n, t) * d % t, nt5 = Ht4(M2, ns2, t);
  if (!Wn2.eql(Wn2.sqr(nt5), e))
    throw new Error("Cannot find square root");
  return nt5;
}
var Wn2 = cn2(di2.p, { sqrt: rf2 });
var nf2 = Qu2(di2, {
  Fp: Wn2,
  endo: ef2
});
var sf2 = tf2(nf2, ku2);
var of2 = sf2.Point;
of2.Fn.ORDER;
function H(e) {
  return wu2(e);
}
function Z(e, t) {
  if (!e) throw new Error(`verifyCryptoBackend: ${t}`);
}
function af2(e) {
  Z(
    e.isPoint(H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPoint should accept generator point"
  ), Z(
    !e.isPoint(H("030000000000000000000000000000000000000000000000000000000000000005")),
    "isPoint should reject invalid point"
  ), Z(
    e.isXOnlyPoint(
      H("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "isXOnlyPoint should accept generator x-coordinate"
  ), Z(
    !e.isXOnlyPoint(
      H("0000000000000000000000000000000000000000000000000000000000000005")
    ),
    "isXOnlyPoint should reject x-coordinate not on curve"
  ), Z(
    !e.isXOnlyPoint(
      H("0000000000000000000000000000000000000000000000000000000000000000")
    ),
    "isXOnlyPoint should reject zero"
  ), Z(
    !e.isXOnlyPoint(H("79be667ef9dcbbac55a06295ce870b07")),
    "isXOnlyPoint should reject wrong length"
  ), Z(
    e.isPrivate(H("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPrivate should accept valid scalar"
  ), Z(
    e.isPrivate(H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")),
    "isPrivate should accept n-1"
  ), Z(
    !e.isPrivate(H("0000000000000000000000000000000000000000000000000000000000000000")),
    "isPrivate should reject zero"
  ), Z(
    !e.isPrivate(H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")),
    "isPrivate should reject n"
  ), Z(
    !e.isPrivate(H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")),
    "isPrivate should reject n+1"
  );
  const t = e.privateAdd(
    H("0000000000000000000000000000000000000000000000000000000000000001"),
    H("0000000000000000000000000000000000000000000000000000000000000000")
  );
  Z(
    t !== null && Ut4(
      t,
      H("0000000000000000000000000000000000000000000000000000000000000001")
    ),
    "privateAdd: 1 + 0 should equal 1"
  ), Z(
    e.privateAdd(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      H("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null,
    "privateAdd: (n-3) + 3 should return null (result is zero mod n)"
  );
  const r = e.privateAdd(
    H("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
    H("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
  );
  Z(
    r !== null && Ut4(
      r,
      H("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    ),
    "privateAdd: known vector failed"
  ), Z(
    Ut4(
      e.privateNegate(
        H("0000000000000000000000000000000000000000000000000000000000000001")
      ),
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ),
    "privateNegate(1) should equal n-1"
  ), Z(
    Ut4(
      e.privateNegate(
        H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      ),
      H("0000000000000000000000000000000000000000000000000000000000000003")
    ),
    "privateNegate(n-3) should equal 3"
  ), Z(
    Ut4(
      e.privateNegate(
        H("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      ),
      H("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    ),
    "privateNegate known vector failed"
  ), Z(
    Ut4(
      e.pointCompress(
        H(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        true
      ),
      H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress uncompressed->compressed failed"
  ), Z(
    Ut4(
      e.pointCompress(
        H(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        false
      ),
      H(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress uncompressed->uncompressed failed"
  ), Z(
    Ut4(
      e.pointCompress(
        H(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        true
      ),
      H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress compressed->compressed failed"
  ), Z(
    Ut4(
      e.pointCompress(
        H(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        false
      ),
      H(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress compressed->uncompressed failed"
  );
  const n = e.pointFromScalar(
    H("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
  );
  Z(
    n !== null && Ut4(
      n,
      H("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    ),
    "pointFromScalar known vector failed"
  ), Z(
    e.xOnlyPointAddTweak(
      H("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null,
    "xOnlyPointAddTweak should return null for infinity result"
  );
  let i = e.xOnlyPointAddTweak(
    H("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    H("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  Z(
    i !== null && Ut4(
      i.xOnlyPubkey,
      H("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && i.parity === 1,
    "xOnlyPointAddTweak parity=1 case failed"
  ), i = e.xOnlyPointAddTweak(
    H("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    H("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), Z(
    i !== null && Ut4(
      i.xOnlyPubkey,
      H("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && i.parity === 0,
    "xOnlyPointAddTweak parity=0 case failed"
  );
  const o = e.sign(
    H("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
    H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
  );
  if (Z(
    Ut4(
      o,
      H(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    ),
    "sign known vector failed"
  ), Z(
    e.verify(
      H("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      H("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      o
    ),
    "verify known vector failed"
  ), e.signSchnorr) {
    const a = e.signSchnorr(
      H("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      H("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
      H("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
    );
    Z(
      Ut4(
        a,
        H(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      ),
      "signSchnorr known vector failed"
    );
  }
  e.verifySchnorr && Z(
    e.verifySchnorr(
      H(
        "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"
      ),
      H(
        "dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"
      ),
      H(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    ),
    "verifySchnorr known vector failed"
  );
}
var _t11, _a17;
var _xt = class _xt {
  constructor(t) {
    __privateAdd(this, _a17);
    __privateSet(this, _a17, t);
  }
  /**
   * The underlying ECC library instance.
   */
  get lib() {
    return __privateGet(this, _a17);
  }
  /**
   * Initializes the ECC context with the provided library.
   * The library is verified before being set as active.
   *
   * @param lib - The CryptoBackend instance to initialize
   * @returns The initialized EccContext instance
   * @throws Error if the CryptoBackend fails verification
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   * import { createNobleBackend } from '@btc-vision/ecpair';
   *
   * const context = EccContext.init(createNobleBackend());
   * ```
   */
  static init(t) {
    return __privateGet(_xt, _t11) && __privateGet(__privateGet(_xt, _t11), _a17) === t ? __privateGet(_xt, _t11) : (af2(t), __privateSet(_xt, _t11, new _xt(t)), __privateGet(_xt, _t11));
  }
  /**
   * Gets the initialized ECC context.
   *
   * @returns The EccContext instance
   * @throws Error if the context has not been initialized
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * const context = EccContext.get();
   * const tweaked = context.lib.xOnlyPointAddTweak(key, tweak);
   * ```
   */
  static get() {
    if (!__privateGet(_xt, _t11))
      throw new Error(
        "ECC library not initialized. Call EccContext.init() or initEccLib() first."
      );
    return __privateGet(_xt, _t11);
  }
  /**
   * Clears the ECC context.
   * Useful for testing or when reinitializing with a different library.
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * EccContext.clear();
   * // Context is now uninitialized
   * ```
   */
  static clear() {
    __privateSet(_xt, _t11, void 0);
  }
  /**
   * Checks if the ECC context has been initialized.
   *
   * @returns True if initialized
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * if (!EccContext.isInitialized()) {
   *     EccContext.init(createNobleBackend());
   * }
   * ```
   */
  static isInitialized() {
    return __privateGet(_xt, _t11) !== void 0;
  }
};
_t11 = new WeakMap();
_a17 = new WeakMap();
__privateAdd(_xt, _t11);
var xt4 = _xt;
function gp2(e) {
  if (e === void 0) {
    xt4.clear();
    return;
  }
  xt4.init(e);
}
function hf2() {
  return xt4.get().lib;
}
var Ge3 = 192;
var $o2 = 128;
var uf2 = (e) => "left" in e && "right" in e;
function qr2(e, t) {
  if (e.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 33.`
    );
  const r = (e.length - 33) / 32;
  let n = t;
  for (let i = 0; i < r; i++) {
    const o = e.subarray(33 + 32 * i, 65 + 32 * i);
    Fe3(n, o) < 0 ? n = je4(n, o) : n = je4(o, n);
  }
  return n;
}
function fr2(e, t) {
  if (e.length < 1)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 1.`
    );
  const r = (e.length - 1) / 32;
  let n = t;
  for (let i = 0; i < r; i++) {
    const o = e.subarray(1 + 32 * i, 33 + 32 * i);
    Fe3(n, o) < 0 ? n = je4(n, o) : n = je4(o, n);
  }
  return n;
}
function cr2(e) {
  if (Ms2(e)) return { hash: Pt3(e) };
  const t = [cr2(e[0]), cr2(e[1])];
  t.sort((i, o) => Fe3(i.hash, o.hash));
  const r = t[0], n = t[1];
  return {
    hash: je4(r.hash, n.hash),
    left: r,
    right: n
  };
}
function Be3(e, t) {
  if (uf2(e)) {
    const r = Be3(e.left, t);
    if (r !== void 0) return [...r, e.right.hash];
    const n = Be3(e.right, t);
    if (n !== void 0) return [...n, e.left.hash];
  } else if (P(e.hash, t))
    return [];
}
function Pt3(e) {
  const t = e.version || Ge3;
  return wr2(
    "TapLeaf",
    _t7([new Uint8Array([t]), cf2(e.output)])
  );
}
function ff2(e, t) {
  return wr2("TapTweak", t ? _t7([e, t]) : e);
}
function ir2(e, t) {
  if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
  const r = ff2(e, t), n = hf2().xOnlyPointAddTweak(e, r);
  return !n || n.xOnlyPubkey === null ? null : {
    parity: n.parity,
    x: new Uint8Array(n.xOnlyPubkey)
  };
}
function je4(e, t) {
  return wr2("TapBranch", _t7([e, t]));
}
function cf2(e) {
  const t = $t4(e.length), r = Et4(t);
  return we4(e.length, r), _t7([r, e]);
}
var is2 = q2;
var ss2 = 2;
var lf2 = 80;
var _a18, _t12, _a19, _e13, _s6, _r6, _n6, _i7, _o7, _h6, _f5, _u6, _c5, _p5, _l5, _d4, _w4, _g5, _y5, _m5, _E3, _I3, _v3, _b4, _S3, _A3, _T3, _k2, _sr_instances, O_fn2, U_fn3, x_fn3, P_fn3, B_fn3, __fn3, R_fn3, N_fn3, H_fn3, L_fn3;
var Ko2 = (_a18 = class {
  /**
   * Creates a new P2MR payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded address (bc1z...)
   * @param params.hash - Merkle root (32 bytes, = witness program)
   * @param params.scriptTree - Full script tree definition
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack
   * @param params.redeem - Redeem script for script-path spending
   * @param params.redeemVersion - Leaf version (defaults to LEAF_VERSION_TAPSCRIPT)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _sr_instances);
    __privateAdd(this, _t12);
    __privateAdd(this, _a19);
    __privateAdd(this, _e13);
    __privateAdd(this, _s6);
    __privateAdd(this, _r6);
    __privateAdd(this, _n6);
    __privateAdd(this, _i7);
    __privateAdd(this, _o7);
    __privateAdd(this, _h6);
    __privateAdd(this, _f5);
    __privateAdd(this, _u6);
    __privateAdd(this, _c5);
    __privateAdd(this, _p5);
    __privateAdd(this, _l5);
    __privateAdd(this, _d4);
    __privateAdd(this, _w4, false);
    __privateAdd(this, _g5, false);
    __privateAdd(this, _y5, false);
    __privateAdd(this, _m5, false);
    __privateAdd(this, _E3, false);
    __privateAdd(this, _I3, false);
    __privateAdd(this, _v3);
    __privateAdd(this, _b4, false);
    __privateAdd(this, _S3);
    __privateAdd(this, _A3, false);
    __privateAdd(this, _T3);
    __privateAdd(this, _k2, false);
    __privateSet(this, _t12, t.network ?? kt3), __privateSet(this, _a19, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e13, t.address), __privateSet(this, _s6, t.hash), __privateSet(this, _r6, t.scriptTree), __privateSet(this, _n6, t.output), __privateSet(this, _i7, t.witness), __privateSet(this, _o7, t.redeem), __privateSet(this, _h6, t.redeemVersion), __privateGet(this, _a19).validate && __privateMethod(this, _sr_instances, L_fn3).call(this);
  }
  /**
   * Payment type discriminant.
   *
   * @returns The P2MR payment type constant.
   */
  get name() {
    return ft4.P2MR;
  }
  /**
   * Network parameters used for address encoding.
   *
   * @returns The network configuration (mainnet, testnet, or regtest).
   */
  get network() {
    return __privateGet(this, _t12);
  }
  /**
   * Bech32m encoded address (bc1z... for mainnet).
   *
   * @returns The bech32m-encoded address, or `undefined` if insufficient data.
   */
  get address() {
    return __privateGet(this, _w4) || (__privateSet(this, _f5, __privateMethod(this, _sr_instances, P_fn3).call(this)), __privateSet(this, _w4, true)), __privateGet(this, _f5);
  }
  /**
   * Merkle root hash (32 bytes). This is the witness program and directly
   * appears in the output script.
   *
   * @returns The 32-byte merkle root, or `undefined` if insufficient data.
   */
  get hash() {
    return __privateGet(this, _g5) || (__privateSet(this, _u6, __privateMethod(this, _sr_instances, B_fn3).call(this)), __privateSet(this, _g5, true)), __privateGet(this, _u6);
  }
  /**
   * The scriptPubKey: `OP_2 <32-byte merkle root>` (34 bytes total).
   *
   * @returns The output script, or `undefined` if insufficient data.
   */
  get output() {
    return __privateGet(this, _y5) || (__privateSet(this, _c5, __privateMethod(this, _sr_instances, __fn3).call(this)), __privateSet(this, _y5, true)), __privateGet(this, _c5);
  }
  /**
   * Redeem script information for script-path spending.
   *
   * @returns The redeem script data, or `undefined` if not available.
   */
  get redeem() {
    return __privateGet(this, _m5) || (__privateSet(this, _p5, __privateMethod(this, _sr_instances, R_fn3).call(this)), __privateSet(this, _m5, true)), __privateGet(this, _p5);
  }
  /**
   * Leaf version used for script-path hashing.
   *
   * @returns The leaf version byte (defaults to LEAF_VERSION_TAPSCRIPT = 0xc0).
   */
  get redeemVersion() {
    return __privateGet(this, _E3) || (__privateSet(this, _l5, __privateMethod(this, _sr_instances, N_fn3).call(this)), __privateSet(this, _E3, true)), __privateGet(this, _l5) ?? Ge3;
  }
  /**
   * Witness stack for script-path spending.
   * Format: `[script inputs..., script, control block]`
   *
   * @returns The witness stack array, or `undefined` if insufficient data.
   */
  get witness() {
    return __privateGet(this, _I3) || (__privateSet(this, _d4, __privateMethod(this, _sr_instances, H_fn3).call(this)), __privateSet(this, _I3, true)), __privateGet(this, _d4);
  }
  /**
   * Creates a P2MR payment from a script tree.
   *
   * @param scriptTree - The script tree
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromScriptTree(t, r) {
    return new _a18({ scriptTree: t, network: r });
  }
  /**
   * Creates a P2MR payment from a bech32m address.
   *
   * @param address - Bech32m encoded address (bc1z...)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromAddress(t, r) {
    return new _a18({ address: t, network: r });
  }
  /**
   * Creates a P2MR payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromOutput(t, r) {
    return new _a18({ output: t, network: r });
  }
  /**
   * Creates a P2MR payment from a merkle root hash.
   *
   * @param hash - The 32-byte merkle root
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromHash(t, r) {
    return new _a18({ hash: t, network: r });
  }
  /**
   * Converts to a plain P2MRPayment object for backwards compatibility.
   *
   * @returns A P2MRPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      scriptTree: __privateGet(this, _r6),
      output: this.output,
      redeem: this.redeem,
      redeemVersion: this.redeemVersion,
      witness: this.witness
    };
  }
}, _t12 = new WeakMap(), _a19 = new WeakMap(), _e13 = new WeakMap(), _s6 = new WeakMap(), _r6 = new WeakMap(), _n6 = new WeakMap(), _i7 = new WeakMap(), _o7 = new WeakMap(), _h6 = new WeakMap(), _f5 = new WeakMap(), _u6 = new WeakMap(), _c5 = new WeakMap(), _p5 = new WeakMap(), _l5 = new WeakMap(), _d4 = new WeakMap(), _w4 = new WeakMap(), _g5 = new WeakMap(), _y5 = new WeakMap(), _m5 = new WeakMap(), _E3 = new WeakMap(), _I3 = new WeakMap(), _v3 = new WeakMap(), _b4 = new WeakMap(), _S3 = new WeakMap(), _A3 = new WeakMap(), _T3 = new WeakMap(), _k2 = new WeakMap(), _sr_instances = new WeakSet(), O_fn2 = function() {
  if (!__privateGet(this, _b4)) {
    if (__privateGet(this, _e13)) {
      const t = dr2(__privateGet(this, _e13));
      t && __privateSet(this, _v3, {
        version: t.version,
        prefix: t.prefix,
        data: t.data
      });
    }
    __privateSet(this, _b4, true);
  }
  return __privateGet(this, _v3);
}, U_fn3 = function() {
  if (!__privateGet(this, _A3)) {
    if (__privateGet(this, _i7) && __privateGet(this, _i7).length > 0) {
      const t = __privateGet(this, _i7)[__privateGet(this, _i7).length - 1];
      __privateGet(this, _i7).length >= 2 && t && t[0] === lf2 ? __privateSet(this, _S3, __privateGet(this, _i7).slice(0, -1)) : __privateSet(this, _S3, __privateGet(this, _i7).slice());
    }
    __privateSet(this, _A3, true);
  }
  return __privateGet(this, _S3);
}, x_fn3 = function() {
  return __privateGet(this, _k2) || (__privateGet(this, _r6) ? __privateSet(this, _T3, cr2(__privateGet(this, _r6))) : __privateGet(this, _s6) && __privateSet(this, _T3, { hash: __privateGet(this, _s6) }), __privateSet(this, _k2, true)), __privateGet(this, _T3);
}, P_fn3 = function() {
  if (__privateGet(this, _e13))
    return __privateGet(this, _e13);
  const t = this.hash;
  if (!t) return;
  const r = J2.bech32m.toWords(t);
  return r.unshift(ss2), J2.bech32m.encode(__privateGet(this, _t12).bech32, r);
}, B_fn3 = function() {
  var _a37;
  if (__privateGet(this, _s6))
    return __privateGet(this, _s6);
  const t = __privateMethod(this, _sr_instances, x_fn3).call(this);
  if (t)
    return t.hash;
  if (__privateGet(this, _n6))
    return __privateGet(this, _n6).subarray(2);
  if (__privateGet(this, _e13))
    return (_a37 = __privateMethod(this, _sr_instances, O_fn2).call(this)) == null ? void 0 : _a37.data;
  const r = __privateMethod(this, _sr_instances, U_fn3).call(this);
  if (r && r.length > 1) {
    const n = r[r.length - 1], i = n[0] & Se3, o = r[r.length - 2], a = Pt3({
      output: o,
      version: i
    });
    return fr2(n, a);
  }
}, __fn3 = function() {
  if (__privateGet(this, _n6))
    return __privateGet(this, _n6);
  const t = this.hash;
  if (t)
    return gt3([is2.OP_2, t]);
}, R_fn3 = function() {
  if (__privateGet(this, _o7))
    return __privateGet(this, _o7);
  const t = __privateMethod(this, _sr_instances, U_fn3).call(this);
  if (!t || t.length < 2)
    return;
  const r = t[t.length - 1];
  return {
    output: t[t.length - 2],
    witness: t.slice(0, -2),
    redeemVersion: r[0] & Se3
  };
}, N_fn3 = function() {
  return __privateGet(this, _h6) !== void 0 ? __privateGet(this, _h6) : __privateGet(this, _o7) && __privateGet(this, _o7).redeemVersion !== void 0 && __privateGet(this, _o7).redeemVersion !== null ? __privateGet(this, _o7).redeemVersion : Ge3;
}, H_fn3 = function() {
  var _a37;
  if (__privateGet(this, _i7))
    return __privateGet(this, _i7);
  const t = __privateMethod(this, _sr_instances, x_fn3).call(this);
  if (t && ((_a37 = __privateGet(this, _o7)) == null ? void 0 : _a37.output)) {
    const r = Pt3({
      output: __privateGet(this, _o7).output,
      version: this.redeemVersion
    }), n = Be3(t, r);
    if (!n) return;
    const i = this.redeemVersion ?? 192, o = _t7([
      new Uint8Array([i | 1]),
      ...n
    ]);
    return [__privateGet(this, _o7).output, o];
  }
}, L_fn3 = function() {
  var _a37;
  let t = new Uint8Array(0);
  if (__privateGet(this, _e13)) {
    const i = __privateMethod(this, _sr_instances, O_fn2).call(this);
    if (!i)
      throw new TypeError("Invalid address");
    if (__privateGet(this, _t12) && __privateGet(this, _t12).bech32 !== i.prefix)
      throw new TypeError("Invalid prefix or Network mismatch");
    if (i.version !== ss2)
      throw new TypeError("Invalid address version");
    if (i.data.length !== 32)
      throw new TypeError("Invalid address data");
    t = i.data;
  }
  if (__privateGet(this, _n6)) {
    if (__privateGet(this, _n6).length !== 34 || __privateGet(this, _n6)[0] !== is2.OP_2 || __privateGet(this, _n6)[1] !== 32)
      throw new TypeError("Output is invalid");
    if (t.length > 0 && !P(t, __privateGet(this, _n6).subarray(2)))
      throw new TypeError("Hash mismatch");
    t = __privateGet(this, _n6).subarray(2);
  }
  if (__privateGet(this, _s6)) {
    if (__privateGet(this, _s6).length !== 32)
      throw new TypeError("Invalid hash length");
    if (t.length > 0 && !P(t, __privateGet(this, _s6)))
      throw new TypeError("Hash mismatch");
  }
  const r = __privateMethod(this, _sr_instances, x_fn3).call(this);
  if (__privateGet(this, _s6) && r && !P(__privateGet(this, _s6), r.hash))
    throw new TypeError("Hash mismatch");
  if (((_a37 = __privateGet(this, _o7)) == null ? void 0 : _a37.output) && r) {
    const i = Pt3({
      output: __privateGet(this, _o7).output,
      version: this.redeemVersion
    });
    if (!Be3(r, i))
      throw new TypeError("Redeem script not in tree");
  }
  const n = __privateMethod(this, _sr_instances, U_fn3).call(this);
  if (__privateGet(this, _o7) && this.redeem) {
    if (__privateGet(this, _o7).redeemVersion && __privateGet(this, _o7).redeemVersion !== this.redeem.redeemVersion)
      throw new TypeError("Redeem.redeemVersion and witness mismatch");
    if (__privateGet(this, _o7).output) {
      const i = tt3(__privateGet(this, _o7).output);
      if (!i || i.length === 0)
        throw new TypeError("Redeem.output is invalid");
      if (this.redeem.output && !P(__privateGet(this, _o7).output, this.redeem.output))
        throw new TypeError("Redeem.output and witness mismatch");
    }
    if (__privateGet(this, _o7).witness && this.redeem.witness && !Oe3(__privateGet(this, _o7).witness, this.redeem.witness))
      throw new TypeError("Redeem.witness and witness mismatch");
  }
  if (n && n.length > 0) {
    if (n.length < 2)
      throw new TypeError(
        "P2MR requires at least 2 witness items (script + control block)"
      );
    const i = n[n.length - 1];
    if (i.length < 1)
      throw new TypeError(
        `The control-block length is too small. Got ${i.length}, expected min 1.`
      );
    if ((i.length - 1) % 32 !== 0)
      throw new TypeError(
        `The control-block length of ${i.length} is incorrect!`
      );
    const o = (i.length - 1) / 32;
    if (o > 128)
      throw new TypeError(`The script path is too long. Got ${o}, expected max 128.`);
    const a = i[0];
    if ((a & 1) !== 1)
      throw new TypeError("P2MR control byte parity bit must be 1");
    const u = a & Se3, l = n[n.length - 2], d = Pt3({
      output: l,
      version: u
    }), f = fr2(i, d);
    if (t.length > 0 && !P(t, f))
      throw new TypeError("Merkle root mismatch for p2mr witness");
  }
}, __publicField(_a18, "NAME", ft4.P2MR), _a18);
function wi2(e, t) {
  if (!e.address && !e.output && !e.hash && !e.scriptTree && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  const r = new Ko2(
    {
      address: e.address,
      hash: e.hash,
      scriptTree: e.scriptTree,
      output: e.output,
      witness: e.witness,
      redeem: e.redeem,
      redeemVersion: e.redeemVersion,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
var os2 = q2;
var as2 = 1;
var pf2 = 80;
var _a20, _t13, _a21, _e14, _s7, _r7, _n7, _i8, _o8, _h7, _f6, _u7, _c6, _p6, _l6, _d5, _w5, _g6, _y6, _m6, _E4, _I4, _v4, _b5, _S4, _A4, _T4, _k3, _O2, _U, _x, _P, _B, __, _R, _N, _H, _or_instances, L_fn4, C_fn2, V_fn, $_fn, K_fn, D_fn, M_fn, F_fn, W_fn, G_fn, j_fn, z_fn, q_fn;
var Do2 = (_a20 = class {
  /**
   * Creates a new P2TR payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded address (bc1p...)
   * @param params.pubkey - x-only output pubkey (32 bytes)
   * @param params.internalPubkey - x-only internal pubkey (32 bytes)
   * @param params.hash - Merkle root (32 bytes, or empty for key-path only)
   * @param params.scriptTree - Full script tree definition
   * @param params.signature - Schnorr signature (for key-path spending)
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack
   * @param params.redeem - Redeem script for script-path spending
   * @param params.redeemVersion - Leaf version (defaults to LEAF_VERSION_TAPSCRIPT)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _or_instances);
    // Private instance fields
    __privateAdd(this, _t13);
    __privateAdd(this, _a21);
    // Input data (provided by user)
    __privateAdd(this, _e14);
    __privateAdd(this, _s7);
    __privateAdd(this, _r7);
    __privateAdd(this, _n7);
    __privateAdd(this, _i8);
    __privateAdd(this, _o8);
    __privateAdd(this, _h7);
    __privateAdd(this, _f6);
    __privateAdd(this, _u7);
    __privateAdd(this, _c6);
    // Cached computed values
    __privateAdd(this, _p6);
    __privateAdd(this, _l6);
    __privateAdd(this, _d5);
    __privateAdd(this, _w5);
    __privateAdd(this, _g6);
    __privateAdd(this, _y6);
    __privateAdd(this, _m6);
    __privateAdd(this, _E4);
    __privateAdd(this, _I4);
    // Cache flags
    __privateAdd(this, _v4, false);
    __privateAdd(this, _b5, false);
    __privateAdd(this, _S4, false);
    __privateAdd(this, _A4, false);
    __privateAdd(this, _T4, false);
    __privateAdd(this, _k3, false);
    __privateAdd(this, _O2, false);
    __privateAdd(this, _U, false);
    __privateAdd(this, _x, false);
    // Decoded address cache
    __privateAdd(this, _P);
    __privateAdd(this, _B, false);
    // Witness without annex
    __privateAdd(this, __);
    __privateAdd(this, _R, false);
    // Hash tree cache
    __privateAdd(this, _N);
    __privateAdd(this, _H, false);
    __privateSet(this, _t13, t.network ?? kt3), __privateSet(this, _a21, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e14, t.address), __privateSet(this, _s7, t.pubkey), __privateSet(this, _r7, t.internalPubkey), __privateSet(this, _n7, t.hash), __privateSet(this, _i8, t.scriptTree), __privateSet(this, _o8, t.signature), __privateSet(this, _h7, t.output), __privateSet(this, _f6, t.witness), __privateSet(this, _u7, t.redeem), __privateSet(this, _c6, t.redeemVersion), __privateGet(this, _a21).validate && __privateMethod(this, _or_instances, q_fn).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ft4.P2TR;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t13);
  }
  /**
   * Bech32m encoded address (bc1p... for mainnet).
   */
  get address() {
    return __privateGet(this, _v4) || (__privateSet(this, _p6, __privateMethod(this, _or_instances, $_fn).call(this)), __privateSet(this, _v4, true)), __privateGet(this, _p6);
  }
  /**
   * x-only output pubkey (32 bytes).
   * This is the tweaked pubkey that appears in the output.
   */
  get pubkey() {
    return __privateGet(this, _b5) || (__privateSet(this, _l6, __privateMethod(this, _or_instances, K_fn).call(this)), __privateSet(this, _b5, true)), __privateGet(this, _l6);
  }
  /**
   * x-only internal pubkey (32 bytes).
   * This is the untweaked pubkey before adding the merkle root tweak.
   */
  get internalPubkey() {
    return __privateGet(this, _S4) || (__privateSet(this, _d5, __privateMethod(this, _or_instances, D_fn).call(this)), __privateSet(this, _S4, true)), __privateGet(this, _d5);
  }
  /**
   * Merkle root hash (32 bytes).
   * Present when a script tree is defined.
   */
  get hash() {
    return __privateGet(this, _A4) || (__privateSet(this, _w5, __privateMethod(this, _or_instances, M_fn).call(this)), __privateSet(this, _A4, true)), __privateGet(this, _w5);
  }
  /**
   * Schnorr signature (for key-path spending).
   */
  get signature() {
    return __privateGet(this, _T4) || (__privateSet(this, _g6, __privateMethod(this, _or_instances, F_fn).call(this)), __privateSet(this, _T4, true)), __privateGet(this, _g6);
  }
  /**
   * The scriptPubKey: `OP_1 {32-byte x-only pubkey}`
   */
  get output() {
    return __privateGet(this, _k3) || (__privateSet(this, _y6, __privateMethod(this, _or_instances, W_fn).call(this)), __privateSet(this, _k3, true)), __privateGet(this, _y6);
  }
  /**
   * Redeem script information (for script-path spending).
   */
  get redeem() {
    return __privateGet(this, _O2) || (__privateSet(this, _m6, __privateMethod(this, _or_instances, G_fn).call(this)), __privateSet(this, _O2, true)), __privateGet(this, _m6);
  }
  /**
   * Leaf version (defaults to LEAF_VERSION_TAPSCRIPT = 0xc0).
   */
  get redeemVersion() {
    return __privateGet(this, _U) || (__privateSet(this, _E4, __privateMethod(this, _or_instances, j_fn).call(this)), __privateSet(this, _U, true)), __privateGet(this, _E4) ?? Ge3;
  }
  /**
   * Witness stack.
   * Key-path: `[signature]`
   * Script-path: `[script inputs..., script, control block]`
   */
  get witness() {
    return __privateGet(this, _x) || (__privateSet(this, _I4, __privateMethod(this, _or_instances, z_fn).call(this)), __privateSet(this, _x, true)), __privateGet(this, _I4);
  }
  // Static factory methods
  /**
   * Creates a P2TR payment from an internal pubkey (key-path only).
   *
   * @param internalPubkey - x-only internal pubkey (32 bytes)
   * @param scriptTree - Optional script tree
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   *
   * @example
   * ```typescript
   * // Key-path only
   * const p2tr = P2TR.fromInternalPubkey(internalPubkey);
   *
   * // With script tree
   * const withScripts = P2TR.fromInternalPubkey(internalPubkey, scriptTree);
   * ```
   */
  static fromInternalPubkey(t, r, n) {
    return new _a20({ internalPubkey: t, scriptTree: r, network: n });
  }
  /**
   * Creates a P2TR payment from a bech32m address.
   *
   * @param address - Bech32m encoded address (bc1p...)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromAddress(t, r) {
    return new _a20({ address: t, network: r });
  }
  /**
   * Creates a P2TR payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromOutput(t, r) {
    return new _a20({ output: t, network: r });
  }
  /**
   * Creates a P2TR payment from a signature (for key-path spending).
   *
   * @param signature - Schnorr signature
   * @param internalPubkey - x-only internal pubkey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromSignature(t, r, n) {
    return new _a20({ signature: t, internalPubkey: r, network: n });
  }
  // Private helper methods
  /**
   * Converts to a plain P2TRPayment object for backwards compatibility.
   *
   * @returns A P2TRPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      pubkey: this.pubkey,
      internalPubkey: this.internalPubkey,
      hash: this.hash,
      scriptTree: __privateGet(this, _i8),
      signature: this.signature,
      output: this.output,
      redeem: this.redeem,
      redeemVersion: this.redeemVersion,
      witness: this.witness
    };
  }
}, _t13 = new WeakMap(), _a21 = new WeakMap(), _e14 = new WeakMap(), _s7 = new WeakMap(), _r7 = new WeakMap(), _n7 = new WeakMap(), _i8 = new WeakMap(), _o8 = new WeakMap(), _h7 = new WeakMap(), _f6 = new WeakMap(), _u7 = new WeakMap(), _c6 = new WeakMap(), _p6 = new WeakMap(), _l6 = new WeakMap(), _d5 = new WeakMap(), _w5 = new WeakMap(), _g6 = new WeakMap(), _y6 = new WeakMap(), _m6 = new WeakMap(), _E4 = new WeakMap(), _I4 = new WeakMap(), _v4 = new WeakMap(), _b5 = new WeakMap(), _S4 = new WeakMap(), _A4 = new WeakMap(), _T4 = new WeakMap(), _k3 = new WeakMap(), _O2 = new WeakMap(), _U = new WeakMap(), _x = new WeakMap(), _P = new WeakMap(), _B = new WeakMap(), __ = new WeakMap(), _R = new WeakMap(), _N = new WeakMap(), _H = new WeakMap(), _or_instances = new WeakSet(), L_fn4 = function() {
  if (!__privateGet(this, _B)) {
    if (__privateGet(this, _e14)) {
      const t = dr2(__privateGet(this, _e14));
      t && __privateSet(this, _P, {
        version: t.version,
        prefix: t.prefix,
        data: t.data
      });
    }
    __privateSet(this, _B, true);
  }
  return __privateGet(this, _P);
}, C_fn2 = function() {
  if (!__privateGet(this, _R)) {
    if (__privateGet(this, _f6) && __privateGet(this, _f6).length > 0) {
      const t = __privateGet(this, _f6)[__privateGet(this, _f6).length - 1];
      __privateGet(this, _f6).length >= 2 && t && t[0] === pf2 ? __privateSet(this, __, __privateGet(this, _f6).slice(0, -1)) : __privateSet(this, __, __privateGet(this, _f6).slice());
    }
    __privateSet(this, _R, true);
  }
  return __privateGet(this, __);
}, // Private computation methods
V_fn = function() {
  return __privateGet(this, _H) || (__privateGet(this, _i8) ? __privateSet(this, _N, cr2(__privateGet(this, _i8))) : __privateGet(this, _n7) && __privateSet(this, _N, { hash: __privateGet(this, _n7) }), __privateSet(this, _H, true)), __privateGet(this, _N);
}, $_fn = function() {
  if (__privateGet(this, _e14))
    return __privateGet(this, _e14);
  const t = this.pubkey;
  if (!t) return;
  const r = J2.bech32m.toWords(t);
  return r.unshift(as2), J2.bech32m.encode(__privateGet(this, _t13).bech32, r);
}, K_fn = function() {
  var _a37;
  if (__privateGet(this, _s7))
    return __privateGet(this, _s7);
  if (__privateGet(this, _h7))
    return __privateGet(this, _h7).subarray(2);
  if (__privateGet(this, _e14))
    return (_a37 = __privateMethod(this, _or_instances, L_fn4).call(this)) == null ? void 0 : _a37.data;
  const t = this.internalPubkey;
  if (t) {
    const r = ir2(t, this.hash);
    if (r)
      return r.x;
  }
}, D_fn = function() {
  if (__privateGet(this, _r7))
    return __privateGet(this, _r7);
  const t = __privateMethod(this, _or_instances, C_fn2).call(this);
  if (t && t.length > 1) {
    const r = t[t.length - 1];
    if (r)
      return r.subarray(1, 33);
  }
}, M_fn = function() {
  const t = __privateMethod(this, _or_instances, V_fn).call(this);
  if (t)
    return t.hash;
  const r = __privateMethod(this, _or_instances, C_fn2).call(this);
  if (r && r.length > 1) {
    const n = r[r.length - 1], i = n[0] & Se3, o = r[r.length - 2], a = Pt3({
      output: o,
      version: i
    });
    return qr2(n, a);
  }
}, F_fn = function() {
  if (__privateGet(this, _o8))
    return __privateGet(this, _o8);
  const t = __privateMethod(this, _or_instances, C_fn2).call(this);
  if (t && t.length === 1)
    return t[0];
}, W_fn = function() {
  if (__privateGet(this, _h7))
    return __privateGet(this, _h7);
  const t = this.pubkey;
  if (t)
    return gt3([os2.OP_1, t]);
}, G_fn = function() {
  if (__privateGet(this, _u7))
    return __privateGet(this, _u7);
  const t = __privateMethod(this, _or_instances, C_fn2).call(this);
  if (!t || t.length < 2)
    return;
  const r = t[t.length - 1];
  return {
    output: t[t.length - 2],
    witness: t.slice(0, -2),
    redeemVersion: r[0] & Se3
  };
}, j_fn = function() {
  return __privateGet(this, _c6) !== void 0 ? __privateGet(this, _c6) : __privateGet(this, _u7) && __privateGet(this, _u7).redeemVersion !== void 0 && __privateGet(this, _u7).redeemVersion !== null ? __privateGet(this, _u7).redeemVersion : Ge3;
}, // Validation
z_fn = function() {
  var _a37;
  if (__privateGet(this, _f6))
    return __privateGet(this, _f6);
  const t = __privateMethod(this, _or_instances, V_fn).call(this);
  if (t && ((_a37 = __privateGet(this, _u7)) == null ? void 0 : _a37.output) && __privateGet(this, _r7)) {
    const r = Pt3({
      output: __privateGet(this, _u7).output,
      version: this.redeemVersion
    }), n = Be3(t, r);
    if (!n) return;
    const i = ir2(__privateGet(this, _r7), t.hash);
    if (!i) return;
    const o = this.redeemVersion ?? 192, a = _t7([
      new Uint8Array([o | i.parity]),
      __privateGet(this, _r7),
      ...n
    ]);
    return [__privateGet(this, _u7).output, a];
  }
  if (__privateGet(this, _o8))
    return [__privateGet(this, _o8)];
}, q_fn = function() {
  var _a37;
  let t = new Uint8Array(0);
  if (__privateGet(this, _e14)) {
    const i = __privateMethod(this, _or_instances, L_fn4).call(this);
    if (!i)
      throw new TypeError("Invalid address");
    if (__privateGet(this, _t13) && __privateGet(this, _t13).bech32 !== i.prefix)
      throw new TypeError("Invalid prefix or Network mismatch");
    if (i.version !== as2)
      throw new TypeError("Invalid address version");
    if (i.data.length !== 32)
      throw new TypeError("Invalid address data");
    t = i.data;
  }
  if (__privateGet(this, _s7)) {
    if (t.length > 0 && !P(t, __privateGet(this, _s7)))
      throw new TypeError("Pubkey mismatch");
    t = __privateGet(this, _s7);
  }
  if (__privateGet(this, _h7)) {
    if (__privateGet(this, _h7).length !== 34 || __privateGet(this, _h7)[0] !== os2.OP_1 || __privateGet(this, _h7)[1] !== 32)
      throw new TypeError("Output is invalid");
    if (t.length > 0 && !P(t, __privateGet(this, _h7).subarray(2)))
      throw new TypeError("Pubkey mismatch");
    t = __privateGet(this, _h7).subarray(2);
  }
  if (__privateGet(this, _r7)) {
    const i = ir2(__privateGet(this, _r7), this.hash);
    if (!i)
      throw new TypeError("Invalid internal pubkey");
    if (t.length > 0 && !P(t, i.x))
      throw new TypeError("Pubkey mismatch");
    t = i.x;
  }
  const r = __privateMethod(this, _or_instances, V_fn).call(this);
  if (__privateGet(this, _n7) && r && !P(__privateGet(this, _n7), r.hash))
    throw new TypeError("Hash mismatch");
  if (((_a37 = __privateGet(this, _u7)) == null ? void 0 : _a37.output) && r) {
    const i = Pt3({
      output: __privateGet(this, _u7).output,
      version: this.redeemVersion
    });
    if (!Be3(r, i))
      throw new TypeError("Redeem script not in tree");
  }
  const n = __privateMethod(this, _or_instances, C_fn2).call(this);
  if (__privateGet(this, _u7) && this.redeem) {
    if (__privateGet(this, _u7).redeemVersion && __privateGet(this, _u7).redeemVersion !== this.redeem.redeemVersion)
      throw new TypeError("Redeem.redeemVersion and witness mismatch");
    if (__privateGet(this, _u7).output) {
      const i = tt3(__privateGet(this, _u7).output);
      if (!i || i.length === 0)
        throw new TypeError("Redeem.output is invalid");
      if (this.redeem.output && !P(__privateGet(this, _u7).output, this.redeem.output))
        throw new TypeError("Redeem.output and witness mismatch");
    }
    if (__privateGet(this, _u7).witness && this.redeem.witness && !Oe3(__privateGet(this, _u7).witness, this.redeem.witness))
      throw new TypeError("Redeem.witness and witness mismatch");
  }
  if (n && n.length > 0)
    if (n.length === 1) {
      const i = n[0];
      if (__privateGet(this, _o8) && !P(__privateGet(this, _o8), i))
        throw new TypeError("Signature mismatch");
    } else {
      const i = n[n.length - 1];
      if (i.length < 33)
        throw new TypeError(
          `The control-block length is too small. Got ${i.length}, expected min 33.`
        );
      if ((i.length - 33) % 32 !== 0)
        throw new TypeError(
          `The control-block length of ${i.length} is incorrect!`
        );
      const o = (i.length - 33) / 32;
      if (o > 128)
        throw new TypeError(`The script path is too long. Got ${o}, expected max 128.`);
      const a = i.subarray(1, 33);
      if (__privateGet(this, _r7) && !P(__privateGet(this, _r7), a))
        throw new TypeError("Internal pubkey mismatch");
      if (!xh2(a))
        throw new TypeError("Invalid internalPubkey for p2tr witness");
      const u = i[0], l = u & Se3, d = n[n.length - 2], f = Pt3({
        output: d,
        version: l
      }), p = qr2(i, f), w = ir2(a, p);
      if (!w)
        throw new TypeError("Invalid outputKey for p2tr witness");
      if (t.length > 0 && !P(t, w.x))
        throw new TypeError("Pubkey mismatch for p2tr witness");
      if (w.parity !== (u & 1))
        throw new Error("Incorrect parity");
    }
}, // Static public fields
__publicField(_a20, "NAME", ft4.P2TR), _a20);
function br2(e, t) {
  if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  const r = new Do2(
    {
      address: e.address,
      pubkey: e.pubkey,
      internalPubkey: e.internalPubkey,
      hash: e.hash,
      scriptTree: e.scriptTree,
      signature: e.signature,
      output: e.output,
      witness: e.witness,
      redeem: e.redeem,
      redeemVersion: e.redeemVersion,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
var hs2 = q2;
var df2 = new Uint8Array(0);
var _a22, _t14, _a23, _e15, _s8, _r8, _n8, _i9, _o9, _h8, _f7, _u8, _c7, _p7, _l7, _d6, _w6, _g7, _y7, _m7, _E5, _I5, _v5, _b6, _S5, _ar_instances, A_fn2, T_fn2, k_fn3, O_fn3, U_fn4, x_fn4, P_fn4, B_fn4, __fn4;
var Mo2 = (_a22 = class {
  /**
   * Creates a new P2WPKH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32 encoded address
   * @param params.hash - 20-byte witness program (pubkey hash)
   * @param params.pubkey - The public key (must be 33 bytes compressed)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack [signature, pubkey]
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _ar_instances);
    // Private instance fields
    __privateAdd(this, _t14);
    __privateAdd(this, _a23);
    // Input data (provided by user)
    __privateAdd(this, _e15);
    __privateAdd(this, _s8);
    __privateAdd(this, _r8);
    __privateAdd(this, _n8);
    __privateAdd(this, _i9);
    __privateAdd(this, _o9);
    // Cached computed values
    __privateAdd(this, _h8);
    __privateAdd(this, _f7);
    __privateAdd(this, _u8);
    __privateAdd(this, _c7);
    __privateAdd(this, _p7);
    __privateAdd(this, _l7);
    __privateAdd(this, _d6);
    // Cache flags
    __privateAdd(this, _w6, false);
    __privateAdd(this, _g7, false);
    __privateAdd(this, _y7, false);
    __privateAdd(this, _m7, false);
    __privateAdd(this, _E5, false);
    __privateAdd(this, _I5, false);
    __privateAdd(this, _v5, false);
    // Decoded address cache
    __privateAdd(this, _b6);
    __privateAdd(this, _S5, false);
    __privateSet(this, _t14, t.network ?? kt3), __privateSet(this, _a23, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e15, t.address), __privateSet(this, _s8, t.hash), __privateSet(this, _r8, t.pubkey), __privateSet(this, _n8, t.signature), __privateSet(this, _i9, t.output), __privateSet(this, _o9, t.witness), __privateGet(this, _a23).validate && __privateMethod(this, _ar_instances, __fn4).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ft4.P2WPKH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t14);
  }
  /**
   * Bech32 encoded address (bc1q... for mainnet).
   */
  get address() {
    return __privateGet(this, _w6) || (__privateSet(this, _h8, __privateMethod(this, _ar_instances, T_fn2).call(this)), __privateSet(this, _w6, true)), __privateGet(this, _h8);
  }
  /**
   * 20-byte witness program (RIPEMD160(SHA256(pubkey))).
   */
  get hash() {
    return __privateGet(this, _g7) || (__privateSet(this, _f7, __privateMethod(this, _ar_instances, k_fn3).call(this)), __privateSet(this, _g7, true)), __privateGet(this, _f7);
  }
  /**
   * The public key (33 bytes compressed).
   */
  get pubkey() {
    return __privateGet(this, _y7) || (__privateSet(this, _u8, __privateMethod(this, _ar_instances, O_fn3).call(this)), __privateSet(this, _y7, true)), __privateGet(this, _u8);
  }
  /**
   * The DER-encoded signature.
   */
  get signature() {
    return __privateGet(this, _m7) || (__privateSet(this, _c7, __privateMethod(this, _ar_instances, U_fn4).call(this)), __privateSet(this, _m7, true)), __privateGet(this, _c7);
  }
  /**
   * The scriptPubKey: `OP_0 {20-byte hash}`
   */
  get output() {
    return __privateGet(this, _E5) || (__privateSet(this, _p7, __privateMethod(this, _ar_instances, x_fn4).call(this)), __privateSet(this, _E5, true)), __privateGet(this, _p7);
  }
  /**
   * The scriptSig (always empty for native SegWit).
   */
  get input() {
    return __privateGet(this, _I5) || (__privateSet(this, _l7, __privateMethod(this, _ar_instances, P_fn4).call(this)), __privateSet(this, _I5, true)), __privateGet(this, _l7);
  }
  /**
   * Witness stack: `[signature, pubkey]`
   */
  get witness() {
    return __privateGet(this, _v5) || (__privateSet(this, _d6, __privateMethod(this, _ar_instances, B_fn4).call(this)), __privateSet(this, _v5, true)), __privateGet(this, _d6);
  }
  // Static factory methods
  /**
   * Creates a P2WPKH payment from a compressed public key.
   *
   * @param pubkey - The public key (must be 33 bytes compressed)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2WPKH.fromPubkey(pubkey);
   * const address = payment.address; // bc1q...
   * ```
   */
  static fromPubkey(t, r) {
    return new _a22({ pubkey: t, network: r });
  }
  /**
   * Creates a P2WPKH payment from a bech32 address.
   *
   * @param address - Bech32 encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2WPKH.fromAddress('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
   * const hash = payment.hash;
   * ```
   */
  static fromAddress(t, r) {
    return new _a22({ address: t, network: r });
  }
  /**
   * Creates a P2WPKH payment from a 20-byte witness program.
   *
   * @param hash - 20-byte witness program (pubkey hash)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   */
  static fromHash(t, r) {
    return new _a22({ hash: t, network: r });
  }
  /**
   * Creates a P2WPKH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   */
  static fromOutput(t, r) {
    return new _a22({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2WPKHPayment object for backwards compatibility.
   *
   * @returns A P2WPKHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
}, _t14 = new WeakMap(), _a23 = new WeakMap(), _e15 = new WeakMap(), _s8 = new WeakMap(), _r8 = new WeakMap(), _n8 = new WeakMap(), _i9 = new WeakMap(), _o9 = new WeakMap(), _h8 = new WeakMap(), _f7 = new WeakMap(), _u8 = new WeakMap(), _c7 = new WeakMap(), _p7 = new WeakMap(), _l7 = new WeakMap(), _d6 = new WeakMap(), _w6 = new WeakMap(), _g7 = new WeakMap(), _y7 = new WeakMap(), _m7 = new WeakMap(), _E5 = new WeakMap(), _I5 = new WeakMap(), _v5 = new WeakMap(), _b6 = new WeakMap(), _S5 = new WeakMap(), _ar_instances = new WeakSet(), // Private computation methods
A_fn2 = function() {
  if (!__privateGet(this, _S5)) {
    if (__privateGet(this, _e15)) {
      const t = J2.bech32.decode(__privateGet(this, _e15)), r = t.words.shift(), n = J2.bech32.fromWords(t.words);
      __privateSet(this, _b6, {
        version: r ?? 0,
        prefix: t.prefix,
        data: new Uint8Array(n)
      });
    }
    __privateSet(this, _S5, true);
  }
  return __privateGet(this, _b6);
}, T_fn2 = function() {
  if (__privateGet(this, _e15))
    return __privateGet(this, _e15);
  const t = this.hash;
  if (!t) return;
  const r = J2.bech32.toWords(t);
  return r.unshift(0), J2.bech32.encode(__privateGet(this, _t14).bech32, r);
}, k_fn3 = function() {
  var _a37;
  if (__privateGet(this, _s8))
    return __privateGet(this, _s8);
  if (__privateGet(this, _i9))
    return __privateGet(this, _i9).subarray(2, 22);
  if (__privateGet(this, _e15))
    return (_a37 = __privateMethod(this, _ar_instances, A_fn2).call(this)) == null ? void 0 : _a37.data;
  const t = __privateGet(this, _r8) ?? this.pubkey;
  if (t)
    return St3(t);
}, O_fn3 = function() {
  if (__privateGet(this, _r8))
    return __privateGet(this, _r8);
  if (__privateGet(this, _o9) && __privateGet(this, _o9).length >= 2)
    return __privateGet(this, _o9)[1];
}, U_fn4 = function() {
  if (__privateGet(this, _n8))
    return __privateGet(this, _n8);
  if (__privateGet(this, _o9) && __privateGet(this, _o9).length >= 1)
    return __privateGet(this, _o9)[0];
}, x_fn4 = function() {
  if (__privateGet(this, _i9))
    return __privateGet(this, _i9);
  const t = this.hash;
  if (t)
    return gt3([hs2.OP_0, t]);
}, P_fn4 = function() {
  if (this.witness)
    return df2;
}, // Validation
B_fn4 = function() {
  if (__privateGet(this, _o9))
    return __privateGet(this, _o9);
  if (!(!__privateGet(this, _r8) || !__privateGet(this, _n8)))
    return [__privateGet(this, _n8), __privateGet(this, _r8)];
}, __fn4 = function() {
  let t = new Uint8Array(0);
  if (__privateGet(this, _e15)) {
    const r = __privateMethod(this, _ar_instances, A_fn2).call(this);
    if (!r)
      throw new TypeError("Invalid address");
    if (__privateGet(this, _t14) && __privateGet(this, _t14).bech32 !== r.prefix)
      throw new TypeError("Invalid prefix or Network mismatch");
    if (r.version !== 0)
      throw new TypeError("Invalid address version");
    if (r.data.length !== 20)
      throw new TypeError("Invalid address data");
    t = r.data;
  }
  if (__privateGet(this, _s8)) {
    if (t.length > 0 && !P(t, __privateGet(this, _s8)))
      throw new TypeError("Hash mismatch");
    t = __privateGet(this, _s8);
  }
  if (__privateGet(this, _i9)) {
    if (__privateGet(this, _i9).length !== 22 || __privateGet(this, _i9)[0] !== hs2.OP_0 || __privateGet(this, _i9)[1] !== 20)
      throw new TypeError("Output is invalid");
    if (t.length > 0 && !P(t, __privateGet(this, _i9).subarray(2)))
      throw new TypeError("Hash mismatch");
    t = __privateGet(this, _i9).subarray(2);
  }
  if (__privateGet(this, _r8)) {
    const r = St3(__privateGet(this, _r8));
    if (t.length > 0 && !P(t, r))
      throw new TypeError("Hash mismatch");
    if (t = r, !xe3(__privateGet(this, _r8)) || __privateGet(this, _r8).length !== 33)
      throw new TypeError("Invalid pubkey for p2wpkh");
  }
  if (__privateGet(this, _o9)) {
    if (__privateGet(this, _o9).length !== 2)
      throw new TypeError("Witness is invalid");
    const r = __privateGet(this, _o9)[0], n = __privateGet(this, _o9)[1];
    if (!_e9(r))
      throw new TypeError("Witness has invalid signature");
    if (!xe3(n) || n.length !== 33)
      throw new TypeError("Witness has invalid pubkey");
    if (__privateGet(this, _n8) && !P(__privateGet(this, _n8), r))
      throw new TypeError("Signature mismatch");
    if (__privateGet(this, _r8) && !P(__privateGet(this, _r8), n))
      throw new TypeError("Pubkey mismatch");
    const i = St3(n);
    if (t.length > 0 && !P(t, i))
      throw new TypeError("Hash mismatch");
  }
}, // Static public fields
__publicField(_a22, "NAME", ft4.P2WPKH), _a22);
function ln2(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  const r = new Mo2(
    {
      address: e.address,
      hash: e.hash,
      pubkey: e.pubkey,
      signature: e.signature,
      output: e.output,
      witness: e.witness,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
var us2 = q2;
var xn2 = new Uint8Array(0);
function Pr2(e) {
  return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && xe3(e));
}
var _t15, _a24, _e16, _s9, _r9, _n9, _i10, _o10, _h9, _f8, _u9, _c8, _p8, _l8, _d7, _w7, _g8, _y8, _m8, _E6, _I6, _v6, _b7, _Ae_instances, S_fn2, A_fn3, T_fn3, k_fn4, O_fn4, U_fn5, x_fn5, P_fn5, B_fn5;
var _Ae = class _Ae {
  /**
   * Creates a new P2WSH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32 encoded address
   * @param params.hash - 32-byte witness program (SHA256 of script)
   * @param params.output - The scriptPubKey
   * @param params.redeem - The redeem script information
   * @param params.witness - The witness stack
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _Ae_instances);
    // Private instance fields
    __privateAdd(this, _t15);
    __privateAdd(this, _a24);
    // Input data (provided by user)
    __privateAdd(this, _e16);
    __privateAdd(this, _s9);
    __privateAdd(this, _r9);
    __privateAdd(this, _n9);
    __privateAdd(this, _i10);
    // Cached computed values
    __privateAdd(this, _o10);
    __privateAdd(this, _h9);
    __privateAdd(this, _f8);
    __privateAdd(this, _u9);
    __privateAdd(this, _c8);
    __privateAdd(this, _p8);
    // Cache flags
    __privateAdd(this, _l8, false);
    __privateAdd(this, _d7, false);
    __privateAdd(this, _w7, false);
    __privateAdd(this, _g8, false);
    __privateAdd(this, _y8, false);
    __privateAdd(this, _m8, false);
    // Decoded address cache
    __privateAdd(this, _E6);
    __privateAdd(this, _I6, false);
    // Decoded redeem chunks cache
    __privateAdd(this, _v6);
    __privateAdd(this, _b7, false);
    let n = t.network;
    n || (n = t.redeem && t.redeem.network || kt3), __privateSet(this, _t15, n), __privateSet(this, _a24, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e16, t.address), __privateSet(this, _s9, t.hash), __privateSet(this, _r9, t.output), __privateSet(this, _n9, t.redeem), __privateSet(this, _i10, t.witness), __privateGet(this, _a24).validate && __privateMethod(this, _Ae_instances, B_fn5).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const t = this.redeem;
    return t !== void 0 && t.name !== void 0 ? `p2wsh-${t.name}` : ft4.P2WSH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t15);
  }
  /**
   * Bech32 encoded address (bc1q... for mainnet).
   */
  get address() {
    return __privateGet(this, _l8) || (__privateSet(this, _o10, __privateMethod(this, _Ae_instances, T_fn3).call(this)), __privateSet(this, _l8, true)), __privateGet(this, _o10);
  }
  /**
   * 32-byte witness program (SHA256 of redeem script).
   */
  get hash() {
    return __privateGet(this, _d7) || (__privateSet(this, _h9, __privateMethod(this, _Ae_instances, k_fn4).call(this)), __privateSet(this, _d7, true)), __privateGet(this, _h9);
  }
  /**
   * The scriptPubKey: `OP_0 {32-byte hash}`
   */
  get output() {
    return __privateGet(this, _w7) || (__privateSet(this, _f8, __privateMethod(this, _Ae_instances, O_fn4).call(this)), __privateSet(this, _w7, true)), __privateGet(this, _f8);
  }
  /**
   * The scriptSig (always empty for native SegWit).
   */
  get input() {
    return __privateGet(this, _g8) || (__privateSet(this, _u9, __privateMethod(this, _Ae_instances, U_fn5).call(this)), __privateSet(this, _g8, true)), __privateGet(this, _u9);
  }
  /**
   * The redeem script information.
   */
  get redeem() {
    return __privateGet(this, _y8) || (__privateSet(this, _c8, __privateMethod(this, _Ae_instances, x_fn5).call(this)), __privateSet(this, _y8, true)), __privateGet(this, _c8);
  }
  /**
   * Witness stack: `[{scriptSig...}, {redeemScript}]`
   */
  get witness() {
    return __privateGet(this, _m8) || (__privateSet(this, _p8, __privateMethod(this, _Ae_instances, P_fn5).call(this)), __privateSet(this, _m8, true)), __privateGet(this, _p8);
  }
  // Static factory methods
  /**
   * Creates a P2WSH payment from a redeem script.
   *
   * @param redeem - The redeem script information
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   *
   * @example
   * ```typescript
   * const p2wsh = P2WSH.fromRedeem({ output: redeemScript });
   * ```
   */
  static fromRedeem(t, r) {
    return new _Ae({ redeem: t, network: r });
  }
  /**
   * Creates a P2WSH payment from a bech32 address.
   *
   * @param address - Bech32 encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromAddress(t, r) {
    return new _Ae({ address: t, network: r });
  }
  /**
   * Creates a P2WSH payment from a 32-byte witness program.
   *
   * @param hash - 32-byte witness program (SHA256 of script)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromHash(t, r) {
    return new _Ae({ hash: t, network: r });
  }
  /**
   * Creates a P2WSH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromOutput(t, r) {
    return new _Ae({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2WSHPayment object for backwards compatibility.
   *
   * @returns A P2WSHPayment object
   */
  toPayment() {
    const t = this.witness, r = this.redeem;
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      output: this.output,
      input: this.input,
      redeem: r,
      witness: t
    };
  }
};
_t15 = new WeakMap();
_a24 = new WeakMap();
_e16 = new WeakMap();
_s9 = new WeakMap();
_r9 = new WeakMap();
_n9 = new WeakMap();
_i10 = new WeakMap();
_o10 = new WeakMap();
_h9 = new WeakMap();
_f8 = new WeakMap();
_u9 = new WeakMap();
_c8 = new WeakMap();
_p8 = new WeakMap();
_l8 = new WeakMap();
_d7 = new WeakMap();
_w7 = new WeakMap();
_g8 = new WeakMap();
_y8 = new WeakMap();
_m8 = new WeakMap();
_E6 = new WeakMap();
_I6 = new WeakMap();
_v6 = new WeakMap();
_b7 = new WeakMap();
_Ae_instances = new WeakSet();
S_fn2 = function() {
  if (!__privateGet(this, _I6)) {
    if (__privateGet(this, _e16)) {
      const t = J2.bech32.decode(__privateGet(this, _e16)), r = t.words.shift(), n = J2.bech32.fromWords(t.words);
      __privateSet(this, _E6, {
        version: r ?? 0,
        prefix: t.prefix,
        data: new Uint8Array(n)
      });
    }
    __privateSet(this, _I6, true);
  }
  return __privateGet(this, _E6);
};
// Private computation methods
A_fn3 = function() {
  var _a37;
  return __privateGet(this, _b7) || (((_a37 = __privateGet(this, _n9)) == null ? void 0 : _a37.input) && __privateSet(this, _v6, tt3(__privateGet(this, _n9).input) ?? void 0), __privateSet(this, _b7, true)), __privateGet(this, _v6);
};
T_fn3 = function() {
  if (__privateGet(this, _e16))
    return __privateGet(this, _e16);
  const t = this.hash;
  if (!t) return;
  const r = J2.bech32.toWords(t);
  return r.unshift(0), J2.bech32.encode(__privateGet(this, _t15).bech32, r);
};
k_fn4 = function() {
  var _a37;
  if (__privateGet(this, _s9))
    return __privateGet(this, _s9);
  if (__privateGet(this, _r9))
    return __privateGet(this, _r9).subarray(2);
  if (__privateGet(this, _e16))
    return (_a37 = __privateMethod(this, _Ae_instances, S_fn2).call(this)) == null ? void 0 : _a37.data;
  const t = this.redeem;
  if (t && t.output)
    return vt4(t.output);
};
O_fn4 = function() {
  if (__privateGet(this, _r9))
    return __privateGet(this, _r9);
  const t = this.hash;
  if (t)
    return gt3([us2.OP_0, t]);
};
U_fn5 = function() {
  if (this.witness)
    return xn2;
};
x_fn5 = function() {
  if (__privateGet(this, _n9))
    return __privateGet(this, _n9);
  if (__privateGet(this, _i10) && __privateGet(this, _i10).length > 0)
    return {
      output: __privateGet(this, _i10)[__privateGet(this, _i10).length - 1],
      input: xn2,
      witness: __privateGet(this, _i10).slice(0, -1)
    };
};
// Validation
P_fn5 = function() {
  if (__privateGet(this, _i10))
    return __privateGet(this, _i10);
  const t = __privateGet(this, _n9);
  if (t) {
    if (t.input && t.input.length > 0 && t.output && t.output.length > 0) {
      const r = __privateMethod(this, _Ae_instances, A_fn3).call(this);
      if (r) {
        const n = js2(r);
        return __privateSet(this, _c8, Object.assign({ witness: n }, t, { input: xn2 })), __privateSet(this, _y8, true), [].concat(n, t.output);
      }
    }
    return !t.output || !t.witness ? void 0 : [].concat(t.witness, t.output);
  }
};
B_fn5 = function() {
  let t = new Uint8Array(0);
  if (__privateGet(this, _e16)) {
    const r = __privateMethod(this, _Ae_instances, S_fn2).call(this);
    if (!r)
      throw new TypeError("Invalid address");
    if (r.prefix !== __privateGet(this, _t15).bech32)
      throw new TypeError("Invalid prefix or Network mismatch");
    if (r.version !== 0)
      throw new TypeError("Invalid address version");
    if (r.data.length !== 32)
      throw new TypeError("Invalid address data");
    t = r.data;
  }
  if (__privateGet(this, _s9)) {
    if (t.length > 0 && !P(t, __privateGet(this, _s9)))
      throw new TypeError("Hash mismatch");
    t = __privateGet(this, _s9);
  }
  if (__privateGet(this, _r9)) {
    if (__privateGet(this, _r9).length !== 34 || __privateGet(this, _r9)[0] !== us2.OP_0 || __privateGet(this, _r9)[1] !== 32)
      throw new TypeError("Output is invalid");
    const r = __privateGet(this, _r9).subarray(2);
    if (t.length > 0 && !P(t, r))
      throw new TypeError("Hash mismatch");
    t = r;
  }
  if (__privateGet(this, _n9)) {
    if (__privateGet(this, _n9).network && __privateGet(this, _n9).network !== __privateGet(this, _t15))
      throw new TypeError("Network mismatch");
    if (__privateGet(this, _n9).input && __privateGet(this, _n9).input.length > 0 && __privateGet(this, _n9).witness && __privateGet(this, _n9).witness.length > 0)
      throw new TypeError("Ambiguous witness source");
    if (__privateGet(this, _n9).output) {
      const n = tt3(__privateGet(this, _n9).output);
      if (!n || n.length < 1)
        throw new TypeError("Redeem.output is invalid");
      if (__privateGet(this, _n9).output.byteLength > 3600)
        throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");
      if (ii2(n) > 201)
        throw new TypeError(
          "Redeem.output unspendable with more than 201 non-push ops"
        );
      const i = vt4(__privateGet(this, _n9).output);
      if (t.length > 0 && !P(t, i))
        throw new TypeError("Hash mismatch");
      t = i;
    }
    const r = __privateMethod(this, _Ae_instances, A_fn3).call(this);
    if (__privateGet(this, _n9).input && r && !an2(r))
      throw new TypeError("Non push-only scriptSig");
    if (__privateGet(this, _i10) && __privateGet(this, _n9).witness && !Oe3(__privateGet(this, _i10), __privateGet(this, _n9).witness))
      throw new TypeError("Witness and redeem.witness mismatch");
    if (__privateGet(this, _n9).input && (r == null ? void 0 : r.some(Pr2)) || __privateGet(this, _n9).output && (tt3(__privateGet(this, _n9).output) || []).some(
      Pr2
    ))
      throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
  }
  if (__privateGet(this, _i10) && __privateGet(this, _i10).length > 0) {
    const r = __privateGet(this, _i10)[__privateGet(this, _i10).length - 1];
    if (__privateGet(this, _n9) && __privateGet(this, _n9).output && !P(__privateGet(this, _n9).output, r))
      throw new TypeError("Witness and redeem.output mismatch");
    if (__privateGet(this, _i10).some(Pr2) || (tt3(r) || []).some(Pr2))
      throw new TypeError("Witness contains uncompressed pubkey");
  }
};
// Static public fields
__publicField(_Ae, "NAME", ft4.P2WSH);
var Ae4 = _Ae;
function mr2(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  return new Ae4(
    {
      address: e.address,
      hash: e.hash,
      output: e.output,
      redeem: e.redeem,
      witness: e.witness,
      network: e.network
    },
    t
  ).toPayment();
}
var fs2 = q2;
var _a25, _t16, _a26, _e17, _s10, _r10, _n10, _i11, _o11, _h10, _f9, _u10, _c9, _p9, _l9, _d8, _w8, _Cr_instances, g_fn, y_fn, m_fn, E_fn2, I_fn2, v_fn2;
var Fo2 = (_a25 = class {
  /**
   * Creates a new P2PK payment instance.
   *
   * @param params - Payment parameters
   * @param params.pubkey - The public key (33 or 65 bytes)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _Cr_instances);
    // Private instance fields
    __privateAdd(this, _t16);
    __privateAdd(this, _a26);
    // Input data (provided by user)
    __privateAdd(this, _e17);
    __privateAdd(this, _s10);
    __privateAdd(this, _r10);
    __privateAdd(this, _n10);
    // Cached computed values
    __privateAdd(this, _i11);
    __privateAdd(this, _o11);
    __privateAdd(this, _h10);
    __privateAdd(this, _f9);
    __privateAdd(this, _u10);
    // Cache flags
    __privateAdd(this, _c9, false);
    __privateAdd(this, _p9, false);
    __privateAdd(this, _l9, false);
    __privateAdd(this, _d8, false);
    __privateAdd(this, _w8, false);
    __privateSet(this, _t16, t.network ?? kt3), __privateSet(this, _a26, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e17, t.pubkey), __privateSet(this, _s10, t.signature), __privateSet(this, _r10, t.output), __privateSet(this, _n10, t.input), __privateGet(this, _a26).validate && __privateMethod(this, _Cr_instances, v_fn2).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ft4.P2PK;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t16);
  }
  /**
   * The public key (33 or 65 bytes).
   * Computed lazily from output if not provided directly.
   */
  get pubkey() {
    return __privateGet(this, _c9) || (__privateSet(this, _i11, __privateMethod(this, _Cr_instances, g_fn).call(this)), __privateSet(this, _c9, true)), __privateGet(this, _i11);
  }
  /**
   * The DER-encoded signature.
   * Computed lazily from input if not provided directly.
   */
  get signature() {
    return __privateGet(this, _p9) || (__privateSet(this, _o11, __privateMethod(this, _Cr_instances, y_fn).call(this)), __privateSet(this, _p9, true)), __privateGet(this, _o11);
  }
  /**
   * The scriptPubKey: `{pubKey} OP_CHECKSIG`
   * Computed lazily from pubkey if not provided directly.
   */
  get output() {
    return __privateGet(this, _l9) || (__privateSet(this, _h10, __privateMethod(this, _Cr_instances, m_fn).call(this)), __privateSet(this, _l9, true)), __privateGet(this, _h10);
  }
  /**
   * The scriptSig: `{signature}`
   * Computed lazily from signature if not provided directly.
   */
  get input() {
    return __privateGet(this, _d8) || (__privateSet(this, _f9, __privateMethod(this, _Cr_instances, E_fn2).call(this)), __privateSet(this, _d8, true)), __privateGet(this, _f9);
  }
  /**
   * Witness stack (empty for P2PK as it's not a SegWit type).
   */
  get witness() {
    return __privateGet(this, _w8) || (__privateSet(this, _u10, __privateMethod(this, _Cr_instances, I_fn2).call(this)), __privateSet(this, _w8, true)), __privateGet(this, _u10);
  }
  // Static factory methods
  /**
   * Creates a P2PK payment from a public key.
   *
   * @param pubkey - The public key (33 or 65 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromPubkey(pubkey);
   * const scriptPubKey = payment.output;
   * ```
   */
  static fromPubkey(t, r) {
    return new _a25({ pubkey: t, network: r });
  }
  /**
   * Creates a P2PK payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromOutput(scriptPubKey);
   * const pubkey = payment.pubkey;
   * ```
   */
  static fromOutput(t, r) {
    return new _a25({ output: t, network: r });
  }
  /**
   * Creates a P2PK payment from a signature (for spending).
   *
   * @param signature - The DER-encoded signature
   * @param pubkey - The public key (optional, for validation)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromSignature(signature, pubkey);
   * const scriptSig = payment.input;
   * ```
   */
  static fromSignature(t, r, n) {
    return new _a25({ signature: t, pubkey: r, network: n });
  }
  // Private computation methods
  /**
   * Converts to a plain P2PKPayment object for backwards compatibility.
   *
   * @returns A P2PKPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
}, _t16 = new WeakMap(), _a26 = new WeakMap(), _e17 = new WeakMap(), _s10 = new WeakMap(), _r10 = new WeakMap(), _n10 = new WeakMap(), _i11 = new WeakMap(), _o11 = new WeakMap(), _h10 = new WeakMap(), _f9 = new WeakMap(), _u10 = new WeakMap(), _c9 = new WeakMap(), _p9 = new WeakMap(), _l9 = new WeakMap(), _d8 = new WeakMap(), _w8 = new WeakMap(), _Cr_instances = new WeakSet(), g_fn = function() {
  if (__privateGet(this, _e17))
    return __privateGet(this, _e17);
  if (__privateGet(this, _r10))
    return __privateGet(this, _r10).subarray(1, -1);
}, y_fn = function() {
  if (__privateGet(this, _s10))
    return __privateGet(this, _s10);
  if (__privateGet(this, _n10)) {
    const t = tt3(__privateGet(this, _n10));
    if (t && t.length > 0)
      return t[0];
  }
}, m_fn = function() {
  if (__privateGet(this, _r10))
    return __privateGet(this, _r10);
  const t = __privateGet(this, _e17);
  if (t)
    return gt3([t, fs2.OP_CHECKSIG]);
}, E_fn2 = function() {
  if (__privateGet(this, _n10))
    return __privateGet(this, _n10);
  const t = __privateGet(this, _s10);
  if (t)
    return gt3([t]);
}, // Validation
I_fn2 = function() {
  if (this.input)
    return [];
}, v_fn2 = function() {
  if (__privateGet(this, _r10)) {
    if (__privateGet(this, _r10)[__privateGet(this, _r10).length - 1] !== fs2.OP_CHECKSIG)
      throw new TypeError("Output is invalid");
    const t = this.pubkey;
    if (!xe3(t))
      throw new TypeError("Output pubkey is invalid");
    if (__privateGet(this, _e17) && t && !P(__privateGet(this, _e17), t))
      throw new TypeError("Pubkey mismatch");
  }
  if (__privateGet(this, _s10)) {
    const t = this.input;
    if (__privateGet(this, _n10) && t && !P(__privateGet(this, _n10), t))
      throw new TypeError("Signature mismatch");
  }
  if (__privateGet(this, _n10)) {
    const t = tt3(__privateGet(this, _n10));
    if (!t || t.length !== 1)
      throw new TypeError("Input is invalid");
    const r = this.signature;
    if (!r || !_e9(r))
      throw new TypeError("Input has invalid signature");
  }
}, // Static public fields
__publicField(_a25, "NAME", ft4.P2PK), _a25);
function gi2(e, t) {
  if (!e.input && !e.output && !e.pubkey && !e.signature)
    throw new TypeError("Not enough data");
  const r = new Fo2(
    {
      pubkey: e.pubkey,
      signature: e.signature,
      output: e.output,
      input: e.input,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
var Ce4 = q2;
var Br2 = Ce4.OP_RESERVED;
var _a27, _t17, _a28, _e18, _s11, _r11, _n11, _i12, _o12, _h11, _f10, _u11, _c10, _p10, _l10, _d9, _w9, _g9, _y9, _m9, _E7, _I7, _v7, _b8, _S6, _Vr_instances, A_fn4, T_fn4, k_fn5, O_fn5, U_fn6, x_fn6, P_fn6, B_fn6, __fn5, R_fn4;
var Wo2 = (_a27 = class {
  /**
   * Creates a new P2MS payment instance.
   *
   * @param params - Payment parameters
   * @param params.m - Required number of signatures
   * @param params.n - Total number of public keys (optional, derived from pubkeys)
   * @param params.pubkeys - Array of public keys
   * @param params.signatures - Array of signatures
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   * @param opts.allowIncomplete - Allow incomplete signatures (default: false)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _Vr_instances);
    // Private instance fields
    __privateAdd(this, _t17);
    __privateAdd(this, _a28);
    // Input data (provided by user)
    __privateAdd(this, _e18);
    __privateAdd(this, _s11);
    __privateAdd(this, _r11);
    __privateAdd(this, _n11);
    __privateAdd(this, _i12);
    __privateAdd(this, _o12);
    // Cached computed values
    __privateAdd(this, _h11);
    __privateAdd(this, _f10);
    __privateAdd(this, _u11);
    __privateAdd(this, _c10);
    __privateAdd(this, _p10);
    __privateAdd(this, _l10);
    __privateAdd(this, _d9);
    // Cache flags
    __privateAdd(this, _w9, false);
    __privateAdd(this, _g9, false);
    __privateAdd(this, _y9, false);
    __privateAdd(this, _m9, false);
    __privateAdd(this, _E7, false);
    __privateAdd(this, _I7, false);
    __privateAdd(this, _v7, false);
    // Decoded chunks cache
    __privateAdd(this, _b8);
    __privateAdd(this, _S6, false);
    __privateSet(this, _t17, t.network ?? kt3), __privateSet(this, _a28, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e18, t.m), __privateSet(this, _s11, t.n), __privateSet(this, _r11, t.pubkeys), __privateSet(this, _n11, t.signatures), __privateSet(this, _i12, t.output), __privateSet(this, _o12, t.input), __privateGet(this, _a28).validate && __privateMethod(this, _Vr_instances, R_fn4).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const t = this.m, r = this.n;
    return t !== void 0 && r !== void 0 ? `p2ms(${t} of ${r})` : ft4.P2MS;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t17);
  }
  /**
   * Required number of signatures (M in M-of-N).
   */
  get m() {
    return __privateGet(this, _w9) || (__privateSet(this, _h11, __privateMethod(this, _Vr_instances, T_fn4).call(this)), __privateSet(this, _w9, true)), __privateGet(this, _h11);
  }
  /**
   * Total number of public keys (N in M-of-N).
   */
  get n() {
    return __privateGet(this, _g9) || (__privateSet(this, _f10, __privateMethod(this, _Vr_instances, k_fn5).call(this)), __privateSet(this, _g9, true)), __privateGet(this, _f10);
  }
  /**
   * Array of public keys.
   */
  get pubkeys() {
    return __privateGet(this, _y9) || (__privateSet(this, _u11, __privateMethod(this, _Vr_instances, O_fn5).call(this)), __privateSet(this, _y9, true)), __privateGet(this, _u11);
  }
  /**
   * Array of signatures.
   */
  get signatures() {
    return __privateGet(this, _m9) || (__privateSet(this, _c10, __privateMethod(this, _Vr_instances, U_fn6).call(this)), __privateSet(this, _m9, true)), __privateGet(this, _c10);
  }
  /**
   * The scriptPubKey: `m {pubkeys} n OP_CHECKMULTISIG`
   */
  get output() {
    return __privateGet(this, _E7) || (__privateSet(this, _p10, __privateMethod(this, _Vr_instances, x_fn6).call(this)), __privateSet(this, _E7, true)), __privateGet(this, _p10);
  }
  /**
   * The scriptSig: `OP_0 {signatures}`
   */
  get input() {
    return __privateGet(this, _I7) || (__privateSet(this, _l10, __privateMethod(this, _Vr_instances, P_fn6).call(this)), __privateSet(this, _I7, true)), __privateGet(this, _l10);
  }
  /**
   * Witness stack (empty for P2MS as it's not a SegWit type).
   */
  get witness() {
    return __privateGet(this, _v7) || (__privateSet(this, _d9, __privateMethod(this, _Vr_instances, B_fn6).call(this)), __privateSet(this, _v7, true)), __privateGet(this, _d9);
  }
  // Static factory methods
  /**
   * Creates a P2MS payment from public keys.
   *
   * @param m - Required number of signatures
   * @param pubkeys - Array of public keys
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   *
   * @example
   * ```typescript
   * // Create a 2-of-3 multisig
   * const payment = P2MS.fromPubkeys(2, [pubkey1, pubkey2, pubkey3]);
   * ```
   */
  static fromPubkeys(t, r, n) {
    return new _a27({ m: t, pubkeys: r, network: n });
  }
  /**
   * Creates a P2MS payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   */
  static fromOutput(t, r) {
    return new _a27({ output: t, network: r });
  }
  /**
   * Creates a P2MS payment from signatures (for spending).
   *
   * @param signatures - Array of signatures
   * @param m - Required number of signatures (optional)
   * @param pubkeys - Array of public keys (optional, for validation)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   */
  static fromSignatures(t, r, n, i) {
    return new _a27({ signatures: t, m: r, pubkeys: n, network: i });
  }
  // Private helper methods
  /**
   * Converts to a plain P2MSPayment object for backwards compatibility.
   *
   * @returns A P2MSPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      m: this.m,
      n: this.n,
      pubkeys: this.pubkeys,
      signatures: this.signatures,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
}, _t17 = new WeakMap(), _a28 = new WeakMap(), _e18 = new WeakMap(), _s11 = new WeakMap(), _r11 = new WeakMap(), _n11 = new WeakMap(), _i12 = new WeakMap(), _o12 = new WeakMap(), _h11 = new WeakMap(), _f10 = new WeakMap(), _u11 = new WeakMap(), _c10 = new WeakMap(), _p10 = new WeakMap(), _l10 = new WeakMap(), _d9 = new WeakMap(), _w9 = new WeakMap(), _g9 = new WeakMap(), _y9 = new WeakMap(), _m9 = new WeakMap(), _E7 = new WeakMap(), _I7 = new WeakMap(), _v7 = new WeakMap(), _b8 = new WeakMap(), _S6 = new WeakMap(), _Vr_instances = new WeakSet(), // Private computation methods
A_fn4 = function(t) {
  __privateGet(this, _S6) || (__privateSet(this, _S6, true), __privateSet(this, _b8, tt3(t) ?? []), __privateSet(this, _h11, __privateGet(this, _b8)[0] - Br2), __privateSet(this, _f10, __privateGet(this, _b8)[__privateGet(this, _b8).length - 2] - Br2), __privateSet(this, _u11, __privateGet(this, _b8).slice(1, -2)), __privateSet(this, _w9, true), __privateSet(this, _g9, true), __privateSet(this, _y9, true));
}, T_fn4 = function() {
  if (__privateGet(this, _e18) !== void 0)
    return __privateGet(this, _e18);
  const t = __privateGet(this, _i12) ?? this.output;
  if (t)
    return __privateMethod(this, _Vr_instances, A_fn4).call(this, t), __privateGet(this, _h11);
}, k_fn5 = function() {
  if (__privateGet(this, _s11) !== void 0)
    return __privateGet(this, _s11);
  if (__privateGet(this, _r11))
    return __privateGet(this, _r11).length;
  if (__privateGet(this, _i12))
    return __privateMethod(this, _Vr_instances, A_fn4).call(this, __privateGet(this, _i12)), __privateGet(this, _f10);
}, O_fn5 = function() {
  if (__privateGet(this, _r11))
    return __privateGet(this, _r11);
  if (__privateGet(this, _i12))
    return __privateMethod(this, _Vr_instances, A_fn4).call(this, __privateGet(this, _i12)), __privateGet(this, _u11);
}, U_fn6 = function() {
  var _a37;
  if (__privateGet(this, _n11))
    return __privateGet(this, _n11);
  if (__privateGet(this, _o12))
    return (_a37 = tt3(__privateGet(this, _o12))) == null ? void 0 : _a37.slice(1);
}, x_fn6 = function() {
  if (__privateGet(this, _i12))
    return __privateGet(this, _i12);
  const t = __privateGet(this, _e18), r = this.n, n = __privateGet(this, _r11);
  if (!(t === void 0 || r === void 0 || !n))
    return gt3(
      [].concat(Br2 + t, n, Br2 + r, Ce4.OP_CHECKMULTISIG)
    );
}, P_fn6 = function() {
  if (__privateGet(this, _o12))
    return __privateGet(this, _o12);
  if (__privateGet(this, _n11))
    return gt3([Ce4.OP_0].concat(__privateGet(this, _n11)));
}, // Validation
B_fn6 = function() {
  if (this.input)
    return [];
}, __fn5 = function(t) {
  return _e9(t) || __privateGet(this, _a28).allowIncomplete && t === Ce4.OP_0;
}, R_fn4 = function() {
  if (__privateGet(this, _i12)) {
    __privateMethod(this, _Vr_instances, A_fn4).call(this, __privateGet(this, _i12));
    const t = __privateGet(this, _b8);
    if (!t)
      throw new TypeError("Output is invalid");
    if (typeof t[0] != "number")
      throw new TypeError("Output is invalid");
    if (typeof t[t.length - 2] != "number")
      throw new TypeError("Output is invalid");
    if (t[t.length - 1] !== Ce4.OP_CHECKMULTISIG)
      throw new TypeError("Output is invalid");
    const r = __privateGet(this, _h11), n = __privateGet(this, _f10), i = __privateGet(this, _u11);
    if (r === void 0 || n === void 0 || !i)
      throw new TypeError("Output is invalid");
    if (r <= 0 || n > 16 || r > n || n !== t.length - 3)
      throw new TypeError("Output is invalid");
    if (!i.every((o) => xe3(o)))
      throw new TypeError("Output is invalid");
    if (__privateGet(this, _e18) !== void 0 && __privateGet(this, _e18) !== r)
      throw new TypeError("m mismatch");
    if (__privateGet(this, _s11) !== void 0 && __privateGet(this, _s11) !== n)
      throw new TypeError("n mismatch");
    if (__privateGet(this, _r11) && !Oe3(__privateGet(this, _r11), i))
      throw new TypeError("Pubkeys mismatch");
  }
  if (__privateGet(this, _r11)) {
    if (__privateGet(this, _s11) !== void 0 && __privateGet(this, _s11) !== __privateGet(this, _r11).length)
      throw new TypeError("Pubkey count mismatch");
    if (__privateSet(this, _f10, __privateGet(this, _r11).length), __privateSet(this, _g9, true), __privateGet(this, _h11) !== void 0 && __privateGet(this, _f10) < __privateGet(this, _h11))
      throw new TypeError("Pubkey count cannot be less than m");
  }
  if (__privateGet(this, _n11)) {
    if (__privateGet(this, _h11) !== void 0 && __privateGet(this, _n11).length < __privateGet(this, _h11))
      throw new TypeError("Not enough signatures provided");
    if (__privateGet(this, _h11) !== void 0 && __privateGet(this, _n11).length > __privateGet(this, _h11))
      throw new TypeError("Too many signatures provided");
  }
  if (__privateGet(this, _o12)) {
    if (__privateGet(this, _o12)[0] !== Ce4.OP_0)
      throw new TypeError("Input is invalid");
    const t = this.signatures;
    if (!t || t.length === 0 || !t.every((r) => __privateMethod(this, _Vr_instances, __fn5).call(this, r)))
      throw new TypeError("Input has invalid signature(s)");
    if (__privateGet(this, _n11) && !Oe3(__privateGet(this, _n11), t))
      throw new TypeError("Signature mismatch");
    if (__privateGet(this, _e18) !== void 0 && __privateGet(this, _n11) && __privateGet(this, _e18) !== __privateGet(this, _n11).length)
      throw new TypeError("Signature count mismatch");
  }
}, // Static public fields
__publicField(_a27, "NAME", ft4.P2MS), _a27);
function Er2(e, t) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  const r = new Wo2(
    {
      m: e.m,
      n: e.n,
      pubkeys: e.pubkeys,
      signatures: e.signatures,
      output: e.output,
      input: e.input,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
function Lt3(e) {
  const t = e.length;
  return $t4(t) + t;
}
function wf2(e) {
  const t = e.length;
  return $t4(t) + e.reduce((r, n) => r + Lt3(n), 0);
}
var fe4 = new Uint8Array(0);
var cs2 = [];
var _r12 = Mt3("0000000000000000000000000000000000000000000000000000000000000000");
var ls2 = Nr2(Mt3("0000000000000000000000000000000000000000000000000000000000000001"));
var gf2 = 0xffffffffffffffffn;
var _a29, _Q_instances, t_fn;
var rt4 = (_a29 = class {
  constructor() {
    __privateAdd(this, _Q_instances);
    __publicField(this, "version", 1);
    __publicField(this, "locktime", 0);
    __publicField(this, "ins", []);
    __publicField(this, "outs", []);
  }
  /**
   * Parse a transaction from a Uint8Array buffer.
   *
   * @param buffer - The raw transaction bytes
   * @param _NO_STRICT - If true, allow extra data after transaction
   * @returns Parsed Transaction instance
   */
  static fromBuffer(t, r) {
    const n = new Ya2(t), i = new _a29();
    i.version = n.readInt32LE();
    const o = n.readUInt8(), a = n.readUInt8();
    let u = false;
    o === _a29.ADVANCED_TRANSACTION_MARKER && a === _a29.ADVANCED_TRANSACTION_FLAG ? u = true : n.offset -= 2;
    const l = n.readVarInt();
    for (let f = 0; f < l; ++f) {
      const p = n.readBytes(32), w = n.readUInt32LE(), y = n.readVarBytes(), m = n.readUInt32LE();
      i.ins.push({
        hash: p,
        index: w,
        script: y,
        sequence: m,
        witness: cs2
      });
    }
    const d = n.readVarInt();
    for (let f = 0; f < d; ++f)
      i.outs.push({
        value: n.readUInt64LE(),
        script: n.readVarBytes()
      });
    if (u) {
      for (let f = 0; f < l; ++f)
        i.ins[f].witness = n.readVector();
      if (!i.hasWitnesses()) throw new Error("Transaction has superfluous witness data");
    }
    if (i.locktime = n.readUInt32LE(), r) return i;
    if (n.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return i;
  }
  /**
   * Parse a transaction from a hex string.
   *
   * @param hex - The transaction as a hex string
   * @returns Parsed Transaction instance
   */
  static fromHex(t) {
    return _a29.fromBuffer(Mt3(t), false);
  }
  /**
   * Check if a hash is a coinbase hash (all zeros).
   *
   * @param hash - 32-byte hash to check
   * @returns true if hash is all zeros (coinbase)
   */
  static isCoinbaseHash(t) {
    if (t.length !== 32)
      throw new TypeError("Expected 32-byte hash");
    for (let r = 0; r < 32; ++r)
      if (t[r] !== 0) return false;
    return true;
  }
  isCoinbase() {
    const t = this.ins[0];
    return this.ins.length === 1 && t !== void 0 && _a29.isCoinbaseHash(t.hash);
  }
  /**
   * Add an input to this transaction.
   *
   * @param hash - 32-byte hash of the previous transaction
   * @param index - Output index in the previous transaction
   * @param sequence - Sequence number (defaults to 0xffffffff)
   * @param scriptSig - Input script (defaults to empty)
   * @returns The index of the newly added input
   */
  addInput(t, r, n, i) {
    if (t.length !== 32)
      throw new TypeError("Expected 32-byte hash");
    if (!Number.isInteger(r) || r < 0 || r > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for index");
    if (n != null && (!Number.isInteger(n) || n < 0 || n > 4294967295))
      throw new TypeError("Expected unsigned 32-bit integer for sequence");
    return n == null && (n = _a29.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: r,
      script: i || fe4,
      sequence: n,
      witness: cs2
    }) - 1;
  }
  /**
   * Add an output to this transaction.
   *
   * @param scriptPubKey - Output script (locking script)
   * @param value - Output value in satoshis (bigint)
   * @returns The index of the newly added output
   */
  addOutput(t, r) {
    if (!(t instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array for scriptPubKey");
    if (typeof r != "bigint" || r < 0n || r > 0x7fffffffffffffffn)
      throw new TypeError("Expected bigint satoshi value (0 to 2^63-1)");
    return this.outs.push({
      script: t,
      value: r
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(false), r = this.byteLength(true);
    return t * 3 + r;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = true) {
    const r = t && this.hasWitnesses();
    return (r ? 10 : 8) + $t4(this.ins.length) + $t4(this.outs.length) + this.ins.reduce((n, i) => n + 40 + Lt3(i.script), 0) + this.outs.reduce((n, i) => n + 8 + Lt3(i.script), 0) + (r ? this.ins.reduce((n, i) => n + wf2(i.witness), 0) : 0);
  }
  clone() {
    const t = new _a29();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r) => ({
      hash: r.hash,
      index: r.index,
      script: r.script,
      sequence: r.sequence,
      witness: r.witness
    })), t.outs = this.outs.map((r) => ({
      script: r.script,
      value: r.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScript - The script of the output being spent
   * @param hashType - Signature hash type
   * @returns 32-byte hash for signing
   */
  hashForSignature(t, r, n) {
    var _a37;
    if (!Number.isInteger(t) || t < 0)
      throw new TypeError("Expected non-negative integer for inIndex");
    if (!(r instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array for prevOutScript");
    if (!Number.isInteger(n))
      throw new TypeError("Expected integer for hashType");
    if (t >= this.ins.length) return ls2;
    const i = tt3(r);
    if (!i) throw new Error("Could not decompile prevOutScript");
    const o = gt3(
      i.filter((l) => l !== q2.OP_CODESEPARATOR)
    ), a = this.clone();
    if ((n & 31) === _a29.SIGHASH_NONE)
      a.outs = [], a.ins.forEach((l, d) => {
        d !== t && (l.sequence = 0);
      });
    else if ((n & 31) === _a29.SIGHASH_SINGLE) {
      if (t >= this.outs.length) return ls2;
      a.outs.length = t + 1;
      for (let l = 0; l < t; l++)
        a.outs[l] = {
          script: fe4,
          value: gf2
        };
      a.ins.forEach((l, d) => {
        d !== t && (l.sequence = 0);
      });
    }
    n & _a29.SIGHASH_ANYONECANPAY ? (a.ins = [a.ins[t]], a.ins[0].script = o) : (a.ins.forEach((l) => {
      l.script = fe4;
    }), a.ins[t].script = o);
    const u = Et4(a.byteLength(false) + 4);
    return new dt4(u, a.byteLength(false)).writeInt32LE(n), __privateMethod(_a37 = a, _Q_instances, t_fn).call(_a37, u, 0, false), Nr2(ce3(u));
  }
  /**
   * Hash transaction for signing a Taproot (witness v1) input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScripts - Scripts of all inputs being spent
   * @param values - Values of all inputs being spent (bigint satoshis)
   * @param hashType - Signature hash type
   * @param leafHash - Optional leaf hash for script path spending
   * @param annex - Optional annex data
   * @returns 32-byte hash for signing
   */
  hashForWitnessV1(t, r, n, i, o, a, u) {
    if (!Number.isInteger(t) || t < 0 || t > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for inIndex");
    if (!Array.isArray(r) || !r.every((z4) => z4 instanceof Uint8Array))
      throw new TypeError("Expected array of Uint8Array for prevOutScripts");
    if (!Array.isArray(n) || !n.every((z4) => typeof z4 == "bigint"))
      throw new TypeError("Expected array of bigint for values");
    if (!Number.isInteger(i) || i < 0 || i > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for hashType");
    if (n.length !== this.ins.length || r.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const l = i === _a29.SIGHASH_DEFAULT ? _a29.SIGHASH_ALL : i & _a29.SIGHASH_OUTPUT_MASK, d = (i & _a29.SIGHASH_INPUT_MASK) === _a29.SIGHASH_ANYONECANPAY, f = l === _a29.SIGHASH_NONE, p = l === _a29.SIGHASH_SINGLE;
    let w = fe4, y = fe4, m = fe4, E2 = fe4, v = fe4;
    if (!d)
      if (u)
        w = u.hashPrevouts, y = u.hashAmounts, m = u.hashScriptPubKeys, E2 = u.hashSequences;
      else {
        let z4 = new dt4(36 * this.ins.length);
        this.ins.forEach((Y2) => {
          z4.writeBytes(Y2.hash), z4.writeUInt32LE(Y2.index);
        }), w = vt4(z4.finish()), z4 = new dt4(8 * this.ins.length), n.forEach((Y2) => z4.writeUInt64LE(Y2)), y = vt4(z4.finish()), z4 = new dt4(
          r.map(Lt3).reduce((Y2, F3) => Y2 + F3)
        ), r.forEach(
          (Y2) => z4.writeVarBytes(Y2)
        ), m = vt4(z4.finish()), z4 = new dt4(4 * this.ins.length), this.ins.forEach((Y2) => z4.writeUInt32LE(Y2.sequence)), E2 = vt4(z4.finish());
      }
    if (f || p) {
      if (p && t < this.outs.length) {
        const z4 = this.outs[t], Y2 = new dt4(8 + Lt3(z4.script));
        Y2.writeUInt64LE(z4.value), Y2.writeVarBytes(z4.script), v = vt4(Y2.finish());
      }
    } else if (u)
      v = u.hashOutputs;
    else {
      if (!this.outs.length)
        throw new Error("Add outputs to the transaction before signing.");
      const z4 = this.outs.map((F3) => 8 + Lt3(F3.script)).reduce((F3, Rt5) => F3 + Rt5), Y2 = new dt4(z4);
      this.outs.forEach((F3) => {
        Y2.writeUInt64LE(F3.value), Y2.writeVarBytes(F3.script);
      }), v = vt4(Y2.finish());
    }
    const x = (o ? 2 : 0) + (a ? 1 : 0), O = 174 - (d ? 49 : 0) - (f ? 32 : 0) + (a ? 32 : 0) + (o ? 37 : 0), T = new dt4(O);
    if (T.writeUInt8(i), T.writeInt32LE(this.version), T.writeUInt32LE(this.locktime), T.writeBytes(w), T.writeBytes(y), T.writeBytes(m), T.writeBytes(E2), f || p || T.writeBytes(v), T.writeUInt8(x), d) {
      const z4 = this.ins[t];
      T.writeBytes(z4.hash), T.writeUInt32LE(z4.index), T.writeUInt64LE(n[t]), T.writeVarBytes(r[t]), T.writeUInt32LE(z4.sequence);
    } else
      T.writeUInt32LE(t);
    if (a) {
      const z4 = new dt4(Lt3(a));
      z4.writeVarBytes(a), T.writeBytes(vt4(z4.finish()));
    }
    p && T.writeBytes(v), o && (T.writeBytes(o), T.writeUInt8(0), T.writeUInt32LE(4294967295));
    const _ = new Uint8Array([0]), M2 = T.finish(), nt5 = new Uint8Array(1 + M2.length);
    return nt5.set(_), nt5.set(M2, 1), Nr2(wr2("TapSighash", nt5));
  }
  /**
   * Pre-compute intermediate hashes for Taproot signing.
   * Call this once before signing multiple inputs to avoid O(n^2) performance.
   *
   * @param prevOutScripts - Array of previous output scripts for all inputs
   * @param values - Array of previous output values for all inputs
   * @returns Cache object to pass to hashForWitnessV1
   */
  getTaprootHashCache(t, r) {
    let n = new dt4(36 * this.ins.length);
    for (const p of this.ins)
      n.writeBytes(p.hash), n.writeUInt32LE(p.index);
    const i = vt4(n.finish());
    n = new dt4(8 * r.length);
    for (const p of r)
      n.writeUInt64LE(p);
    const o = vt4(n.finish());
    let a = 0;
    for (const p of t)
      a += Lt3(p);
    n = new dt4(a);
    for (const p of t)
      n.writeVarBytes(p);
    const u = vt4(n.finish());
    n = new dt4(4 * this.ins.length);
    for (const p of this.ins)
      n.writeUInt32LE(p.sequence);
    const l = vt4(n.finish());
    let d = 0;
    for (const p of this.outs)
      d += 8 + Lt3(p.script);
    n = new dt4(d);
    for (const p of this.outs)
      n.writeUInt64LE(p.value), n.writeVarBytes(p.script);
    const f = this.outs.length ? vt4(n.finish()) : _r12;
    return { hashPrevouts: i, hashAmounts: o, hashScriptPubKeys: u, hashSequences: l, hashOutputs: f };
  }
  /**
   * Hash transaction for signing a SegWit v0 (P2WPKH/P2WSH) input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScript - The script of the output being spent
   * @param value - Value of the output being spent (bigint satoshis)
   * @param hashType - Signature hash type
   * @returns 32-byte hash for signing
   */
  hashForWitnessV0(t, r, n, i) {
    if (!Number.isInteger(t) || t < 0 || t > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for inIndex");
    if (!(r instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array for prevOutScript");
    if (typeof n != "bigint")
      throw new TypeError("Expected bigint for value");
    if (!Number.isInteger(i) || i < 0 || i > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for hashType");
    let o, a, u = _r12, l = _r12, d = _r12;
    if (i & _a29.SIGHASH_ANYONECANPAY || (o = Et4(36 * this.ins.length), a = new dt4(o, 0), this.ins.forEach((p) => {
      a.writeBytes(p.hash), a.writeUInt32LE(p.index);
    }), l = ce3(o)), !(i & _a29.SIGHASH_ANYONECANPAY) && (i & 31) !== _a29.SIGHASH_SINGLE && (i & 31) !== _a29.SIGHASH_NONE && (o = Et4(4 * this.ins.length), a = new dt4(o, 0), this.ins.forEach((p) => {
      a.writeUInt32LE(p.sequence);
    }), d = ce3(o)), (i & 31) !== _a29.SIGHASH_SINGLE && (i & 31) !== _a29.SIGHASH_NONE) {
      const p = this.outs.reduce((w, y) => w + 8 + Lt3(y.script), 0);
      o = Et4(p), a = new dt4(o, 0), this.outs.forEach((w) => {
        a.writeUInt64LE(w.value), a.writeVarBytes(w.script);
      }), u = ce3(o);
    } else if ((i & 31) === _a29.SIGHASH_SINGLE && t < this.outs.length) {
      const p = this.outs[t];
      o = Et4(8 + Lt3(p.script)), a = new dt4(o, 0), a.writeUInt64LE(p.value), a.writeVarBytes(p.script), u = ce3(o);
    }
    o = Et4(156 + Lt3(r)), a = new dt4(o, 0);
    const f = this.ins[t];
    return a.writeInt32LE(this.version), a.writeBytes(l), a.writeBytes(d), a.writeBytes(f.hash), a.writeUInt32LE(f.index), a.writeVarBytes(r), a.writeUInt64LE(n), a.writeUInt32LE(f.sequence), a.writeBytes(u), a.writeUInt32LE(this.locktime), a.writeUInt32LE(i), Nr2(ce3(o));
  }
  /**
   * Get the transaction hash.
   *
   * @param forWitness - If true, include witness data (wtxid)
   * @returns 32-byte transaction hash
   */
  getHash(t) {
    return t && this.isCoinbase() ? new Uint8Array(32) : ce3(__privateMethod(this, _Q_instances, t_fn).call(this, void 0, void 0, t));
  }
  /**
   * Get the transaction ID (txid) as a hex string.
   *
   * @returns Transaction ID in reversed hex format
   */
  getId() {
    return Yt4(ei2(this.getHash(false)));
  }
  /**
   * Serialize the transaction to a Uint8Array buffer.
   *
   * @param buffer - Optional pre-allocated buffer
   * @param initialOffset - Optional starting offset in buffer
   * @returns Serialized transaction bytes
   */
  toBuffer(t, r) {
    return __privateMethod(this, _Q_instances, t_fn).call(this, t, r, true);
  }
  /**
   * Serialize the transaction to a hex string.
   *
   * @returns Transaction as hex string
   */
  toHex() {
    return Yt4(this.toBuffer(void 0, void 0));
  }
  /**
   * Set the input script for a specific input.
   *
   * @param index - Input index
   * @param scriptSig - The script to set
   */
  setInputScript(t, r) {
    if (!Number.isInteger(t) || t < 0)
      throw new TypeError("Expected non-negative integer for index");
    if (!(r instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array for scriptSig");
    this.ins[t].script = r;
  }
  /**
   * Set the witness data for a specific input.
   *
   * @param index - Input index
   * @param witness - Array of witness elements
   */
  setWitness(t, r) {
    if (!Number.isInteger(t) || t < 0)
      throw new TypeError("Expected non-negative integer for index");
    if (!Array.isArray(r) || !r.every((n) => n instanceof Uint8Array))
      throw new TypeError("Expected array of Uint8Array for witness");
    this.ins[t].witness = r;
  }
}, _Q_instances = new WeakSet(), /**
 * Internal method to serialize the transaction.
 *
 * @param buffer - Optional pre-allocated buffer
 * @param initialOffset - Optional starting offset
 * @param _ALLOW_WITNESS - Whether to include witness data
 * @returns Serialized transaction bytes
 */
t_fn = function(t, r, n = false) {
  t || (t = Et4(this.byteLength(n)));
  const i = new dt4(t, r || 0);
  i.writeInt32LE(this.version);
  const o = n && this.hasWitnesses();
  return o && (i.writeUInt8(_a29.ADVANCED_TRANSACTION_MARKER), i.writeUInt8(_a29.ADVANCED_TRANSACTION_FLAG)), i.writeVarInt(this.ins.length), this.ins.forEach((a) => {
    i.writeBytes(a.hash), i.writeUInt32LE(a.index), i.writeVarBytes(a.script), i.writeUInt32LE(a.sequence);
  }), i.writeVarInt(this.outs.length), this.outs.forEach((a) => {
    i.writeUInt64LE(a.value), i.writeVarBytes(a.script);
  }), o && this.ins.forEach((a) => {
    i.writeVector(a.witness);
  }), i.writeUInt32LE(this.locktime), r !== void 0 ? t.subarray(r, i.offset) : t;
}, __publicField(_a29, "DEFAULT_SEQUENCE", 4294967295), __publicField(_a29, "SIGHASH_DEFAULT", 0), __publicField(_a29, "SIGHASH_ALL", 1), __publicField(_a29, "SIGHASH_NONE", 2), __publicField(_a29, "SIGHASH_SINGLE", 3), __publicField(_a29, "SIGHASH_ANYONECANPAY", 128), __publicField(_a29, "SIGHASH_OUTPUT_MASK", 3), __publicField(_a29, "SIGHASH_INPUT_MASK", 128), __publicField(_a29, "ADVANCED_TRANSACTION_MARKER", 0), __publicField(_a29, "ADVANCED_TRANSACTION_FLAG", 1), __publicField(_a29, "TRUC_VERSION", 3), __publicField(_a29, "TRUC_MAX_VSIZE", 1e4), __publicField(_a29, "TRUC_CHILD_MAX_VSIZE", 1e3), _a29);
function ge3(e) {
  return (t) => {
    try {
      return e({ output: t }), true;
    } catch {
      return false;
    }
  };
}
var yf2 = ge3(Er2);
var bf2 = ge3(gi2);
var mf2 = ge3(gr2);
var pn2 = ge3(ln2);
var ps2 = ge3(mr2);
var Go2 = ge3(yr2);
var jo2 = ge3(br2);
var zo2 = ge3(wi2);
var yp2 = (e) => e.length === 4 && e[0] === 81 && // OP_1
e[1] === 2 && // push 2 bytes
e[2] === 78 && e[3] === 115;
function hr(e) {
  const t = [];
  function r(a) {
    t.push(a);
  }
  function n(a) {
    const u = $t4(a), l = Et4(u);
    we4(a, l, 0), t.push(l);
  }
  function i(a) {
    n(a.length), r(a);
  }
  function o(a) {
    n(a.length), a.forEach(i);
  }
  return o(e), _t7(t);
}
function qo2(e, t) {
  const r = tt3(t);
  if (r === null) throw new Error("Unknown script error");
  const n = St3(e), i = $e4(e), o = Dn2(e), a = (o == null ? void 0 : o.hybrid) ? St3(o.hybrid) : void 0, u = (o == null ? void 0 : o.uncompressed) ? St3(o.uncompressed) : void 0;
  return r.findIndex((l) => typeof l == "number" ? false : !!(Ur2(l, e) || Ur2(l, i) || P(l, n) || o && (Ur2(l, o.uncompressed) || Ur2(l, o.hybrid) || a && P(l, a) || u && P(l, u))));
}
function Yr2(e, t) {
  return qo2(e, t) !== -1;
}
function Ef2(e, t) {
  return If2(e).some((r) => Yo2(r, Te4.decode, t));
}
function Yo2(e, t, r) {
  const { hashType: n } = t(e), i = [];
  switch (n & rt4.SIGHASH_ANYONECANPAY && i.push("addInput"), n & 31) {
    case rt4.SIGHASH_ALL:
      break;
    case rt4.SIGHASH_SINGLE:
    case rt4.SIGHASH_NONE:
      i.push("addOutput"), i.push("setInputSequence");
      break;
  }
  return i.indexOf(r) === -1;
}
function If2(e) {
  const { partialSig: t } = e;
  let r;
  if (!t || t.length === 0) {
    if (!e.finalScriptSig && !e.finalScriptWitness) return [];
    r = vf2(e);
  } else
    r = t;
  return r.map((n) => new Uint8Array(n.signature));
}
function vf2(e) {
  const t = e.finalScriptSig ? tt3(new Uint8Array(e.finalScriptSig)) || [] : [], r = e.finalScriptWitness ? tt3(new Uint8Array(e.finalScriptWitness)) || [] : [];
  return t.concat(r).filter((n) => n instanceof Uint8Array && _e9(n)).map((n) => ({ signature: n }));
}
function ds2(e, t, r) {
  const n = Lf2(t, e, r);
  try {
    const i = Nf2(t, n).concat(new Uint8Array(n.script)).concat(new Uint8Array(n.controlBlock));
    return { finalScriptWitness: hr(i) };
  } catch (i) {
    throw new Error(`Can not finalize taproot input #${e}: ${i}`, { cause: i });
  }
}
function Ve4(e, t) {
  const r = t ? new Uint8Array([t]) : new Uint8Array(0);
  return _t7([e, r]);
}
function Vt4(e) {
  return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && (jo2(new Uint8Array(e.witnessUtxo.script)) || zo2(new Uint8Array(e.witnessUtxo.script))));
}
function Gn2(e) {
  return !!(e.witnessUtxo && zo2(new Uint8Array(e.witnessUtxo.script)));
}
function On2(e, t) {
  return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function ws2(e, t, r) {
  Bf2(e, t, r), Rf2(e, t, r);
}
function gs2(e, t, r) {
  _f11(e, t, r), Af2(e, t);
}
function Af2(e, t) {
  if (!t.tapTree && !t.tapInternalKey) return;
  const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
  if (r) {
    const i = e.script, o = Sf2(r, n);
    if (i && !P(i, o))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function Sf2(e, t) {
  const r = t && Tf2(t.leaves), { output: n } = br2({
    internalPubkey: new Uint8Array(e),
    scriptTree: r
  });
  if (!n) throw new Error("Failed to generate taproot script pubkey");
  return n;
}
function Tf2(e = []) {
  const t = e[0];
  return e.length === 1 && t && t.depth === 0 ? {
    output: new Uint8Array(t.script),
    version: t.leafVersion
  } : Pf2(e);
}
function kf2(e, t) {
  return xf2(e).some((r) => Yo2(r, Uf2, t));
}
function Uf2(e) {
  return {
    signature: e.subarray(0, 64),
    hashType: e.subarray(64)[0] || rt4.SIGHASH_DEFAULT
  };
}
function xf2(e) {
  const t = [];
  if (e.tapKeySig && t.push(new Uint8Array(e.tapKeySig)), e.tapScriptSig && t.push(...e.tapScriptSig.map((r) => new Uint8Array(r.signature))), !t.length) {
    const r = Of2(
      e.finalScriptWitness ? new Uint8Array(e.finalScriptWitness) : void 0
    );
    r && t.push(r);
  }
  return t;
}
function Of2(e) {
  if (!e) return;
  const t = e.subarray(2);
  if (t.length === 64 || t.length === 65) return t;
}
function Pf2(e) {
  let t;
  for (const r of e)
    if (t = jn2(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
  return t;
}
function jn2(e, t, r = 0) {
  if (r > $o2) throw new Error("Max taptree depth exceeded.");
  if (e.depth === r)
    return t ? void 0 : {
      output: new Uint8Array(e.script),
      version: e.leafVersion
    };
  if (Ms2(t)) return;
  const n = jn2(e, t && t[0], r + 1);
  if (n) return [n, t && t[1]];
  const i = jn2(e, t && t[1], r + 1);
  if (i) return [t && t[0], i];
}
function Bf2(e, t, r) {
  const n = Vt4(e) && De3(t), i = De3(e) && Vt4(t), o = e === t && Vt4(t) && De3(t);
  if (n || i || o)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function _f11(e, t, r) {
  const n = On2(e) && De3(t), i = De3(e) && On2(t), o = e === t && On2(t) && De3(t);
  if (n || i || o)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function Rf2(e, t, r) {
  const n = Gn2(e) || Gn2(t);
  if (t.tapMerkleRoot) {
    const i = new Uint8Array(t.tapMerkleRoot), o = (t.tapLeafScript || []).every(
      (u) => Pn2(u, i, n)
    ), a = (e.tapLeafScript || []).every(
      (u) => Pn2(u, i, n)
    );
    if (!o || !a)
      throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
  } else if (e.tapMerkleRoot) {
    const i = new Uint8Array(e.tapMerkleRoot);
    if (!(t.tapLeafScript || []).every(
      (o) => Pn2(o, i, n)
    ))
      throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
  }
}
function Pn2(e, t, r = false) {
  if (!t) return true;
  const n = Pt3({
    output: new Uint8Array(e.script),
    version: e.leafVersion
  }), i = new Uint8Array(e.controlBlock);
  if (r)
    return P(fr2(i, n), t);
  const o = i.length >= 33 && (i.length - 33) % 32 === 0, a = i.length >= 1 && (i.length - 1) % 32 === 0;
  if (o) {
    const u = qr2(i, n);
    if (P(u, t)) return true;
  }
  if (a) {
    const u = fr2(i, n);
    if (P(u, t)) return true;
  }
  return false;
}
function Nf2(e, t) {
  const r = new Uint8Array(t.script), n = Pt3({
    output: r,
    version: t.leafVersion
  });
  return (e.tapScriptSig || []).filter((i) => P(new Uint8Array(i.leafHash), n)).map((i) => Hf2(r, i)).sort((i, o) => o.positionInScript - i.positionInScript).map((i) => new Uint8Array(i.signature));
}
function Hf2(e, t) {
  return Object.assign(
    {
      positionInScript: qo2(new Uint8Array(t.pubkey), e)
    },
    t
  );
}
function Lf2(e, t, r) {
  const { tapScriptSig: n } = e;
  if (!n || !n.length)
    throw new Error(
      `Can not finalize taproot input #${t}. No tapleaf script signature provided.`
    );
  const i = (e.tapLeafScript || []).sort((o, a) => o.controlBlock.length - a.controlBlock.length).find((o) => Cf2(o, n, r));
  if (!i)
    throw new Error(
      `Can not finalize taproot input #${t}. Signature for tapleaf script not found.`
    );
  return i;
}
function Cf2(e, t, r) {
  const n = Pt3({
    output: new Uint8Array(e.script),
    version: e.leafVersion
  });
  return (!r || P(r, n)) && t.find((i) => P(new Uint8Array(i.leafHash), n)) !== void 0;
}
function De3(e) {
  return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
var Xo2 = {
  /** ECDSA signature (secp256k1) */
  ECDSA: 0,
  /** Schnorr signature (BIP340) */
  Schnorr: 1
};
function Vf2(e) {
  return e.type === "batchResult";
}
function $f2(e) {
  return e.type === "ready";
}
var At3 = {
  /** Worker is initializing */
  Initializing: 0,
  /** Worker is ready and idle */
  Idle: 1,
  /** Worker is processing a task */
  Busy: 2,
  /** Worker is shutting down */
  ShuttingDown: 3,
  /** Worker has terminated */
  Terminated: 4
};
var Kf2 = '"use strict";var nobleBundle=(()=>{var rt=Object.defineProperty;var _e=Object.getOwnPropertyDescriptor;var Ce=Object.getOwnPropertyNames;var ke=Object.prototype.hasOwnProperty;var Ve=(e,t,n)=>t in e?rt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Ct=(e,t)=>{for(var n in t)rt(e,n,{get:t[n],enumerable:!0})},Te=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of Ce(t))!ke.call(e,r)&&r!==n&&rt(e,r,{get:()=>t[r],enumerable:!(s=_e(t,r))||s.enumerable});return e};var Ge=e=>Te(rt({},"__esModule",{value:!0}),e);var l=(e,t,n)=>Ve(e,typeof t!="symbol"?t+"":t,n);var yn={};Ct(yn,{hmac:()=>lt,secp:()=>Lt,sha256:()=>ht});var Lt={};Ct(Lt,{Point:()=>U,Signature:()=>R,etc:()=>sn,getPublicKey:()=>Pt,getSharedSecret:()=>en,hash:()=>je,hashes:()=>K,keygen:()=>nn,recoverPublicKey:()=>Qe,recoverPublicKeyAsync:()=>tn,schnorr:()=>un,sign:()=>We,signAsync:()=>ze,utils:()=>rn,verify:()=>qe,verifyAsync:()=>Je});var Nt={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:D,n:v,Gx:Fe,Gy:De,b:Zt}=Nt,w=32,Z=64,et={publicKey:w+1,publicKeyUncompressed:Z+1,signature:Z,seed:w+w/2},Ke=(...e)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...e)},b=(e="")=>{let t=new Error(e);throw Ke(t,b),t},Oe=e=>typeof e=="bigint",Ne=e=>typeof e=="string",Ze=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",A=(e,t,n="")=>{let s=Ze(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;b(c+"expected Uint8Array"+i+", got "+u)}return e},k=e=>new Uint8Array(e),jt=(e,t)=>e.toString(16).padStart(t,"0"),wt=e=>Array.from(A(e)).map(t=>jt(t,2)).join(""),V={_0:48,_9:57,A:65,F:70,a:97,f:102},kt=e=>{if(e>=V._0&&e<=V._9)return e-V._0;if(e>=V.A&&e<=V.F)return e-(V.A-10);if(e>=V.a&&e<=V.f)return e-(V.a-10)},mt=e=>{let t="hex invalid";if(!Ne(e))return b(t);let n=e.length,s=n/2;if(n%2)return b(t);let r=k(s);for(let o=0,c=0;o<s;o++,c+=2){let i=kt(e.charCodeAt(c)),u=kt(e.charCodeAt(c+1));if(i===void 0||u===void 0)return b(t);r[o]=i*16+u}return r},Rt=()=>globalThis?.crypto,Vt=()=>Rt()?.subtle??b("crypto.subtle must be defined, consider polyfill"),L=(...e)=>{let t=k(e.reduce((s,r)=>s+A(r).length,0)),n=0;return e.forEach(s=>{t.set(s,n),n+=s.length}),t},nt=(e=w)=>Rt().getRandomValues(k(e)),Y=BigInt,j=(e,t,n,s="bad number: out of range")=>Oe(e)&&t<=e&&e<n?e:b(s),a=(e,t=D)=>{let n=e%t;return n>=0n?n:t+n},E=e=>a(e,v),st=(e,t)=>{(e===0n||t<=0n)&&b("no inverse n="+e+" mod="+t);let n=a(e,t),s=t,r=0n,o=1n,c=1n,i=0n;for(;n!==0n;){let u=s/n,d=s%n,f=r-c*u,h=o-i*u;s=n,n=d,r=c,o=i,c=f,i=h}return s===1n?a(r,t):b("no inverse")},it=e=>{let t=K[e];return typeof t!="function"&&b("hashes."+e+" not set"),t},je=e=>it("sha256")(e),xt=e=>e instanceof U?e:b("Point expected"),Xt=e=>a(a(e*e)*e+Zt),Tt=e=>j(e,0n,D),tt=e=>j(e,1n,D),bt=e=>j(e,1n,v),M=e=>(e&1n)===0n,ft=e=>Uint8Array.of(e),Yt=e=>ft(M(e)?2:3),Mt=e=>{let t=Xt(tt(e)),n=1n;for(let s=t,r=(D+1n)/4n;r>0n;r>>=1n)r&1n&&(n=n*s%D),s=s*s%D;return a(n*n)===t?n:b("sqrt invalid")},C=class C{constructor(t,n,s){l(this,"X");l(this,"Y");l(this,"Z");this.X=Tt(t),this.Y=tt(n),this.Z=Tt(s),Object.freeze(this)}static CURVE(){return Nt}static fromAffine(t){let{x:n,y:s}=t;return n===0n&&s===0n?N:new C(n,s,1n)}static fromBytes(t){A(t);let{publicKey:n,publicKeyUncompressed:s}=et,r,o=t.length,c=t[0],i=t.subarray(1),u=P(i,0,w);if(o===n&&(c===2||c===3)){let d=Mt(u),f=M(d);M(Y(c))!==f&&(d=a(-d)),r=new C(u,d,1n)}return o===s&&c===4&&(r=new C(u,P(i,w,Z),1n)),r?r.assertValidity():b("bad point: not on curve")}static fromHex(t){return C.fromBytes(mt(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=a(n*i),d=a(o*r),f=a(s*i),h=a(c*r);return u===d&&f===h}is0(){return this.equals(N)}negate(){return new C(this.X,a(-this.Y),this.Z)}double(){return this.add(this)}add(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=0n,d=Zt,f=0n,h=0n,x=0n,y=a(d*3n),p=a(n*o),g=a(s*c),H=a(r*i),I=a(n+s),m=a(o+c);I=a(I*m),m=a(p+g),I=a(I-m),m=a(n+r);let S=a(o+i);return m=a(m*S),S=a(p+H),m=a(m-S),S=a(s+r),f=a(c+i),S=a(S*f),f=a(g+H),S=a(S-f),x=a(u*m),f=a(y*H),x=a(f+x),f=a(g-x),x=a(g+x),h=a(f*x),g=a(p+p),g=a(g+p),H=a(u*H),m=a(y*m),g=a(g+H),H=a(p-H),H=a(u*H),m=a(m+H),p=a(g*m),h=a(h+p),p=a(S*m),f=a(I*f),f=a(f-p),p=a(I*g),x=a(S*x),x=a(x+p),new C(f,h,x)}subtract(t){return this.add(xt(t).negate())}multiply(t,n=!0){if(!n&&t===0n)return N;if(bt(t),t===1n)return this;if(this.equals(T))return ln(t).p;let s=N,r=T;for(let o=this;t>0n;o=o.double(),t>>=1n)t&1n?s=s.add(o):n&&(r=r.add(o));return s}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){let{X:t,Y:n,Z:s}=this;if(this.equals(N))return{x:0n,y:0n};if(s===1n)return{x:t,y:n};let r=st(s,D);return a(s*r)!==1n&&b("inverse invalid"),{x:a(t*r),y:a(n*r)}}assertValidity(){let{x:t,y:n}=this.toAffine();return tt(t),tt(n),a(n*n)===Xt(t)?this:b("bad point: not on curve")}toBytes(t=!0){let{x:n,y:s}=this.assertValidity().toAffine(),r=B(n);return t?L(Yt(s),r):L(ft(4),r,B(s))}toHex(t){return wt(this.toBytes(t))}};l(C,"BASE"),l(C,"ZERO");var U=C,T=new U(Fe,De,1n),N=new U(0n,1n,0n);U.BASE=T;U.ZERO=N;var At=(e,t,n)=>T.multiply(t,!1).add(e.multiply(n,!1)).assertValidity(),G=e=>Y("0x"+(wt(e)||"0")),P=(e,t,n)=>G(e.subarray(t,n)),Re=2n**256n,B=e=>mt(jt(j(e,0n,Re),Z)),W=e=>{let t=G(A(e,w,"secret key"));return j(t,1n,v,"invalid secret key: outside of range")},Ht=e=>e>v>>1n,Pt=(e,t=!0)=>T.multiply(W(e)).toBytes(t),Xe=e=>{try{return!!W(e)}catch{return!1}},Ye=(e,t)=>{let{publicKey:n,publicKeyUncompressed:s}=et;try{let r=e.length;return t===!0&&r!==n||t===!1&&r!==s?!1:!!U.fromBytes(e)}catch{return!1}},$t=e=>{[0,1,2,3].includes(e)||b("recovery id must be valid and present")},Me=e=>{e!=null&&!Gt.includes(e)&&b(`Signature format must be one of: ${Gt.join(", ")}`),e===qt&&b(\'Signature format "der" is not supported: switch to noble-curves\')},Wt=(e,t=$)=>{Me(t);let n=et.signature,s=n+1,r=`Signature format "${t}" expects Uint8Array with length `;t===$&&e.length!==n&&b(r+n),t===ot&&e.length!==s&&b(r+s)},R=class e{constructor(t,n,s){l(this,"r");l(this,"s");l(this,"recovery");this.r=bt(t),this.s=bt(n),s!=null&&(this.recovery=s),Object.freeze(this)}static fromBytes(t,n=$){Wt(t,n);let s;n===ot&&(s=t[0],t=t.subarray(1));let r=P(t,0,w),o=P(t,w,Z);return new e(r,o,s)}addRecoveryBit(t){return new e(this.r,this.s,t)}hasHighS(){return Ht(this.s)}toBytes(t=$){let{r:n,s,recovery:r}=this,o=L(B(n),B(s));return t===ot?($t(r),L(Uint8Array.of(r),o)):o}},zt=e=>{let t=e.length*8-256;t>1024&&b("msg invalid");let n=G(e);return t>0?n>>Y(t):n},St=e=>E(zt(A(e))),$="compact",ot="recovered",qt="der",Gt=[$,ot,qt],Ft={lowS:!0,prehash:!0,format:$,extraEntropy:!1},Dt="SHA-256",K={hmacSha256Async:async(e,t)=>{let n=Vt(),s="HMAC",r=await n.importKey("raw",e,{name:s,hash:{name:Dt}},!1,["sign"]);return k(await n.sign(s,r,t))},hmacSha256:void 0,sha256Async:async e=>k(await Vt().digest(Dt,e)),sha256:void 0},z=(e,t,n)=>(A(e,void 0,"message"),t.prehash?n?K.sha256Async(e):it("sha256")(e):e),Jt=k(0),Qt=ft(0),te=ft(1),ee=1e3,ne="drbg: tried max amount of iterations",Pe=(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>it("hmacSha256")(s,L(n,...f)),i=(f=Jt)=>{s=c(Qt,f),n=c(),f.length!==0&&(s=c(te,f),n=c())},u=()=>(r++>=ee&&b(ne),n=c(),n);o(),i(e);let d;for(;!(d=t(u()));)i();return o(),d},$e=async(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>K.hmacSha256Async(s,L(n,...f)),i=async(f=Jt)=>{s=await c(Qt,f),n=await c(),f.length!==0&&(s=await c(te,f),n=await c())},u=async()=>(r++>=ee&&b(ne),n=await c(),n);o(),await i(e);let d;for(;!(d=t(await u()));)await i();return o(),d},se=(e,t,n,s)=>{let{lowS:r,extraEntropy:o}=n,c=B,i=St(e),u=c(i),d=W(t),f=[c(d),u];if(o!=null&&o!==!1){let p=o===!0?nt(w):o;f.push(A(p,void 0,"extraEntropy"))}let h=L(...f),x=i;return s(h,p=>{let g=zt(p);if(!(1n<=g&&g<v))return;let H=st(g,v),I=T.multiply(g).toAffine(),m=E(I.x);if(m===0n)return;let S=E(H*E(x+m*d));if(S===0n)return;let vt=(I.x===m?0:2)|Number(I.y&1n),_t=S;return r&&Ht(S)&&(_t=E(-S),vt^=1),new R(m,_t,vt).toBytes(n.format)})},re=(e,t,n,s={})=>{let{lowS:r,format:o}=s;e instanceof R&&b("Signature must be in Uint8Array, use .toBytes()"),Wt(e,o),A(n,void 0,"publicKey");try{let{r:c,s:i}=R.fromBytes(e,o),u=St(t),d=U.fromBytes(n);if(r&&Ht(i))return!1;let f=st(i,v),h=E(u*f),x=E(c*f),y=At(d,h,x).toAffine();return E(y.x)===c}catch{return!1}},q=e=>{let t={};return Object.keys(Ft).forEach(n=>{t[n]=e[n]??Ft[n]}),t},We=(e,t,n={})=>(n=q(n),e=z(e,n,!1),se(e,t,n,Pe)),ze=async(e,t,n={})=>(n=q(n),e=await z(e,n,!0),se(e,t,n,$e)),qe=(e,t,n,s={})=>(s=q(s),t=z(t,s,!1),re(e,t,n,s)),Je=async(e,t,n,s={})=>(s=q(s),t=await z(t,s,!0),re(e,t,n,s)),oe=(e,t)=>{let n=R.fromBytes(e,"recovered"),{r:s,s:r,recovery:o}=n;$t(o);let c=St(A(t,w)),i=o===2||o===3?s+v:s;tt(i);let u=Yt(Y(o)),d=L(u,B(i)),f=U.fromBytes(d),h=st(i,v),x=E(-c*h),y=E(r*h);return At(f,x,y).toBytes()},Qe=(e,t,n={})=>(t=z(t,q(n),!1),oe(e,t)),tn=async(e,t,n={})=>(t=await z(t,q(n),!0),oe(e,t)),en=(e,t,n=!0)=>U.fromBytes(t).multiply(W(e)).toBytes(n),ce=(e=nt(et.seed))=>{A(e),(e.length<et.seed||e.length>1024)&&b("expected 40-1024b");let t=a(G(e),v-1n);return B(t+1n)},ie=e=>t=>{let n=ce(t);return{secretKey:n,publicKey:e(n)}},nn=ie(Pt),sn={hexToBytes:mt,bytesToHex:wt,concatBytes:L,bytesToNumberBE:G,numberToBytesBE:B,mod:a,invert:st,randomBytes:nt,secretKeyToScalar:W,abytes:A},rn={isValidSecretKey:Xe,isValidPublicKey:Ye,randomSecretKey:ce},fe=e=>Uint8Array.from("BIP0340/"+e,t=>t.charCodeAt(0)),ae="aux",ue="nonce",he="challenge",yt=(e,...t)=>{let n=it("sha256"),s=n(fe(e));return n(L(s,s,...t))},pt=async(e,...t)=>{let n=K.sha256Async,s=await n(fe(e));return await n(L(s,s,...t))},Bt=e=>{let t=W(e),n=T.multiply(t),{x:s,y:r}=n.assertValidity().toAffine(),o=M(r)?t:E(-t),c=B(s);return{d:o,px:c}},Et=e=>E(G(e)),de=(...e)=>Et(yt(he,...e)),le=async(...e)=>Et(await pt(he,...e)),xe=e=>Bt(e).px,on=ie(xe),be=(e,t,n)=>{let{px:s,d:r}=Bt(t);return{m:A(e),px:s,d:r,a:A(n,w)}},ye=e=>{let t=Et(e);t===0n&&b("sign failed: k is zero");let{px:n,d:s}=Bt(B(t));return{rx:n,k:s}},pe=(e,t,n,s)=>L(t,B(E(e+n*s))),ge="invalid signature produced",cn=(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=yt(ae,c),u=B(o^G(i)),d=yt(ue,u,r,s),{rx:f,k:h}=ye(d),x=de(f,r,s),y=pe(h,f,x,o);return me(y,s,r)||b(ge),y},fn=async(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=await pt(ae,c),u=B(o^G(i)),d=await pt(ue,u,r,s),{rx:f,k:h}=ye(d),x=await le(f,r,s),y=pe(h,f,x,o);return await Ae(y,s,r)||b(ge),y},an=(e,t)=>e instanceof Promise?e.then(t):t(e),we=(e,t,n,s)=>{let r=A(e,Z,"signature"),o=A(t,void 0,"message"),c=A(n,w,"publicKey");try{let i=G(c),u=Mt(i),d=M(u)?u:a(-u),f=new U(i,d,1n).assertValidity(),h=B(f.toAffine().x),x=P(r,0,w);j(x,1n,D);let y=P(r,w,Z);j(y,1n,v);let p=L(B(x),h,o);return an(s(p),g=>{let{x:H,y:I}=At(f,y,E(-g)).toAffine();return!(!M(I)||H!==x)})}catch{return!1}},me=(e,t,n)=>we(e,t,n,de),Ae=async(e,t,n)=>we(e,t,n,le),un={keygen:on,getPublicKey:xe,sign:cn,verify:me,signAsync:fn,verifyAsync:Ae},ct=8,hn=256,He=Math.ceil(hn/ct)+1,gt=2**(ct-1),dn=()=>{let e=[],t=T,n=t;for(let s=0;s<He;s++){n=t,e.push(n);for(let r=1;r<gt;r++)n=n.add(t),e.push(n);t=n.double()}return e},Kt,Ot=(e,t)=>{let n=t.negate();return e?n:t},ln=e=>{let t=Kt||(Kt=dn()),n=N,s=T,r=2**ct,o=r,c=Y(r-1),i=Y(ct);for(let u=0;u<He;u++){let d=Number(e&c);e>>=i,d>gt&&(d-=o,e+=1n);let f=u*gt,h=f,x=f+Math.abs(d)-1,y=u%2!==0,p=d<0;d===0?s=s.add(Ot(y,t[h])):n=n.add(Ot(p,t[x]))}return e!==0n&&b("invalid wnaf"),{p:n,f:s}};function xn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Se(e,t=""){if(!Number.isSafeInteger(e)||e<0){let n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function J(e,t,n=""){let s=xn(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;throw new Error(c+"expected Uint8Array"+i+", got "+u)}return e}function Be(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Se(e.outputLen),Se(e.blockLen)}function Q(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Ee(e,t){J(e,void 0,"digestInto() output");let n=t.outputLen;if(e.length<n)throw new Error(\'"digestInto() output" expected to be of length >=\'+n)}function X(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function at(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function _(e,t){return e<<32-t|e>>>t}function Le(e,t={}){let n=(r,o)=>e(o).update(r).digest(),s=e(void 0);return n.outputLen=s.outputLen,n.blockLen=s.blockLen,n.create=r=>e(r),Object.assign(n,t),Object.freeze(n)}var Ue=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function Ie(e,t,n){return e&t^~e&n}function ve(e,t,n){return e&t^e&n^t&n}var ut=class{constructor(t,n,s,r){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=t,this.outputLen=n,this.padOffset=s,this.isLE=r,this.buffer=new Uint8Array(t),this.view=at(this.buffer)}update(t){Q(this),J(t);let{view:n,buffer:s,blockLen:r}=this,o=t.length;for(let c=0;c<o;){let i=Math.min(r-this.pos,o-c);if(i===r){let u=at(t);for(;r<=o-c;c+=r)this.process(u,c);continue}s.set(t.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Q(this),Ee(t,this),this.finished=!0;let{buffer:n,view:s,blockLen:r,isLE:o}=this,{pos:c}=this;n[c++]=128,X(this.buffer.subarray(c)),this.padOffset>r-c&&(this.process(s,0),c=0);for(let h=c;h<r;h++)n[h]=0;s.setBigUint64(r-8,BigInt(this.length*8),o),this.process(s,0);let i=at(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let d=u/4,f=this.get();if(d>f.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<d;h++)i.setUint32(4*h,f[h],o)}digest(){let{buffer:t,outputLen:n}=this;this.digestInto(t);let s=t.slice(0,n);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:n,buffer:s,length:r,finished:o,destroyed:c,pos:i}=this;return t.destroyed=c,t.finished=o,t.length=r,t.pos=i,r%n&&t.buffer.set(s),t}clone(){return this._cloneInto()}},F=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var bn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),O=new Uint32Array(64),Ut=class extends ut{constructor(t){super(64,t,8,!1)}get(){let{A:t,B:n,C:s,D:r,E:o,F:c,G:i,H:u}=this;return[t,n,s,r,o,c,i,u]}set(t,n,s,r,o,c,i,u){this.A=t|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=c|0,this.G=i|0,this.H=u|0}process(t,n){for(let h=0;h<16;h++,n+=4)O[h]=t.getUint32(n,!1);for(let h=16;h<64;h++){let x=O[h-15],y=O[h-2],p=_(x,7)^_(x,18)^x>>>3,g=_(y,17)^_(y,19)^y>>>10;O[h]=g+O[h-7]+p+O[h-16]|0}let{A:s,B:r,C:o,D:c,E:i,F:u,G:d,H:f}=this;for(let h=0;h<64;h++){let x=_(i,6)^_(i,11)^_(i,25),y=f+x+Ie(i,u,d)+bn[h]+O[h]|0,g=(_(s,2)^_(s,13)^_(s,22))+ve(s,r,o)|0;f=d,d=u,u=i,i=c+y|0,c=o,o=r,r=s,s=y+g|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,c=c+this.D|0,i=i+this.E|0,u=u+this.F|0,d=d+this.G|0,f=f+this.H|0,this.set(s,r,o,c,i,u,d,f)}roundClean(){X(O)}destroy(){this.set(0,0,0,0,0,0,0,0),X(this.buffer)}},It=class extends Ut{constructor(){super(32);l(this,"A",F[0]|0);l(this,"B",F[1]|0);l(this,"C",F[2]|0);l(this,"D",F[3]|0);l(this,"E",F[4]|0);l(this,"F",F[5]|0);l(this,"G",F[6]|0);l(this,"H",F[7]|0)}};var ht=Le(()=>new It,Ue(1));var dt=class{constructor(t,n){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if(Be(t),J(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let s=this.blockLen,r=new Uint8Array(s);r.set(n.length>s?t.create().update(n).digest():n);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=t.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),X(r)}update(t){return Q(this),this.iHash.update(t),this}digestInto(t){Q(this),J(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:n,iHash:s,finished:r,destroyed:o,blockLen:c,outputLen:i}=this;return t=t,t.finished=r,t.destroyed=o,t.blockLen=c,t.outputLen=i,t.oHash=n._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},lt=(e,t,n)=>new dt(e,t).update(n).digest();lt.create=(e,t)=>new dt(e,t);K.sha256=ht;K.hmacSha256=(e,...t)=>{let n=new Uint8Array(t.reduce((r,o)=>r+o.length,0)),s=0;for(let r of t)n.set(r,s),s+=r.length;return lt(ht,e,n)};return Ge(yn);})();\n/*! Bundled license information:\n\n@noble/secp256k1/index.js:\n  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)\n\n@noble/hashes/utils.js:\n  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n*/\n';
function Df2() {
  return `
'use strict';

/**
 * Zero out a Uint8Array to clear sensitive data.
 * @param {Uint8Array} arr - Array to zero
 */
function secureZero(arr) {
    if (arr && arr.fill) {
        arr.fill(0);
        // Double-write to prevent optimization
        for (let i = 0; i < arr.length; i++) {
            arr[i] = 0;
        }
    }
}

/**
 * Bundled @noble/secp256k1 + hashes library (embedded at compile time).
 */
const eccBundle = ${JSON.stringify(Kf2)};

/**
 * Initialize the ECC library from the bundle.
 * The bundle exports nobleBundle with { secp, sha256, hmac }.
 */
const eccModule = (function() {
    // Execute the IIFE and return the nobleBundle object
    const fn = new Function(eccBundle + '; return nobleBundle;');
    return fn();
})();

/**
 * ECC library wrapper with the interface we need.
 * Uses eccModule.secp which has hashes pre-configured.
 */
const eccLib = {
    sign: (hash, privateKey) => {
        // noble's sign returns Signature object, we need compact 64-byte format
        const sig = eccModule.secp.sign(hash, privateKey, { lowS: true });
        return sig.toCompactRawBytes();
    },
    signSchnorr: (hash, privateKey) => {
        return eccModule.secp.schnorr.sign(hash, privateKey);
    }
};

/**
 * Whether initialization is complete.
 */
let initialized = false;

/**
 * Pending messages received before init completes.
 */
const pendingMessages = [];

/**
 * Handle incoming messages from main thread.
 */
self.onmessage = async function(event) {
    const msg = event.data;

    // Queue messages until initialized (except init)
    if (!initialized && msg.type !== 'init') {
        pendingMessages.push(msg);
        return;
    }

    await handleMessage(msg);
};

/**
 * Process a message.
 */
async function handleMessage(msg) {
    switch (msg.type) {
        case 'init':
            handleInit(msg);
            break;
        case 'sign':
            handleSign(msg);
            break;
        case 'signBatch':
            handleSignBatch(msg);
            break;
        case 'shutdown':
            handleShutdown();
            break;
        default:
            self.postMessage({
                type: 'error',
                taskId: msg.taskId || 'unknown',
                error: 'Unknown message type: ' + msg.type,
                inputIndex: msg.inputIndex || -1
            });
    }
}

/**
 * Initialize the worker.
 * ECC library is already bundled, so this just marks as ready.
 */
function handleInit(msg) {
    initialized = true;

    // Signal ready
    self.postMessage({ type: 'ready' });

    // Process pending messages
    while (pendingMessages.length > 0) {
        handleMessage(pendingMessages.shift());
    }
}

/**
 * Handle a signing request.
 *
 * SECURITY: Private key is zeroed immediately after use.
 *
 * @param {Object} msg - Signing task message
 */
function handleSign(msg) {
    const {
        taskId,
        hash,
        privateKey,
        publicKey,
        signatureType,
        lowR,
        inputIndex,
        sighashType,
        leafHash
    } = msg;

    // Validate inputs
    if (!hash || hash.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: 'Invalid hash: must be 32 bytes',
            inputIndex: inputIndex
        });
        return;
    }

    if (!privateKey || privateKey.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: 'Invalid private key: must be 32 bytes',
            inputIndex: inputIndex
        });
        return;
    }

    let signature;

    try {
        if (signatureType === 1) {
            // Schnorr signature (BIP340)
            if (typeof eccLib.signSchnorr !== 'function') {
                throw new Error('ECC library does not support Schnorr signatures');
            }
            signature = eccLib.signSchnorr(hash, privateKey);
        } else {
            // ECDSA signature
            if (typeof eccLib.sign !== 'function') {
                throw new Error('ECC library does not support ECDSA signatures');
            }
            signature = eccLib.sign(hash, privateKey, { lowR: lowR || false });
        }

        if (!signature) {
            throw new Error('Signing returned null or undefined');
        }

    } catch (error) {
        // ALWAYS zero the key, even on error
        secureZero(privateKey);

        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: error.message || 'Signing failed',
            inputIndex: inputIndex
        });
        return;
    }

    // CRITICAL: Zero the private key immediately after signing
    secureZero(privateKey);

    // Send result back
    const result = {
        type: 'result',
        taskId: taskId,
        signature: signature,
        inputIndex: inputIndex,
        publicKey: publicKey,
        signatureType: signatureType
    };

    if (leafHash) {
        result.leafHash = leafHash;
    }

    self.postMessage(result);
}

/**
 * Handle a batch signing request.
 * Signs multiple tasks and returns all results in a single message.
 *
 * SECURITY: Private key is zeroed immediately after all signatures.
 *
 * @param {Object} msg - Batch signing message with tasks array
 */
function handleSignBatch(msg) {
    const { batchId, tasks, privateKey } = msg;
    const results = [];
    const errors = [];

    // Validate private key once
    if (!privateKey || privateKey.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'batchResult',
            batchId: batchId,
            results: [],
            errors: [{ inputIndex: -1, error: 'Invalid private key: must be 32 bytes' }]
        });
        return;
    }

    // Process all tasks
    for (const task of tasks) {
        const { taskId, hash, publicKey, signatureType, lowR, inputIndex, sighashType, leafHash } = task;

        // Validate hash
        if (!hash || hash.length !== 32) {
            errors.push({ taskId, inputIndex, error: 'Invalid hash: must be 32 bytes' });
            continue;
        }

        try {
            let signature;
            if (signatureType === 1) {
                // Schnorr signature (BIP340)
                signature = eccLib.signSchnorr(hash, privateKey);
            } else {
                // ECDSA signature
                signature = eccLib.sign(hash, privateKey, { lowR: lowR || false });
            }

            if (!signature) {
                throw new Error('Signing returned null or undefined');
            }

            const result = {
                taskId: taskId,
                signature: signature,
                inputIndex: inputIndex,
                publicKey: publicKey,
                signatureType: signatureType
            };

            if (leafHash) {
                result.leafHash = leafHash;
            }

            results.push(result);
        } catch (error) {
            errors.push({ taskId, inputIndex, error: error.message || 'Signing failed' });
        }
    }

    // CRITICAL: Zero the private key after processing all tasks
    secureZero(privateKey);

    // Send batch result back
    self.postMessage({
        type: 'batchResult',
        batchId: batchId,
        results: results,
        errors: errors
    });
}

/**
 * Handle shutdown request.
 */
function handleShutdown() {
    initialized = false;
    pendingMessages.length = 0;

    self.postMessage({ type: 'shutdown-ack' });

    // Close the worker
    self.close();
}
`;
}
function Mf2() {
  const e = Df2(), t = new Blob([e], { type: "application/javascript" });
  return URL.createObjectURL(t);
}
function Ff2(e) {
  URL.revokeObjectURL(e);
}
var Wf2 = {
  workerCount: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
  taskTimeoutMs: 3e4,
  maxKeyHoldTimeMs: 5e3,
  verifySignatures: true,
  preserveWorkers: false
};
var _a30, _t18, _a31, _e19, _s12, _r13, _n12, _i13, _o13, _h12, _f12, _le_instances, u_fn, c_fn, p_fn, l_fn2, d_fn, w_fn;
var bp2 = (_a30 = class {
  /**
   * Creates a new WorkerSigningPool.
   *
   * @param config - Pool configuration
   */
  constructor(t = {}) {
    __privateAdd(this, _le_instances);
    /**
     * Pool configuration.
     */
    __privateAdd(this, _a31);
    /**
     * Worker pool.
     */
    __privateAdd(this, _e19, []);
    /**
     * Pending batches awaiting completion.
     */
    __privateAdd(this, _s12, /* @__PURE__ */ new Map());
    /**
     * Worker blob URL (shared across all workers).
     */
    __privateAdd(this, _r13, null);
    /**
     * Whether workers are preserved between batches.
     */
    __privateAdd(this, _n12, false);
    /**
     * Next worker ID counter.
     */
    __privateAdd(this, _i13, 0);
    /**
     * Next task ID counter.
     */
    __privateAdd(this, _o13, 0);
    /**
     * Whether the pool is initialized.
     */
    __privateAdd(this, _h12, false);
    /**
     * Whether the pool is shutting down.
     */
    __privateAdd(this, _f12, false);
    __privateSet(this, _a31, { ...Wf2, ...t }), __privateSet(this, _n12, __privateGet(this, _a31).preserveWorkers);
  }
  /**
   * Number of workers in the pool.
   */
  get workerCount() {
    return __privateGet(this, _e19).length;
  }
  /**
   * Number of idle workers available.
   */
  get idleWorkerCount() {
    return __privateGet(this, _e19).filter((t) => t.state === At3.Idle).length;
  }
  /**
   * Number of busy workers.
   */
  get busyWorkerCount() {
    return __privateGet(this, _e19).filter((t) => t.state === At3.Busy).length;
  }
  /**
   * Whether workers are being preserved between batches.
   */
  get isPreservingWorkers() {
    return __privateGet(this, _n12);
  }
  /**
   * Gets the singleton pool instance.
   *
   * @param config - Optional configuration (only used on first call)
   * @returns The singleton pool instance
   *
   * @example
   * ```typescript
   * const pool = WorkerSigningPool.getInstance({ workerCount: 8 });
   * ```
   */
  static getInstance(t) {
    return __privateGet(_a30, _t18) || __privateSet(_a30, _t18, new _a30(t)), __privateGet(_a30, _t18);
  }
  /**
   * Resets the singleton instance (for testing).
   */
  static resetInstance() {
    __privateGet(_a30, _t18) && (__privateGet(_a30, _t18).shutdown().catch(() => {
    }), __privateSet(_a30, _t18, null));
  }
  /**
   * Enables worker preservation between signing batches.
   *
   * When enabled, workers remain alive after completing a batch,
   * ready for the next signing operation. This is faster but
   * keeps workers in memory.
   *
   * Call shutdown() when done to terminate all workers.
   *
   * @example
   * ```typescript
   * const pool = WorkerSigningPool.getInstance();
   * pool.preserveWorkers(); // Enable at app startup
   *
   * // ... do many signing operations ...
   *
   * await pool.shutdown(); // Cleanup at app shutdown
   * ```
   */
  preserveWorkers() {
    __privateSet(this, _n12, true);
  }
  /**
   * Disables worker preservation.
   *
   * Workers will be terminated after each signing batch.
   * More secure (no persistent workers) but slower for multiple batches.
   */
  releaseWorkers() {
    __privateSet(this, _n12, false);
  }
  /**
   * Initializes the worker pool.
   *
   * Creates workers and waits for them to be ready.
   * Called automatically on first signBatch() if not called manually.
   *
   * @returns Promise that resolves when all workers are ready
   */
  async initialize() {
    if (__privateGet(this, _h12))
      return;
    if (__privateGet(this, _f12))
      throw new Error("Cannot initialize pool while shutting down");
    __privateSet(this, _r13, Mf2());
    const t = [];
    for (let r = 0; r < __privateGet(this, _a31).workerCount; r++)
      t.push(__privateMethod(this, _le_instances, u_fn).call(this));
    await Promise.all(t), __privateSet(this, _h12, true);
  }
  /**
   * Signs a batch of tasks in parallel.
   *
   * SECURITY: Private keys are obtained via keyPair.getPrivateKey() and
   * cloned to workers. Keys are zeroed in workers immediately after signing.
   *
   * Tasks are distributed across workers and processed in batches for efficiency.
   *
   * @param tasks - Signing tasks (hashes, input indices, etc.)
   * @param keyPair - Key pair with getPrivateKey() method
   * @returns Promise resolving to signing results
   *
   * @example
   * ```typescript
   * const tasks: SigningTask[] = [
   *     { taskId: '1', inputIndex: 0, hash: hash0, signatureType: SignatureType.ECDSA, sighashType: 0x01 },
   *     { taskId: '2', inputIndex: 1, hash: hash1, signatureType: SignatureType.Schnorr, sighashType: 0x00 },
   * ];
   *
   * const result = await pool.signBatch(tasks, keyPair);
   *
   * if (result.success) {
   *     for (const [inputIndex, sig] of result.signatures) {
   *         console.log(`Input ${inputIndex}: ${sig.signature}`);
   *     }
   * }
   * ```
   */
  async signBatch(t, r) {
    var _a37;
    const n = performance.now();
    if (__privateGet(this, _h12) || await this.initialize(), t.length === 0)
      return {
        success: true,
        signatures: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map(),
        durationMs: performance.now() - n
      };
    const i = Math.min(__privateGet(this, _e19).length, t.length), o = Array.from({ length: i }, () => []);
    for (let u = 0; u < t.length; u++)
      o[u % i].push(t[u]);
    const a = r.getPrivateKey();
    try {
      const u = await Promise.allSettled(
        o.map(
          (f, p) => __privateMethod(this, _le_instances, c_fn).call(this, f, a, r.publicKey, p)
        )
      ), l = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
      for (let f = 0; f < u.length; f++) {
        const p = u[f];
        if (p.status === "fulfilled") {
          const w = p.value;
          for (const y of w.results)
            l.set(y.inputIndex, {
              type: "result",
              taskId: y.taskId,
              signature: y.signature,
              inputIndex: y.inputIndex,
              publicKey: y.publicKey,
              signatureType: y.signatureType,
              leafHash: y.leafHash
            });
          for (const y of w.errors)
            d.set(y.inputIndex, y.error);
        } else {
          const w = ((_a37 = p.reason) == null ? void 0 : _a37.message) ?? "Batch signing failed", y = o[f];
          for (const m of y)
            d.set(m.inputIndex, w);
        }
      }
      return __privateGet(this, _n12) || await __privateMethod(this, _le_instances, w_fn).call(this), {
        success: d.size === 0,
        signatures: l,
        errors: d,
        durationMs: performance.now() - n
      };
    } finally {
      a.fill(0);
    }
  }
  /**
   * Disposes of the pool by shutting down all workers.
   *
   * Enables `await using pool = ...` syntax for automatic cleanup.
   */
  async [Symbol.asyncDispose]() {
    await this.shutdown();
  }
  /**
   * Shuts down the pool and terminates all workers.
   *
   * Call this when the application is done with signing operations.
   *
   * @returns Promise that resolves when all workers are terminated
   */
  async shutdown() {
    if (__privateGet(this, _f12))
      return;
    __privateSet(this, _f12, true);
    const t = __privateGet(this, _e19).map((r) => __privateMethod(this, _le_instances, d_fn).call(this, r));
    await Promise.all(t), __privateGet(this, _e19).length = 0, __privateGet(this, _s12).clear(), __privateGet(this, _r13) && (Ff2(__privateGet(this, _r13)), __privateSet(this, _r13, null)), __privateSet(this, _h12, false), __privateSet(this, _f12, false);
  }
  [Symbol.dispose]() {
    this.shutdown();
  }
}, _t18 = new WeakMap(), _a31 = new WeakMap(), _e19 = new WeakMap(), _s12 = new WeakMap(), _r13 = new WeakMap(), _n12 = new WeakMap(), _i13 = new WeakMap(), _o13 = new WeakMap(), _h12 = new WeakMap(), _f12 = new WeakMap(), _le_instances = new WeakSet(), u_fn = async function() {
  if (!__privateGet(this, _r13))
    throw new Error("Worker blob URL not created");
  const t = __privateWrapper(this, _i13)._++, r = new Worker(__privateGet(this, _r13), {
    name: `signing-worker-${t}`
  }), n = {
    id: t,
    state: At3.Initializing,
    worker: r,
    currentTaskId: null,
    taskStartTime: null
  };
  __privateGet(this, _e19).push(n), await new Promise((i, o) => {
    const a = setTimeout(() => {
      o(new Error(`Worker ${t} initialization timeout`));
    }, 1e4), u = (l) => {
      $f2(l.data) && (clearTimeout(a), r.removeEventListener("message", u), n.state = At3.Idle, i());
    };
    r.addEventListener("message", u), r.addEventListener("error", (l) => {
      clearTimeout(a), o(new Error(`Worker ${t} error: ${l.message}`));
    }), r.postMessage({
      type: "init"
    });
  }), r.addEventListener("message", (i) => {
    __privateMethod(this, _le_instances, l_fn2).call(this, n, i.data);
  });
}, c_fn = async function(t, r, n, i) {
  if (t.length === 0)
    return { type: "batchResult", batchId: "", results: [], errors: [] };
  const o = __privateGet(this, _e19)[i] ?? await __privateMethod(this, _le_instances, p_fn).call(this), a = `batch-${__privateWrapper(this, _o13)._++}`;
  return new Promise((u, l) => {
    const d = setTimeout(() => {
      __privateGet(this, _s12).delete(a), o.state = At3.Idle, o.currentTaskId = null, o.taskStartTime = null, __privateMethod(this, _le_instances, d_fn).call(this, o).catch(() => {
      }), __privateMethod(this, _le_instances, u_fn).call(this).catch(() => {
      }), l(new Error(`Batch signing timeout for ${t.length} tasks`));
    }, __privateGet(this, _a31).maxKeyHoldTimeMs), f = {
      batchId: a,
      resolve: u,
      reject: l,
      timeoutId: d
    };
    __privateGet(this, _s12).set(a, f), o.state = At3.Busy, o.currentTaskId = a, o.taskStartTime = Date.now();
    const p = t.map((y) => ({
      taskId: y.taskId,
      hash: y.hash,
      publicKey: n,
      signatureType: y.signatureType,
      lowR: y.lowR,
      inputIndex: y.inputIndex,
      sighashType: y.sighashType,
      leafHash: y.leafHash
    })), w = {
      type: "signBatch",
      batchId: a,
      tasks: p,
      privateKey: r
      // Cloned to worker, zeroed there after all signatures
    };
    o.worker.postMessage(w);
  });
}, p_fn = async function() {
  let t = __privateGet(this, _e19).find((r) => r.state === At3.Idle);
  return t || __privateGet(this, _e19).length < __privateGet(this, _a31).workerCount && (await __privateMethod(this, _le_instances, u_fn).call(this), t = __privateGet(this, _e19).find((r) => r.state === At3.Idle), t) ? t : new Promise((r) => {
    const n = setInterval(() => {
      const i = __privateGet(this, _e19).find((o) => o.state === At3.Idle);
      i && (clearInterval(n), r(i));
    }, 10);
  });
}, /**
 * Handles a message from a worker.
 */
l_fn2 = function(t, r) {
  if (Vf2(r)) {
    const n = __privateGet(this, _s12).get(r.batchId);
    n && (clearTimeout(n.timeoutId), __privateGet(this, _s12).delete(r.batchId), t.state = At3.Idle, t.currentTaskId = null, t.taskStartTime = null, n.resolve(r));
  }
}, d_fn = async function(t) {
  if (t.state === At3.Terminated)
    return;
  t.state = At3.ShuttingDown, t.worker.postMessage({ type: "shutdown" }), await new Promise((n) => {
    const i = setTimeout(() => {
      t.worker.terminate(), t.state = At3.Terminated, n();
    }, 1e3), o = (a) => {
      a.data.type === "shutdown-ack" && (clearTimeout(i), t.worker.removeEventListener("message", o), t.worker.terminate(), t.state = At3.Terminated, n());
    };
    t.worker.addEventListener("message", o);
  });
  const r = __privateGet(this, _e19).indexOf(t);
  r >= 0 && __privateGet(this, _e19).splice(r, 1);
}, w_fn = async function() {
  const t = __privateGet(this, _e19).filter((r) => r.state === At3.Idle);
  await Promise.all(t.map((r) => __privateMethod(this, _le_instances, d_fn).call(this, r)));
}, /**
 * Singleton instance.
 */
__privateAdd(_a30, _t18, null), _a30);
function mp2(e, t, r = {}) {
  const n = [], i = e.data.inputs, o = t.publicKey;
  for (let a = 0; a < i.length; a++) {
    const u = i[a];
    if (e.inputHasPubkey(a, o))
      if (Vt4(u)) {
        const l = Gf2(e, a, u, t, r);
        n.push(...l);
      } else {
        const l = jf2(e, a, u, t, r);
        l && n.push(l);
      }
  }
  return n;
}
function Gf2(e, t, r, n, i) {
  const o = [];
  try {
    const a = e.checkTaprootHashesForSig(
      t,
      r,
      n,
      i.tapLeafHash,
      i.sighashTypes
    );
    for (const { hash: u, leafHash: l } of a)
      o.push({
        taskId: `taproot-${t}-${l ? "script" : "key"}`,
        inputIndex: t,
        hash: u,
        signatureType: Xo2.Schnorr,
        sighashType: r.sighashType ?? rt4.SIGHASH_DEFAULT,
        leafHash: l
      });
  } catch {
  }
  return o;
}
function jf2(e, t, r, n, i) {
  try {
    const o = r.sighashType ?? rt4.SIGHASH_ALL;
    return (i.sighashTypes ?? [rt4.SIGHASH_ALL]).includes(o), null;
  } catch {
    return null;
  }
}
function Ep2(e, t, r) {
  const n = r.publicKey;
  for (const [i, o] of t.signatures) {
    const a = e.data.inputs[i];
    if (o.signatureType === Xo2.Schnorr)
      if (o.leafHash) {
        const u = [
          {
            pubkey: $e4(n),
            signature: Ve4(
              o.signature,
              a.sighashType
            ),
            leafHash: o.leafHash
          }
        ];
        e.data.updateInput(i, { tapScriptSig: u });
      } else {
        const u = Ve4(o.signature, a.sighashType);
        e.data.updateInput(i, { tapKeySig: u });
      }
    else {
      const u = Te4.encode(
        o.signature,
        a.sighashType ?? rt4.SIGHASH_ALL
      ), l = [
        {
          pubkey: Uint8Array.from(n),
          signature: u
        }
      ];
      e.data.updateInput(i, { partialSig: l });
    }
  }
}
function zf2(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
var Ir2 = 40;
var vr2 = 2;
var Ar2 = 15;
var Zo2 = 16;
var Xr2 = 16;
var dn2 = 2;
var wn2 = 80;
var qf2 = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
var Qo2 = (e) => {
  try {
    const t = e.subarray(2);
    if (t.length < vr2 || t.length > Ir2)
      throw new TypeError("Invalid program length for segwit address");
    const r = e[0];
    if (r === void 0) throw new TypeError("Empty output");
    const n = r - wn2;
    if (n < dn2 || n > Ar2 + 1)
      throw new TypeError("Invalid version for segwit address");
    if (n === 1) throw new TypeError("taproot");
    return true;
  } catch {
  }
  return false;
};
function Jo2(e, t) {
  if (!(e instanceof Uint8Array)) throw new TypeError("output must be a Uint8Array");
  if (!t.bech32Opnet) throw new Error("Network does not support opnet");
  const r = e[0];
  let n = 1, i;
  const o = e[1], a = e[2];
  if (o !== void 0 && o < 76)
    i = o, n = 2;
  else if (o === 76 && a !== void 0)
    i = a, n = 3;
  else
    throw new TypeError("Unsupported push opcode in script");
  const u = e.subarray(n, n + i);
  if (u.length < vr2 || u.length > Ir2)
    throw new TypeError("Invalid program length for segwit address");
  const l = r === q2.OP_0 ? 0 : r !== void 0 && r >= q2.OP_1 && r <= q2.OP_16 ? r - (q2.OP_1 - 1) : -1;
  if (l < Ar2 || l > Zo2)
    throw new TypeError(`Invalid segwit version ${l}`);
  const d = [l, ...J2.bech32m.toWords(u)];
  return J2.bech32m.encode(t.bech32Opnet, d);
}
function ta2(e, t) {
  const r = e.subarray(2);
  if (r.length < vr2 || r.length > Ir2)
    throw new TypeError("Invalid program length for segwit address");
  const n = e[0];
  if (n === void 0) throw new TypeError("Empty output");
  const i = n - wn2;
  if (i < dn2 || i > Ar2)
    throw new TypeError("Invalid version for segwit address");
  if (e[1] !== r.length)
    throw new TypeError(`Invalid script for segwit address ${e[1]} !== ${r.length}`);
  return Zr2(r, i, t.bech32, t.bech32Opnet);
}
function ea2(e) {
  const t = new Uint8Array(ti2(e));
  if (t.length < 21) throw new TypeError(e + " is too short");
  if (t.length > 21) throw new TypeError(e + " is too long");
  const r = t[0], n = t.subarray(1);
  return { version: r, hash: n };
}
function zn2(e, t) {
  if (!Ds2(e)) throw new TypeError("Expected 20 bytes hash");
  if (!Ks2(t)) throw new TypeError("Expected UInt8 version");
  const r = Et4(21);
  return r[0] = t, r.set(e, 1), Jn2(r);
}
function Zr2(e, t, r, n) {
  const i = J2.bech32.toWords(e);
  return i.unshift(t), t === Xr2 && n ? J2.bech32m.encode(n, i) : t === 0 ? J2.bech32.encode(r, i) : J2.bech32m.encode(r, i);
}
function ra2(e, t) {
  t = t || kt3;
  const r = e.length;
  if (r === 25 && e[0] === 118 && e[1] === 169 && e[2] === 20 && e[23] === 136 && e[24] === 172)
    return zn2(e.subarray(3, 23), t.pubKeyHash);
  if (r === 23 && e[0] === 169 && e[1] === 20 && e[22] === 135)
    return zn2(e.subarray(2, 22), t.scriptHash);
  if (r === 22 && e[0] === 0 && e[1] === 20)
    return Zr2(e.subarray(2, 22), 0, t.bech32);
  if (r === 34 && e[0] === 0 && e[1] === 32)
    return Zr2(e.subarray(2, 34), 0, t.bech32);
  if (r === 34 && e[0] === 81 && e[1] === 32) {
    const n = J2.bech32m.toWords(e.subarray(2, 34));
    return n.unshift(1), J2.bech32m.encode(t.bech32, n);
  }
  if (r === 34 && e[0] === 82 && e[1] === 32) {
    const n = J2.bech32m.toWords(e.subarray(2, 34));
    return n.unshift(2), J2.bech32m.encode(t.bech32, n);
  }
  try {
    return Jo2(e, t);
  } catch {
  }
  try {
    return ta2(e, t);
  } catch {
  }
  throw new Error(Gs2(e) + " has no matching Address");
}
function na2(e, t) {
  let r, n;
  t && "bech32" in t ? r = t : t && typeof t == "object" ? (r = t.network || kt3, n = t.onFutureSegwitWarning) : r = kt3;
  let i, o;
  try {
    i = ea2(e);
  } catch {
  }
  if (i) {
    if (i.version === r.pubKeyHash)
      return gr2({ hash: i.hash }).output;
    if (i.version === r.scriptHash)
      return yr2({ hash: i.hash }).output;
  } else {
    try {
      o = dr2(e);
    } catch {
    }
    if (o) {
      if (o.prefix !== r.bech32 && r.bech32Opnet && o.prefix !== r.bech32Opnet)
        throw new Error(e + " has an invalid prefix");
      if (o.version === 0) {
        if (o.data.length === 20)
          return ln2({ hash: Ph2(o.data) }).output;
        if (o.data.length === 32)
          return mr2({ hash: Pi2(o.data) }).output;
      } else if (o.version === 1) {
        if (o.data.length === 32)
          return br2({ pubkey: o.data }).output;
      } else {
        if (o.version === 2 && o.data.length === 32)
          return wi2({ hash: Pi2(o.data) }).output;
        if (o.version === Xr2) {
          if (!r.bech32Opnet) throw new Error(e + " has an invalid prefix");
          return Ys2({
            program: o.data,
            network: r
          }).output;
        } else if (o.version >= dn2 && o.version <= Ar2 && o.data.length >= vr2 && o.data.length <= Ir2)
          return o.version !== Xr2 && n && n(qf2), gt3([
            o.version + wn2,
            o.data
          ]);
      }
    }
  }
  throw new TypeError(e + " has no matching Script");
}
var Ip2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  FUTURE_MAX_VERSION: Zo2,
  FUTURE_OPNET_VERSION: Xr2,
  FUTURE_SEGWIT_MAX_SIZE: Ir2,
  FUTURE_SEGWIT_MAX_VERSION: Ar2,
  FUTURE_SEGWIT_MIN_SIZE: vr2,
  FUTURE_SEGWIT_MIN_VERSION: dn2,
  FUTURE_SEGWIT_VERSION_DIFF: wn2,
  _toFutureSegwitAddress: ta2,
  fromBase58Check: ea2,
  fromBech32: dr2,
  fromOutputScript: ra2,
  isUnknownSegwitVersion: Qo2,
  toBase58Check: zn2,
  toBech32: Zr2,
  toFutureOPNetAddress: Jo2,
  toOutputScript: na2
}, Symbol.toStringTag, { value: "Module" }));
var ys = q2;
var _t19, _a32, _e20, _s13, _r14, _n13, _i14, _o14, _lr_instances, h_fn, f_fn, u_fn2;
var _lr = class _lr {
  /**
   * Creates a new Embed payment instance.
   *
   * @param params - Payment parameters
   * @param params.data - Array of data chunks to embed
   * @param params.output - The scriptPubKey
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    __privateAdd(this, _lr_instances);
    // Private instance fields
    __privateAdd(this, _t19);
    __privateAdd(this, _a32);
    // Input data (provided by user)
    __privateAdd(this, _e20);
    __privateAdd(this, _s13);
    // Cached computed values
    __privateAdd(this, _r14);
    __privateAdd(this, _n13);
    // Cache flags
    __privateAdd(this, _i14, false);
    __privateAdd(this, _o14, false);
    __privateSet(this, _t19, t.network ?? kt3), __privateSet(this, _a32, {
      validate: (r == null ? void 0 : r.validate) ?? true,
      allowIncomplete: (r == null ? void 0 : r.allowIncomplete) ?? false
    }), __privateSet(this, _e20, t.data), __privateSet(this, _s13, t.output), __privateGet(this, _a32).validate && __privateMethod(this, _lr_instances, u_fn2).call(this);
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ft4.Embed;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _t19);
  }
  /**
   * The embedded data chunks.
   */
  get data() {
    return __privateGet(this, _i14) || (__privateSet(this, _r14, __privateMethod(this, _lr_instances, h_fn).call(this)), __privateSet(this, _i14, true)), __privateGet(this, _r14) ?? [];
  }
  /**
   * The scriptPubKey: `OP_RETURN {data...}`
   */
  get output() {
    return __privateGet(this, _o14) || (__privateSet(this, _n13, __privateMethod(this, _lr_instances, f_fn).call(this)), __privateSet(this, _o14, true)), __privateGet(this, _n13);
  }
  // Static factory methods
  /**
   * Creates an Embed payment from data chunks.
   *
   * @param data - Array of data chunks to embed
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new Embed payment instance
   *
   * @example
   * ```typescript
   * const payment = Embed.fromData([
   *   new TextEncoder().encode('Hello'),
   *   new TextEncoder().encode('Bitcoin')
   * ]);
   * ```
   */
  static fromData(t, r) {
    return new _lr({ data: t, network: r });
  }
  /**
   * Creates an Embed payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new Embed payment instance
   */
  static fromOutput(t, r) {
    return new _lr({ output: t, network: r });
  }
  // Private computation methods
  /**
   * Converts to a plain EmbedPayment object for backwards compatibility.
   *
   * @returns An EmbedPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      data: this.data,
      output: this.output
    };
  }
};
_t19 = new WeakMap();
_a32 = new WeakMap();
_e20 = new WeakMap();
_s13 = new WeakMap();
_r14 = new WeakMap();
_n13 = new WeakMap();
_i14 = new WeakMap();
_o14 = new WeakMap();
_lr_instances = new WeakSet();
h_fn = function() {
  var _a37;
  if (__privateGet(this, _e20))
    return __privateGet(this, _e20);
  if (__privateGet(this, _s13))
    return (_a37 = tt3(__privateGet(this, _s13))) == null ? void 0 : _a37.slice(1);
};
// Validation
f_fn = function() {
  if (__privateGet(this, _s13))
    return __privateGet(this, _s13);
  if (__privateGet(this, _e20))
    return gt3([ys.OP_RETURN].concat(__privateGet(this, _e20)));
};
u_fn2 = function() {
  if (__privateGet(this, _s13)) {
    const t = tt3(__privateGet(this, _s13));
    if (!t)
      throw new TypeError("Output is invalid");
    if (t[0] !== ys.OP_RETURN)
      throw new TypeError("Output is invalid");
    if (!t.slice(1).every((r) => r instanceof Uint8Array))
      throw new TypeError("Output is invalid");
    if (__privateGet(this, _e20) && !Oe3(__privateGet(this, _e20), this.data))
      throw new TypeError("Data mismatch");
  }
};
// Static public fields
__publicField(_lr, "NAME", ft4.Embed);
var lr2 = _lr;
function Yf2(e, t) {
  if (!e.data && !e.output)
    throw new TypeError("Not enough data");
  const r = new lr2(
    {
      data: e.data,
      output: e.output,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
var Xf2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  Embed: lr2,
  LEAF_VERSION_TAPSCRIPT: Ge3,
  MAX_TAPTREE_DEPTH: $o2,
  P2MR: Ko2,
  P2MS: Wo2,
  P2OP: qs2,
  P2PK: Fo2,
  P2PKH: lo2,
  P2SH: po2,
  P2TR: Do2,
  P2WPKH: Mo2,
  P2WSH: Ae4,
  PaymentType: ft4,
  findScriptPath: Be3,
  p2data: Yf2,
  p2mr: wi2,
  p2ms: Er2,
  p2op: Ys2,
  p2pk: gi2,
  p2pkh: gr2,
  p2sh: yr2,
  p2tr: br2,
  p2wpkh: ln2,
  p2wsh: mr2,
  rootHashFromPath: qr2,
  rootHashFromPathP2MR: fr2,
  tapBranchHash: je4,
  tapleafHash: Pt3,
  toHashTree: cr2,
  tweakKey: ir2
}, Symbol.toStringTag, { value: "Module" }));
Mt3("6a24aa21a9ed");
var qt4;
(function(e) {
  e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(qt4 || (qt4 = {}));
var R;
(function(e) {
  e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(R || (R = {}));
var ht3;
(function(e) {
  e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(ht3 || (ht3 = {}));
var Qr2 = "0123456789abcdefABCDEF";
var Jr2 = Qr2.split("").map((e) => e.codePointAt(0));
var tn2 = Array(256).fill(true).map((e, t) => {
  const r = String.fromCodePoint(t), n = Qr2.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
});
var ia2 = new TextEncoder();
var sa2 = new TextDecoder();
function Zf2(e) {
  return sa2.decode(e);
}
function Qf2(e) {
  return ia2.encode(e);
}
function Xt4(e) {
  const t = e.reduce((i, o) => i + o.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const i of e)
    r.set(i, n), n += i.length;
  return r;
}
function j2(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? tc2(t) : Jf2(t);
}
function Jf2(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += Qr2[tn2[Jr2[e[r] >> 4]]], t += Qr2[tn2[Jr2[e[r] & 15]]];
  return t;
}
function tc2(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = Jr2[e[r] >> 4], t[r * 2 + 1] = Jr2[e[r] & 15];
  return sa2.decode(t);
}
function ec2(e) {
  const t = ia2.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const i = tn2[t[n * 2]], o = tn2[t[n * 2 + 1]];
    if (i === void 0 || o === void 0)
      break;
    r[n] = i << 4 | o;
  }
  return n === r.length ? r : r.slice(0, n);
}
function rc2(e) {
  return btoa(String.fromCharCode(...e));
}
function nc2(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
function Zt3(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function yi2(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function bs2(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function gn2(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function ic2(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function sc2(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let n = 0n;
  if (r === "LE")
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
  {
    let i = 0n;
    return i = (i << 8n) + BigInt(e[t]), i = (i << 8n) + BigInt(e[t + 1]), i = (i << 8n) + BigInt(e[t + 2]), i = (i << 8n) + BigInt(e[t + 3]), i = (i << 8n) + BigInt(e[t + 4]), i = (i << 8n) + BigInt(e[t + 5]), i = (i << 8n) + BigInt(e[t + 6]), i = (i << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? i : i - 0x10000000000000000n;
  }
}
var oc2 = (e) => [...Array(e).keys()];
function ac2(e) {
  if (e.key[0] !== qt4.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + j2(e.key)
    );
  if (e.key.length !== 79 || ![2, 3].includes(e.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + j2(e.key)
    );
  if (e.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const t = e.key.slice(1), r = {
    masterFingerprint: e.value.slice(0, 4),
    extendedPubkey: t,
    path: "m"
  };
  for (const n of oc2(e.value.length / 4 - 1)) {
    const i = gn2(e.value, n * 4 + 4, "LE"), o = !!(i & 2147483648), a = i & 2147483647;
    r.path += "/" + a.toString(10) + (o ? "'" : "");
  }
  return r;
}
function hc2(e) {
  const t = new Uint8Array([qt4.GLOBAL_XPUB]), r = Xt4([t, e.extendedPubkey]), n = e.path.split("/"), i = new Uint8Array(n.length * 4);
  i.set(e.masterFingerprint, 0);
  let o = 4;
  return n.slice(1).forEach((a) => {
    const u = a.slice(-1) === "'";
    let l = 2147483647 & parseInt(u ? a.slice(0, -1) : a, 10);
    u && (l += 2147483648), yi2(i, o, l, "LE"), o += 4;
  }), {
    key: r,
    value: i
  };
}
var uc2 = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function fc2(e) {
  const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
  return t instanceof Uint8Array && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function cc2(e, t, r) {
  const n = j2(t.extendedPubkey);
  return r.has(n) ? false : (r.add(n), e.filter((i) => Zt3(i.extendedPubkey, t.extendedPubkey)).length === 0);
}
var lc2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: cc2,
  check: fc2,
  decode: ac2,
  encode: hc2,
  expected: uc2
}, Symbol.toStringTag, { value: "Module" }));
function pc2(e) {
  return {
    key: new Uint8Array([qt4.UNSIGNED_TX]),
    value: e.toBuffer()
  };
}
var dc2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  encode: pc2
}, Symbol.toStringTag, { value: "Module" }));
function wc2(e) {
  if (e.key[0] !== R.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + j2(e.key)
    );
  return e.value;
}
function gc2(e) {
  return {
    key: new Uint8Array([R.FINAL_SCRIPTSIG]),
    value: e
  };
}
var yc2 = "Uint8Array";
function bc2(e) {
  return e instanceof Uint8Array;
}
function mc2(e, t) {
  return !!e && !!t && e.finalScriptSig === void 0;
}
var Ec2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: mc2,
  check: bc2,
  decode: wc2,
  encode: gc2,
  expected: yc2
}, Symbol.toStringTag, { value: "Module" }));
function Ic2(e) {
  if (e.key[0] !== R.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + j2(e.key)
    );
  return e.value;
}
function vc2(e) {
  return {
    key: new Uint8Array([R.FINAL_SCRIPTWITNESS]),
    value: e
  };
}
var Ac2 = "Uint8Array";
function Sc2(e) {
  return e instanceof Uint8Array;
}
function Tc2(e, t) {
  return !!e && !!t && e.finalScriptWitness === void 0;
}
var kc2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Tc2,
  check: Sc2,
  decode: Ic2,
  encode: vc2,
  expected: Ac2
}, Symbol.toStringTag, { value: "Module" }));
function Uc2(e) {
  if (e.key[0] !== R.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + j2(e.key)
    );
  return e.value;
}
function xc2(e) {
  return {
    key: new Uint8Array([R.NON_WITNESS_UTXO]),
    value: e
  };
}
var Oc2 = "Uint8Array";
function Pc2(e) {
  return e instanceof Uint8Array;
}
function Bc2(e, t) {
  return !!e && !!t && e.nonWitnessUtxo === void 0;
}
var _c11 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Bc2,
  check: Pc2,
  decode: Uc2,
  encode: xc2,
  expected: Oc2
}, Symbol.toStringTag, { value: "Module" }));
function Rc2(e) {
  if (e.key[0] !== R.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + j2(e.key)
    );
  if (!(e.key.length === 34 || e.key.length === 66) || ![2, 3, 4].includes(e.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + j2(e.key)
    );
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}
function Nc2(e) {
  const t = new Uint8Array([R.PARTIAL_SIG]);
  return {
    key: Xt4([t, e.pubkey]),
    value: e.signature
  };
}
var Hc2 = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function Lc2(e) {
  return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && Cc2(e.signature);
}
function Cc2(e) {
  if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return false;
  const t = e[3];
  if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return false;
  const r = e[3 + t + 2];
  return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function Vc2(e, t, r) {
  const n = j2(t.pubkey);
  return r.has(n) ? false : (r.add(n), e.filter((i) => Zt3(i.pubkey, t.pubkey) === 0).length === 0);
}
var $c2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: Vc2,
  check: Lc2,
  decode: Rc2,
  encode: Nc2,
  expected: Hc2
}, Symbol.toStringTag, { value: "Module" }));
function Kc2(e) {
  if (e.key[0] !== R.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + j2(e.key)
    );
  return Zf2(e.value);
}
function Dc2(e) {
  return {
    key: new Uint8Array([R.POR_COMMITMENT]),
    value: Qf2(e)
  };
}
var Mc2 = "string";
function Fc2(e) {
  return typeof e == "string";
}
function Wc2(e, t) {
  return !!e && !!t && e.porCommitment === void 0;
}
var Gc2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Wc2,
  check: Fc2,
  decode: Kc2,
  encode: Dc2,
  expected: Mc2
}, Symbol.toStringTag, { value: "Module" }));
function jc2(e) {
  if (e.key[0] !== R.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + j2(e.key)
    );
  return Number(gn2(e.value, 0, "LE"));
}
function zc2(e) {
  const t = Uint8Array.from([R.SIGHASH_TYPE]), r = new Uint8Array(4);
  return yi2(r, 0, e, "LE"), {
    key: t,
    value: r
  };
}
var qc2 = "number";
function Yc2(e) {
  return typeof e == "number";
}
function Xc2(e, t) {
  return !!e && !!t && e.sighashType === void 0;
}
var Zc2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Xc2,
  check: Yc2,
  decode: jc2,
  encode: zc2,
  expected: qc2
}, Symbol.toStringTag, { value: "Module" }));
function Qc2(e) {
  if (e.key[0] !== R.TAP_KEY_SIG || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + j2(e.key)
    );
  if (!oa2(e.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return e.value;
}
function Jc2(e) {
  return { key: Uint8Array.from([R.TAP_KEY_SIG]), value: e };
}
var tl2 = "Uint8Array";
function oa2(e) {
  return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function el2(e, t) {
  return !!e && !!t && e.tapKeySig === void 0;
}
var rl2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: el2,
  check: oa2,
  decode: Qc2,
  encode: Jc2,
  expected: tl2
}, Symbol.toStringTag, { value: "Module" }));
function nl2(e) {
  if (e.key[0] !== R.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + j2(e.key)
    );
  if ((e.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + j2(e.key)
    );
  const t = e.value[e.value.length - 1];
  if ((e.key[1] & 254) !== t)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + j2(e.key)
    );
  const r = e.value.slice(0, -1);
  return { controlBlock: e.key.slice(1), script: r, leafVersion: t };
}
function il2(e) {
  const t = Uint8Array.from([R.TAP_LEAF_SCRIPT]), r = Uint8Array.from([e.leafVersion]);
  return {
    key: Xt4([t, e.controlBlock]),
    value: Xt4([e.script, r])
  };
}
var sl2 = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function ol2(e) {
  return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function al2(e, t, r) {
  const n = j2(t.controlBlock);
  return r.has(n) ? false : (r.add(n), e.filter((i) => Zt3(i.controlBlock, t.controlBlock) === 0).length === 0);
}
var hl2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: al2,
  check: ol2,
  decode: nl2,
  encode: il2,
  expected: sl2
}, Symbol.toStringTag, { value: "Module" }));
function ul2(e) {
  if (e.key[0] !== R.TAP_MERKLE_ROOT || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + j2(e.key)
    );
  if (!aa2(e.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}
function fl2(e) {
  return { key: Uint8Array.from([R.TAP_MERKLE_ROOT]), value: e };
}
var cl2 = "Uint8Array";
function aa2(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function ll2(e, t) {
  return !!e && !!t && e.tapMerkleRoot === void 0;
}
var pl2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: ll2,
  check: aa2,
  decode: ul2,
  encode: fl2,
  expected: cl2
}, Symbol.toStringTag, { value: "Module" }));
function dl2(e) {
  if (e.key[0] !== R.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + j2(e.key)
    );
  if (e.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + j2(e.key)
    );
  if (e.value.length !== 64 && e.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + j2(e.key)
    );
  const t = e.key.slice(1, 33), r = e.key.slice(33);
  return {
    pubkey: t,
    leafHash: r,
    signature: e.value
  };
}
function wl2(e) {
  const t = Uint8Array.from([R.TAP_SCRIPT_SIG]);
  return {
    key: Xt4([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}
var gl2 = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function yl2(e) {
  return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function bl2(e, t, r) {
  const n = j2(t.pubkey) + j2(t.leafHash);
  return r.has(n) ? false : (r.add(n), e.filter(
    (i) => Zt3(i.pubkey, t.pubkey) === 0 && Zt3(i.leafHash, t.leafHash) === 0
  ).length === 0);
}
var ml2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: bl2,
  check: yl2,
  decode: dl2,
  encode: wl2,
  expected: gl2
}, Symbol.toStringTag, { value: "Module" }));
function El2(e) {
  if (e.key[0] !== R.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + j2(e.key)
    );
  const t = sc2(e.value, 0, "LE");
  let r = 8;
  const { numberValue: n, bytes: i } = ze2(
    e.value,
    r
  );
  r += i;
  const o = e.value.slice(r);
  if (o.length !== n)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: o,
    value: t
  };
}
function Il2(e) {
  const { script: t, value: r } = e, n = $t4(t.length), i = new Uint8Array(8 + n + t.length);
  return ic2(i, 0, BigInt(r), "LE"), we4(t.length, i, 8), i.set(t, 8 + n), {
    key: Uint8Array.from([R.WITNESS_UTXO]),
    value: i
  };
}
var vl2 = "{ script: Uint8Array; value: bigint; }";
function Al2(e) {
  return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function Sl2(e, t) {
  return !!e && !!t && e.witnessUtxo === void 0;
}
var Tl2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Sl2,
  check: Al2,
  decode: El2,
  encode: Il2,
  expected: vl2
}, Symbol.toStringTag, { value: "Module" }));
function kl2(e) {
  if (e.key[0] !== ht3.TAP_TREE || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + j2(e.key)
    );
  let t = 0;
  const r = [];
  for (; t < e.value.length; ) {
    const n = e.value[t++], i = e.value[t++], { numberValue: o, bytes: a } = ze2(
      e.value,
      t
    );
    t += a, r.push({
      depth: n,
      leafVersion: i,
      script: e.value.slice(t, t + o)
    }), t += o;
  }
  return { leaves: r };
}
function Ul2(e) {
  const t = Uint8Array.from([ht3.TAP_TREE]), r = [].concat(
    ...e.leaves.map((n) => [
      Uint8Array.of(n.depth, n.leafVersion),
      we4(BigInt(n.script.length)).buffer,
      n.script
    ])
  );
  return {
    key: t,
    value: Xt4(r)
  };
}
var xl2 = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function Ol2(e) {
  return Array.isArray(e.leaves) && e.leaves.every(
    (t) => t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array
  );
}
function Pl2(e, t) {
  return !!e && !!t && e.tapTree === void 0;
}
var Bl2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Pl2,
  check: Ol2,
  decode: kl2,
  encode: Ul2,
  expected: xl2
}, Symbol.toStringTag, { value: "Module" }));
var _l11 = (e) => [...Array(e).keys()];
var Rl2 = (e) => e.length === 33 && [2, 3].includes(e[0]) || e.length === 65 && e[0] === 4;
function bi2(e, t = Rl2) {
  function r(u) {
    if (u.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + j2(u.key)
      );
    const l = u.key.slice(1);
    if (!t(l))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + j2(u.key)
      );
    if (u.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const d = {
      masterFingerprint: u.value.slice(0, 4),
      pubkey: l,
      path: "m"
    };
    for (const f of _l11(u.value.length / 4 - 1)) {
      const p = gn2(u.value, f * 4 + 4, "LE"), w = !!(p & 2147483648), y = p & 2147483647;
      d.path += "/" + y.toString(10) + (w ? "'" : "");
    }
    return d;
  }
  function n(u) {
    const l = Uint8Array.from([e]), d = Xt4([l, u.pubkey]), f = u.path.split("/"), p = new Uint8Array(f.length * 4);
    p.set(u.masterFingerprint, 0);
    let w = 4;
    return f.slice(1).forEach((y) => {
      const m = y.slice(-1) === "'";
      let E2 = 2147483647 & parseInt(m ? y.slice(0, -1) : y, 10);
      m && (E2 += 2147483648), yi2(p, w, E2, "LE"), w += 4;
    }), {
      key: d,
      value: p
    };
  }
  const i = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function o(u) {
    return u.pubkey instanceof Uint8Array && u.masterFingerprint instanceof Uint8Array && typeof u.path == "string" && t(u.pubkey) && u.masterFingerprint.length === 4;
  }
  function a(u, l, d) {
    const f = j2(l.pubkey);
    return d.has(f) ? false : (d.add(f), u.filter((p) => Zt3(p.pubkey, l.pubkey) === 0).length === 0);
  }
  return {
    decode: r,
    encode: n,
    check: o,
    expected: i,
    canAddToArray: a
  };
}
function mi2(e) {
  return t;
  function t(r) {
    let n;
    if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![2, 3, 4].includes(n[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + j2(r.key)
      );
    return n;
  }
}
function ha2(e) {
  function t(a) {
    if (a.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + j2(a.key)
      );
    return a.value;
  }
  function r(a) {
    return {
      key: Uint8Array.from([e]),
      value: a
    };
  }
  const n = "Uint8Array";
  function i(a) {
    return a instanceof Uint8Array;
  }
  function o(a, u) {
    return !!a && !!u && a.redeemScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: i,
    expected: n,
    canAdd: o
  };
}
var Nl2 = (e) => e.length === 32;
function ua2(e) {
  const t = bi2(e, Nl2);
  function r(a) {
    const { numberValue: u, bytes: l } = ze2(
      a.value
    ), d = t.decode({
      key: a.key,
      value: a.value.slice(l + Number(u) * 32)
    }), f = new Array(Number(u));
    for (let p = 0, w = l; p < u; p++, w += 32)
      f[p] = a.value.slice(w, w + 32);
    return { ...d, leafHashes: f };
  }
  function n(a) {
    const u = t.encode(a), l = $t4(a.leafHashes.length), d = new Uint8Array(l);
    we4(a.leafHashes.length, d);
    const f = Xt4([d, ...a.leafHashes, u.value]);
    return { ...u, value: f };
  }
  const i = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function o(a) {
    return Array.isArray(a.leafHashes) && a.leafHashes.every(
      (u) => u instanceof Uint8Array && u.length === 32
    ) && t.check(a);
  }
  return {
    decode: r,
    encode: n,
    check: o,
    expected: i,
    canAddToArray: t.canAddToArray
  };
}
function fa2(e) {
  function t(a) {
    if (a.key[0] !== e || a.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + j2(a.key)
      );
    if (a.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return a.value;
  }
  function r(a) {
    return { key: Uint8Array.from([e]), value: a };
  }
  const n = "Uint8Array";
  function i(a) {
    return a instanceof Uint8Array && a.length === 32;
  }
  function o(a, u) {
    return !!a && !!u && a.tapInternalKey === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: i,
    expected: n,
    canAdd: o
  };
}
function ca2(e) {
  function t(a) {
    if (a.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + j2(a.key)
      );
    return a.value;
  }
  function r(a) {
    return {
      key: Uint8Array.from([e]),
      value: a
    };
  }
  const n = "Uint8Array";
  function i(a) {
    return a instanceof Uint8Array;
  }
  function o(a, u) {
    return !!a && !!u && a.witnessScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: i,
    expected: n,
    canAdd: o
  };
}
var Ei = {
  unsignedTx: dc2,
  globalXpub: lc2,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: mi2([])
};
var wt4 = {
  nonWitnessUtxo: _c11,
  partialSig: $c2,
  sighashType: Zc2,
  finalScriptSig: Ec2,
  finalScriptWitness: kc2,
  porCommitment: Gc2,
  witnessUtxo: Tl2,
  bip32Derivation: bi2(R.BIP32_DERIVATION),
  redeemScript: ha2(R.REDEEM_SCRIPT),
  witnessScript: ca2(R.WITNESS_SCRIPT),
  checkPubkey: mi2([
    R.PARTIAL_SIG,
    R.BIP32_DERIVATION
  ]),
  tapKeySig: rl2,
  tapScriptSig: ml2,
  tapLeafScript: hl2,
  tapBip32Derivation: ua2(
    R.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: fa2(R.TAP_INTERNAL_KEY),
  tapMerkleRoot: pl2
};
var ee3 = {
  bip32Derivation: bi2(ht3.BIP32_DERIVATION),
  redeemScript: ha2(ht3.REDEEM_SCRIPT),
  witnessScript: ca2(ht3.WITNESS_SCRIPT),
  checkPubkey: mi2([ht3.BIP32_DERIVATION]),
  tapBip32Derivation: ua2(
    ht3.TAP_BIP32_DERIVATION
  ),
  tapTree: Bl2,
  tapInternalKey: fa2(ht3.TAP_INTERNAL_KEY)
};
var Hl2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  globals: Ei,
  inputs: wt4,
  outputs: ee3
}, Symbol.toStringTag, { value: "Module" }));
var en2 = (e) => [...Array(e).keys()];
function ms2(e) {
  const t = e.map(Ll2);
  return t.push(Uint8Array.from([0])), Xt4(t);
}
function Ll2(e) {
  const t = e.key.length, r = e.value.length, n = $t4(t), i = $t4(r), o = new Uint8Array(n + t + i + r);
  return we4(t, o, 0), o.set(e.key, n), we4(r, o, n + t), o.set(e.value, n + t + i), o;
}
function Cl2(e, t) {
  let r = 0;
  function n() {
    const { numberValue: v, bytes: x } = ze2(e, r);
    r += x;
    const O = e.slice(r, r + Number(v));
    return r += Number(v), O;
  }
  function i() {
    const v = gn2(e, r, "BE");
    return r += 4, v;
  }
  function o() {
    const v = bs2(e, r);
    return r += 1, v;
  }
  function a() {
    const v = n(), x = n();
    return {
      key: v,
      value: x
    };
  }
  function u() {
    if (r >= e.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const v = bs2(e, r) === 0;
    return v && r++, v;
  }
  if (i() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (o() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const l = [], d = {};
  for (; !u(); ) {
    const v = a(), x = j2(v.key);
    if (d[x])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + x
      );
    d[x] = 1, l.push(v);
  }
  const f = l.filter(
    (v) => v.key[0] === qt4.UNSIGNED_TX
  );
  if (f.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const p = t(f[0].value), { inputCount: w, outputCount: y } = p.getInputOutputCounts(), m = [], E2 = [];
  for (const v of en2(w)) {
    const x = {}, O = [];
    for (; !u(); ) {
      const T = a(), _ = j2(T.key);
      if (x[_])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + v + " key " + _
        );
      x[_] = 1, O.push(T);
    }
    m.push(O);
  }
  for (const v of en2(y)) {
    const x = {}, O = [];
    for (; !u(); ) {
      const T = a(), _ = j2(T.key);
      if (x[_])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + v + " key " + _
        );
      x[_] = 1, O.push(T);
    }
    E2.push(O);
  }
  return la2(p, {
    globalMapKeyVals: l,
    inputKeyVals: m,
    outputKeyVals: E2
  });
}
function It4(e, t, r) {
  if (Zt3(t, Uint8Array.from([r])))
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${e} key: ${j2(t)}`
    );
}
function la2(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
  const i = {
    unsignedTx: e
  };
  let o = 0;
  for (const f of t)
    switch (f.key[0]) {
      case qt4.UNSIGNED_TX:
        if (It4("global", f.key, qt4.UNSIGNED_TX), o > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        o++;
        break;
      case qt4.GLOBAL_XPUB:
        i.globalXpub === void 0 && (i.globalXpub = []), i.globalXpub.push(Ei.globalXpub.decode(f));
        break;
      default:
        i.unknownKeyVals || (i.unknownKeyVals = []), i.unknownKeyVals.push(f);
    }
  const a = r.length, u = n.length, l = [], d = [];
  for (const f of en2(a)) {
    const p = {};
    for (const w of r[f])
      switch (wt4.checkPubkey(w), w.key[0]) {
        case R.NON_WITNESS_UTXO:
          if (It4("input", w.key, R.NON_WITNESS_UTXO), p.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          p.nonWitnessUtxo = wt4.nonWitnessUtxo.decode(w);
          break;
        case R.WITNESS_UTXO:
          if (It4("input", w.key, R.WITNESS_UTXO), p.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          p.witnessUtxo = wt4.witnessUtxo.decode(w);
          break;
        case R.PARTIAL_SIG:
          p.partialSig === void 0 && (p.partialSig = []), p.partialSig.push(wt4.partialSig.decode(w));
          break;
        case R.SIGHASH_TYPE:
          if (It4("input", w.key, R.SIGHASH_TYPE), p.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          p.sighashType = wt4.sighashType.decode(w);
          break;
        case R.REDEEM_SCRIPT:
          if (It4("input", w.key, R.REDEEM_SCRIPT), p.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          p.redeemScript = wt4.redeemScript.decode(w);
          break;
        case R.WITNESS_SCRIPT:
          if (It4("input", w.key, R.WITNESS_SCRIPT), p.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          p.witnessScript = wt4.witnessScript.decode(w);
          break;
        case R.BIP32_DERIVATION:
          p.bip32Derivation === void 0 && (p.bip32Derivation = []), p.bip32Derivation.push(
            wt4.bip32Derivation.decode(w)
          );
          break;
        case R.FINAL_SCRIPTSIG:
          It4("input", w.key, R.FINAL_SCRIPTSIG), p.finalScriptSig = wt4.finalScriptSig.decode(w);
          break;
        case R.FINAL_SCRIPTWITNESS:
          It4("input", w.key, R.FINAL_SCRIPTWITNESS), p.finalScriptWitness = wt4.finalScriptWitness.decode(
            w
          );
          break;
        case R.POR_COMMITMENT:
          It4("input", w.key, R.POR_COMMITMENT), p.porCommitment = wt4.porCommitment.decode(w);
          break;
        case R.TAP_KEY_SIG:
          It4("input", w.key, R.TAP_KEY_SIG), p.tapKeySig = wt4.tapKeySig.decode(w);
          break;
        case R.TAP_SCRIPT_SIG:
          p.tapScriptSig === void 0 && (p.tapScriptSig = []), p.tapScriptSig.push(wt4.tapScriptSig.decode(w));
          break;
        case R.TAP_LEAF_SCRIPT:
          p.tapLeafScript === void 0 && (p.tapLeafScript = []), p.tapLeafScript.push(wt4.tapLeafScript.decode(w));
          break;
        case R.TAP_BIP32_DERIVATION:
          p.tapBip32Derivation === void 0 && (p.tapBip32Derivation = []), p.tapBip32Derivation.push(
            wt4.tapBip32Derivation.decode(w)
          );
          break;
        case R.TAP_INTERNAL_KEY:
          It4("input", w.key, R.TAP_INTERNAL_KEY), p.tapInternalKey = wt4.tapInternalKey.decode(w);
          break;
        case R.TAP_MERKLE_ROOT:
          It4("input", w.key, R.TAP_MERKLE_ROOT), p.tapMerkleRoot = wt4.tapMerkleRoot.decode(w);
          break;
        default:
          p.unknownKeyVals || (p.unknownKeyVals = []), p.unknownKeyVals.push(w);
      }
    l.push(p);
  }
  for (const f of en2(u)) {
    const p = {};
    for (const w of n[f])
      switch (ee3.checkPubkey(w), w.key[0]) {
        case ht3.REDEEM_SCRIPT:
          if (It4("output", w.key, ht3.REDEEM_SCRIPT), p.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          p.redeemScript = ee3.redeemScript.decode(w);
          break;
        case ht3.WITNESS_SCRIPT:
          if (It4("output", w.key, ht3.WITNESS_SCRIPT), p.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          p.witnessScript = ee3.witnessScript.decode(w);
          break;
        case ht3.BIP32_DERIVATION:
          p.bip32Derivation === void 0 && (p.bip32Derivation = []), p.bip32Derivation.push(
            ee3.bip32Derivation.decode(w)
          );
          break;
        case ht3.TAP_INTERNAL_KEY:
          It4("output", w.key, ht3.TAP_INTERNAL_KEY), p.tapInternalKey = ee3.tapInternalKey.decode(w);
          break;
        case ht3.TAP_TREE:
          It4("output", w.key, ht3.TAP_TREE), p.tapTree = ee3.tapTree.decode(w);
          break;
        case ht3.TAP_BIP32_DERIVATION:
          p.tapBip32Derivation === void 0 && (p.tapBip32Derivation = []), p.tapBip32Derivation.push(
            ee3.tapBip32Derivation.decode(w)
          );
          break;
        default:
          p.unknownKeyVals || (p.unknownKeyVals = []), p.unknownKeyVals.push(w);
      }
    d.push(p);
  }
  return { globalMap: i, inputs: l, outputs: d };
}
function Vl2({ globalMap: e, inputs: t, outputs: r }) {
  const { globalKeyVals: n, inputKeyVals: i, outputKeyVals: o } = qn2({
    globalMap: e,
    inputs: t,
    outputs: r
  }), a = ms2(n), u = (p) => p.length === 0 ? [Uint8Array.from([0])] : p.map(ms2), l = u(i), d = u(o), f = new Uint8Array(5);
  return f.set([112, 115, 98, 116, 255], 0), Xt4(
    [f, a].concat(l, d)
  );
}
var $l2 = (e, t) => Zt3(e.key, t.key);
function Bn2(e, t) {
  const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((o, [a, u]) => {
    if (a === "unknownKeyVals") return o;
    const l = t[a];
    if (l === void 0) return o;
    const d = (Array.isArray(u) ? u : [u]).map(
      l.encode
    );
    return d.map((f) => j2(f.key)).forEach((f) => {
      if (r.has(f))
        throw new Error("Serialize Error: Duplicate key: " + f);
      r.add(f);
    }), o.concat(d);
  }, []), i = e.unknownKeyVals ? e.unknownKeyVals.filter((o) => !r.has(j2(o.key))) : [];
  return n.concat(i).sort($l2);
}
function qn2({ globalMap: e, inputs: t, outputs: r }) {
  return {
    globalKeyVals: Bn2(e, Ei),
    inputKeyVals: t.map((n) => Bn2(n, wt4)),
    outputKeyVals: r.map((n) => Bn2(n, ee3))
  };
}
function Kl2(e) {
  const t = e[0], r = qn2(t), n = e.slice(1);
  if (n.length === 0) throw new Error("Combine: Nothing to combine");
  const i = Es2(t);
  if (i === void 0)
    throw new Error("Combine: Self missing transaction");
  const o = Le3(r.globalKeyVals), a = r.inputKeyVals.map(Le3), u = r.outputKeyVals.map(Le3);
  for (const l of n) {
    const d = Es2(l);
    if (d === void 0 || Zt3(d.toBuffer(), i.toBuffer()) !== 0)
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const f = qn2(l);
    Le3(f.globalKeyVals).forEach(
      _n14(
        o,
        r.globalKeyVals,
        f.globalKeyVals
      )
    ), f.inputKeyVals.map(Le3).forEach(
      (p, w) => p.forEach(
        _n14(
          a[w],
          r.inputKeyVals[w],
          f.inputKeyVals[w]
        )
      )
    ), f.outputKeyVals.map(Le3).forEach(
      (p, w) => p.forEach(
        _n14(
          u[w],
          r.outputKeyVals[w],
          f.outputKeyVals[w]
        )
      )
    );
  }
  return la2(i, {
    globalMapKeyVals: r.globalKeyVals,
    inputKeyVals: r.inputKeyVals,
    outputKeyVals: r.outputKeyVals
  });
}
function _n14(e, t, r) {
  return (n) => {
    if (e.has(n)) return;
    const i = r.filter((o) => j2(o.key) === n)[0];
    t.push(i), e.add(n);
  };
}
function Es2(e) {
  return e.globalMap.unsignedTx;
}
function Le3(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    const n = j2(r.key);
    if (t.has(n))
      throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(n);
  }), t;
}
function mt4(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No input #${t}`);
  return r;
}
function pr2(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No output #${t}`);
  return r;
}
function Rn2(e, t, r) {
  if (e.key[0] < r)
    throw new Error(
      "Use the method for your specific key instead of addUnknownKeyVal*"
    );
  if (t && t.filter((n) => Zt3(n.key, e.key) === 0).length !== 0)
    throw new Error(`Duplicate Key: ${j2(e.key)}`);
}
function Nn2(e) {
  let t = 0;
  return Object.keys(e).forEach((r) => {
    Number(isNaN(Number(r))) && t++;
  }), t;
}
function Dl2(e, t) {
  let r = false;
  if (t.nonWitnessUtxo || t.witnessUtxo) {
    const n = !!t.redeemScript, i = !!t.witnessScript, o = !n || !!t.finalScriptSig, a = !i || !!t.finalScriptWitness, u = !!t.finalScriptSig || !!t.finalScriptWitness;
    r = o && a && u;
  }
  if (r === false)
    throw new Error(
      `Input #${e} has too much or too little data to clean`
    );
}
function Is2(e, t, r, n) {
  throw new Error(
    `Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`
  );
}
function Ii2(e) {
  return (t, r) => {
    for (const n of Object.keys(t)) {
      const i = t[n], { canAdd: o, canAddToArray: a, check: u, expected: l } = (
        // @ts-ignore
        Hl2[e + "s"][n] || {}
      ), d = !!a;
      if (u)
        if (d) {
          if (!Array.isArray(i) || // @ts-ignore
          r[n] && !Array.isArray(r[n]))
            throw new Error(`Key type ${n} must be an array`);
          i.every(u) || Is2(e, n, l, i);
          const f = r[n] || [], p = /* @__PURE__ */ new Set();
          if (!i.every((w) => a(f, w, p)))
            throw new Error("Can not add duplicate data to array");
          r[n] = f.concat(i);
        } else {
          if (u(i) || Is2(e, n, l, i), !o(r, i))
            throw new Error(`Can not add duplicate data to ${e}`);
          r[n] = i;
        }
    }
  };
}
var Ml2 = Ii2("global");
var pa2 = Ii2("input");
var da2 = Ii2("output");
function Fl2(e, t) {
  const r = e.length - 1, n = mt4(e, r);
  pa2(t, n);
}
function Wl2(e, t) {
  const r = e.length - 1, n = pr2(e, r);
  da2(t, n);
}
var vs = class {
  constructor(e) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: e
    };
  }
  static fromBase64(e, t) {
    const r = nc2(e);
    return this.fromBuffer(r, t);
  }
  static fromHex(e, t) {
    const r = ec2(e);
    return this.fromBuffer(r, t);
  }
  static fromBuffer(e, t) {
    const r = Cl2(e, t), n = new this(r.globalMap.unsignedTx);
    return Object.assign(n, r), n;
  }
  toBase64() {
    const e = this.toBuffer();
    return rc2(e);
  }
  toHex() {
    const e = this.toBuffer();
    return j2(e);
  }
  toBuffer() {
    return Vl2(this);
  }
  updateGlobal(e) {
    return Ml2(e, this.globalMap), this;
  }
  updateInput(e, t) {
    const r = mt4(this.inputs, e);
    return pa2(t, r), this;
  }
  updateOutput(e, t) {
    const r = pr2(this.outputs, e);
    return da2(t, r), this;
  }
  addUnknownKeyValToGlobal(e) {
    return Rn2(
      e,
      this.globalMap.unknownKeyVals,
      Nn2(qt4)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(e), this;
  }
  addUnknownKeyValToInput(e, t) {
    const r = mt4(this.inputs, e);
    return Rn2(t, r.unknownKeyVals, Nn2(R)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
  }
  addUnknownKeyValToOutput(e, t) {
    const r = pr2(this.outputs, e);
    return Rn2(t, r.unknownKeyVals, Nn2(ht3)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
  }
  addInput(e) {
    this.globalMap.unsignedTx.addInput(e), this.inputs.push({
      unknownKeyVals: []
    });
    const t = e.unknownKeyVals || [], r = this.inputs.length - 1;
    if (!Array.isArray(t))
      throw new Error("unknownKeyVals must be an Array");
    return t.forEach(
      (n) => this.addUnknownKeyValToInput(r, n)
    ), Fl2(this.inputs, e), this;
  }
  addOutput(e) {
    this.globalMap.unsignedTx.addOutput(e), this.outputs.push({
      unknownKeyVals: []
    });
    const t = e.unknownKeyVals || [], r = this.outputs.length - 1;
    if (!Array.isArray(t))
      throw new Error("unknownKeyVals must be an Array");
    return t.forEach(
      (n) => this.addUnknownKeyValToOutput(r, n)
    ), Wl2(this.outputs, e), this;
  }
  clearFinalizedInput(e) {
    const t = mt4(this.inputs, e);
    Dl2(e, t);
    for (const r of Object.keys(t))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(r) || delete t[r];
    return this;
  }
  combine(...e) {
    const t = Kl2([this].concat(e));
    return Object.assign(this, t), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
function Rr2(e) {
  if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0)
    throw new Error("Invalid 32 bit integer");
}
function Hn2(e) {
  if (e.unsafeSignNonSegwit)
    throw new Error("Not BIP174 compliant, can not export");
}
function Yn2(e) {
  return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function Gl2(e) {
  if (!e.ins.every(
    (t) => t.script && t.script.length === 0 && t.witness && t.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function wa2(e, t) {
  const r = ei2(new Uint8Array(t.hash)), n = `${Yt4(r)}:${t.index}`;
  if (e.txInCache[n]) throw new Error("Duplicate input detected.");
  e.txInCache[n] = 1;
}
function jl2(e, t) {
  e.ins.forEach((r) => {
    wa2(t, r);
  });
}
function Je3(e, t, r) {
  r !== false && e.forEach((n) => {
    if (Vt4(n) ? kf2(n, t) : Ef2(n, t)) throw new Error("Can not modify transaction, signatures exist.");
  });
}
function zl2(e) {
  if (!e.sighashType || !e.partialSig) return;
  const { partialSig: t, sighashType: r } = e;
  t.forEach((n) => {
    const { hashType: i } = Te4.decode(n.signature);
    if (r !== i)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function ga2(e, t, r) {
  if (!Yr2(e, t))
    throw new Error(`Can not ${r} for this input with the key ${Yt4(e)}`);
}
function ya2(e, t) {
  return (r, n, i, o) => {
    const a = e({
      redeem: { output: i }
    }).output;
    if (!P(n, a))
      throw new Error(
        `${t} for ${o} #${r} doesn't match the scriptPubKey in the prevout`
      );
  };
}
var As2 = ya2(yr2, "Redeem script");
var Ss2 = ya2(mr2, "Witness script");
function Ts2(e) {
  let t = 0;
  function r(a) {
    return t += a, e.subarray(t - a, t);
  }
  function n() {
    const a = ze2(e, t);
    return t += a.bytes, a.numberValue || 0;
  }
  function i() {
    return r(n());
  }
  function o() {
    const a = n(), u = [];
    for (let l = 0; l < a; l++) u.push(i());
    return u;
  }
  return o();
}
function ql2(e) {
  let t = e & rt4.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (e & 31) {
    case rt4.SIGHASH_ALL:
      t += "SIGHASH_ALL";
      break;
    case rt4.SIGHASH_SINGLE:
      t += "SIGHASH_SINGLE";
      break;
    case rt4.SIGHASH_NONE:
      t += "SIGHASH_NONE";
      break;
  }
  return t;
}
function Yl2(e) {
  if (e.length === 65) {
    const t = e[64] & 1, r = new Uint8Array(e.subarray(0, 33));
    return r[0] = 2 | t, r;
  }
  return new Uint8Array(e);
}
function ks2(e) {
  return e.length === 33 && zs2(e);
}
function Xl2(e) {
  return _e9(e);
}
function vi2(e) {
  return pn2(e) ? "witnesspubkeyhash" : mf2(e) ? "pubkeyhash" : yf2(e) ? "multisig" : bf2(e) ? "pubkey" : "nonstandard";
}
function tr(e) {
  return [...Array(e).keys()];
}
function rn2(e) {
  if (pn2(e) || Go2(e))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function nn2(e, t, r, n, i) {
  const o = Go2(e), a = o && n && ps2(n), u = ps2(e);
  if (o && n === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  let l;
  if (a) {
    if (!i)
      throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    if (!n) throw new Error("P2SH-P2WSH requires redeemScript");
    l = i, As2(t, e, n, r), Ss2(t, n, i, r), rn2(l);
  } else if (u) {
    if (!i)
      throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    l = i, Ss2(t, e, i, r), rn2(l);
  } else if (o) {
    if (!n) throw new Error("P2SH requires redeemScript");
    l = n, As2(t, e, n, r);
  } else
    l = e;
  return {
    meaningfulScript: l,
    type: a ? "p2sh-p2wsh" : o ? "p2sh" : u ? "p2wsh" : "raw"
  };
}
var Zl2 = class {
  constructor(t) {
    __publicField(this, "nonWitnessUtxoTxCache");
    __publicField(this, "nonWitnessUtxoBufCache");
    __publicField(this, "txInCache");
    __publicField(this, "tx");
    __publicField(this, "unsafeSignNonSegwit");
    __publicField(this, "hasSignatures");
    __publicField(this, "fee");
    __publicField(this, "feeRate");
    __publicField(this, "extractedTx");
    __publicField(this, "prevOuts");
    __publicField(this, "signingScripts");
    __publicField(this, "values");
    __publicField(this, "taprootHashCache");
    this.nonWitnessUtxoTxCache = [], this.nonWitnessUtxoBufCache = [], this.txInCache = {}, this.tx = t, this.unsafeSignNonSegwit = false, this.hasSignatures = false;
  }
  /**
   * Invalidates cached computed values.
   * @param scope - 'full' clears everything (for input changes), 'outputs' clears fee/extract/taproot caches
   */
  invalidate(t) {
    this.fee = void 0, this.feeRate = void 0, this.extractedTx = void 0, this.taprootHashCache = void 0, t === "full" && (this.prevOuts = void 0, this.signingScripts = void 0, this.values = void 0);
  }
  addNonWitnessTxCache(t, r, n) {
    if (!t.nonWitnessUtxo) throw new Error("nonWitnessUtxo is required");
    if (t === null || t === Object.prototype)
      throw new Error("Invalid input object");
    const i = t.nonWitnessUtxo;
    this.nonWitnessUtxoBufCache[r] = i, this.nonWitnessUtxoTxCache[r] = n(i);
  }
  getNonWitnessUtxoTx(t, r, n) {
    return this.nonWitnessUtxoTxCache[r] || this.addNonWitnessTxCache(t, r, n), this.nonWitnessUtxoTxCache[r];
  }
  getScriptFromUtxo(t, r, n) {
    const { script: i } = this.getScriptAndAmountFromUtxo(t, r, n);
    return i;
  }
  getScriptAndAmountFromUtxo(t, r, n) {
    if (r.witnessUtxo !== void 0)
      return {
        script: r.witnessUtxo.script,
        value: r.witnessUtxo.value
      };
    if (r.nonWitnessUtxo !== void 0) {
      const i = this.getNonWitnessUtxoTx(r, t, n), o = this.tx.ins[t], a = i.outs[o.index];
      return { script: a.script, value: a.value };
    } else
      throw new Error("Can't find pubkey in input without Utxo data");
  }
  computeFee(t, r = false, n) {
    if (!t.every(Yn2)) throw new Error("PSBT must be finalized to calculate fee");
    if (this.fee !== void 0) return this.fee;
    let i, o = true;
    this.extractedTx ? (i = this.extractedTx, o = false) : i = this.tx.clone();
    const { fee: a } = this.finalizeAndComputeAmounts(
      t,
      i,
      o,
      r,
      n
    );
    return a;
  }
  computeFeeRate(t, r = false, n) {
    if (!t.every(Yn2))
      throw new Error("PSBT must be finalized to calculate fee rate");
    if (this.feeRate !== void 0) return this.feeRate;
    let i, o = true;
    this.extractedTx ? (i = this.extractedTx, o = false) : i = this.tx.clone();
    const { feeRate: a } = this.finalizeAndComputeAmounts(
      t,
      i,
      o,
      r,
      n
    );
    return a;
  }
  checkFees(t) {
    const r = this.feeRate;
    if (!this.extractedTx) throw new Error("Transaction not extracted");
    if (r === void 0) throw new Error("Fee rate not computed");
    const n = this.extractedTx.virtualSize(), i = r * n;
    if (r >= t.maximumFeeRate)
      throw new Error(
        `Warning: You are paying around ${(i / 1e8).toFixed(8)} in fees, which is ${r} satoshi per byte for a transaction with a VSize of ${n} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
      );
  }
  pubkeyInInput(t, r, n, i) {
    const o = this.getScriptFromUtxo(n, r, i), { meaningfulScript: a } = nn2(
      o,
      n,
      "input",
      r.redeemScript,
      r.witnessScript
    );
    return Yr2(t, a);
  }
  pubkeyInOutput(t, r, n) {
    const i = this.tx.outs[n].script, { meaningfulScript: o } = nn2(
      i,
      n,
      "output",
      r.redeemScript,
      r.witnessScript
    );
    return Yr2(t, o);
  }
  redeemFromFinalScriptSig(t) {
    if (!t) return;
    const r = tt3(t);
    if (!r) return;
    const n = r[r.length - 1];
    if (!(!(n instanceof Uint8Array) || ks2(n) || Xl2(n) || !tt3(n)))
      return n;
  }
  redeemFromFinalWitnessScript(t) {
    if (!t) return;
    const r = Ts2(t), n = r[r.length - 1];
    if (!(!n || ks2(n) || !tt3(n)))
      return n;
  }
  /**
   * Finalize transaction inputs and compute fee amounts.
   * Returns computed values instead of mutating cache parameters directly.
   */
  finalizeAndComputeAmounts(t, r, n, i, o) {
    let a = 0n;
    t.forEach((w, y) => {
      const m = r.ins[y];
      if (n && w.finalScriptSig && (m.script = w.finalScriptSig), n && w.finalScriptWitness && (m.witness = Ts2(w.finalScriptWitness)), w.witnessUtxo)
        a += w.witnessUtxo.value;
      else if (w.nonWitnessUtxo) {
        if (!o)
          throw new Error("txFromBuffer is required for nonWitnessUtxo inputs");
        const E2 = this.getNonWitnessUtxoTx(w, y, o), v = m.index, x = E2.outs[v];
        a += x.value;
      }
    });
    const u = r.outs.reduce((w, y) => w + y.value, 0n), l = a - u;
    if (!i && l < 0n)
      throw new Error(
        `Outputs are spending more than Inputs ${a} < ${u}`
      );
    const d = r.virtualSize(), f = Number(l), p = Math.floor(f / d);
    return this.fee = f, this.extractedTx = r, this.feeRate = p, { fee: f, feeRate: p };
  }
  getScriptFromInput(t, r, n) {
    const i = {
      script: null,
      isSegwit: false,
      isP2SH: false,
      isP2WSH: false
    };
    if (i.isP2SH = !!r.redeemScript, i.isP2WSH = !!r.witnessScript, r.witnessScript)
      i.script = r.witnessScript;
    else if (r.redeemScript)
      i.script = r.redeemScript;
    else if (r.nonWitnessUtxo) {
      const o = this.getNonWitnessUtxoTx(r, t, n), a = this.tx.ins[t].index;
      i.script = o.outs[a].script;
    } else r.witnessUtxo && (i.script = r.witnessUtxo.script);
    return (r.witnessScript || i.script && pn2(i.script) || i.script && Qo2(i.script)) && (i.isSegwit = true), i;
  }
  getPrevoutTaprootKey(t, r, n) {
    const { script: i } = this.getScriptAndAmountFromUtxo(t, r, n);
    return jo2(i) ? i.subarray(2, 34) : null;
  }
};
var _t20, _a33;
var Ql2 = class {
  constructor(t, r) {
    __privateAdd(this, _t20);
    __privateAdd(this, _a33);
    __privateSet(this, _t20, t), __privateSet(this, _a33, r);
  }
  getHashAndSighashType(t, r, n, i) {
    const o = mt4(t, r), { hash: a, sighashType: u, script: l } = this.getHashForSig(
      r,
      o,
      false,
      i
    );
    return ga2(n, l, "sign"), { hash: a, sighashType: u };
  }
  getHashForSig(t, r, n, i) {
    const o = __privateGet(this, _t20).tx, a = r.sighashType || rt4.SIGHASH_ALL;
    Us2(a, i);
    let u, l;
    if (r.nonWitnessUtxo) {
      const w = __privateGet(this, _t20).getNonWitnessUtxoTx(
        r,
        t,
        __privateGet(this, _a33)
      ), y = o.ins[t], m = y.hash, E2 = w.getHash();
      if (!P(m, E2))
        throw new Error(
          `Non-witness UTXO hash for input #${t} doesn't match the hash specified in the prevout`
        );
      const v = y.index;
      l = w.outs[v];
    } else if (r.witnessUtxo)
      l = {
        script: r.witnessUtxo.script,
        value: r.witnessUtxo.value
      };
    else
      throw new Error("Need a Utxo input item for signing");
    const { meaningfulScript: d, type: f } = nn2(
      l.script,
      t,
      "input",
      r.redeemScript,
      r.witnessScript
    ), p = d;
    if (["p2sh-p2wsh", "p2wsh"].includes(f))
      u = o.hashForWitnessV0(t, p, l.value, a);
    else if (pn2(d)) {
      const w = gr2({
        hash: d.subarray(2)
      });
      if (!w.output) throw new Error("Unable to create signing script");
      u = o.hashForWitnessV0(
        t,
        w.output,
        l.value,
        a
      );
    } else {
      if (r.nonWitnessUtxo === void 0 && !__privateGet(this, _t20).unsafeSignNonSegwit)
        throw new Error(
          `Input #${t} has witnessUtxo but non-segwit script: ` + Yt4(d)
        );
      !n && __privateGet(this, _t20).unsafeSignNonSegwit && console.warn(
        `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
      ), u = o.hashForSignature(t, p, a);
    }
    return { script: p, sighashType: a, hash: u };
  }
  getTaprootHashesForSig(t, r, n, i, o, a) {
    const u = __privateGet(this, _t20).tx, l = r.sighashType || rt4.SIGHASH_DEFAULT;
    if (Us2(l, a), !__privateGet(this, _t20).prevOuts) {
      const m = n.map(
        (E2, v) => __privateGet(this, _t20).getScriptAndAmountFromUtxo(v, E2, __privateGet(this, _a33))
      );
      __privateGet(this, _t20).prevOuts = m, __privateGet(this, _t20).signingScripts = m.map((E2) => E2.script), __privateGet(this, _t20).values = m.map((E2) => E2.value);
    }
    const d = __privateGet(this, _t20).signingScripts, f = __privateGet(this, _t20).values;
    __privateGet(this, _t20).taprootHashCache || (__privateGet(this, _t20).taprootHashCache = u.getTaprootHashCache(d, f));
    const p = __privateGet(this, _t20).taprootHashCache, w = [];
    if (r.tapInternalKey && !o) {
      const m = __privateGet(this, _t20).getPrevoutTaprootKey(t, r, __privateGet(this, _a33)) || new Uint8Array(0);
      if (P($e4(i), m)) {
        const E2 = u.hashForWitnessV1(
          t,
          d,
          f,
          l,
          void 0,
          void 0,
          p
        );
        w.push({ pubkey: i, hash: E2 });
      }
    }
    const y = (r.tapLeafScript || []).filter((m) => Yr2(i, m.script)).map((m) => {
      const E2 = Pt3({
        output: m.script,
        version: m.leafVersion
      });
      return Object.assign({ hash: E2 }, m);
    }).filter((m) => !o || P(o, m.hash)).map((m) => {
      const E2 = u.hashForWitnessV1(
        t,
        d,
        f,
        l,
        m.hash,
        void 0,
        p
      );
      return {
        pubkey: i,
        hash: E2,
        leafHash: m.hash
      };
    });
    return w.concat(y);
  }
  getAllTaprootHashesForSig(t, r, n) {
    const i = [];
    if (r.tapInternalKey) {
      const o = __privateGet(this, _t20).getPrevoutTaprootKey(t, r, __privateGet(this, _a33));
      o && i.push(o);
    }
    if (r.tapScriptSig) {
      const o = r.tapScriptSig.map((a) => a.pubkey);
      i.push(...o);
    }
    return i.map(
      (o) => this.getTaprootHashesForSig(t, r, n, o)
    ).flat();
  }
  trimTaprootSig(t) {
    return t.length === 64 ? t : t.subarray(0, 64);
  }
  getSignersFromHD(t, r, n) {
    const i = mt4(r, t);
    if (!i.bip32Derivation || i.bip32Derivation.length === 0)
      throw new Error("Need bip32Derivation to sign with HD");
    const o = i.bip32Derivation.map((a) => {
      if (P(a.masterFingerprint, n.fingerprint))
        return a;
    }).filter((a) => !!a);
    if (o.length === 0)
      throw new Error(
        "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
      );
    return o.map((a) => {
      const u = n.derivePath(a.path);
      if (!P(a.pubkey, u.publicKey))
        throw new Error("pubkey did not match bip32Derivation");
      return u;
    });
  }
  bip32DerivationIsMine(t) {
    return (r) => {
      const n = t.fingerprint instanceof Uint8Array ? t.fingerprint : new Uint8Array(t.fingerprint);
      if (!P(r.masterFingerprint, n)) return false;
      const i = t.derivePath(r.path).publicKey, o = i instanceof Uint8Array ? i : new Uint8Array(i);
      return !!P(o, r.pubkey);
    };
  }
};
_t20 = new WeakMap();
_a33 = new WeakMap();
function Us2(e, t) {
  if (t && !t.includes(e)) {
    const r = ql2(e);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`
    );
  }
}
var _t21, _a34;
var Jl2 = class {
  constructor(t, r) {
    __privateAdd(this, _t21);
    __privateAdd(this, _a34);
    __privateSet(this, _t21, t), __privateSet(this, _a34, r);
  }
  getFinalScripts(t, r, n, i, o, a, u = true, l) {
    const d = vi2(n);
    if (!ma2(r, n, d) && u)
      throw new Error(`Can not finalize input #${t}`);
    if (!r.partialSig) throw new Error("Input missing partial signatures");
    return ba2(
      n,
      d,
      r.partialSig,
      i,
      o,
      a,
      l
    );
  }
  getScriptFromInput(t, r) {
    return __privateGet(this, _t21).getScriptFromInput(t, r, __privateGet(this, _a34));
  }
};
_t21 = new WeakMap();
_a34 = new WeakMap();
function tp2(e, t, r, n, i, o, a = true, u) {
  const l = vi2(r);
  if (!ma2(t, r, l) && a)
    throw new Error(`Can not finalize input #${e}`);
  if (!t.partialSig) throw new Error("Input missing partial signatures");
  return ba2(
    r,
    l,
    t.partialSig,
    n,
    i,
    o,
    u
  );
}
function ba2(e, t, r, n, i, o, a) {
  let u, l;
  const d = ep2(e, t, r), f = o ? mr2({ redeem: d }) : null, p = i ? yr2({ redeem: f || d }) : null;
  return n ? (f && f.witness ? l = hr(f.witness) : d && d.witness ? l = hr(d.witness) : l = hr(a ?? [new Uint8Array([0])]), p && (u = p == null ? void 0 : p.input)) : p ? u = p == null ? void 0 : p.input : d ? u = d.input : u = Array.isArray(a) && a[0] ? a[0] : new Uint8Array([1]), { finalScriptSig: u, finalScriptWitness: l };
}
function ma2(e, t, r) {
  switch (r) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return xs2(1, e.partialSig);
    case "multisig": {
      const n = Er2({
        output: t
      });
      if (n.m === void 0) throw new Error("Cannot determine m for multisig");
      return xs2(n.m, e.partialSig, n.pubkeys);
    }
    case "nonstandard":
      return true;
    default:
      return false;
  }
}
function xs2(e, t, r) {
  if (!t) return false;
  let n;
  if (r ? n = r.map((i) => {
    const o = Yl2(i);
    return t.find((a) => P(a.pubkey, o));
  }).filter((i) => !!i) : n = t, n.length > e) throw new Error("Too many signatures");
  return n.length === e;
}
function ep2(e, t, r) {
  const n = e;
  switch (t) {
    case "multisig": {
      const i = rp2(e, r);
      return Er2({
        output: n,
        signatures: i
      });
    }
    case "pubkey": {
      const i = r[0];
      return gi2({
        output: n,
        signature: i.signature
      });
    }
    case "pubkeyhash": {
      const i = r[0];
      return gr2({
        output: n,
        pubkey: i.pubkey,
        signature: i.signature
      });
    }
    case "witnesspubkeyhash": {
      const i = r[0];
      return ln2({
        output: n,
        pubkey: i.pubkey,
        signature: i.signature
      });
    }
    default:
      throw new Error(`Unknown script type: ${t}`);
  }
}
function rp2(e, t) {
  const r = Er2({ output: e });
  if (!r.pubkeys) throw new Error("Cannot extract pubkeys from multisig script");
  const n = [];
  for (const i of r.pubkeys) {
    const o = t.filter((a) => P(a.pubkey, i))[0];
    o && n.push(new Uint8Array(o.signature));
  }
  return n;
}
var np2 = new Uint8Array([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
var Ea = class {
  constructor(t = np2) {
    __publicField(this, "tx");
    this.tx = rt4.fromBuffer(t), Gl2(this.tx), Object.defineProperty(this, "tx", {
      enumerable: false,
      writable: true
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(t) {
    if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number")
      throw new Error("Error adding input.");
    const r = typeof t.hash == "string" ? ei2(Mt3(t.hash)) : t.hash;
    this.tx.addInput(r, t.index, t.sequence);
  }
  addOutput(t) {
    if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint")
      throw new Error("Error adding output.");
    this.tx.addOutput(t.script, t.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
};
var ip2 = (e) => new Ea(e);
var sp2 = {
  network: kt3,
  maximumFeeRate: 5e3
};
function jt4(e) {
  return rt4.fromBuffer(e);
}
function op2(e, t, r, n, i, o, a = true, u) {
  return tp2(
    e,
    t,
    r,
    n,
    i,
    o,
    a,
    u
  );
}
var _t22, _a35, _e21, _s14, _Xn_instances, r_get, n_get, i_fn, o_fn, h_fn2, f_fn2, u_fn3, c_fn2, p_fn2, l_fn3;
var _Xn = class _Xn {
  constructor(t = {}, r = new vs(new Ea())) {
    __privateAdd(this, _Xn_instances);
    __privateAdd(this, _t22);
    __privateAdd(this, _a35);
    __privateAdd(this, _e21);
    __privateAdd(this, _s14);
    this.data = r, __privateSet(this, _s14, Object.assign({}, sp2, t));
    const n = this.data.globalMap.unsignedTx.tx;
    __privateSet(this, _t22, new Zl2(n)), t.version === 3 ? this.setVersionTRUC() : this.data.inputs.length === 0 && this.setVersion(2);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return __privateGet(this, _t22).tx.version;
  }
  set version(t) {
    this.setVersion(t);
  }
  get locktime() {
    return __privateGet(this, _t22).tx.locktime;
  }
  set locktime(t) {
    this.setLocktime(t);
  }
  get txInputs() {
    return __privateGet(this, _t22).tx.ins.map((t) => ({
      hash: xi2(t.hash),
      index: t.index,
      sequence: t.sequence
    }));
  }
  get txOutputs() {
    return __privateGet(this, _t22).tx.outs.map((t) => {
      let r;
      try {
        r = ra2(t.script, __privateGet(this, _s14).network);
      } catch {
      }
      return {
        script: xi2(t.script),
        value: t.value,
        address: r
      };
    });
  }
  static fromBase64(t, r = {}) {
    const n = zf2(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r = {}) {
    const n = Mt3(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r = {}) {
    const n = vs.fromBuffer(t, ip2), i = new _Xn(r, n);
    return jl2(__privateGet(i, _t22).tx, __privateGet(i, _t22)), __privateGet(i, _t22).hasSignatures = i.data.inputs.some(
      (o) => {
        var _a37, _b9;
        return ((_a37 = o.partialSig) == null ? void 0 : _a37.length) || o.tapKeySig || ((_b9 = o.tapScriptSig) == null ? void 0 : _b9.length) || o.finalScriptSig || o.finalScriptWitness;
      }
    ), i;
  }
  combine(...t) {
    return this.data.combine(...t.map((r) => r.data)), this;
  }
  clone() {
    const t = structuredClone(__privateGet(this, _s14));
    return _Xn.fromBuffer(new Uint8Array(this.data.toBuffer()), t);
  }
  get maximumFeeRate() {
    return __privateGet(this, _s14).maximumFeeRate;
  }
  setMaximumFeeRate(t) {
    Rr2(t), __privateGet(this, _s14).maximumFeeRate = t;
  }
  setVersion(t) {
    return Rr2(t), Je3(this.data.inputs, "setVersion", __privateGet(this, _t22).hasSignatures), __privateGet(this, _t22).tx.version = t, __privateGet(this, _t22).invalidate("outputs"), this;
  }
  setVersionTRUC() {
    return this.setVersion(rt4.TRUC_VERSION);
  }
  setLocktime(t) {
    return Rr2(t), Je3(this.data.inputs, "setLocktime", __privateGet(this, _t22).hasSignatures), __privateGet(this, _t22).tx.locktime = t, __privateGet(this, _t22).invalidate("outputs"), this;
  }
  setInputSequence(t, r) {
    if (Rr2(r), Je3(this.data.inputs, "setInputSequence", __privateGet(this, _t22).hasSignatures), __privateGet(this, _t22).tx.ins.length <= t)
      throw new Error("Input index too high");
    return __privateGet(this, _t22).tx.ins[t].sequence = r, __privateGet(this, _t22).invalidate("outputs"), this;
  }
  addInputs(t, r = true) {
    return t.forEach((n) => this.addInput(n, r)), this;
  }
  addInput(t, r = true) {
    if (!t || t.hash === void 0 || t.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    ws2(t, t, "addInput"), r && Je3(this.data.inputs, "addInput", __privateGet(this, _t22).hasSignatures), t.witnessScript && rn2(t.witnessScript);
    const n = t.witnessUtxo ? {
      ...t,
      witnessUtxo: {
        script: t.witnessUtxo.script,
        value: typeof t.witnessUtxo.value == "bigint" ? t.witnessUtxo.value : BigInt(t.witnessUtxo.value)
      }
    } : t;
    this.data.addInput(n);
    const i = __privateGet(this, _t22).tx.ins[__privateGet(this, _t22).tx.ins.length - 1];
    wa2(__privateGet(this, _t22), i);
    const o = this.data.inputs.length - 1, a = this.data.inputs[o];
    return a.nonWitnessUtxo && __privateGet(this, _t22).addNonWitnessTxCache(a, o, jt4), __privateGet(this, _t22).invalidate("full"), this;
  }
  addOutputs(t, r = true) {
    return t.forEach((n) => this.addOutput(n, r)), this;
  }
  addOutput(t, r = true) {
    const n = "address" in t, i = "script" in t;
    if (!t || t.value === void 0 || !n && !i)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    if (r && Je3(this.data.inputs, "addOutput", __privateGet(this, _t22).hasSignatures), n) {
      const { address: o } = t, { network: a } = __privateGet(this, _s14), u = na2(o, a);
      t = Object.assign({}, t, { script: u });
    }
    return gs2(t, t, "addOutput"), this.data.addOutput(t), __privateGet(this, _t22).invalidate("outputs"), this;
  }
  extractTransaction(t, r) {
    if (r && (this.data.inputs = this.data.inputs.filter(
      (i) => !i.partialSig
    )), !this.data.inputs.every(Yn2)) throw new Error("Not finalized");
    if (t || (__privateGet(this, _t22).computeFeeRate(this.data.inputs, r, jt4), __privateGet(this, _t22).checkFees(__privateGet(this, _s14))), __privateGet(this, _t22).extractedTx) return __privateGet(this, _t22).extractedTx;
    const n = __privateGet(this, _t22).tx.clone();
    return __privateGet(this, _t22).finalizeAndComputeAmounts(
      this.data.inputs,
      n,
      true,
      r,
      jt4
    ), n;
  }
  getFeeRate(t = false) {
    return __privateGet(this, _t22).computeFeeRate(this.data.inputs, t, jt4);
  }
  getFee(t = false) {
    return __privateGet(this, _t22).computeFee(this.data.inputs, t, jt4);
  }
  finalizeAllInputs() {
    return mt4(this.data.inputs, 0), tr(this.data.inputs.length).forEach((t) => this.finalizeInput(t)), this;
  }
  finalizeInput(t, r, n) {
    const i = mt4(this.data.inputs, t);
    return Vt4(i) ? __privateMethod(this, _Xn_instances, o_fn).call(this, t, i, void 0, r) : __privateMethod(this, _Xn_instances, i_fn).call(this, t, i, r, n ?? true);
  }
  finalizeTaprootInput(t, r, n = ds2) {
    const i = mt4(this.data.inputs, t);
    if (Vt4(i))
      return __privateMethod(this, _Xn_instances, o_fn).call(this, t, i, r, n);
    throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
  }
  getInputType(t) {
    const r = mt4(this.data.inputs, t), n = __privateGet(this, _t22).getScriptFromUtxo(t, r, jt4), i = nn2(
      n,
      t,
      "input",
      r.redeemScript || __privateGet(this, _t22).redeemFromFinalScriptSig(r.finalScriptSig),
      r.witnessScript || __privateGet(this, _t22).redeemFromFinalWitnessScript(r.finalScriptWitness)
    ), o = i.type === "raw" ? "" : i.type + "-", a = vi2(i.meaningfulScript);
    return o + a;
  }
  inputHasPubkey(t, r) {
    const n = mt4(this.data.inputs, t);
    return __privateGet(this, _t22).pubkeyInInput(r, n, t, jt4);
  }
  inputHasHDKey(t, r) {
    const n = mt4(this.data.inputs, t), i = __privateGet(this, _Xn_instances, r_get).bip32DerivationIsMine(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(i);
  }
  outputHasPubkey(t, r) {
    const n = pr2(this.data.outputs, t);
    return __privateGet(this, _t22).pubkeyInOutput(r, n, t);
  }
  outputHasHDKey(t, r) {
    const n = pr2(this.data.outputs, t), i = __privateGet(this, _Xn_instances, r_get).bip32DerivationIsMine(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(i);
  }
  validateSignaturesOfAllInputs(t) {
    return mt4(this.data.inputs, 0), tr(this.data.inputs.length).map(
      (r) => this.validateSignaturesOfInput(r, t)
    ).every((r) => r);
  }
  validateSignaturesOfInput(t, r, n) {
    const i = this.data.inputs[t];
    return Vt4(i) ? __privateMethod(this, _Xn_instances, f_fn2).call(this, t, r, n) : __privateMethod(this, _Xn_instances, h_fn2).call(this, t, r, n);
  }
  signAllInputsHD(t, r = [rt4.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const n = [];
    for (const i of tr(this.data.inputs.length))
      try {
        this.signInputHD(i, t, r), n.push(true);
      } catch {
        n.push(false);
      }
    if (n.every((i) => !i))
      throw new Error("No inputs were signed");
    return this;
  }
  async signAllInputsHDAsync(t, r = [rt4.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const n = [], i = [];
    for (const o of tr(this.data.inputs.length))
      i.push(
        this.signInputHDAsync(o, t, r).then(
          () => {
            n.push(true);
          },
          () => {
            n.push(false);
          }
        )
      );
    if (await Promise.all(i), n.every((o) => !o))
      throw new Error("No inputs were signed");
  }
  signInputHD(t, r, n = [rt4.SIGHASH_ALL]) {
    if (!r || !r.publicKey || !r.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return __privateGet(this, _Xn_instances, r_get).getSignersFromHD(t, this.data.inputs, r).forEach((i) => this.signInput(t, i, n)), this;
  }
  async signInputHDAsync(t, r, n = [rt4.SIGHASH_ALL]) {
    if (!r || !r.publicKey || !r.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const i = __privateGet(this, _Xn_instances, r_get).getSignersFromHD(t, this.data.inputs, r).map(
      (o) => this.signInputAsync(t, o, n)
    );
    await Promise.all(i);
  }
  signAllInputs(t, r) {
    if (!t || !t.publicKey) throw new Error("Need Signer to sign input");
    const n = [];
    for (const i of tr(this.data.inputs.length))
      try {
        this.signInput(i, t, r), n.push(true);
      } catch {
        n.push(false);
      }
    if (n.every((i) => !i))
      throw new Error("No inputs were signed");
    return this;
  }
  async signAllInputsAsync(t, r) {
    if (!t || !t.publicKey) throw new Error("Need Signer to sign input");
    const n = [], i = [];
    for (const [o] of this.data.inputs.entries())
      i.push(
        this.signInputAsync(o, t, r).then(
          () => {
            n.push(true);
          },
          () => {
            n.push(false);
          }
        )
      );
    if (await Promise.all(i), n.every((o) => !o))
      throw new Error("No inputs were signed");
  }
  signInput(t, r, n) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const i = mt4(this.data.inputs, t);
    return Vt4(i) ? __privateMethod(this, _Xn_instances, c_fn2).call(this, t, i, r, void 0, n) : __privateMethod(this, _Xn_instances, u_fn3).call(this, t, r, n);
  }
  signTaprootInput(t, r, n, i) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const o = mt4(this.data.inputs, t);
    if (Vt4(o))
      return __privateMethod(this, _Xn_instances, c_fn2).call(this, t, o, r, n, i);
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  async signInputAsync(t, r, n) {
    if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
    const i = mt4(this.data.inputs, t);
    return Vt4(i) ? __privateMethod(this, _Xn_instances, l_fn3).call(this, t, i, r, void 0, n) : __privateMethod(this, _Xn_instances, p_fn2).call(this, t, r, n);
  }
  async signTaprootInputAsync(t, r, n, i) {
    if (!r || !r.publicKey) throw new Error("Need Signer to sign input");
    const o = mt4(this.data.inputs, t);
    if (Vt4(o))
      return __privateMethod(this, _Xn_instances, l_fn3).call(this, t, o, r, n, i);
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  toBuffer() {
    return Hn2(__privateGet(this, _t22)), new Uint8Array(this.data.toBuffer());
  }
  toHex() {
    return Hn2(__privateGet(this, _t22)), this.data.toHex();
  }
  toBase64() {
    return Hn2(__privateGet(this, _t22)), this.data.toBase64();
  }
  updateGlobal(t) {
    return this.data.updateGlobal(t), this;
  }
  updateInput(t, r) {
    r.witnessScript && rn2(r.witnessScript), ws2(this.data.inputs[t], r, "updateInput");
    const n = r.witnessUtxo ? {
      ...r,
      witnessUtxo: {
        script: r.witnessUtxo.script,
        value: typeof r.witnessUtxo.value == "bigint" ? r.witnessUtxo.value : BigInt(r.witnessUtxo.value)
      }
    } : r;
    return this.data.updateInput(t, n), r.nonWitnessUtxo && __privateGet(this, _t22).addNonWitnessTxCache(
      this.data.inputs[t],
      t,
      jt4
    ), this;
  }
  updateOutput(t, r) {
    const n = this.data.outputs[t];
    return gs2(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
  }
  addUnknownKeyValToGlobal(t) {
    return this.data.addUnknownKeyValToGlobal(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    return this.data.addUnknownKeyValToInput(t, r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    return this.data.addUnknownKeyValToOutput(t, r), this;
  }
  clearFinalizedInput(t) {
    return this.data.clearFinalizedInput(t), this;
  }
  checkTaprootHashesForSig(t, r, n, i, o) {
    if (!("signSchnorr" in n) || typeof n.signSchnorr != "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
    const a = n.publicKey instanceof Uint8Array ? n.publicKey : new Uint8Array(n.publicKey), u = __privateGet(this, _Xn_instances, r_get).getTaprootHashesForSig(
      t,
      r,
      this.data.inputs,
      a,
      i,
      o
    );
    if (!u || !u.length)
      throw new Error(`Can not sign for input #${t} with the key ${Yt4(a)}`);
    return u;
  }
};
_t22 = new WeakMap();
_a35 = new WeakMap();
_e21 = new WeakMap();
_s14 = new WeakMap();
_Xn_instances = new WeakSet();
r_get = function() {
  return __privateGet(this, _a35) || __privateSet(this, _a35, new Ql2(__privateGet(this, _t22), jt4)), __privateGet(this, _a35);
};
n_get = function() {
  return __privateGet(this, _e21) || __privateSet(this, _e21, new Jl2(__privateGet(this, _t22), jt4)), __privateGet(this, _e21);
};
i_fn = function(t, r, n = op2, i = true) {
  const { script: o, isP2SH: a, isP2WSH: u, isSegwit: l } = __privateGet(this, _Xn_instances, n_get).getScriptFromInput(
    t,
    r
  );
  if (!o) throw new Error(`No script found for input #${t}`);
  zl2(r);
  const { finalScriptSig: d, finalScriptWitness: f } = n(
    t,
    r,
    o,
    l,
    a,
    u,
    i
  );
  if (d && this.data.updateInput(t, { finalScriptSig: d }), f && this.data.updateInput(t, { finalScriptWitness: f }), !d && !f)
    throw new Error(`Unknown error finalizing input #${t}`);
  return this.data.clearFinalizedInput(t), this;
};
o_fn = function(t, r, n, i = ds2) {
  if (!r.witnessUtxo)
    throw new Error(`Cannot finalize input #${t}. Missing witness utxo.`);
  if (r.tapKeySig && !Gn2(r)) {
    const o = br2({
      output: r.witnessUtxo.script,
      signature: r.tapKeySig
    });
    if (!o.witness) throw new Error("Cannot finalize taproot key spend");
    const a = hr(o.witness);
    this.data.updateInput(t, { finalScriptWitness: a });
  } else {
    const { finalScriptWitness: o } = i(
      t,
      r,
      n
    );
    this.data.updateInput(t, { finalScriptWitness: o });
  }
  return this.data.clearFinalizedInput(t), this;
};
h_fn2 = function(t, r, n) {
  const i = this.data.inputs[t], o = i == null ? void 0 : i.partialSig;
  if (!i || !o || o.length < 1)
    throw new Error("No signatures to validate");
  if (typeof r != "function")
    throw new Error("Need validator function to validate signatures");
  const a = n ? o.filter((p) => P(p.pubkey, n)) : o;
  if (a.length < 1) throw new Error("No signatures for this pubkey");
  const u = [];
  let l, d, f;
  for (const p of a) {
    const w = p.signature, y = p.pubkey, m = Te4.decode(w), { hash: E2, script: v } = f !== m.hashType || !l || !d ? __privateGet(this, _Xn_instances, r_get).getHashForSig(
      t,
      Object.assign({}, i, {
        sighashType: m.hashType
      }),
      true
    ) : { hash: l, script: d };
    f = m.hashType, l = E2, d = v, ga2(y, v, "verify"), u.push(r(y, E2, m.signature));
  }
  return u.every((p) => p);
};
f_fn2 = function(t, r, n) {
  const i = this.data.inputs[t], o = i == null ? void 0 : i.tapKeySig, a = i == null ? void 0 : i.tapScriptSig;
  if (!i && !o && !(a && !a.length))
    throw new Error("No signatures to validate");
  if (typeof r != "function")
    throw new Error("Need validator function to validate signatures");
  const u = n ? $e4(n) : void 0, l = u ? __privateGet(this, _Xn_instances, r_get).getTaprootHashesForSig(t, i, this.data.inputs, u) : __privateGet(this, _Xn_instances, r_get).getAllTaprootHashesForSig(t, i, this.data.inputs);
  if (!l.length) throw new Error("No signatures for this pubkey");
  const d = l.find((p) => !p.leafHash);
  let f = 0;
  if (o && d) {
    if (!r(
      d.pubkey,
      d.hash,
      __privateGet(this, _Xn_instances, r_get).trimTaprootSig(o)
    )) return false;
    f++;
  }
  if (a)
    for (const p of a) {
      const w = p.pubkey, y = l.find((m) => P(w, m.pubkey));
      if (y) {
        if (!r(
          w,
          y.hash,
          __privateGet(this, _Xn_instances, r_get).trimTaprootSig(p.signature)
        )) return false;
        f++;
      }
    }
  return f > 0;
};
u_fn3 = function(t, r, n = [rt4.SIGHASH_ALL]) {
  const i = r.publicKey instanceof Uint8Array ? r.publicKey : new Uint8Array(r.publicKey), { hash: o, sighashType: a } = __privateGet(this, _Xn_instances, r_get).getHashAndSighashType(
    this.data.inputs,
    t,
    i,
    n
  ), u = r.sign(o), l = [
    {
      pubkey: i,
      signature: Te4.encode(
        u instanceof Uint8Array ? u : new Uint8Array(u),
        a
      )
    }
  ];
  return this.data.updateInput(t, { partialSig: l }), __privateGet(this, _t22).hasSignatures = true, this;
};
c_fn2 = function(t, r, n, i, o = [rt4.SIGHASH_DEFAULT]) {
  const a = n.publicKey instanceof Uint8Array ? n.publicKey : new Uint8Array(n.publicKey);
  if (!("signSchnorr" in n) || typeof n.signSchnorr != "function")
    throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
  const u = this.checkTaprootHashesForSig(
    t,
    r,
    n,
    i,
    o
  ), l = n.signSchnorr.bind(n), d = u.filter((p) => !p.leafHash).map(
    (p) => Ve4(l(p.hash), r.sighashType)
  )[0], f = u.filter((p) => !!p.leafHash).map(
    (p) => ({
      pubkey: $e4(a),
      signature: Ve4(
        l(p.hash),
        r.sighashType
      ),
      leafHash: p.leafHash
    })
  );
  return d && (this.data.updateInput(t, { tapKeySig: d }), __privateGet(this, _t22).hasSignatures = true), f.length && (this.data.updateInput(t, { tapScriptSig: f }), __privateGet(this, _t22).hasSignatures = true), this;
};
p_fn2 = async function(t, r, n = [rt4.SIGHASH_ALL]) {
  const i = r.publicKey instanceof Uint8Array ? r.publicKey : new Uint8Array(r.publicKey), { hash: o, sighashType: a } = __privateGet(this, _Xn_instances, r_get).getHashAndSighashType(
    this.data.inputs,
    t,
    i,
    n
  ), u = await r.sign(o), l = u instanceof Uint8Array ? u : new Uint8Array(u), d = [
    {
      pubkey: i,
      signature: Te4.encode(l, a)
    }
  ];
  this.data.updateInput(t, { partialSig: d }), __privateGet(this, _t22).hasSignatures = true;
};
l_fn3 = async function(t, r, n, i, o = [rt4.SIGHASH_DEFAULT]) {
  const a = n.publicKey instanceof Uint8Array ? n.publicKey : new Uint8Array(n.publicKey);
  if (!("signSchnorr" in n) || typeof n.signSchnorr != "function")
    throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
  const u = this.checkTaprootHashesForSig(
    t,
    r,
    n,
    i,
    o
  ), l = n.signSchnorr.bind(n), d = u.find((p) => !p.leafHash);
  if (d) {
    const p = await l(d.hash), w = Ve4(p, r.sighashType);
    this.data.updateInput(t, { tapKeySig: w }), __privateGet(this, _t22).hasSignatures = true;
  }
  const f = u.filter(
    (p) => !!p.leafHash
  );
  if (f.length) {
    const p = await Promise.all(
      f.map(async (w) => {
        const y = await l(w.hash);
        return {
          pubkey: $e4(a),
          signature: Ve4(y, r.sighashType),
          leafHash: w.leafHash
        };
      })
    );
    this.data.updateInput(t, { tapScriptSig: p }), __privateGet(this, _t22).hasSignatures = true;
  }
};
var Xn2 = _Xn;
var vp2 = {
  payments: Xf2,
  script: Vh2,
  crypto: Zh2
};

// node_modules/@btc-vision/transaction/browser/index.js
var zt5 = Symbol;
typeof zt5.dispose != "symbol" && (zt5.dispose = Symbol.for("Symbol.dispose"));
typeof zt5.asyncDispose != "symbol" && (zt5.asyncDispose = Symbol.for("Symbol.asyncDispose"));
var Gi3 = "1.8.0-rc.9";
function Qi3(n, t = {}) {
  return new Uint8Array(wy.gzip(n, { level: t.level || 6 }));
}
function ji3(n) {
  return new Uint8Array(wy.ungzip(n));
}
function Zi3(n, t = {}) {
  return new Uint8Array(wy.deflate(n, { level: t.level || 6 }));
}
function Ji3(n) {
  return new Uint8Array(wy.inflate(n));
}
var Ke5 = {
  gzipSync: Qi3,
  gunzipSync: ji3,
  deflateSync: Zi3,
  inflateSync: Ji3
};
var _Y = class _Y {
  /**
   * Compresses the data using gzip.
   * @param {Uint8Array} data The data to compress.
   * @returns {Uint8Array} The compressed data.
   */
  static compress(t) {
    return new Uint8Array(Ke5.gzipSync(t, _Y.zlibOptions));
  }
  /**
   * Decompresses the data using gunzip.
   * @param {Uint8Array} data The data to decompress.
   * @returns {Uint8Array} The decompressed data.
   */
  static decompress(t) {
    return new Uint8Array(Ke5.gunzipSync(t, _Y.zlibOptions));
  }
};
__publicField(_Y, "zlibOptions", {
  level: 9,
  maxOutputLength: 1024 * 1024 * 16
  // 16mb, limit it to 16mb.
});
var Y = _Y;
var H2 = Lg();
var tr2 = H2;
gp2(tr2);
var ze3 = typeof _y == "function" ? _y : $b.BIP32Factory;
if (!ze3)
  throw new Error("Failed to load BIP32 library");
var gt4 = He2.Point;
var er2 = gt4.Fn.ORDER;
var ir3 = new Uint8Array([84, 97, 112, 84, 119, 101, 97, 107]);
var xe4 = l0(ir3);
function rr2(n) {
  return l0(F0(xe4, xe4, n));
}
var _P2 = class _P2 {
  /**
   * Generate a keypair from a WIF
   * @param {string} wif - The WIF to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromWIF(t, e = ap2.bitcoin) {
    return Zr.fromWIF(H2, t, e);
  }
  /**
   * Generate a keypair from a private key
   * @param {Uint8Array} privateKey - The private key to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromPrivateKey(t, e = ap2.bitcoin) {
    return Zr.fromPrivateKey(H2, t, e);
  }
  /**
   * Generate a keypair from a public key
   * @param {Uint8Array} publicKey - The public key to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromPublicKey(t, e = ap2.bitcoin) {
    return Zr.fromPublicKey(H2, t, e);
  }
  /**
   * Generate a multi-sig address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(t, e, i = ap2.bitcoin) {
    const r = this.verifyPubKeys(t, i);
    if (r.length !== t.length) throw new Error("Contains invalid public keys");
    const s = Xf2.p2ms({
      m: e,
      pubkeys: r,
      network: i
    }), a = Xf2.p2wsh({ redeem: s, network: i }).address;
    if (!a)
      throw new Error("Failed to generate address");
    return a;
  }
  /**
   * Verify public keys and return the public keys
   * @param {Uint8Array[]} pubKeys - The public keys to verify
   * @param {Network} network - The network to use
   * @returns {Uint8Array[]} - The verified public keys
   * @throws {Error} - If the key cannot be regenerated
   */
  static verifyPubKeys(t, e = ap2.bitcoin) {
    return t.map((i) => {
      const r = _P2.fromPublicKey(i, e);
      if (!r)
        throw new Error("Failed to regenerate key");
      return r.publicKey;
    });
  }
  /**
   * Get a P2WPKH address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The address
   */
  static getP2WPKHAddress(t, e = ap2.bitcoin) {
    const i = Xf2.p2wpkh({ pubkey: t.publicKey, network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the address of a tweaked public key
   * @param {string} tweakedPubKeyHex - The tweaked public key hex string
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static tweakedPubKeyToAddress(t, e) {
    t.startsWith("0x") && (t = t.slice(2));
    let i = Mt3(t);
    return i.length !== 32 && (i = $e4(i)), _P2.tweakedPubKeyBufferToAddress(i, e);
  }
  /**
   * Get the address of a tweaked public key
   * @param {Uint8Array} tweakedPubKeyBuffer - The tweaked public key buffer
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static tweakedPubKeyBufferToAddress(t, e) {
    const { address: i } = Xf2.p2tr({
      pubkey: t,
      network: e
    });
    if (!i)
      throw new Error("Failed to generate Taproot address");
    return i;
  }
  /**
   * Generate a P2OP address
   * @param bytes - The bytes to use for the P2OP address
   * @param network - The network to use
   * @param deploymentVersion - The deployment version (default is 0)
   * @returns {string} - The generated P2OP address
   */
  static p2op(t, e = ap2.bitcoin, i = 0) {
    const r = _t7([
      new Uint8Array([i]),
      vp2.crypto.hash160(t)
    ]);
    if (r.length < 2 || r.length > 40)
      throw new Error("Witness program must be 2-40 bytes.");
    const s = Vh2.compile([q2.OP_16, r]);
    return ra2(s, e);
  }
  /**
   * Get the address of a xOnly tweaked public key
   * @param {string} tweakedPubKeyHex - The xOnly tweaked public key hex string
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static xOnlyTweakedPubKeyToAddress(t, e) {
    t.startsWith("0x") && (t = t.slice(2));
    const i = Mt3(t);
    if (i.length !== 32)
      throw new Error("Invalid xOnly public key length");
    const { address: r } = Xf2.p2tr({
      pubkey: i,
      network: e
    });
    if (!r)
      throw new Error("Failed to generate Taproot address");
    return r;
  }
  /**
   * Tweak a public key
   * @param {Uint8Array | string} pub - The public key to tweak
   * @returns {Uint8Array} - The tweaked public key
   * @throws {Error} - If the public key cannot be tweaked
   */
  static tweakPublicKey(t) {
    typeof t == "string" && t.startsWith("0x") && (t = t.slice(2));
    const e = typeof t == "string" ? t : Yt4(t), i = gt4.fromHex(e), r = (i.y & 1n) === 0n ? i : i.negate(), s = r.toBytes(true).subarray(1), o = rr2(s), a = X2(wt2(o), er2);
    return r.add(gt4.BASE.multiply(a)).toBytes(true);
  }
  /**
   * Tweak a batch of public keys
   * @param {readonly Uint8Array[]} pubkeys - The public keys to tweak
   * @param {bigint} tweakScalar - The scalar to use for tweaking
   * @returns {Uint8Array[]} - The tweaked public keys
   */
  static tweakBatchSharedT(t, e) {
    const i = gt4.BASE.multiply(e);
    return t.map((r) => {
      const s = gt4.fromHex(Yt4(r));
      return (s.y % 2n === 0n ? s : s.negate()).add(i).toBytes(true);
    });
  }
  /**
   * Generate a random wallet with both classical and quantum keys
   *
   * @param network - The network to use
   * @param securityLevel - The ML-DSA security level for quantum keys (default: LEVEL2/44)
   * @returns An object containing both classical and quantum key information
   */
  static generateWallet(t = ap2.bitcoin, e = $b.MLDSASecurityLevel.LEVEL2) {
    const i = Zr.makeRandom(H2, t, {
      rng: (o) => T0(o)
    }), r = this.getP2WPKHAddress(i, t);
    if (!r)
      throw new Error("Failed to generate wallet");
    const s = this.generateQuantumKeyPair(e, t);
    return {
      address: r,
      privateKey: i.toWIF(),
      publicKey: Yt4(i.publicKey),
      quantumPrivateKey: Yt4(s.privateKey),
      quantumPublicKey: Yt4(s.publicKey)
    };
  }
  /**
   * Generate a random quantum ML-DSA keypair
   *
   * This creates a standalone quantum-resistant keypair without using BIP32 derivation.
   * The keys are generated using cryptographically secure random bytes.
   *
   * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
   * @param network - The Bitcoin network (default: bitcoin mainnet)
   * @returns A random ML-DSA keypair
   */
  static generateQuantumKeyPair(t = $b.MLDSASecurityLevel.LEVEL2, e = ap2.bitcoin) {
    const i = T0(64), r = $b.QuantumBIP32Factory.fromSeed(i, e, t);
    if (!r.privateKey || !r.publicKey)
      throw new Error("Failed to generate quantum keypair");
    return {
      privateKey: new Uint8Array(r.privateKey),
      publicKey: new Uint8Array(r.publicKey)
    };
  }
  /**
   * Verify that a contract address is a valid p2tr address
   * @param {string} contractAddress - The contract address to verify
   * @param {Network} network - The network to use
   * @returns {boolean} - Whether the address is valid
   */
  static verifyContractAddress(t, e = ap2.bitcoin) {
    return !!Ip2.toOutputScript(t, e);
  }
  /**
   * Get the legacy segwit address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getLegacySegwitAddress(t, e = ap2.bitcoin) {
    const i = Xf2.p2sh({
      redeem: Xf2.p2wpkh({ pubkey: t.publicKey, network: e }),
      network: e
    });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the legacy address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getLegacyAddress(t, e = ap2.bitcoin) {
    const i = Xf2.p2pkh({ pubkey: t.publicKey, network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the legacy address from a public key
   * @param publicKey
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getP2PKH(t, e = ap2.bitcoin) {
    const i = Xf2.p2pkh({ pubkey: t, network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the P2PK output from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getP2PKAddress(t, e = ap2.bitcoin) {
    const i = Xf2.p2pk({ pubkey: t.publicKey, network: e });
    if (!i.output)
      throw new Error("Failed to generate wallet");
    return "0x" + Yt4(i.output);
  }
  /**
   * Generate a random keypair
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static generateRandomKeyPair(t = ap2.bitcoin) {
    return Zr.makeRandom(H2, t, {
      rng: (e) => T0(e)
    });
  }
  /**
   * Generate a BIP32 keypair from a seed
   * @param {Uint8Array} seed - The seed to generate the keypair from
   * @param {Network} network - The network to use
   * @returns {BIP32Interface} - The generated keypair
   */
  static fromSeed(t, e = ap2.bitcoin) {
    return this.BIP32.fromSeed(t, e);
  }
  /**
   * Get taproot address from keypair
   * @param {UniversalSigner | Signer} keyPair - The keypair to get the taproot address for
   * @param {Network} network - The network to use
   * @returns {string} - The taproot address
   */
  static getTaprootAddress(t, e = ap2.bitcoin) {
    const { address: i } = Xf2.p2tr({
      internalPubkey: $e4(t.publicKey),
      network: e
    });
    if (!i)
      throw new Error("Failed to generate sender address for transaction");
    return i;
  }
  /**
   * Get taproot address from address
   * @param {string} inAddr - The address to convert to taproot
   * @param {Network} network - The network to use
   * @returns {string} - The taproot address
   */
  static getTaprootAddressFromAddress(t, e = ap2.bitcoin) {
    const { address: i } = Xf2.p2tr({
      address: t,
      network: e
    });
    if (!i)
      throw new Error("Failed to generate sender address for transaction");
    return i;
  }
  /**
   * Get a keypair from a given seed.
   * @param {Uint8Array} seed - The seed to generate the key pair from
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated key pair
   */
  static fromSeedKeyPair(t, e = ap2.bitcoin) {
    const r = this.BIP32.fromSeed(t, e).privateKey;
    if (!r) throw new Error("Failed to generate key pair");
    return Zr.fromPrivateKey(H2, r, e);
  }
};
__publicField(_P2, "BIP32", ze3(H2));
__publicField(_P2, "ECPairSigner", Zr);
gt4.BASE.precompute(8);
var P2 = _P2;
var $3 = ((n) => (n[n.ACCESS_LIST = 1] = "ACCESS_LIST", n[n.EPOCH_SUBMISSION = 2] = "EPOCH_SUBMISSION", n[n.MLDSA_LINK_PUBKEY = 4] = "MLDSA_LINK_PUBKEY", n))($3 || {});
var et4 = ((n) => (n[n.ACCESS_LIST = 1] = "ACCESS_LIST", n[n.EPOCH_SUBMISSION = 2] = "EPOCH_SUBMISSION", n[n.MLDSA_LINK_PUBKEY = 3] = "MLDSA_LINK_PUBKEY", n))(et4 || {});
var D = 32;
var mt5 = 64;
var Tt5 = 64;
var sr2 = 4;
var kt4 = 32;
var Ut5 = 16;
var qt5 = 8;
var bt4 = 4;
var At4 = 2;
var Xt5 = 1;
var nr = 32;
var Bt5 = 16;
var Lt4 = 8;
var Rt4 = 4;
var Kt3 = 2;
var xt5 = 1;
var or2 = 1;
function ar(n, t, e, i) {
  throw new Error(`${t} (${e}: ${i})`);
}
function cr3() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof globalThis < "u")
    return globalThis;
  throw new Error("unable to locate global object");
}
var De4 = cr3();
De4.crypto || De4.msCrypto;
function oe4(n) {
  switch (n) {
    case "sha256":
      return l0.create();
    case "sha512":
      return x0.create();
  }
  ar(false, "invalid hashing algorithm name", "algorithm", n);
}
var ur2 = /^[0-9a-fA-F]+$/;
var M = class _M {
  /**
   * Converts satoshi to BTC
   * @param {number} btc - The amount in BTC
   * @returns {bigint} The amount in satoshi
   */
  static btcToSatoshi(t) {
    return BigInt(t * 1e8);
  }
  /**
   * Generates random bytes.
   * @public
   * @returns {Uint8Array} The random bytes
   */
  static rndBytes() {
    return _M.getSafeRandomValues(64);
  }
  static getSafeRandomValues(t) {
    if (typeof globalThis.window < "u" && globalThis.window.crypto && typeof globalThis.window.crypto.getRandomValues == "function") {
      const e = new Uint8Array(t);
      return window.crypto.getRandomValues(e), e;
    } else if (globalThis.crypto && typeof globalThis.crypto.getRandomValues == "function") {
      const e = new Uint8Array(t);
      return globalThis.crypto.getRandomValues(e), e;
    } else
      throw console.log(
        "No secure random number generator available. Please upgrade your environment.",
        globalThis.window.crypto,
        globalThis.crypto
      ), new Error(
        "No secure random number generator available. Please upgrade your environment."
      );
  }
  static isValidHex(t) {
    return ur2.test(t);
  }
  /**
   * Hashes the given data
   * @param {Uint8Array} data - The data to hash
   * @returns {string} The hashed data
   */
  static opnetHash(t) {
    const e = oe4("sha512");
    e.update(t);
    const i = e.digest();
    return `0x${Yt4(new Uint8Array(i))}`;
  }
};
var Z2 = class {
  /**
   * Check if a UTXO is a P2WDA output by examining its script structure
   */
  static isP2WDAUTXO(t) {
    if (!t.witnessScript)
      return false;
    const e = t.witnessScript instanceof Uint8Array ? t.witnessScript : Mt3(t.witnessScript);
    return this.isP2WDAWitnessScript(e);
  }
  /**
   * Check if a witness script follows the P2WDA pattern
   */
  static isP2WDAWitnessScript(t) {
    try {
      const e = Vh2.decompile(t);
      if (!e || e.length !== 7)
        return false;
      for (let i = 0; i < 5; i++)
        if (e[i] !== q2.OP_2DROP)
          return false;
      return e[5] instanceof Uint8Array && e[5].length === 33 && // Compressed public key
      e[6] === q2.OP_CHECKSIG;
    } catch {
      return false;
    }
  }
  /**
   * Generate a P2WDA address from a public key
   */
  static generateP2WDAAddress(t, e) {
    if (t.length !== 33)
      throw new Error("Public key must be 33 bytes (compressed)");
    const i = Vh2.compile([
      q2.OP_2DROP,
      q2.OP_2DROP,
      q2.OP_2DROP,
      q2.OP_2DROP,
      q2.OP_2DROP,
      t,
      q2.OP_CHECKSIG
    ]), r = Xf2.p2wsh({
      redeem: { output: i },
      network: e
    });
    if (!r.address || !r.output)
      throw new Error("Failed to generate P2WDA address");
    return {
      address: r.address,
      witnessScript: i,
      scriptPubKey: r.output
    };
  }
  /**
   * Extract the public key from a P2WDA witness script
   */
  static extractPublicKeyFromP2WDA(t) {
    try {
      const e = Vh2.decompile(t);
      if (!e || e.length !== 7)
        return null;
      for (let i = 0; i < 5; i++)
        if (e[i] !== q2.OP_2DROP)
          return null;
      return e[5] instanceof Uint8Array && e[5].length === 33 && e[6] === q2.OP_CHECKSIG ? e[5] : null;
    } catch {
      return null;
    }
  }
  /**
   * Create witness data for a simple P2WDA spend (no operation data)
   */
  static createSimpleP2WDAWitness(t, e) {
    const i = [t];
    for (let r = 0; r < 10; r++)
      i.push(new Uint8Array(0));
    return i.push(e), i;
  }
  /**
   * Validate P2WDA operation data signature
   */
  static validateP2WDASignature(t, e, i) {
    return e.length === 64;
  }
  /**
   * Calculate the witness size for P2WDA transaction estimation
   */
  static estimateP2WDAWitnessSize(t = 0) {
    return 72 + t + 39 + 12;
  }
  /**
   * Check if a scriptPubKey is a P2WSH that could be P2WDA
   */
  static couldBeP2WDA(t) {
    return t.length === 34 && t[0] === 0 && t[1] === 32;
  }
};
var st3 = ((n) => (n.P2PKH = "P2PKH", n.P2OP = "P2OP", n.P2SH_OR_P2SH_P2WPKH = "P2SH_OR_P2SH-P2WPKH", n.P2PK = "P2PK", n.P2TR = "P2TR", n.P2MR = "P2MR", n.P2WPKH = "P2WPKH", n.P2WSH = "P2WSH", n.P2WDA = "P2WDA", n))(st3 || {});
var Q2 = class _Q {
  static isValidP2TRAddress(t, e) {
    if (!t || t.length < 50) return false;
    let i = false;
    try {
      Ip2.toOutputScript(t, e), i = Ip2.fromBech32(t).version === 1;
    } catch {
    }
    return i;
  }
  /**
   * Validates that the given address is a valid P2MR (BIP 360) address.
   * Checks for witness version 2 with a 32-byte Merkle root program.
   */
  static isValidP2MRAddress(t, e) {
    if (!t || t.length < 50) return false;
    let i = false;
    try {
      Ip2.toOutputScript(t, e);
      const r = Ip2.fromBech32(t);
      i = r.version === 2 && r.data.length === 32;
    } catch {
    }
    return i;
  }
  static isP2WPKHAddress(t, e) {
    if (!t || t.length < 20 || t.length > 50) return false;
    let i = false;
    try {
      const r = Ip2.fromBech32(t);
      Ip2.toOutputScript(t, e), i = r.version === 0 && r.data.length === 20;
    } catch {
    }
    return i;
  }
  static isP2WDAWitnessScript(t) {
    return Z2.isP2WDAWitnessScript(t);
  }
  static isP2PKHOrP2SH(t, e) {
    try {
      const i = Ip2.fromBase58Check(t);
      return i.version === e.pubKeyHash ? true : i.version === e.scriptHash;
    } catch {
      return false;
    }
  }
  static isValidPublicKey(t, e) {
    try {
      if (t.startsWith("0x") && (t = t.slice(2)), !M.isValidHex(t))
        return false;
      if (t.length === 64)
        return true;
      const i = Mt3(t);
      if (t.length === 130 && i[0] === 6 || i[0] === 7)
        return true;
      if (t.length === 66 || t.length === 130)
        return P2.fromPublicKey(i, e), true;
    } catch {
      return false;
    }
    return false;
  }
  static isValidMLDSAPublicKey(t) {
    try {
      let e;
      if (typeof t != "string" && t instanceof Uint8Array)
        e = t.length;
      else {
        if (t.startsWith("0x") && (t = t.slice(2)), !M.isValidHex(t))
          return null;
        e = t.length / 2;
      }
      switch (e) {
        case 1312:
          return $b.MLDSASecurityLevel.LEVEL2;
        case 1952:
          return $b.MLDSASecurityLevel.LEVEL3;
        case 2592:
          return $b.MLDSASecurityLevel.LEVEL5;
        default:
          return null;
      }
    } catch {
      return null;
    }
  }
  static isValidP2OPAddress(t, e) {
    if (!t || t.length < 20) return false;
    try {
      const i = Ip2.fromBech32(t);
      return i.prefix === e.bech32 || i.prefix === e.bech32Opnet ? i.version === 16 && i.data.length === 21 : false;
    } catch {
      return false;
    }
  }
  static requireRedeemScript(t, e) {
    try {
      const i = Ip2.fromBase58Check(t);
      return i.version === e.pubKeyHash ? false : i.version === e.scriptHash;
    } catch {
      return false;
    }
  }
  static detectAddressType(t, e) {
    if (_Q.isValidPublicKey(t, e))
      return "P2PK";
    try {
      const i = Ip2.fromBase58Check(t);
      if (i.version === e.pubKeyHash)
        return "P2PKH";
      if (i.version === e.scriptHash)
        return "P2SH_OR_P2SH-P2WPKH";
    } catch {
    }
    try {
      const i = Ip2.fromBech32(t);
      if ((i.prefix === e.bech32Opnet || i.prefix === e.bech32) && i.version === 16 && i.data.length === 21)
        return "P2OP";
      if (i.prefix === e.bech32) {
        if (i.version === 0 && i.data.length === 20)
          return "P2WPKH";
        if (i.version === 0 && i.data.length === 32)
          return "P2WSH";
        if (i.version === 1 && i.data.length === 32)
          return "P2TR";
        if (i.version === 2 && i.data.length === 32)
          return "P2MR";
      }
    } catch {
    }
    return null;
  }
  static detectAddressTypeWithWitnessScript(t, e, i) {
    const r = _Q.detectAddressType(t, e);
    return r === "P2WSH" && i && _Q.isP2WDAWitnessScript(i) ? "P2WDA" : r;
  }
  static validateP2WDAAddress(t, e, i) {
    try {
      if (_Q.detectAddressType(t, e) !== "P2WSH")
        return {
          isValid: false,
          isPotentiallyP2WDA: false,
          isDefinitelyP2WDA: false,
          error: "Not a P2WSH address"
        };
      if (!i)
        return {
          isValid: true,
          isPotentiallyP2WDA: true,
          isDefinitelyP2WDA: false
        };
      if (!_Q.isP2WDAWitnessScript(i))
        return {
          isValid: true,
          isPotentiallyP2WDA: true,
          isDefinitelyP2WDA: false,
          error: "Witness script does not match P2WDA pattern"
        };
      if (Xf2.p2wsh({
        redeem: { output: i },
        network: e
      }).address !== t)
        return {
          isValid: false,
          isPotentiallyP2WDA: false,
          isDefinitelyP2WDA: false,
          error: "Witness script does not match address"
        };
      const o = Z2.extractPublicKeyFromP2WDA(i);
      return o ? {
        isValid: true,
        isPotentiallyP2WDA: true,
        isDefinitelyP2WDA: true,
        publicKey: o
      } : {
        isValid: false,
        isPotentiallyP2WDA: false,
        isDefinitelyP2WDA: false,
        error: "Failed to extract public key from witness script"
      };
    } catch (r) {
      return {
        isValid: false,
        isPotentiallyP2WDA: false,
        isDefinitelyP2WDA: false,
        error: r.message
      };
    }
  }
};
var ht4 = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
var qe4 = class {
  constructor(t = 1e4) {
    /**
     * The maximum increments to try before giving up on deriving a valid x.
     */
    __publicField(this, "maxTries");
    this.maxTries = t;
  }
  /**
   * Main entry point.
   * Given a 32-byte input, ensures we obtain a "real" x on secp256k1.
   * - If the given x is valid, we use it.
   * - Otherwise, we increment x (mod p) until we find one whose (x^3 + 7) is a quadratic residue.
   * Then we return { x, y1, y2 } for that valid point.
   *
   * @param xBytes A 32-byte Uint8Array for the candidate x
   * @param failOnInvalidX (optional) whether to throw if the given x is not a valid curve point, defaults to true
   * @param maxTries (optional) number of increments to attempt, defaults to this.maxTries
   * @returns An object { x: bigint; y1: bigint; y2: bigint } describing a valid curve point
   * @throws If no valid x found within maxTries
   */
  findOrDeriveValidPoint(t, e = true, i = this.maxTries) {
    if (t.length !== 32)
      throw new Error("xBytes must be exactly 32 bytes.");
    let r = this.bytesToBigInt(t) % ht4, s = this.isValidX(r);
    if (e && s === null)
      throw new Error("The given x is not a valid curve point.");
    let o = 0;
    for (; s === null; )
      if (r = (r + 1n) % ht4, s = this.isValidX(r), o++, o > i)
        throw new Error(`Could not find a valid X point within ${i} increments.`);
    const a = s, c = (ht4 - a) % ht4;
    return { x: r, y1: a, y2: c };
  }
  /**
   * Given two candidate y values, returns the one with the smaller y-coordinate.
   * @param {bigint} y
   * @param {bigint} y2
   */
  getCanonicalY(t, e) {
    return t < e ? t : e;
  }
  /**
   * Creates a 65-byte "hybrid public key" from the specified x and y.
   * - First byte:
   *   - 0x06 if y is even
   *   - 0x07 if y is odd
   * - Next 32 bytes: x
   * - Last 32 bytes: y
   *
   * @param x X-coordinate as a bigint
   * @param y Y-coordinate as a bigint
   * @returns A Uint8Array of length 65
   */
  getHybridPublicKey(t, e) {
    const i = e % 2n === 0n ? 6 : 7, r = this.bigIntTo32Bytes(t), s = this.bigIntTo32Bytes(e), o = new Uint8Array(65);
    return o[0] = i, o.set(r, 1), o.set(s, 33), o;
  }
  /**
   * Checks if (x^3 + 7) is a quadratic residue mod p.
   * Returns the square root if it is, or null if not.
   */
  isValidX(t) {
    const e = (this.modPow(t, 3n, ht4) + 7n) % ht4;
    return this.sqrtModP(e, ht4);
  }
  /**
   * Computes base^exp (mod m) using exponentiation by squaring.
   */
  modPow(t, e, i) {
    let r = 1n, s = t % i, o = e;
    for (; o > 0; )
      (o & 1n) === 1n && (r = r * s % i), s = s * s % i, o >>= 1n;
    return r;
  }
  /**
   * sqrtModP(a, p):
   *   Attempts to compute the square root of `a` modulo prime `p`.
   *   Returns the root if it exists, or null if `a` is not a quadratic residue.
   *
   * Since p  3 (mod 4), we can do:
   *   sqrt(a) = a^((p+1)/4) mod p
   */
  sqrtModP(t, e) {
    const i = this.modPow(t, e + 1n >> 2n, e);
    return i * i % e !== t % e ? null : i;
  }
  /**
   * Convert a 32-byte Uint8Array (big-endian) to a BigInt.
   */
  bytesToBigInt(t) {
    let e = 0n;
    for (const i of t)
      e = e << 8n | BigInt(i);
    return e;
  }
  /**
   * Convert a BigInt to a 32-byte array (big-endian).
   */
  bigIntTo32Bytes(t) {
    const e = new Uint8Array(32);
    for (let i = 31; i >= 0; i--)
      e[i] = Number(t & 0xffn), t >>= 8n;
    return e;
  }
};
var lr3 = class {
  constructor() {
    __publicField(this, "deriver", new qe4());
  }
  generateHybridKeyFromHash(t) {
    const e = this.deriver.findOrDeriveValidPoint(new Uint8Array(t), false), i = this.deriver.getCanonicalY(e.y1, e.y2);
    return new Uint8Array(this.deriver.getHybridPublicKey(e.x, i));
  }
};
var ae3 = new lr3();
var _z = class _z {
  /**
   * Generate a P2WSH address with CSV timelock
   * Note: This uses ECDSA, not Schnorr (Schnorr only available in Taproot)
   */
  static generateTimeLockAddress(t, e = ap2.bitcoin, i = _z.CSV_BLOCKS) {
    const r = this.generateTimeLockScript(t, i), s = vp2.payments.p2wsh({
      redeem: { output: r },
      network: e
    });
    if (!s.address)
      throw new Error("Failed to generate P2WSH address");
    return {
      address: s.address,
      witnessScript: r
    };
  }
  /**
   * Generate a P2TR address with CSV time lock
   * Note: This uses Schnorr signatures
   */
  static generateTimeLockAddressP2TR(t, e = ap2.bitcoin, i = _z.CSV_BLOCKS) {
    if (t.length !== 32)
      throw new Error("Public key must be 32 bytes for Taproot");
    const r = this.generateTimeLockScript(t, i), s = vp2.payments.p2tr({
      redeem: { output: r },
      network: e,
      internalPubkey: _z.UNSPENDABLE_INTERNAL_KEY
    });
    if (!s.address)
      throw new Error("Failed to generate P2TR address");
    return s.address;
  }
  /**
   * Generate a P2MR address with CSV time lock
   * Note: This uses Schnorr signatures within a P2MR (BIP 360) script tree
   */
  static generateTimeLockAddressP2MR(t, e = ap2.bitcoin, i = _z.CSV_BLOCKS) {
    if (t.length !== 32)
      throw new Error("Public key must be 32 bytes for P2MR");
    const s = { output: this.generateTimeLockScript(t, i), version: 192 }, o = Xf2.p2mr({ scriptTree: s, network: e });
    if (!o.address)
      throw new Error("Failed to generate P2MR address");
    return o.address;
  }
  static generateTimeLockScript(t, e = _z.CSV_BLOCKS) {
    return Vh2.compile([
      Vh2.number.encode(e),
      q2.OP_CHECKSEQUENCEVERIFY,
      q2.OP_DROP,
      t,
      q2.OP_CHECKSIG
    ]);
  }
};
__publicField(_z, "UNSPENDABLE_INTERNAL_KEY", Mt3(
  "50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0"
));
__publicField(_z, "CSV_BLOCKS", 75);
var z3 = _z;
var hr2 = [1312, 1952, 2592];
var _t23, _e22, _n15, _i15, _h13, _r15, _s15, _d10, _a36, _c12, _u12, _l12, _p11, _f13, _g10, _S7, _o15;
var _K = class _K extends Uint8Array {
  constructor(t, e) {
    super(D);
    __privateAdd(this, _t23);
    __privateAdd(this, _e22);
    __privateAdd(this, _n15);
    __privateAdd(this, _i15);
    __privateAdd(this, _h13);
    __privateAdd(this, _r15);
    __privateAdd(this, _s15);
    __privateAdd(this, _d10);
    __privateAdd(this, _a36);
    __privateAdd(this, _c12);
    __privateAdd(this, _u12);
    __privateAdd(this, _l12);
    __privateAdd(this, _p11);
    __privateAdd(this, _f13);
    // Lazy loading state - defers expensive EC operations until actually needed
    __privateAdd(this, _g10);
    __privateAdd(this, _S7, false);
    // After processing, this is 32-byte tweaked x-only (same as original behavior)
    __privateAdd(this, _o15);
    if (!!t) {
      if (e) {
        if (![D, 33, 65].includes(e.length))
          throw new Error(`Invalid public key length ${e.length}`);
        __privateSet(this, _g10, new Uint8Array(e.length)), __privateGet(this, _g10).set(e);
      }
      this.setMldsaKey(t);
    }
  }
  /**
   * Prevent TypedArray methods (subarray, slice, etc.) from creating Address
   * instances. Without this, @noble/hashes and other libraries that call
   * subarray() on an Address would invoke the Address constructor that recomputes
   * everything leading to bad performance.
   */
  static get [Symbol.species]() {
    return Uint8Array;
  }
  get mldsaLevel() {
    return __privateGet(this, _f13);
  }
  set mldsaLevel(t) {
    __privateSet(this, _f13, t);
  }
  get originalMDLSAPublicKey() {
    return __privateGet(this, _p11);
  }
  set originalMDLSAPublicKey(t) {
    __privateSet(this, _p11, t ? new Uint8Array(t) : void 0);
  }
  /**
   * If available, this will return the original public key associated with the address.
   * @returns {Uint8Array} The original public key used to create the address.
   */
  get originalPublicKey() {
    return this.ensureLegacyProcessed(), __privateGet(this, _i15);
  }
  get mldsaPublicKey() {
    return __privateGet(this, _a36);
  }
  /**
   * Get the legacy public key (32-byte tweaked x-only after processing).
   * Triggers lazy processing if not yet done.
   */
  get legacyPublicKey() {
    return this.ensureLegacyProcessed(), __privateGet(this, _o15);
  }
  /**
   * Get the key pair for the address
   * @description This is only for internal use. Please use address.tweakedBytes instead.
   */
  get keyPair() {
    if (this.ensureLegacyProcessed(), !__privateGet(this, _h13))
      throw new Error("Legacy public key not set for address");
    return __privateGet(this, _h13);
  }
  static dead() {
    return _K.fromString(
      "0x0000000000000000000000000000000000000000000000000000000000000000",
      // DEAD ADDRESS
      "0x04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"
    );
  }
  /**
   * Create an address from a hex string
   * @param {string} mldsaPublicKey The ml-dsa public key in hex format
   * @param {string} legacyPublicKey The classical public key in hex format
   * @returns {Address} The address
   */
  static fromString(t, e) {
    if (!t)
      throw new Error("Invalid public key");
    if (t.startsWith("0x") && (t = t.slice(2)), !M.isValidHex(t))
      throw new Error(
        'You must only pass public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.'
      );
    let i;
    if (e) {
      if (e.startsWith("0x") && (e = e.slice(2)), !M.isValidHex(e))
        throw new Error(
          'You must only pass classical public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.'
        );
      i = Mt3(e);
    }
    return new _K(Mt3(t), i);
  }
  /**
   * Create an address from a public key
   * @returns {Address} The address
   * @param {ArrayLike<number>} bytes The public key
   */
  static wrap(t) {
    return new _K(t);
  }
  static uncompressedToCompressed(t) {
    const e = Uint8Array.from(t), i = e.slice(1, 33), r = e.slice(33), s = new Uint8Array(33);
    return s[0] = 2 + (r[r.length - 1] & 1), s.set(i, 1), s;
  }
  /**
   * Creates an Address instance from a BigInt value.
   *
   * Converts a 256-bit unsigned integer into a 32-byte address by splitting it
   * into four 64-bit chunks and writing them in big-endian format using DataView.
   * This is the inverse operation of toBigInt().
   *
   * @param {bigint} value - The 256-bit unsigned integer to convert (0 to 2^256-1)
   * @param {bigint} [tweakedValue] - Optional tweaked public key as a 256-bit unsigned integer
   * @returns {Address} A new Address instance containing the converted value
   *
   * @throws {RangeError} If the value is negative or exceeds 2^256-1
   *
   * @example
   * ```typescript
   * const bigIntValue = 12345678901234567890n;
   * const address = Address.fromBigInt(bigIntValue);
   * console.log(address.toHex()); // 0x0000000000000000000000000000000000000000000000000000abc123...
   * ```
   */
  static fromBigInt(t, e) {
    const i = _K.bigintToUint8Array(t), r = e !== void 0 ? _K.bigintToUint8Array(e) : void 0;
    return new _K(i, r);
  }
  /**
   * Creates an Address instance from four 64-bit unsigned integers.
   *
   * Constructs a 32-byte address by combining four 64-bit big-endian unsigned integers.
   * This is the inverse operation of toUint64Array() and provides an efficient way
   * to create addresses from word-aligned data.
   *
   * @param {bigint} w0 - Most significant 64 bits (bytes 0-7)
   * @param {bigint} w1 - Second 64 bits (bytes 8-15)
   * @param {bigint} w2 - Third 64 bits (bytes 16-23)
   * @param {bigint} w3 - Least significant 64 bits (bytes 24-31)
   * @returns {Address} A new Address instance containing the combined value
   *
   * @throws {RangeError} If any value exceeds 64 bits (2^64-1)
   *
   * @example
   * ```typescript
   * const address = Address.fromUint64Array(
   *     0x0123456789abcdefn,
   *     0xfedcba9876543210n,
   *     0x1111222233334444n,
   *     0x5555666677778888n
   * );
   * console.log(address.toHex());
   * ```
   */
  static fromUint64Array(t, e, i, r) {
    const s = new Uint8Array(32), o = new DataView(s.buffer);
    return o.setBigUint64(0, t, false), o.setBigUint64(8, e, false), o.setBigUint64(16, i, false), o.setBigUint64(24, r, false), new _K(s);
  }
  static bigintToUint8Array(t) {
    const e = new Uint8Array(32), i = new DataView(e.buffer);
    return i.setBigUint64(0, t >> 192n & 0xffffffffffffffffn, false), i.setBigUint64(8, t >> 128n & 0xffffffffffffffffn, false), i.setBigUint64(16, t >> 64n & 0xffffffffffffffffn, false), i.setBigUint64(24, t & 0xffffffffffffffffn, false), e;
  }
  [Symbol.dispose]() {
    var _a37, _b9;
    this.fill(0), __privateSet(this, _t23, void 0), __privateSet(this, _e22, void 0), __privateSet(this, _n15, void 0), __privateSet(this, _i15, void 0), __privateSet(this, _h13, void 0), __privateSet(this, _r15, void 0), __privateSet(this, _s15, void 0), __privateSet(this, _d10, void 0), (_a37 = __privateGet(this, _a36)) == null ? void 0 : _a37.fill(0), __privateSet(this, _a36, void 0), __privateSet(this, _c12, void 0), __privateSet(this, _u12, void 0), __privateSet(this, _l12, void 0), (_b9 = __privateGet(this, _p11)) == null ? void 0 : _b9.fill(0), __privateSet(this, _p11, void 0), __privateSet(this, _f13, void 0), __privateSet(this, _S7, false), __privateSet(this, _o15, void 0);
  }
  /**
   * Converts the address to four 64-bit unsigned integers.
   *
   * Splits the 32-byte (256-bit) address into four 64-bit big-endian unsigned integers.
   * This representation is useful for efficient storage, comparison operations, or
   * interfacing with systems that work with 64-bit word sizes.
   *
   * @returns {[bigint, bigint, bigint, bigint]} An array of four 64-bit unsigned integers
   *          representing the address from most significant to least significant bits
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...');
   * const [w0, w1, w2, w3] = address.toUint64Array();
   * console.log(w0); // Most significant 64 bits
   * console.log(w3); // Least significant 64 bits
   * ```
   */
  toUint64Array() {
    if (__privateGet(this, _l12) !== void 0)
      return __privateGet(this, _l12);
    const t = new DataView(this.buffer, this.byteOffset, 32);
    return __privateSet(this, _l12, [
      t.getBigUint64(0, false),
      t.getBigUint64(8, false),
      t.getBigUint64(16, false),
      t.getBigUint64(24, false)
    ]), __privateGet(this, _l12);
  }
  /**
   * Check if the address is the dead address
   * @returns {boolean}
   */
  isDead() {
    for (let t = 0; t < D; t++)
      if (this[t] !== 0)
        return false;
    return true;
  }
  /**
   * Converts the address to a hex string
   * @returns {string} The hex string
   */
  toHex() {
    return "0x" + Yt4(this);
  }
  /**
   * Converts the classical public key to a hex string
   * @returns {string} The hex string
   */
  tweakedToHex() {
    const t = this.legacyPublicKey;
    if (!t)
      throw new Error("Legacy public key not set");
    return "0x" + Yt4(t);
  }
  /**
   * Converts the address content (SHA256 hash of ML-DSA public key) to a Uint8Array
   * @returns {Uint8Array} The Uint8Array containing the hashed ML-DSA public key
   */
  toBuffer() {
    return new Uint8Array(this);
  }
  /**
   * Converts the classical public key to a Uint8Array
   * @returns {Uint8Array} The Uint8Array
   */
  tweakedPublicKeyToBuffer() {
    const t = this.legacyPublicKey;
    if (!t)
      throw new Error("Legacy public key not set");
    return new Uint8Array(t);
  }
  toUncompressedHex() {
    if (this.ensureLegacyProcessed(), !__privateGet(this, _r15))
      throw new Error("Legacy public key not set");
    return "0x" + Yt4(__privateGet(this, _r15).uncompressed);
  }
  toUncompressedBuffer() {
    if (this.ensureLegacyProcessed(), !__privateGet(this, _r15))
      throw new Error("Legacy public key not set");
    return __privateGet(this, _r15).uncompressed;
  }
  toHybridPublicKeyHex() {
    if (this.ensureLegacyProcessed(), !__privateGet(this, _r15))
      throw new Error("Legacy public key not set");
    return "0x" + Yt4(__privateGet(this, _r15).hybrid);
  }
  toHybridPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), !__privateGet(this, _r15))
      throw new Error("Legacy public key not set");
    return __privateGet(this, _r15).hybrid;
  }
  originalPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), !__privateGet(this, _i15))
      throw new Error("Legacy public key not set");
    return new Uint8Array(__privateGet(this, _i15));
  }
  /**
   * Converts the address to a BigInt representation.
   *
   * This method uses an optimized DataView approach to read the 32-byte address
   * as four 64-bit big-endian unsigned integers, then combines them using bitwise
   * operations. This is approximately 10-20x faster than string-based conversion.
   *
   * @returns {bigint} The address as a 256-bit unsigned integer
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...');
   * const bigIntValue = address.toBigInt();
   * console.log(bigIntValue); // 123456789...n
   * ```
   */
  toBigInt() {
    if (__privateGet(this, _c12) !== void 0)
      return __privateGet(this, _c12);
    const t = new DataView(this.buffer, this.byteOffset, 32);
    return __privateSet(this, _c12, t.getBigUint64(0, false) << 192n | t.getBigUint64(8, false) << 128n | t.getBigUint64(16, false) << 64n | t.getBigUint64(24, false)), __privateGet(this, _c12);
  }
  /**
   * Converts the tweaked public key to a BigInt representation.
   *
   * This method uses an optimized DataView approach to read the 32-byte address
   * as four 64-bit big-endian unsigned integers, then combines them using bitwise
   * operations. This is approximately 10-20x faster than string-based conversion.
   *
   * @returns {bigint} The address as a 256-bit unsigned integer
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...', '0xtweaked...');
   * const bigIntValue = address.tweakedToBigInt();
   * console.log(bigIntValue); // 123456789...n
   * ```
   */
  tweakedToBigInt() {
    if (!this.legacyPublicKey)
      throw new Error("Legacy public key not set");
    if (__privateGet(this, _u12) !== void 0)
      return __privateGet(this, _u12);
    const t = new DataView(this.legacyPublicKey.buffer, this.byteOffset, 32);
    return __privateSet(this, _u12, t.getBigUint64(0, false) << 192n | t.getBigUint64(8, false) << 128n | t.getBigUint64(16, false) << 64n | t.getBigUint64(24, false)), __privateGet(this, _u12);
  }
  equals(t) {
    const e = this;
    if (t.length !== e.length)
      return false;
    for (let i = 0; i < e.length; i++)
      if (e[i] !== t[i])
        return false;
    return true;
  }
  /**
   * Check if the address is bigger than another address
   * @returns {boolean} If bigger
   */
  lessThan(t) {
    const e = this;
    for (let i = 0; i < D; i++) {
      const r = e[i], s = t[i];
      if (r < s)
        return true;
      if (r > s)
        return false;
    }
    return false;
  }
  /**
   * Check if the address is smaller than another address
   * @returns {boolean} If smaller
   */
  greaterThan(t) {
    const e = this;
    for (let i = 0; i < D; i++) {
      const r = e[i], s = t[i];
      if (r > s)
        return true;
      if (r < s)
        return false;
    }
    return false;
  }
  /**
   * Set the public key
   * @param {ArrayLike<number>} mldsaPublicKey ML-DSA public key
   * @returns {void}
   */
  set(t) {
    this.setMldsaKey(t);
  }
  /**
   * Check if the public key is valid
   * @param {Network} network The network
   * @returns {boolean} If the public key is valid
   */
  isValidLegacyPublicKey(t) {
    const e = this.legacyPublicKey;
    if (!e)
      throw new Error("Legacy key not set.");
    return Q2.isValidPublicKey(Yt4(e), t);
  }
  /**
   * Get the public key as address
   */
  p2pk() {
    return this.toHex();
  }
  /**
   * Get the address in p2wpkh format
   * @param {Network} network The network
   */
  p2wpkh(t) {
    return P2.getP2WPKHAddress(this.keyPair, t);
  }
  /**
   * Get the address in p2pkh format
   * @param {Network} network The network
   */
  p2pkh(t) {
    return P2.getLegacyAddress(this.keyPair, t);
  }
  /**
   * Get the address in p2sh-p2wpkh format
   * @param {Network} network The network
   */
  p2shp2wpkh(t) {
    return P2.getLegacySegwitAddress(this.keyPair, t);
  }
  /**
   * Convert the address to a string
   */
  toString() {
    return this.toHex();
  }
  /**
   * Convert the address to a JSON string
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * Get the address in p2tr format
   * @param {Network} network The network
   */
  p2tr(t) {
    if (__privateGet(this, _t23) && __privateGet(this, _n15) === t)
      return __privateGet(this, _t23);
    const e = this.legacyPublicKey;
    if (!e)
      throw new Error("Legacy public key not set");
    const i = P2.tweakedPubKeyBufferToAddress(e, t);
    if (i)
      return __privateSet(this, _n15, t), __privateSet(this, _t23, i), i;
    throw new Error("Legacy public key not set");
  }
  /**
   * Generate a P2WDA (Pay-to-Witness-Data-Authentication) address
   *
   * P2WDA addresses are a special type of P2WSH address that allows embedding
   * authenticated data directly in the witness field, achieving 75% cost reduction
   * through Bitcoin's witness discount.
   *
   * The witness script pattern is: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   * This allows up to 10 witness data fields (5 * 2 = 10), where each field
   * can hold up to 80 bytes of data due to relay rules.
   *
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The P2WDA address
   * @throws {Error} If the public key is not set or address generation fails
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x02...');
   * const p2wdaAddress = address.p2wda(networks.bitcoin);
   * console.log(p2wdaAddress); // bc1q...
   * ```
   */
  p2wda(t) {
    if (__privateGet(this, _d10) && __privateGet(this, _n15) === t)
      return __privateGet(this, _d10);
    if (this.ensureLegacyProcessed(), !__privateGet(this, _i15))
      throw new Error("Cannot create P2WDA address: public key not set");
    const e = new Uint8Array(__privateGet(this, _i15));
    if (e.length !== 33)
      throw new Error("P2WDA requires a compressed public key (33 bytes)");
    try {
      const i = Z2.generateP2WDAAddress(e, t);
      return __privateSet(this, _n15, t), __privateSet(this, _d10, i), {
        address: i.address,
        witnessScript: i.witnessScript
      };
    } catch (i) {
      throw new Error(`Failed to generate P2WDA address: ${i.message}`, {
        cause: i
      });
    }
  }
  /**
   * Generate a P2WSH address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The timelocked address and its witness script
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSV(t, e) {
    const i = Number(t);
    if (i < 1 || i > 65535)
      throw new Error("CSV block number must be between 1 and 65535");
    if (this.ensureLegacyProcessed(), !__privateGet(this, _i15))
      throw new Error("Cannot create CSV address: public key not set");
    const r = new Uint8Array(__privateGet(this, _i15));
    return z3.generateTimeLockAddress(r, e, i);
  }
  /**
   * Generate a P2TR address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The timelocked address and its witness script
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSVTweaked(t, e) {
    const i = Number(t);
    if (i < 1 || i > 65535)
      throw new Error("CSV block number must be between 1 and 65535");
    if (this.ensureLegacyProcessed(), !__privateGet(this, _i15))
      throw new Error("Cannot create CSV address: public key not set");
    return z3.generateTimeLockAddressP2TR(
      this.tweakedPublicKeyToBuffer(),
      e,
      i
    );
  }
  /**
   * Generate a P2MR address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created. Uses P2MR (BIP 360) instead of P2TR.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {string} The timelocked P2MR address
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSVP2MR(t, e) {
    const i = Number(t);
    if (i < 1 || i > 65535)
      throw new Error("CSV block number must be between 1 and 65535");
    if (this.ensureLegacyProcessed(), !__privateGet(this, _o15))
      throw new Error("Cannot create CSV P2MR address: public key not set");
    return z3.generateTimeLockAddressP2MR(
      this.tweakedPublicKeyToBuffer(),
      e,
      i
    );
  }
  /**
   * Returns the OPNet address encoded in bech32m format, derived from the SHA256 hash of the ML-DSA public key
   * (which is what the Address internally stores).
   *
   * This method generates a P2OP (Pay-to-OPNet) address using witness version 16, suitable for
   * quantum-resistant transactions on the OPNet protocol.
   *
   * @param network - The Bitcoin network to use (mainnet, testnet, regtest)
   * @returns The P2OP address in bech32m format
   */
  p2op(t) {
    if (__privateGet(this, _e22) && __privateGet(this, _n15) === t)
      return __privateGet(this, _e22);
    const e = P2.p2op(this, t);
    if (e)
      return __privateSet(this, _n15, t), __privateSet(this, _e22, e), e;
    throw new Error("ML-DSA public key not set");
  }
  toTweakedHybridPublicKeyHex() {
    if (this.ensureLegacyProcessed(), this.ensureTweakedUncompressed(), !__privateGet(this, _s15))
      throw new Error("Legacy public key not set");
    return "0x" + Yt4(__privateGet(this, _s15));
  }
  toTweakedHybridPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), this.ensureTweakedUncompressed(), !__privateGet(this, _s15))
      throw new Error("Legacy public key not set");
    return __privateGet(this, _s15);
  }
  /**
   * Lazily generates the tweaked uncompressed/hybrid key from the legacy public key.
   * Only called when toTweakedHybridPublicKey* methods are accessed.
   */
  ensureTweakedUncompressed() {
    if (__privateGet(this, _s15)) return;
    const t = __privateGet(this, _o15);
    if (t && t.length === D && !__privateGet(this, _i15))
      try {
        __privateSet(this, _s15, ae3.generateHybridKeyFromHash(t));
      } catch {
      }
  }
  /**
   * Sets the MLDSA key portion of the address.
   * @param {ArrayLike<number>} mldsaPublicKey - The MLDSA public key or its hash
   */
  setMldsaKey(t) {
    if (t.length === D) {
      const e = new Uint8Array(D);
      e.set(t), super.set(e);
    } else {
      if (!hr2.includes(t.length))
        throw new Error(
          `Invalid ML-DSA public key length: ${t.length}. Expected 1312 (ML-DSA-44/LEVEL2), 1952 (ML-DSA-65/LEVEL3), or 2592 (ML-DSA-87/LEVEL5) bytes.`
        );
      __privateSet(this, _a36, new Uint8Array(t.length)), __privateGet(this, _a36).set(t);
      const e = l0(new Uint8Array(t)), i = new Uint8Array(D);
      i.set(e), super.set(i);
    }
  }
  /**
   * Lazy processing of legacy key - defers expensive EC operations until actually needed.
   * Does the EXACT same logic as the original set() method did for legacy keys.
   */
  ensureLegacyProcessed() {
    if (__privateGet(this, _S7)) return;
    __privateSet(this, _S7, true);
    const t = __privateGet(this, _g10);
    t && (t.length === D ? __privateSet(this, _o15, t) : this.autoFormat(t));
  }
  /**
   * Processes a 33 or 65 byte public key, performing EC operations.
   * Sets #tweakedPublicKey to 32-byte tweaked x-only (same as original behavior).
   */
  autoFormat(t) {
    const e = t[0];
    e === 3 || e === 2 || (e === 4 || e === 6 || e === 7) && (t = _K.uncompressedToCompressed(t)), __privateSet(this, _i15, Uint8Array.from(t)), __privateSet(this, _h13, P2.fromPublicKey(__privateGet(this, _i15))), __privateSet(this, _r15, Dn2(__privateGet(this, _i15)));
    const i = $e4(
      P2.tweakPublicKey(__privateGet(this, _i15))
    );
    __privateSet(this, _s15, ae3.generateHybridKeyFromHash(i)), __privateSet(this, _o15, new Uint8Array(D)), __privateGet(this, _o15).set(i);
  }
};
_t23 = new WeakMap();
_e22 = new WeakMap();
_n15 = new WeakMap();
_i15 = new WeakMap();
_h13 = new WeakMap();
_r15 = new WeakMap();
_s15 = new WeakMap();
_d10 = new WeakMap();
_a36 = new WeakMap();
_c12 = new WeakMap();
_u12 = new WeakMap();
_l12 = new WeakMap();
_p11 = new WeakMap();
_f13 = new WeakMap();
_g10 = new WeakMap();
_S7 = new WeakMap();
_o15 = new WeakMap();
var K2 = _K;
var It5 = class _It {
  constructor(t) {
    __publicField(this, "_keys", []);
    __publicField(this, "_values", {});
    if (t instanceof _It)
      this.setAll(t);
    else if (t)
      for (const [e, i] of t)
        this.set(e, i);
  }
  get size() {
    return this._keys.length;
  }
  setAll(t) {
    this._keys = [...t._keys], this._values = { ...t._values };
  }
  addAll(t) {
    for (const [e, i] of t.entries())
      this.set(e, i);
  }
  *keys() {
    yield* this._keys;
  }
  *values() {
    for (const t of this._keys)
      yield this._values[t];
  }
  *entries() {
    for (const t of this._keys)
      yield [t, this._values[t]];
  }
  set(t, e) {
    return this.has(t) || this._keys.push(t), this._values[t] = e, this;
  }
  indexOf(t) {
    if (!this.has(t))
      return -1;
    for (let e = 0; e < this._keys.length; e++)
      if (this._keys[e] === t)
        return e;
    throw new Error("Key not found, this should not happen.");
  }
  get(t) {
    return this._values[t];
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this._values, t);
  }
  delete(t) {
    if (!this.has(t))
      return false;
    const e = this.indexOf(t);
    return this._keys.splice(e, 1), delete this._values[t], true;
  }
  clear() {
    this._keys = [], this._values = {};
  }
  [Symbol.dispose]() {
    this.clear();
  }
  forEach(t, e) {
    for (const i of this._keys)
      t.call(e, this._values[i], i, this);
  }
  *[Symbol.iterator]() {
    for (const t of this._keys)
      yield [t, this._values[t]];
  }
};
var Xe3 = class {
  constructor(t) {
    __publicField(this, "items");
    if (this.items = new It5(), t)
      for (const [e, i] of t)
        this.set(e, i);
  }
  get size() {
    return this.items.size;
  }
  set(t, e) {
    const i = t.toBigInt();
    return this.items.set(i, e), this;
  }
  get(t) {
    return this.items.get(t.toBigInt());
  }
  has(t) {
    return this.items.has(t.toBigInt());
  }
  delete(t) {
    const e = t.toBigInt();
    return this.items.delete(e);
  }
  clear() {
    this.items.clear();
  }
  [Symbol.dispose]() {
    this.clear();
  }
  indexOf(t) {
    return this.items.indexOf(t.toBigInt());
  }
  /**
   * WARNING, THIS RETURN NEW COPY OF THE KEYS
   */
  *entries() {
    for (const [t, e] of this.items.entries())
      yield [K2.fromBigInt(t), e];
  }
  *keys() {
    for (const t of this.items.keys())
      yield K2.fromBigInt(t);
  }
  *values() {
    for (const t of this.items.values())
      yield t;
  }
  forEach(t, e) {
    for (const [i, r] of this.items.entries()) {
      const s = K2.fromBigInt(i);
      t.call(e, r, s, this);
    }
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
};
var $e5 = class {
  constructor(t) {
    // Store tweaked bigint -> index mapping for fast lookup
    __publicField(this, "indexMap");
    // Store actual addresses and values
    __publicField(this, "_keys", []);
    __publicField(this, "_values", []);
    if (this.indexMap = new It5(), t)
      for (const [e, i] of t)
        this.set(e, i);
  }
  get size() {
    return this._keys.length;
  }
  set(t, e) {
    const i = t.tweakedToBigInt(), r = this.indexMap.get(i);
    if (r !== void 0)
      this._values[r] = e;
    else {
      const s = this._keys.length;
      this._keys.push(t), this._values.push(e), this.indexMap.set(i, s);
    }
    return this;
  }
  get(t) {
    const e = t.tweakedToBigInt(), i = this.indexMap.get(e);
    if (i !== void 0)
      return this._values[i];
  }
  has(t) {
    return this.indexMap.has(t.tweakedToBigInt());
  }
  delete(t) {
    const e = t.tweakedToBigInt(), i = this.indexMap.get(e);
    if (i === void 0)
      return false;
    this._keys.splice(i, 1), this._values.splice(i, 1), this.indexMap.clear();
    for (let r = 0; r < this._keys.length; r++)
      this.indexMap.set(this._keys[r].tweakedToBigInt(), r);
    return true;
  }
  clear() {
    this.indexMap.clear(), this._keys = [], this._values = [];
  }
  [Symbol.dispose]() {
    this.clear();
  }
  indexOf(t) {
    const e = this.indexMap.get(t.tweakedToBigInt());
    return e !== void 0 ? e : -1;
  }
  *entries() {
    for (let t = 0; t < this._keys.length; t++)
      yield [this._keys[t], this._values[t]];
  }
  *keys() {
    for (const t of this._keys)
      yield t;
  }
  *values() {
    for (const t of this._values)
      yield t;
  }
  forEach(t, e) {
    for (let i = 0; i < this._keys.length; i++)
      t.call(e, this._values[i], this._keys[i], this);
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
};
var Wt5 = class {
  static bufferToUint8Array(t) {
    const e = new Uint8Array(t.byteLength);
    return e.set(t), e;
  }
  static uint8ArrayToHex(t) {
    return Yt4(t);
  }
  static hexToUint8Array(t) {
    let e = t;
    return e.length >= 2 && e[0] === "0" && (e[1] === "x" || e[1] === "X") && (e = e.slice(2)), e.length % 2 !== 0 && (e = "0" + e), Mt3(e);
  }
  static pointerToUint8Array(t) {
    if (t < 0n)
      throw new RangeError("Pointer cannot be negative");
    const e = t.toString(16).padStart(64, "0");
    if (e.length > 64)
      throw new RangeError("Pointer exceeds 256-bit range");
    return Mt3(e);
  }
  static uint8ArrayToPointer(t) {
    return t.length === 0 ? 0n : BigInt("0x" + Yt4(t));
  }
  static valueToUint8Array(t, e = kt4) {
    if (t < 0n)
      throw new RangeError("Value cannot be negative");
    const i = t.toString(16).padStart(e * 2, "0");
    if (i.length > e * 2)
      throw new RangeError(`Value exceeds ${e}-byte range`);
    return Mt3(i);
  }
  static uint8ArrayToValue(t) {
    return t.length === 0 ? 0n : BigInt("0x" + Yt4(t));
  }
};
__publicField(Wt5, "EXPECTED_BUFFER_LENGTH", 32);
var te4 = class {
  constructor(t) {
    __publicField(this, "buffer");
    __publicField(this, "currentOffset", 0);
    this.buffer = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  get byteLength() {
    return this.buffer.byteLength;
  }
  // Helpers for comparisons; unchanged
  static stringCompare(t, e) {
    return t.localeCompare(e);
  }
  static bigintCompare(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  static numberCompare(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  setBuffer(t) {
    this.buffer = new DataView(t.buffer, t.byteOffset, t.byteLength), this.currentOffset = 0;
  }
  length() {
    return this.buffer.byteLength;
  }
  bytesLeft() {
    return this.buffer.byteLength - this.currentOffset;
  }
  // ------------------- Signed Integer Readers ------------------- //
  /**
   * Reads a single signed byte (i8).
   */
  readI8() {
    this.verifyEnd(this.currentOffset + xt5);
    const t = this.buffer.getInt8(this.currentOffset);
    return this.currentOffset += xt5, t;
  }
  /**
   * Reads a signed 16-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI16(t = true) {
    this.verifyEnd(this.currentOffset + Kt3);
    const e = this.buffer.getInt16(this.currentOffset, !t);
    return this.currentOffset += Kt3, e;
  }
  /**
   * Reads a signed 32-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI32(t = true) {
    this.verifyEnd(this.currentOffset + Rt4);
    const e = this.buffer.getInt32(this.currentOffset, !t);
    return this.currentOffset += Rt4, e;
  }
  /**
   * Reads a signed 64-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI64(t = true) {
    this.verifyEnd(this.currentOffset + Lt4);
    const e = this.buffer.getBigInt64(this.currentOffset, !t);
    return this.currentOffset += Lt4, e;
  }
  // ------------------- Unsigned Integer Readers ------------------- //
  /**
   * Reads a single unsigned byte (u8).
   */
  readU8() {
    this.verifyEnd(this.currentOffset + Xt5);
    const t = this.buffer.getUint8(this.currentOffset);
    return this.currentOffset += Xt5, t;
  }
  /**
   * Reads an unsigned 16-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU16(t = true) {
    this.verifyEnd(this.currentOffset + At4);
    const e = this.buffer.getUint16(this.currentOffset, !t);
    return this.currentOffset += At4, e;
  }
  /**
   * Reads an unsigned 32-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU32(t = true) {
    this.verifyEnd(this.currentOffset + bt4);
    const e = this.buffer.getUint32(this.currentOffset, !t);
    return this.currentOffset += bt4, e;
  }
  /**
   * Reads an unsigned 64-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU64(t = true) {
    this.verifyEnd(this.currentOffset + qt5);
    const e = this.buffer.getBigUint64(this.currentOffset, !t);
    return this.currentOffset += qt5, e;
  }
  /**
   * Reads a 128-bit unsigned integer. By default, read big-endian.
   * @param be - Endianness; true => big-endian (default).
   */
  readU128(t = true) {
    const e = this.readBytes(Ut5);
    let i = e;
    return t || (i = this.reverseBytes(e)), BigInt("0x" + this.toHexString(i));
  }
  /**
   * Reads a 256-bit unsigned integer. Same approach as readU128.
   * @param be - Endianness; true => big-endian (default).
   */
  readU256(t = true) {
    const e = this.readBytes(kt4);
    let i = e;
    return t || (i = this.reverseBytes(e)), BigInt("0x" + this.toHexString(i));
  }
  /**
   * Reads a 128-bit signed integer. Interpret the sign bit if big-endian.
   * @param be - Endianness; true => big-endian (default).
   */
  readI128(t = true) {
    const e = this.readBytes(Bt5);
    let i = e;
    t || (i = this.reverseBytes(e));
    let r = BigInt("0x" + this.toHexString(i));
    if (i[0] & 128) {
      const o = BigInt(1) << BigInt(128);
      r = r - o;
    }
    return r;
  }
  /**
   * Read a boolean (u8 != 0).
   */
  readBoolean() {
    return this.readU8() !== 0;
  }
  /**
   * Reads 32 bits
   */
  readSelector() {
    return this.readU32(true);
  }
  /**
   * Reads a raw sequence of bytes (length must be known).
   * If zeroStop = true, stops if we encounter 0x00 early.
   */
  readBytes(t, e = false) {
    this.verifyEnd(this.currentOffset + t);
    let i = new Uint8Array(t);
    for (let r = 0; r < t; r++) {
      const s = this.buffer.getUint8(this.currentOffset++);
      if (e && s === 0) {
        i = new Uint8Array(i.subarray(0, r));
        break;
      }
      i[r] = s;
    }
    return i;
  }
  /**
   * Reads a string of the given length in raw bytes. By default, do NOT zero-stop
   * (matching how we wrote the raw bytes).
   */
  readString(t) {
    const e = new TextDecoder(), i = this.readBytes(t, false);
    return e.decode(i);
  }
  /**
   * Reads a string that was written as [u16 length][raw bytes].
   */
  readStringWithLength(t = true) {
    const e = this.readU32(t);
    return this.readString(e);
  }
  /**
   * Reads an address (32 bytes MLDSA key hash only).
   */
  readAddress() {
    const t = Array.from(this.readBytes(D));
    return new K2(t);
  }
  /**
   * Reads the tweaked public key portion (32 bytes) and returns it as a raw Uint8Array.
   * Use this when you only need the tweaked key without the full Address object.
   */
  readTweakedPublicKey() {
    return this.verifyEnd(this.currentOffset + D), this.readBytes(D);
  }
  /**
   * Reads a full address with both MLDSA key hash and tweaked public key (64 bytes total).
   * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
   *
   * This is the equivalent of btc-runtime's readExtendedAddress().
   *
   * @returns An Address instance with both keys set
   */
  readExtendedAddress() {
    this.verifyEnd(this.currentOffset + mt5);
    const t = Array.from(this.readBytes(D)), e = Array.from(this.readBytes(D));
    return new K2(e, t);
  }
  /**
   * Reads a Schnorr signature with its associated full Address.
   * Format: [64 bytes full Address][64 bytes signature]
   *
   * Used for deserializing signed data where both the signer's address
   * and their Schnorr signature are stored together.
   *
   * @returns A SchnorrSignature containing the address and signature
   */
  readSchnorrSignature() {
    this.verifyEnd(
      this.currentOffset + mt5 + Tt5
    );
    const t = this.readExtendedAddress(), e = this.readBytes(Tt5);
    return { address: t, signature: e };
  }
  /**
   * Reads bytes written as [u32 length][bytes].
   * @param maxLength if > 0, enforces an upper bound
   * @param be
   */
  readBytesWithLength(t = 0, e = true) {
    const i = this.readU32(e);
    if (t > 0 && i > t)
      throw new Error("Data length exceeds maximum length.");
    return this.readBytes(i);
  }
  // ------------------ Array readers ------------------ //
  readArrayOfBuffer(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readBytesWithLength();
    return i;
  }
  readAddressArray(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readAddress();
    return i;
  }
  readU256Array(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU256(t);
    return i;
  }
  readU128Array(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU128(t);
    return i;
  }
  readU64Array(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU64(t);
    return i;
  }
  readU32Array(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU32(t);
    return i;
  }
  readU16Array(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU16(t);
    return i;
  }
  readU8Array() {
    const t = this.readU16(true), e = new Array(t);
    for (let i = 0; i < t; i++)
      e[i] = this.readU8();
    return e;
  }
  readStringArray(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readStringWithLength(t);
    return i;
  }
  readBytesArray(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readBytesWithLength(0, t);
    return i;
  }
  /**
   * Reads [u16 length][ (address, u256) pairs ].
   */
  readAddressValueTuple(t = true) {
    const e = this.readU16(t), i = new Xe3();
    for (let r = 0; r < e; r++) {
      const s = this.readAddress(), o = this.readU256(t);
      if (i.has(s))
        throw new Error("Duplicate address found in map");
      i.set(s, o);
    }
    return i;
  }
  /**
   * Reads an array of full addresses (64 bytes each).
   * Format: [u16 length][FullAddress 0][FullAddress 1]...
   */
  readExtendedAddressArray(t = true) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readExtendedAddress();
    return i;
  }
  /**
   * Reads a map of full Address -> u256 using the tweaked key for map lookup.
   * Format: [u16 length][FullAddress key][u256 value]...
   *
   * This is the equivalent of btc-runtime's readExtendedAddressMapU256().
   */
  readExtendedAddressMapU256(t = true) {
    const e = this.readU16(t), i = new $e5();
    for (let r = 0; r < e; r++) {
      const s = this.readExtendedAddress(), o = this.readU256(t);
      if (i.has(s))
        throw new Error("Duplicate tweaked address found in map");
      i.set(s, o);
    }
    return i;
  }
  // --------------------------------------------------- //
  getOffset() {
    return this.currentOffset;
  }
  setOffset(t) {
    this.currentOffset = t;
  }
  /**
   * Verifies we have enough bytes in the buffer to read up to `size`.
   */
  verifyEnd(t) {
    if (t > this.buffer.byteLength)
      throw new Error(
        `Attempt to read beyond buffer length: requested up to byte offset ${t}, but buffer is only ${this.buffer.byteLength} bytes.`
      );
  }
  /**
   * Utility: reverses a byte array in-place or returns a reversed copy.
   */
  reverseBytes(t) {
    const e = new Uint8Array(t.length);
    for (let i = 0; i < t.length; i++)
      e[i] = t[t.length - 1 - i];
    return e;
  }
  /**
   * Utility: turn bytes into a hex string without `0x` prefix.
   */
  toHexString(t) {
    return Array.from(t, (e) => e.toString(16).padStart(2, "0")).join("");
  }
};
var V = class _V {
  constructor(t = 0) {
    __publicField(this, "currentOffset", 0);
    __publicField(this, "buffer");
    this.buffer = this.getDefaultBuffer(t);
  }
  static estimateArrayOfBufferLength(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    let e = At4;
    for (let i = 0; i < t.length; i++)
      e += bt4 + t[i].length;
    return e;
  }
  writeU8(t) {
    if (t > 255) throw new Error("u8 value is too large.");
    this.allocSafe(Xt5), this.buffer.setUint8(this.currentOffset++, t);
  }
  writeU16(t, e = true) {
    if (t > 65535) throw new Error("u16 value is too large.");
    this.allocSafe(At4), this.buffer.setUint16(this.currentOffset, t, !e), this.currentOffset += 2;
  }
  writeU32(t, e = true) {
    if (t > 4294967295) throw new Error("u32 value is too large.");
    this.allocSafe(bt4), this.buffer.setUint32(this.currentOffset, t, !e), this.currentOffset += 4;
  }
  writeU64(t, e = true) {
    if (t > 18446744073709551615n) throw new Error("u64 value is too large.");
    this.allocSafe(qt5), this.buffer.setBigUint64(this.currentOffset, t, !e), this.currentOffset += 8;
  }
  // ------------------- Signed Integer Writers ------------------- //
  /**
   * Writes a signed 8-bit integer.
   */
  writeI8(t) {
    if (t < -128 || t > 127) throw new Error("i8 value is out of range.");
    this.allocSafe(xt5), this.buffer.setInt8(this.currentOffset, t), this.currentOffset += xt5;
  }
  /**
   * Writes a signed 16-bit integer. By default big-endian (be = true).
   */
  writeI16(t, e = true) {
    if (t < -32768 || t > 32767) throw new Error("i16 value is out of range.");
    this.allocSafe(Kt3), this.buffer.setInt16(this.currentOffset, t, !e), this.currentOffset += Kt3;
  }
  /**
   * Writes a signed 32-bit integer. By default big-endian (be = true).
   */
  writeI32(t, e = true) {
    if (t < -2147483648 || t > 2147483647)
      throw new Error("i32 value is out of range.");
    this.allocSafe(Rt4), this.buffer.setInt32(this.currentOffset, t, !e), this.currentOffset += Rt4;
  }
  /**
   * Writes a signed 64-bit integer. By default big-endian (be = true).
   */
  writeI64(t, e = true) {
    if (t < -9223372036854775808n || t > 9223372036854775807n)
      throw new Error("i64 value is out of range.");
    this.allocSafe(Lt4), this.buffer.setBigInt64(this.currentOffset, t, !e), this.currentOffset += Lt4;
  }
  // ---------------------------------------------------------------- //
  writeSelector(t) {
    this.writeU32(t, true);
  }
  writeBoolean(t) {
    this.writeU8(t ? 1 : 0);
  }
  writeI128(t, e = true) {
    if (t > 170141183460469231731687303715884105727n || t < -170141183460469231731687303715884105728n)
      throw new Error("i128 value is too large.");
    this.allocSafe(Bt5);
    const i = Wt5.valueToUint8Array(t, Bt5);
    if (i.byteLength !== Bt5)
      throw new Error(`Invalid i128 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeU256(t, e = true) {
    if (t > 115792089237316195423570985008687907853269984665640564039457584007913129639935n && t < 0n)
      throw new Error("u256 value is too large or negative.");
    this.allocSafe(kt4);
    const i = Wt5.valueToUint8Array(t);
    if (i.byteLength !== kt4)
      throw new Error(`Invalid u256 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeU128(t, e = true) {
    if (t > 340282366920938463463374607431768211455n && t < 0n)
      throw new Error("u128 value is too large or negative.");
    this.allocSafe(Ut5);
    const i = Wt5.valueToUint8Array(t, Ut5);
    if (i.byteLength !== Ut5)
      throw new Error(`Invalid u128 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeBytes(t) {
    this.allocSafe(t.byteLength);
    for (let e = 0; e < t.byteLength; e++)
      this.writeU8(t[e]);
  }
  writeString(t) {
    const i = new TextEncoder().encode(t);
    this.allocSafe(i.length), this.writeBytes(i);
  }
  writeStringWithLength(t) {
    const i = new TextEncoder().encode(t);
    this.allocSafe(bt4 + i.length), this.writeU32(i.length), this.writeBytes(i);
  }
  /**
   * Writes an address (32 bytes MLDSA key hash only).
   */
  writeAddress(t) {
    this.verifyAddress(t), this.writeBytes(t);
  }
  /**
   * Writes the tweaked public key from an Address (32 bytes).
   * @param value - The Address containing the tweaked public key
   */
  writeTweakedPublicKey(t) {
    const e = t.tweakedPublicKeyToBuffer();
    this.allocSafe(D), this.writeBytes(e);
  }
  /**
   * Writes a full address with both tweaked public key and MLDSA key hash (64 bytes total).
   * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
   *
   * This is the equivalent of btc-runtime's writeExtendedAddress().
   *
   * @param value - The Address containing both keys
   */
  writeExtendedAddress(t) {
    this.allocSafe(mt5), this.writeTweakedPublicKey(t), this.writeBytes(t);
  }
  /**
   * Writes a Schnorr signature with its associated full Address.
   * Format: [64 bytes full Address][64 bytes signature]
   *
   * Used for serializing signed data where both the signer's address
   * and their Schnorr signature need to be stored together.
   *
   * @param address - The signer's Address (with both MLDSA and tweaked keys)
   * @param signature - The 64-byte Schnorr signature
   * @throws {Error} If signature is not exactly 64 bytes
   */
  writeSchnorrSignature(t, e) {
    if (e.length !== Tt5)
      throw new Error(
        `Invalid Schnorr signature length: expected ${Tt5}, got ${e.length}`
      );
    this.allocSafe(mt5 + Tt5), this.writeExtendedAddress(t), this.writeBytes(e);
  }
  getBuffer(t = true) {
    const e = new Uint8Array(this.buffer.byteLength);
    for (let i = 0; i < this.buffer.byteLength; i++)
      e[i] = this.buffer.getUint8(i);
    return t && this.clear(), e;
  }
  reset() {
    this.currentOffset = 0, this.buffer = this.getDefaultBuffer(4);
  }
  toBytesReader() {
    return new te4(this.getBuffer());
  }
  getOffset() {
    return this.currentOffset;
  }
  setOffset(t) {
    this.currentOffset = t;
  }
  clear() {
    this.currentOffset = 0, this.buffer = this.getDefaultBuffer();
  }
  [Symbol.dispose]() {
    this.clear();
  }
  allocSafe(t) {
    this.currentOffset + t > this.buffer.byteLength && this.resize(t);
  }
  writeAddressValueTuple(t, e = true) {
    if (t.size > 65535) throw new Error("Map size is too large");
    this.writeU16(t.size, e);
    const i = Array.from(t.keys());
    for (let r = 0; r < i.length; r++) {
      const s = i[r], o = t.get(s);
      if (o == null) throw new Error("Value not found");
      this.writeAddress(s), this.writeU256(o, e);
    }
  }
  /**
   * Writes a map of full Address -> u256 using the tweaked key for map lookup.
   * Format: [u16 length][FullAddress key][u256 value]...
   *
   * This is the equivalent of btc-runtime's writeExtendedAddressMapU256().
   */
  writeExtendedAddressMapU256(t, e = true) {
    if (t.size > 65535) throw new Error("Map size is too large");
    this.writeU16(t.size, e);
    for (const [i, r] of t.entries())
      this.writeExtendedAddress(i), this.writeU256(r, e);
  }
  writeBytesWithLength(t) {
    this.writeU32(t.length), this.writeBytes(t);
  }
  writeArrayOfBuffer(t, e = true) {
    const i = _V.estimateArrayOfBufferLength(t);
    this.allocSafe(i), this.writeU16(t.length, e);
    for (let r = 0; r < t.length; r++)
      this.writeU32(t[r].length, e), this.writeBytes(t[r]);
  }
  writeAddressArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeAddress(t[e]);
  }
  /**
   * Writes an array of full addresses (64 bytes each).
   * Format: [u16 length][FullAddress 0][FullAddress 1]...
   */
  writeExtendedAddressArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.allocSafe(At4 + t.length * mt5), this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeExtendedAddress(t[e]);
  }
  writeU32Array(t, e = true) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU32(t[i], e);
  }
  writeU256Array(t, e = true) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU256(t[i], e);
  }
  writeU128Array(t, e = true) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU128(t[i], e);
  }
  writeStringArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeStringWithLength(t[e]);
  }
  writeU16Array(t, e = true) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU16(t[i], e);
  }
  writeU8Array(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeU8(t[e]);
  }
  writeU64Array(t, e = true) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU64(t[i], e);
  }
  writeBytesArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeBytesWithLength(t[e]);
  }
  verifyAddress(t) {
    if (t.byteLength > D)
      throw new Error(
        `Address is too long ${t.byteLength} > ${D} bytes`
      );
  }
  resize(t) {
    const e = new Uint8Array(this.buffer.byteLength + t);
    for (let i = 0; i < this.buffer.byteLength; i++)
      e[i] = this.buffer.getUint8(i);
    this.buffer = new DataView(e.buffer, e.byteOffset, e.byteLength);
  }
  getDefaultBuffer(t = 0) {
    return new DataView(new ArrayBuffer(t));
  }
};
var _J = class _J {
  constructor(t, e, i = ap2.bitcoin) {
    /**
     * The public key of the sender
     * @protected
     */
    __publicField(this, "senderPubKey");
    /**
     * The public key of the sender
     * @protected
     */
    __publicField(this, "xSenderPubKey");
    /**
     * The public key of the contract salt
     * @protected
     */
    __publicField(this, "contractSaltPubKey");
    /**
     * The network to use
     * @protected
     */
    __publicField(this, "network", ap2.bitcoin);
    this.senderPubKey = t, this.contractSaltPubKey = e, this.network = i, this.xSenderPubKey = $e4(t);
  }
  buildHeader(t) {
    let e = 0;
    for (const r of t)
      e |= r;
    const i = Et4(3);
    return i[0] = e >> 16 & 255, i[1] = e >> 8 & 255, i[2] = e & 255, Uint8Array.from([this.senderPubKey[0], ...i]);
  }
  getHeader(t, e = []) {
    const i = new V(12);
    return i.writeBytes(this.buildHeader(e)), i.writeU64(t), new Uint8Array(i.getBuffer());
  }
  /**
   * Split a buffer into chunks
   * @param {Uint8Array} buffer - The buffer to split
   * @param {number} chunkSize - The size of each chunk
   * @protected
   * @returns {Array<Uint8Array[]>} - The chunks
   */
  splitBufferIntoChunks(t, e = _J.DATA_CHUNK_SIZE) {
    const i = [];
    for (let r = 0; r < t.length; r += e) {
      const s = Math.min(e, t.length - r), o = Et4(s);
      for (let a = 0; a < s; a++)
        o[a] = t[r + a];
      i.push([o]);
    }
    return i;
  }
  encodeFeature(t, e) {
    switch (t.opcode) {
      case $3.ACCESS_LIST:
        return this.encodeAccessListFeature(t, e);
      case $3.EPOCH_SUBMISSION:
        return this.encodeChallengeSubmission(
          t,
          e
        );
      case $3.MLDSA_LINK_PUBKEY:
        return this.encodeLinkRequest(t, e);
      default:
        throw new Error(`Unknown feature type: ${t.opcode}`);
    }
  }
  encodeAccessListFeature(t, e) {
    const i = new V();
    i.writeU16(Object.keys(t.data).length);
    for (const r in t.data) {
      const s = K2.fromString(r), o = t.data[r];
      i.writeAddress(s), i.writeU32(o.length);
      for (const a of o) {
        const c = Uint8Array.from(atob(a), (u) => u.charCodeAt(0));
        if (c.length !== 32)
          throw new Error(`Invalid pointer length: ${c.length}`);
        i.writeBytes(c);
      }
    }
    e.writeBytesWithLength(Y.compress(new Uint8Array(i.getBuffer())));
  }
  encodeChallengeSubmission(t, e) {
    if ("verifySignature" in t.data && !t.data.verifySignature())
      throw new Error("Invalid signature in challenge submission feature");
    const i = new V();
    i.writeBytes(t.data.publicKey.toBuffer()), i.writeBytes(t.data.solution), t.data.graffiti && i.writeBytesWithLength(t.data.graffiti), e.writeBytesWithLength(i.getBuffer());
  }
  encodeLinkRequest(t, e) {
    const i = t.data, r = new V();
    if (r.writeU8(i.level), r.writeBytes(i.hashedPublicKey), r.writeBoolean(i.verifyRequest), i.verifyRequest) {
      if (!i.publicKey || !i.mldsaSignature)
        throw new Error(
          "MLDSA public key and signature required when verifyRequest is true"
        );
      r.writeBytes(i.publicKey), r.writeBytes(i.mldsaSignature);
    }
    if (!i.legacySignature || i.legacySignature.length !== 64)
      throw new Error("Legacy signature must be exactly 64 bytes");
    r.writeBytes(i.legacySignature), e.writeBytesWithLength(r.getBuffer());
  }
};
/**
 * The maximum size of a data chunk
 */
__publicField(_J, "DATA_CHUNK_SIZE", 512);
/**
 * The magic number of OPNet
 */
__publicField(_J, "MAGIC", pp2("op"));
var J3 = _J;
var pe4 = class extends J3 {
  constructor(t, e, i = ap2.bitcoin) {
    super(t, e, i);
  }
  /**
   * Get the public key as a buffer
   * @param {Uint8Array[]} witnessKeys - The public keys
   * @param {Network} network - The network to use
   * @private
   * @returns {Uint8Array} - The public key as a buffer
   */
  static getPubKeyAsBuffer(t, e) {
    let i = new Uint8Array(0);
    for (const s of t) {
      if (!P2.fromPublicKey(s, e).compressed)
        throw new Error("Public key must be compressed");
      if (s.byteLength !== 33)
        throw new Error(`Public key must be 33 bytes, got ${s.byteLength} bytes.`);
      i = _t7([i, s]);
    }
    const r = Y.compress(i);
    return r.byteLength >= i.byteLength ? i : r;
  }
  /**
   * Compile an interaction bitcoin script
   * @param {Uint8Array} calldata - The calldata to use
   * @param {Uint8Array} contractSecret - The contract secret
   * @param {IChallengeSolution} challenge
   * @param maxPriority - Amount of satoshis to spend max on priority fee
   * @param {Feature<Features>[]} featuresRaw - The features to use
   * @returns {Uint8Array} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t, e, i, r, s = []) {
    if (!this.contractSaltPubKey) throw new Error("Contract salt public key not set");
    const o = this.splitBufferIntoChunks(t);
    if (!o.length) throw new Error("No data chunks found");
    const a = [], c = [];
    if (s && s.length) {
      const p = s.sort(
        (m, A) => m.priority - A.priority
      ), y = new V();
      for (let m = 0; m < p.length; m++) {
        const A = p[m];
        a.push(A.opcode), this.encodeFeature(A, y);
      }
      c.push(
        ...this.splitBufferIntoChunks(new Uint8Array(y.getBuffer()))
      );
    }
    let u = [
      this.getHeader(r, a),
      q2.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i.publicKey.toBuffer(),
      q2.OP_TOALTSTACK,
      i.solution,
      q2.OP_TOALTSTACK,
      this.xSenderPubKey,
      q2.OP_DUP,
      q2.OP_HASH256,
      Zh2.hash256(this.xSenderPubKey),
      q2.OP_EQUALVERIFY,
      q2.OP_CHECKSIGVERIFY,
      this.contractSaltPubKey,
      q2.OP_CHECKSIGVERIFY,
      q2.OP_HASH160,
      Zh2.hash160(e),
      q2.OP_EQUALVERIFY,
      q2.OP_DEPTH,
      q2.OP_1,
      q2.OP_NUMEQUAL,
      q2.OP_IF,
      J3.MAGIC
    ];
    u = u.concat(
      ...c,
      q2.OP_1NEGATE,
      ...o,
      q2.OP_ELSE,
      q2.OP_1,
      q2.OP_ENDIF
    );
    const l = u.flat(), h = Vh2.compile(l);
    if (!Vh2.decompile(h))
      throw new Error("Failed to decompile script??");
    return h;
  }
};
var Ye4 = class extends J3 {
  constructor(t, e = ap2.bitcoin) {
    super(t, void 0, e);
  }
  /**
   * Compile an interaction bitcoin script
   * @param compiledData - The compiled data
   * @returns {Uint8Array} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t) {
    const e = t.flat(), i = Vh2.compile(e);
    if (!Vh2.decompile(i))
      throw new Error("Failed to decompile script??");
    return i;
  }
};
var Ge4 = 0;
var Qe4 = Uint8Array.from([Ge4]);
var fe5 = class extends J3 {
  constructor(t, e, i = ap2.bitcoin) {
    super(t, e, i);
  }
  /**
   * Compile a bitcoin script representing a contract deployment
   * @param {Uint8Array} contractBytecode - The contract bytecode
   * @param {Uint8Array} contractSalt - The contract salt
   * @param {ChallengeSolution} challenge - The challenge for reward
   * @param {bigint} maxPriority - The maximum priority for the contract
   * @param {Uint8Array} [calldata] - The calldata to be passed to the contract
   * @param {Feature<Features>[]} [features] - Optional features to include in the script
   * @returns {Uint8Array} - The compiled script
   */
  compile(t, e, i, r, s, o) {
    const a = this.getAsm(
      t,
      e,
      i,
      r,
      s,
      o
    ), c = Vh2.compile(a);
    if (!Vh2.decompile(c))
      throw new Error("Failed to decompile script??");
    return c;
  }
  getAsm(t, e, i, r, s, o) {
    if (!this.contractSaltPubKey) throw new Error("Contract salt public key not set");
    const a = this.splitBufferIntoChunks(t), c = s ? this.splitBufferIntoChunks(s) : [], u = [], l = [];
    if (o && o.length) {
      const d = o.sort(
        (y, m) => y.priority - m.priority
      ), p = new V();
      for (let y = 0; y < d.length; y++) {
        const m = d[y];
        u.push(m.opcode), this.encodeFeature(m, p);
      }
      l.push(
        ...this.splitBufferIntoChunks(new Uint8Array(p.getBuffer()))
      );
    }
    return [
      this.getHeader(r, u),
      q2.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i.publicKey.toBuffer(),
      q2.OP_TOALTSTACK,
      i.solution,
      q2.OP_TOALTSTACK,
      this.xSenderPubKey,
      q2.OP_DUP,
      q2.OP_HASH256,
      Zh2.hash256(this.xSenderPubKey),
      q2.OP_EQUALVERIFY,
      q2.OP_CHECKSIGVERIFY,
      this.contractSaltPubKey,
      q2.OP_CHECKSIGVERIFY,
      q2.OP_HASH256,
      Zh2.hash256(e),
      q2.OP_EQUALVERIFY,
      q2.OP_DEPTH,
      q2.OP_1,
      q2.OP_NUMEQUAL,
      q2.OP_IF,
      J3.MAGIC,
      ...l,
      q2.OP_0,
      ...c,
      q2.OP_1NEGATE,
      ...a,
      q2.OP_ELSE,
      q2.OP_1,
      q2.OP_ENDIF
    ].flat();
  }
};
var _I8 = class _I8 extends ky {
  constructor(t, e = ap2.bitcoin) {
    super();
    __publicField(this, "logColor", "#4a90d9");
    __publicField(this, "publicKey");
    __publicField(this, "network");
    if (t.length !== 33)
      throw new Error("Public key must be 33 bytes (compressed)");
    this.publicKey = t, this.network = e;
  }
  /**
   * Calculate the maximum number of inputs per standard reveal transaction.
   *
   * Standard tx weight limit: 400,000
   * With max chunks per input (~10,385 weight), only ~38 inputs fit
   *
   * @returns Maximum inputs per reveal tx (~38 with max chunks)
   */
  static calculateMaxInputsPerTx() {
    const i = _I8.MAX_STANDARD_WEIGHT - 40 - 200;
    return Math.floor(i / _I8.WEIGHT_PER_INPUT);
  }
  /**
   * Calculate maximum data per standard reveal transaction.
   *
   * @returns Maximum data in bytes (~300KB with batched chunks at 70 chunks/output)
   */
  static calculateMaxDataPerTx() {
    return _I8.calculateMaxInputsPerTx() * _I8.MAX_CHUNKS_PER_OUTPUT * _I8.MAX_CHUNK_SIZE;
  }
  /**
   * Estimate the number of P2WSH outputs needed for a given data size.
   *
   * @param dataSize Data size in bytes
   * @returns Number of P2WSH outputs needed
   */
  static estimateOutputCount(t) {
    return Math.ceil(
      t / (_I8.MAX_CHUNKS_PER_OUTPUT * _I8.MAX_CHUNK_SIZE)
    );
  }
  /**
   * Estimate the number of 80-byte chunks for a given data size.
   *
   * @param dataSize Data size in bytes
   * @returns Number of 80-byte chunks needed
   */
  static estimateChunkCount(t) {
    return Math.ceil(t / _I8.MAX_CHUNK_SIZE);
  }
  /**
   * Validate that a witness script is a valid multi-hash committed script.
   *
   * Script structure: (OP_HASH160 <hash> OP_EQUALVERIFY)+ <pubkey> OP_CHECKSIG
   *
   * @param witnessScript The witness script to validate
   * @returns true if valid hash-committed script
   */
  static validateHashCommittedScript(t) {
    try {
      const e = Vh2.decompile(t);
      if (!e || e.length < 5)
        return false;
      const i = e.length - 1;
      if (e[i] !== q2.OP_CHECKSIG)
        return false;
      const r = e[i - 1];
      if (!(r instanceof Uint8Array) || r.length !== 33)
        return false;
      const s = e.slice(0, -2);
      if (s.length % 3 !== 0 || s.length === 0)
        return false;
      for (let o = 0; o < s.length; o += 3) {
        const a = s[o + 1];
        if (s[o] !== q2.OP_HASH160 || !(a instanceof Uint8Array) || a.length !== 20 || s[o + 2] !== q2.OP_EQUALVERIFY)
          return false;
      }
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Extract all data hashes from a hash-committed witness script.
   *
   * @param witnessScript The witness script
   * @returns Array of 20-byte data hashes (in data order), or null if invalid
   */
  static extractDataHashes(t) {
    try {
      const e = Vh2.decompile(t);
      if (!e || !_I8.validateHashCommittedScript(t))
        return null;
      const i = e.slice(0, -2), r = [];
      for (let s = 0; s < i.length; s += 3)
        r.push(i[s + 1]);
      return r.reverse();
    } catch {
      return null;
    }
  }
  /**
   * Extract the public key from a hash-committed witness script.
   *
   * @param witnessScript The witness script
   * @returns The 33-byte public key, or null if invalid script
   */
  static extractPublicKey(t) {
    try {
      const e = Vh2.decompile(t);
      return !e || !_I8.validateHashCommittedScript(t) ? null : e[e.length - 2];
    } catch {
      return null;
    }
  }
  /**
   * Verify that data chunks match their committed hashes.
   *
   * @param dataChunks Array of data chunks (in order)
   * @param witnessScript The witness script containing the hash commitments
   * @returns true if all chunks match their commitments
   */
  static verifyChunkCommitments(t, e) {
    const i = _I8.extractDataHashes(e);
    if (!i || i.length !== t.length)
      return false;
    for (let r = 0; r < t.length; r++) {
      const s = Zh2.hash160(t[r]);
      if (!P(i[r], s))
        return false;
    }
    return true;
  }
  /**
   * Estimate fees for a complete CHCT flow (setup + reveal).
   *
   * @param dataSize Data size in bytes (before compression)
   * @param feeRate Fee rate in sat/vB
   * @param compressionRatio Expected compression ratio (default: 0.7)
   * @returns Fee estimates
   */
  static estimateFees(t, e, i = 0.7) {
    const r = Math.ceil(t * i), s = _I8.estimateOutputCount(r), o = _I8.estimateChunkCount(r), a = 116, c = s * 43 + 43, l = 11 + a + c, h = 40 + s * _I8.WEIGHT_PER_INPUT + 200, d = Math.ceil(h / 4), p = BigInt(Math.ceil(l * e)), y = BigInt(Math.ceil(d * e)), m = p + y, A = BigInt(s) * _I8.MIN_OUTPUT_VALUE, x = m + A;
    return {
      compressedSize: r,
      outputCount: s,
      chunkCount: o,
      setupVBytes: l,
      revealVBytes: d,
      setupFee: p,
      revealFee: y,
      totalFee: m,
      outputsValue: A,
      totalCost: x
    };
  }
  /**
   * Calculate the HASH160 of a data chunk.
   * HASH160 = RIPEMD160(SHA256(data))
   */
  hashChunk(t) {
    return Zh2.hash160(t);
  }
  /**
   * Generate a hash-committed witness script for multiple data chunks.
   *
   * Script structure (for N chunks):
   * OP_HASH160 <hash_N> OP_EQUALVERIFY
   * OP_HASH160 <hash_N-1> OP_EQUALVERIFY
   * ...
   * OP_HASH160 <hash_1> OP_EQUALVERIFY
   * <pubkey> OP_CHECKSIG
   *
   * Hashes are in reverse order because witness stack is LIFO.
   * Witness stack: [sig, data_1, data_2, ..., data_N, witnessScript]
   * Stack before execution: [sig, data_1, data_2, ..., data_N] (data_N on top)
   *
   * @param dataHashes Array of HASH160 values (in data order, will be reversed in script)
   * @returns The compiled witness script
   */
  generateWitnessScript(t) {
    if (t.length === 0)
      throw new Error("At least one data hash is required");
    if (t.length > _I8.MAX_CHUNKS_PER_OUTPUT)
      throw new Error(
        `Too many chunks: ${t.length} exceeds limit of ${_I8.MAX_CHUNKS_PER_OUTPUT}`
      );
    for (const i of t)
      if (i.length !== 20)
        throw new Error(`HASH160 requires 20-byte hash, got ${i.length}`);
    const e = [];
    for (let i = t.length - 1; i >= 0; i--)
      e.push(q2.OP_HASH160), e.push(t[i]), e.push(q2.OP_EQUALVERIFY);
    return e.push(this.publicKey), e.push(q2.OP_CHECKSIG), Vh2.compile(e);
  }
  /**
   * Generate a P2WSH address from a witness script.
   *
   * @param witnessScript The witness script
   * @returns P2WSH address info
   */
  generateP2WSHAddress(t) {
    const e = Xf2.p2wsh({
      redeem: { output: t },
      network: this.network
    });
    if (!e.address || !e.output)
      throw new Error("Failed to generate P2WSH address");
    return {
      address: e.address,
      witnessScript: t,
      scriptPubKey: e.output
    };
  }
  /**
   * Split data into chunks and generate hash-committed P2WSH outputs.
   *
   * Each output commits to up to 98 data chunks (80 bytes each = 7,840 bytes).
   * This is MUCH more efficient than one output per chunk.
   *
   * @param data The data to chunk and commit
   * @param maxChunkSize Maximum bytes per stack item (default: 80, P2WSH stack item limit)
   * @returns Array of hash-committed P2WSH outputs
   */
  prepareChunks(t, e = _I8.MAX_CHUNK_SIZE) {
    if (e > _I8.MAX_CHUNK_SIZE)
      throw new Error(
        `Chunk size ${e} exceeds P2WSH stack item limit of ${_I8.MAX_CHUNK_SIZE}`
      );
    if (t.length === 0)
      throw new Error("Data cannot be empty");
    const i = [];
    let r = 0;
    for (; r < t.length; ) {
      const c = Math.min(e, t.length - r);
      i.push(new Uint8Array(t.subarray(r, r + c))), r += c;
    }
    const s = [];
    let o = 0;
    for (; o < i.length; ) {
      const c = i.slice(
        o,
        o + _I8.MAX_CHUNKS_PER_OUTPUT
      ), u = c, l = u.map((p) => this.hashChunk(p)), h = this.generateWitnessScript(l), d = this.generateP2WSHAddress(h);
      s.push({
        address: d.address,
        witnessScript: d.witnessScript,
        scriptPubKey: d.scriptPubKey,
        dataHashes: l,
        dataChunks: u,
        chunkStartIndex: o
      }), o += c.length;
    }
    const a = i.length;
    return this.log(
      `Prepared ${s.length} P2WSH outputs with ${a} chunks (${t.length} bytes, ~${Math.ceil(t.length / s.length)} bytes/output)`
    ), s;
  }
};
/**
 * Maximum chunk size per Bitcoin P2WSH stack item limit.
 * See policy.h: MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80
 */
__publicField(_I8, "MAX_CHUNK_SIZE", 80);
/**
 * Maximum stack items per P2WSH input.
 * See policy.h: MAX_STANDARD_P2WSH_STACK_ITEMS = 100
 */
__publicField(_I8, "MAX_STACK_ITEMS", 100);
/**
 * Maximum total witness size (serialized).
 * See policy.cpp: GetSerializeSize(tx.vin[i].scriptWitness.stack) > g_script_size_policy_limit
 * Default: 1650 bytes
 */
__publicField(_I8, "MAX_WITNESS_SIZE", 1650);
/** Maximum weight per standard transaction */
__publicField(_I8, "MAX_STANDARD_WEIGHT", 4e5);
/** Minimum satoshis per output (dust limit) */
__publicField(_I8, "MIN_OUTPUT_VALUE", 330n);
/**
 * Bytes per hash commitment in witness script.
 * OP_HASH160 (1) + push (1) + hash (20) + OP_EQUALVERIFY (1) = 23 bytes
 */
__publicField(_I8, "BYTES_PER_COMMITMENT", 23);
/**
 * Fixed overhead in witness serialization:
 * - Stack item count: 1 byte
 * - Signature: 73 bytes (72 + 1 length prefix)
 * - Script length prefix: 3 bytes (varInt for sizes 253-65535)
 * - Script base (pubkey + checksig): 35 bytes
 */
__publicField(_I8, "WITNESS_FIXED_OVERHEAD", 112);
/**
 * Per-chunk overhead in witness:
 * - Data: 81 bytes (80 + 1 length prefix)
 * - Script commitment: 23 bytes
 * Total: 104 bytes per chunk
 */
__publicField(_I8, "WITNESS_PER_CHUNK_OVERHEAD", _I8.MAX_CHUNK_SIZE + 1 + _I8.BYTES_PER_COMMITMENT);
/**
 * Maximum data chunks per P2WSH output.
 * Limited by total witness size: (1650 - 112) / 104 = 14 chunks
 */
__publicField(_I8, "MAX_CHUNKS_PER_OUTPUT", Math.floor(
  (_I8.MAX_WITNESS_SIZE - _I8.WITNESS_FIXED_OVERHEAD) / _I8.WITNESS_PER_CHUNK_OVERHEAD
));
/** Base weight per input (non-witness): 41 bytes * 4 = 164 */
__publicField(_I8, "INPUT_BASE_WEIGHT", 164);
/**
 * Witness weight per input with max chunks:
 * Total witness size is ~1566 bytes (under 1650 limit)
 * Witness bytes count as 1 weight unit each.
 */
__publicField(_I8, "INPUT_WITNESS_WEIGHT_MAX", _I8.MAX_WITNESS_SIZE);
// Use max as upper bound
/** Total weight per input (with max chunks) */
__publicField(_I8, "WEIGHT_PER_INPUT", _I8.INPUT_BASE_WEIGHT + _I8.INPUT_WITNESS_WEIGHT_MAX);
var I = _I8;
var dr3 = class extends J3 {
  constructor(t, e = ap2.bitcoin) {
    super(t, new Uint8Array(0), e);
  }
  /**
   * Get the public key as a buffer
   * @param {Uint8Array[]} witnessKeys - The public keys
   * @param {Network} network - The network to use
   * @private
   * @returns {Uint8Array} - The public key as a buffer
   */
  static getPubKeyAsBuffer(t, e) {
    let i = new Uint8Array(0);
    for (const s of t) {
      if (!P2.fromPublicKey(s, e).compressed)
        throw new Error("Public key must be compressed");
      if (s.byteLength !== 33)
        throw new Error(`Public key must be 33 bytes, got ${s.byteLength} bytes.`);
      i = _t7([i, s]);
    }
    const r = Y.compress(i);
    return r.byteLength >= i.byteLength ? i : r;
  }
  /**
   * Compile an interaction bitcoin script
   * @param {Uint8Array} calldata - The calldata to use
   * @param {Uint8Array} contractSecret - The contract secret
   * @param {Uint8Array} challenge - The challenge to use
   * @param {bigint} maxPriority - The maximum priority
   * @param {number[]} [featuresRaw=[]] - The features to use (optional)
   * @returns {Uint8Array} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t, e, i, r, s = []) {
    const o = this.splitBufferIntoChunks(t);
    if (!o.length) throw new Error("No data chunks found");
    const a = [], c = [];
    if (s && s.length) {
      const p = s.sort(
        (m, A) => m.priority - A.priority
      ), y = new V();
      for (let m = 0; m < p.length; m++) {
        const A = p[m];
        a.push(A.opcode), this.encodeFeature(A, y);
      }
      c.push(
        ...this.splitBufferIntoChunks(new Uint8Array(y.getBuffer()))
      );
    }
    let u = [
      this.getHeader(r, a),
      q2.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i,
      q2.OP_TOALTSTACK,
      this.senderPubKey,
      q2.OP_DUP,
      q2.OP_HASH256,
      Zh2.hash256(this.senderPubKey),
      q2.OP_EQUALVERIFY,
      q2.OP_CHECKSIGVERIFY,
      e,
      q2.OP_TOALTSTACK,
      q2.OP_DEPTH,
      q2.OP_1,
      q2.OP_NUMEQUAL,
      q2.OP_IF,
      J3.MAGIC
    ];
    u = u.concat(
      ...c,
      q2.OP_1NEGATE,
      ...o,
      q2.OP_ELSE,
      q2.OP_1,
      q2.OP_ENDIF
    );
    const l = u.flat(), h = Vh2.compile(l);
    if (!Vh2.decompile(h))
      throw new Error("Failed to decompile script??");
    return h;
  }
};
var _Dt = class _Dt {
  static compile(t, e = 0, i) {
    if (e < 2)
      throw new Error("Minimum signatures must be greater than 1");
    if (t.length < e)
      throw new Error("The amount of public keys is lower than the minimum required");
    if (e > _Dt.MAXIMUM_SUPPORTED_SIGNATURE)
      throw new Error(
        `The maximum amount of signatures is ${_Dt.MAXIMUM_SUPPORTED_SIGNATURE}`
      );
    const r = Et4(1);
    r[0] = e, t = t.filter(
      (h, d, p) => d === p.findIndex((y) => P(h, y))
    ), t = t.sort((h, d) => Fe3(h, d));
    let s = false;
    const o = t.map((h) => {
      const d = $e4(h);
      return i && !s && (s = P(i, d)), d;
    });
    i && !s && o.push(i);
    const c = [
      // Push the initial 0 (for OP_CHECKSIGADD)
      q2.OP_0,
      // For each public key, add CHECKSIGADD operation
      ...o.flatMap((h) => [
        h,
        // Push the public key
        q2.OP_CHECKSIGADD
        // Add the public key to the signature set
      ]),
      // Finally, compare the sum with the minimum required signatures
      r,
      q2.OP_NUMEQUAL
      // Use NUMEQUALVERIFY to ensure the correct number of signatures
    ].flat(), u = Vh2.compile(c);
    if (!Vh2.decompile(u))
      throw new Error("Failed to decompile script.");
    return u;
  }
};
__publicField(_Dt, "MAXIMUM_SUPPORTED_SIGNATURE", 255);
var Dt5 = _Dt;
var _Ct = class _Ct extends J3 {
  constructor(t, e, i = ap2.bitcoin) {
    super(t, e, i);
  }
  /**
   * Validate that operation data will fit in P2WDA witness fields
   *
   * @param dataSize Size of the operation data
   * @param maxWitnessFields Maximum number of witness fields (default 10)
   * @param maxBytesPerWitness Maximum bytes per witness field (default 80)
   * @returns true if data will fit, false otherwise
   */
  static validateWitnessSize(t, e = 10, i = 80) {
    const o = t + 64, a = Math.ceil(o * 0.7);
    return Math.ceil(a / i) <= e;
  }
  /**
   * Compile operation data for P2WDA witness embedding
   *
   * This creates a binary structure containing all operation information
   * without Bitcoin script opcodes. The structure is:
   *
   * [version(1)] [header(12)] [contract(32)] [challenge_pubkey(33)] [challenge_solution(32)]
   * [calldata_length(4)] [calldata] [features_length(2)] [features_data]
   *
   * @param calldata The compressed calldata for the contract interaction
   * @param contractSecret The 32-byte contract secret
   * @param challenge The challenge solution for epoch rewards
   * @param maxPriority Maximum priority fee in satoshis
   * @param featuresRaw Optional features like access lists
   * @returns Raw operation data ready for signing and compression
   */
  compile(t, e, i, r, s = []) {
    if (!this.contractSaltPubKey)
      throw new Error("Contract salt public key not set");
    if (e.length !== 32)
      throw new Error("Contract secret must be exactly 32 bytes");
    const o = new V();
    o.writeU8(_Ct.P2WDA_VERSION);
    const a = s.sort((c, u) => c.priority - u.priority);
    return o.writeBytes(
      this.getHeader(
        r,
        a.map((c) => c.opcode)
      )
    ), o.writeBytes(e), o.writeBytes(i.publicKey.toBuffer()), o.writeBytes(i.solution), o.writeU32(t.length), o.writeBytes(t), this.writeFeatures(o, a), new Uint8Array(o.getBuffer());
  }
  getHeader(t, e = []) {
    return super.getHeader(t, e);
  }
  /**
   * Write features section to the operation data
   *
   * Features are encoded as:
   * [feature_count(2)] [feature1_opcode(1)] [feature1_length(4)] [feature1_data] ...
   *
   * @param writer Binary writer to write to
   * @param features Array of features to encode
   */
  writeFeatures(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      t.writeU8(i.opcode), this.encodeFeature(i, t);
  }
};
__publicField(_Ct, "P2WDA_VERSION", 1);
var Ct5 = _Ct;
var ge4 = class {
  // Generate a valid SegWit address from random bytes
  static generatePKSH(t, e) {
    if (t.length !== 32) throw new Error("Invalid hash length");
    const i = qh2(t);
    return this.toSegwitAddress(i, e);
  }
  // Generate a valid Taproot address from a public key
  static generateTaprootAddress(t, e) {
    if (t.length !== 32) throw new Error("Invalid public key length");
    const i = Ey.bech32m.toWords(t);
    return i.unshift(1), Ey.bech32m.encode(e.bech32, i);
  }
  // Convert a hash to a SegWit address
  static toSegwitAddress(t, e) {
    const i = Ey.bech32.toWords(t);
    return i.unshift(0), Ey.bech32.encode(e.bech32, i);
  }
};
var _nt = class _nt {
  static getContractAddress(t) {
    const { scriptTree: e } = _nt.buildScriptTree(t);
    return _nt.generateAddressFromScript(t, e);
  }
  static verifyControlBlock(t, e) {
    const { scriptTree: i, compiledTargetScript: r, network: s } = _nt.buildScriptTree(t), a = Xf2.p2tr({
      internalPubkey: $e4(t.deployerPubKey),
      network: s,
      scriptTree: i,
      redeem: {
        output: r,
        redeemVersion: _nt.TAP_SCRIPT_VERSION
      }
    }).witness;
    if (!a || a.length === 0)
      return false;
    const c = a[a.length - 1];
    return P(c, e);
  }
  static getContractSeed(t, e, i) {
    const r = Zh2.hash256(e), s = _t7([t, i, r]);
    return Zh2.hash256(s);
  }
  static generateAddressFromScript(t, e) {
    const i = t.network || ap2.bitcoin, r = {
      internalPubkey: $e4(t.deployerPubKey),
      network: i,
      scriptTree: e
    };
    return Xf2.p2tr(r).address;
  }
  static buildScriptTree(t) {
    const e = t.network || ap2.bitcoin, r = new fe5(
      t.deployerPubKey,
      $e4(t.contractSaltPubKey),
      e
    ).compile(
      t.bytecode,
      t.originalSalt,
      t.challenge,
      t.priorityFee,
      t.calldata,
      t.features
    ), s = Vh2.compile([
      $e4(t.deployerPubKey),
      q2.OP_CHECKSIG
    ]);
    return { scriptTree: [
      {
        output: r,
        version: _nt.TAP_SCRIPT_VERSION
      },
      {
        output: s,
        version: _nt.TAP_SCRIPT_VERSION
      }
    ], compiledTargetScript: r, network: e };
  }
};
__publicField(_nt, "TAP_SCRIPT_VERSION", 192);
var nt4 = _nt;
function pt4(n) {
  return "privateKey" in n && n.privateKey != null;
}
var Se4 = class {
  /**
   * Tweak a signer
   * @param {UniversalSigner} signer - The signer to tweak (must have privateKey)
   * @param {TweakSettings} opts - The tweak settings
   * @returns {UniversalSigner} - The tweaked signer
   */
  static tweakSigner(t, e = {}) {
    let i = t.privateKey;
    if (!i)
      throw new Error("Private key is required for tweaking signer!");
    t.publicKey[0] === 3 && (i = H2.privateNegate(i));
    const r = H2.privateAdd(
      i,
      ff2($e4(t.publicKey), e.tweakHash)
    );
    if (!r)
      throw new Error("Invalid tweaked private key!");
    return P2.fromPrivateKey(r, e.network);
  }
};
function je5(n) {
  return typeof n == "object" && n !== null && "web3" in n && typeof n.web3 == "object" && "getMLDSAPublicKey" in n.web3 && "signMLDSAMessage" in n.web3;
}
var pr3 = class {
  sha256(t) {
    return Zh2.sha256(t);
  }
  async trySignSchnorrWithOPWallet(t) {
    const e = this.getOPWallet();
    if (!e)
      return null;
    const i = typeof t == "string" ? new TextEncoder().encode(t) : t, r = this.sha256(i), s = Yt4(r), o = await e.web3.signSchnorr(s);
    return {
      signature: Mt3(o),
      message: r
    };
  }
  async trySignMLDSAWithOPWallet(t) {
    const e = this.getOPWallet();
    if (!e)
      return null;
    const i = typeof t == "string" ? new TextEncoder().encode(t) : t, r = this.sha256(i), s = Yt4(r), o = await e.web3.signMLDSAMessage(s);
    return {
      signature: Mt3(o.signature),
      message: r,
      publicKey: Mt3(o.publicKey),
      securityLevel: o.securityLevel
    };
  }
  async signMessageAuto(t, e) {
    if (!e) {
      const i = await this.trySignSchnorrWithOPWallet(t);
      if (i)
        return i;
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    return this.signMessage(e, t);
  }
  async tweakAndSignMessageAuto(t, e, i) {
    if (!e) {
      const r = await this.trySignSchnorrWithOPWallet(t);
      if (r)
        return r;
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    if (!i)
      throw new Error("Network is required when signing with a local keypair.");
    return this.tweakAndSignMessage(e, t, i);
  }
  async signMLDSAMessageAuto(t, e) {
    if (!e) {
      const i = await this.trySignMLDSAWithOPWallet(t);
      if (i)
        return i;
      throw new Error("No ML-DSA keypair provided and OP_WALLET is not available.");
    }
    return this.signMLDSAMessage(e, t);
  }
  async verifyMLDSAWithOPWallet(t, e) {
    const i = this.getOPWallet();
    if (!i)
      return null;
    const r = typeof t == "string" ? new TextEncoder().encode(t) : t, s = this.sha256(r), o = {
      signature: Yt4(e.signature),
      publicKey: Yt4(e.publicKey),
      securityLevel: e.securityLevel,
      messageHash: Yt4(s)
    };
    return i.web3.verifyMLDSASignature(Yt4(s), o);
  }
  async getMLDSAPublicKeyFromOPWallet() {
    const t = this.getOPWallet();
    if (!t)
      return null;
    const e = await t.web3.getMLDSAPublicKey();
    return Mt3(e);
  }
  tweakAndSignMessage(t, e, i) {
    const r = Se4.tweakSigner(t, { network: i });
    return this.signMessage(r, e);
  }
  signMessage(t, e) {
    if (typeof e == "string" && (e = new TextEncoder().encode(e)), !t.privateKey)
      throw new Error("Private key not found in keypair.");
    const i = this.sha256(e);
    if (!H2.signSchnorr)
      throw new Error("backend.signSchnorr is not available.");
    return {
      signature: H2.signSchnorr(i, t.privateKey),
      message: i
    };
  }
  verifySignature(t, e, i) {
    if (typeof e == "string" && (e = new TextEncoder().encode(e)), i.length !== 64)
      throw new Error("Invalid signature length.");
    const r = this.sha256(e);
    if (!H2.verifySchnorr)
      throw new Error("backend.verifySchnorr is not available.");
    return H2.verifySchnorr(
      r,
      $e4(t),
      i
    );
  }
  tweakAndVerifySignature(t, e, i) {
    const r = P2.tweakPublicKey(t);
    return this.verifySignature(r, e, i);
  }
  signMLDSAMessage(t, e) {
    if (typeof e == "string" && (e = new TextEncoder().encode(e)), !t.privateKey)
      throw new Error("ML-DSA private key not found in keypair.");
    const i = this.sha256(e), r = t.sign(i);
    return {
      signature: new Uint8Array(r),
      message: i,
      publicKey: new Uint8Array(t.publicKey),
      securityLevel: t.securityLevel
    };
  }
  verifyMLDSASignature(t, e, i) {
    typeof e == "string" && (e = new TextEncoder().encode(e));
    const r = this.sha256(e);
    return t.verify(r, i);
  }
  isOPWalletAvailable() {
    return this.getOPWallet() !== null;
  }
  getOPWallet() {
    if (typeof window > "u")
      return null;
    const t = window;
    return !t.opnet || !je5(t.opnet) ? null : t.opnet;
  }
};
var ct4 = new pr3();
var rt5 = class _rt {
  constructor(t, e, i = ap2.bitcoin, r = $b.MLDSASecurityLevel.LEVEL2, s) {
    __publicField(this, "_keypair");
    __publicField(this, "_mldsaKeypair");
    __publicField(this, "_securityLevel");
    __publicField(this, "_chainCode");
    __publicField(this, "_p2wpkh");
    __publicField(this, "_p2tr");
    __publicField(this, "_p2wda");
    __publicField(this, "_legacy");
    __publicField(this, "_segwitLegacy");
    __publicField(this, "_bufferPubKey");
    __publicField(this, "_tweakedKey");
    __publicField(this, "_address");
    this.network = i, this._securityLevel = r;
    const o = t.startsWith("0x") ? t.slice(2) : t;
    M.isValidHex(o) ? this._keypair = P2.fromPrivateKey(Mt3(o), this.network) : this._keypair = P2.fromWIF(o, this.network);
    const a = e.startsWith("0x") ? e.slice(2) : e;
    if (M.isValidHex(a)) {
      const c = Mt3(a), u = $b.getMLDSAConfig(r, this.network), l = u.privateKeySize, h = u.publicKeySize, d = l + h;
      let p;
      if (c.length === l)
        p = c;
      else if (c.length === d)
        p = c.subarray(0, l);
      else
        throw new Error(
          `Invalid ML-DSA key length for security level ${r}. Expected ${l} bytes (private only) or ${d} bytes (private+public), got ${c.length} bytes.`
        );
      if (s && s.length !== 32)
        throw new Error("Chain code must be 32 bytes");
      this._chainCode = s || new Uint8Array(32), this._mldsaKeypair = $b.QuantumBIP32Factory.fromPrivateKey(
        p,
        this._chainCode,
        this.network,
        r
      );
    } else
      this._mldsaKeypair = $b.QuantumBIP32Factory.fromBase58(a), this._chainCode = new Uint8Array(this._mldsaKeypair.chainCode), this._securityLevel = this._mldsaKeypair.securityLevel;
    this._bufferPubKey = this._keypair.publicKey, this._address = new K2(this._mldsaKeypair.publicKey, this._keypair.publicKey), this._p2tr = this._address.p2tr(this.network), this._p2wpkh = this._address.p2wpkh(this.network), this._legacy = this._address.p2pkh(this.network), this._segwitLegacy = this._address.p2shp2wpkh(this.network), this._p2wda = this._address.p2wda(this.network), this._tweakedKey = this._address.tweakedPublicKeyToBuffer();
  }
  get address() {
    return this._address;
  }
  get tweakedPubKeyKey() {
    return this._tweakedKey;
  }
  get keypair() {
    if (!this._keypair) throw new Error("Keypair not set");
    return this._keypair;
  }
  get mldsaKeypair() {
    return this._mldsaKeypair;
  }
  get securityLevel() {
    return this._securityLevel;
  }
  get chainCode() {
    return this._chainCode;
  }
  get p2wpkh() {
    return this._p2wpkh;
  }
  get p2tr() {
    return this._p2tr;
  }
  get p2wda() {
    return this._p2wda;
  }
  get legacy() {
    return this._legacy;
  }
  get addresses() {
    return [this.p2wpkh, this.p2tr, this.legacy, this.segwitLegacy];
  }
  get segwitLegacy() {
    return this._segwitLegacy;
  }
  get publicKey() {
    if (!this._bufferPubKey) throw new Error("Public key not set");
    return this._bufferPubKey;
  }
  get quantumPublicKey() {
    return new Uint8Array(this._mldsaKeypair.publicKey);
  }
  get quantumPrivateKey() {
    if (!this._mldsaKeypair.privateKey)
      throw new Error("Quantum private key not set");
    return new Uint8Array(this._mldsaKeypair.privateKey);
  }
  get quantumPublicKeyHex() {
    return Yt4(new Uint8Array(this._mldsaKeypair.publicKey));
  }
  get quantumPrivateKeyHex() {
    if (!this._mldsaKeypair.privateKey)
      throw new Error("Quantum private key not set");
    return Yt4(new Uint8Array(this._mldsaKeypair.privateKey));
  }
  get xOnly() {
    if (!this.keypair) throw new Error("Keypair not set");
    return $e4(this._bufferPubKey);
  }
  static fromWif(t, e, i = ap2.bitcoin, r = $b.MLDSASecurityLevel.LEVEL2, s) {
    return new _rt(t, e, i, r, s);
  }
  static generate(t = ap2.bitcoin, e = $b.MLDSASecurityLevel.LEVEL2) {
    const i = P2.generateWallet(t, e);
    if (!i.quantumPrivateKey)
      throw new Error("Failed to generate quantum keys");
    return new _rt(
      i.privateKey,
      i.quantumPrivateKey,
      t,
      e
    );
  }
  static fromPrivateKeys(t, e, i = ap2.bitcoin, r = $b.MLDSASecurityLevel.LEVEL2, s) {
    return new _rt(
      t,
      e,
      i,
      r,
      s
    );
  }
  toWIF() {
    return this._keypair.toWIF();
  }
  toPrivateKeyHex() {
    if (!this._keypair.privateKey)
      throw new Error("Private key not available");
    return Yt4(this._keypair.privateKey);
  }
  toPublicKeyHex() {
    return Yt4(this._bufferPubKey);
  }
  toQuantumBase58() {
    return this._mldsaKeypair.toBase58();
  }
  /**
   * Best-effort zeroing of private key material held by this wallet.
   *
   * Zeros classical and quantum private key buffers and the chain code in-place.
   * This cannot guarantee all copies are erased (the JS runtime may have copied
   * buffers internally, and string representations cannot be zeroed), but it
   * eliminates the primary references.
   */
  zeroize() {
    var _a37, _b9;
    (_a37 = this._keypair.privateKey) == null ? void 0 : _a37.fill(0), (_b9 = this._mldsaKeypair.privateKey) == null ? void 0 : _b9.fill(0), this._chainCode.fill(0);
  }
  [Symbol.dispose]() {
    this.zeroize();
  }
  derivePath(t) {
    const e = this._mldsaKeypair.derivePath(t);
    if (!this._keypair.privateKey)
      throw new Error("Cannot derive from a watch-only wallet (no private key available)");
    const r = P2.BIP32.fromPrivateKey(
      this._keypair.privateKey,
      this._chainCode,
      this.network
    ).derivePath(t);
    if (!r.privateKey)
      throw new Error("Failed to derive classical private key");
    if (!r.chainCode)
      throw new Error("Failed to derive classical chain code");
    return new _rt(
      Yt4(new Uint8Array(r.privateKey)),
      e.toBase58(),
      this.network,
      this._securityLevel,
      new Uint8Array(r.chainCode)
    );
  }
};
var $t5 = ((n) => (n[n.MINIMUM = 128] = "MINIMUM", n[n.LOW = 160] = "LOW", n[n.MEDIUM = 192] = "MEDIUM", n[n.HIGH = 224] = "HIGH", n[n.MAXIMUM = 256] = "MAXIMUM", n))($t5 || {});
var _t24 = ((n) => (n[n.BIP44 = 44] = "BIP44", n[n.BIP49 = 49] = "BIP49", n[n.BIP84 = 84] = "BIP84", n[n.BIP86 = 86] = "BIP86", n))(_t24 || {});
function fr3(n) {
  switch (n) {
    case 44:
      return "BIP44: Legacy addresses (P2PKH), widely used by Unisat and other wallets";
    case 49:
      return "BIP49: Wrapped SegWit addresses (P2SH-P2WPKH)";
    case 84:
      return "BIP84: Native SegWit addresses (P2WPKH) - DEFAULT";
    case 86:
      return "BIP86: Taproot addresses (P2TR)";
    default:
      return "Unknown BIP standard";
  }
}
function Ze5(n, t, e, i, r) {
  return `m/${n}'/${t}'/${e}'/${i}/${r}`;
}
var gr3 = $b.BIP32Factory(H2);
var we5 = class _we {
  constructor(t, e = "", i = ap2.bitcoin, r = $b.MLDSASecurityLevel.LEVEL2) {
    __publicField(this, "_phrase");
    __publicField(this, "_passphrase");
    __publicField(this, "_network");
    __publicField(this, "_securityLevel");
    __publicField(this, "_seed");
    __publicField(this, "_classicalRoot");
    __publicField(this, "_quantumRoot");
    if (!Ay.validateMnemonic(t))
      throw new Error("Invalid mnemonic phrase");
    this._phrase = t, this._passphrase = e, this._network = i, this._securityLevel = r, this._seed = Ay.mnemonicToSeedSync(this._phrase, this._passphrase), this._classicalRoot = gr3.fromSeed(this._seed, this._network), this._quantumRoot = $b.QuantumBIP32Factory.fromSeed(
      this._seed,
      this._network,
      this._securityLevel
    );
  }
  get phrase() {
    return this._phrase;
  }
  get network() {
    return this._network;
  }
  get securityLevel() {
    return this._securityLevel;
  }
  get seed() {
    return new Uint8Array(this._seed);
  }
  static generatePhrase(t = $t5.MAXIMUM) {
    return Ay.generateMnemonic(t);
  }
  static generate(t = $t5.MAXIMUM, e = "", i = ap2.bitcoin, r = $b.MLDSASecurityLevel.LEVEL2) {
    const s = Ay.generateMnemonic(t);
    return new _we(s, e, i, r);
  }
  static validate(t) {
    return Ay.validateMnemonic(t);
  }
  /**
   * Best-effort zeroing of secret material held by this mnemonic.
   *
   * Zeros the seed buffer and root private keys in-place.
   * The mnemonic phrase and passphrase are JS strings and cannot be zeroed.
   */
  zeroize() {
    var _a37, _b9;
    this._seed.fill(0), (_a37 = this._classicalRoot.privateKey) == null ? void 0 : _a37.fill(0), (_b9 = this._quantumRoot.privateKey) == null ? void 0 : _b9.fill(0);
  }
  [Symbol.dispose]() {
    this.zeroize();
  }
  derive(t = 0, e = 0, i = false, r = _t24.BIP84) {
    const s = this.buildClassicalPath(e, t, i, r), o = this._classicalRoot.derivePath(s);
    if (!o.privateKey)
      throw new Error(`Failed to derive classical private key at index ${t}`);
    const a = this.buildQuantumPath(e, t, i), c = this._quantumRoot.derivePath(a);
    if (!c.privateKey)
      throw new Error(`Failed to derive quantum private key at index ${t}`);
    return new rt5(
      Yt4(new Uint8Array(o.privateKey)),
      Yt4(new Uint8Array(c.privateKey)),
      this._network,
      this._securityLevel,
      new Uint8Array(this._quantumRoot.chainCode)
    );
  }
  deriveOPWallet(t = st3.P2TR, e = 0, i = 0, r = false) {
    let s;
    switch (t) {
      case st3.P2PKH:
        s = 44;
        break;
      case st3.P2SH_OR_P2SH_P2WPKH:
        s = 49;
        break;
      case st3.P2WPKH:
        s = 84;
        break;
      case st3.P2TR:
        s = 86;
        break;
      default:
        throw new Error(`Unsupported address type: ${t}`);
    }
    const o = this.getCoinType(), a = r ? 1 : 0, c = `m/${s}'/0'/${i}'/${a}/${e}`, u = this._classicalRoot.derivePath(c);
    if (!u.privateKey)
      throw new Error(`Failed to derive classical private key at path ${c}`);
    const l = `m/360'/${o}'/${i}'/${a}/${e}`, h = this._quantumRoot.derivePath(l);
    if (!h.privateKey)
      throw new Error(`Failed to derive quantum private key at path ${l}`);
    return new rt5(
      Yt4(new Uint8Array(u.privateKey)),
      Yt4(new Uint8Array(h.privateKey)),
      this._network,
      this._securityLevel,
      new Uint8Array(this._quantumRoot.chainCode)
    );
  }
  deriveMultipleUnisat(t = st3.P2TR, e = 5, i = 0, r = 0, s = false) {
    const o = [];
    for (let a = 0; a < e; a++)
      o.push(this.deriveOPWallet(t, i + a, r, s));
    return o;
  }
  deriveMultiple(t, e = 0, i = 0, r = false, s = _t24.BIP84) {
    const o = [];
    for (let a = 0; a < t; a++)
      o.push(this.derive(e + a, i, r, s));
    return o;
  }
  deriveCustomPath(t, e) {
    const i = this._classicalRoot.derivePath(t), r = this._quantumRoot.derivePath(e);
    if (!i.privateKey)
      throw new Error(`Failed to derive classical private key at path ${t}`);
    if (!r.privateKey)
      throw new Error(`Failed to derive quantum private key at path ${e}`);
    return new rt5(
      Yt4(new Uint8Array(i.privateKey)),
      Yt4(new Uint8Array(r.privateKey)),
      this._network,
      this._securityLevel,
      new Uint8Array(this._quantumRoot.chainCode)
    );
  }
  getClassicalRoot() {
    return this._classicalRoot;
  }
  getQuantumRoot() {
    return this._quantumRoot;
  }
  buildClassicalPath(t, e, i, r = _t24.BIP84) {
    const s = this.getCoinType();
    return Ze5(r, s, t, i ? 1 : 0, e);
  }
  buildQuantumPath(t, e, i) {
    return `m/360'/${this.getCoinType()}'/${t}'/${i ? 1 : 0}/${e}`;
  }
  getCoinType() {
    return this._network.bech32 === ap2.testnet.bech32 || this._network.bech32 === ap2.opnetTestnet.bech32 || this._network.bech32 === ap2.regtest.bech32 ? 1 : 0;
  }
};
var Je4 = ((n) => (n[n.MLDSA44 = 1312] = "MLDSA44", n[n.MLDSA65 = 1952] = "MLDSA65", n[n.MLDSA87 = 2592] = "MLDSA87", n))(Je4 || {});
function ce4(n) {
  switch (n) {
    case 1312:
      return $b.MLDSASecurityLevel.LEVEL2;
    case 1952:
      return $b.MLDSASecurityLevel.LEVEL3;
    case 2592:
      return $b.MLDSASecurityLevel.LEVEL5;
    default:
      throw new Error(`Invalid MLDSA public key length: ${n}`);
  }
}
var Sr = class {
  constructor(t = ap2.bitcoin) {
    this.network = t;
  }
  /**
   * @description Get the contract address
   * @param {Network} network - The network to get the address for
   */
  static getAddress(t = ap2.bitcoin) {
    throw new Error("Method not implemented.");
  }
  /**
   * @description Get the contract address
   */
  getAddress() {
    return this.address;
  }
};
var ye4 = ((n) => (n[n.Bitcoin = 0] = "Bitcoin", n[n.Fractal = 1] = "Fractal", n))(ye4 || {});
function me4(n) {
  return n && !!(n.tapInternalKey || n.tapMerkleRoot || n.tapLeafScript && n.tapLeafScript.length || n.tapBip32Derivation && n.tapBip32Derivation.length || n.witnessUtxo && (jo2(n.witnessUtxo.script) || zo2(n.witnessUtxo.script)));
}
function wr3(n) {
  return n.redeemScript ? n.redeemScript : n.witnessScript ? n.witnessScript : n.witnessUtxo ? n.witnessUtxo.script : (n.nonWitnessUtxo, null);
}
function Te5(n, t) {
  if (n.nonWitnessUtxo && !n.redeemScript && !n.witnessScript && !n.witnessUtxo || n.redeemScript)
    return true;
  const e = wr3(n);
  return e ? be3(t, e) : false;
}
function be3(n, t) {
  return qo2(n, t) !== -1;
}
var Ae5 = class {
  constructor() {
  }
};
var yt4 = ((n) => (n.Mainnet = "mainnet", n.Testnet = "testnet", n.OpnetTestnet = "opnetTestnet", n.Regtest = "regtest", n))(yt4 || {});
var ti3 = ((n) => (n.BITCOIN_MAINNET = "BITCOIN_MAINNET", n.BITCOIN_TESTNET = "BITCOIN_TESTNET", n.BITCOIN_TESTNET4 = "BITCOIN_TESTNET4", n.BITCOIN_REGTEST = "BITCOIN_REGTEST", n.BITCOIN_SIGNET = "BITCOIN_SIGNET", n.OPNET_TESTNET = "OPNET_TESTNET", n.FRACTAL_BITCOIN_MAINNET = "FRACTAL_BITCOIN_MAINNET", n.FRACTAL_BITCOIN_TESTNET = "FRACTAL_BITCOIN_TESTNET", n.DOGECOIN_MAINNET = "DOGECOIN_MAINNET", n.DOGECOIN_TESTNET = "DOGECOIN_TESTNET", n.DOGECOIN_REGTEST = "DOGECOIN_REGTEST", n.LITECOIN_MAINNET = "LITECOIN_MAINNET", n.LITECOIN_TESTNET = "LITECOIN_TESTNET", n.LITECOIN_REGTEST = "LITECOIN_REGTEST", n.BITCOINCASH_MAINNET = "BITCOINCASH_MAINNET", n.BITCOINCASH_TESTNET = "BITCOINCASH_TESTNET", n.BITCOINCASH_REGTEST = "BITCOINCASH_REGTEST", n.DASH_MAINNET = "DASH_MAINNET", n.DASH_TESTNET = "DASH_TESTNET", n.DASH_REGTEST = "DASH_REGTEST", n))(ti3 || {});
var ei3 = ((n) => (n.ecdsa = "ecdsa", n.bip322 = "bip322-simple", n))(ei3 || {});
var ii3 = ((n) => (n.ecdsa = "ecdsa", n.schnorr = "schnorr", n))(ii3 || {});
var yr3 = class extends Ae5 {
  constructor() {
    super();
    __publicField(this, "isInitialized", false);
    __publicField(this, "_p2tr");
    __publicField(this, "_p2wpkh");
    __publicField(this, "_addresses");
    __publicField(this, "_publicKey");
    __publicField(this, "_network");
    if (!window)
      throw new Error("UnisatSigner can only be used in a browser environment");
  }
  get p2tr() {
    if (!this._p2tr)
      throw new Error("P2TR address not set");
    return this._p2tr;
  }
  get p2wpkh() {
    if (!this._p2wpkh)
      throw new Error("P2PKH address not set");
    return this._p2wpkh;
  }
  get addresses() {
    if (!this._addresses)
      throw new Error("Addresses not set");
    return this._addresses;
  }
  get publicKey() {
    if (!this._publicKey)
      throw new Error("Public key not set");
    return this._publicKey;
  }
  get network() {
    if (!this._network)
      throw new Error("Network not set");
    return this._network;
  }
  get unisat() {
    if (!window) throw new Error("Window not found");
    const t = window.unisat;
    if (!t)
      throw new Error("Unisat extension not found");
    return t;
  }
  async signData(t, e) {
    const i = Yt4(t), r = await this.unisat.signData(i, e);
    return Mt3(r);
  }
  async init() {
    if (this.isInitialized)
      return;
    const t = await this.unisat.getNetwork();
    switch (t) {
      case yt4.Mainnet:
        this._network = ap2.bitcoin;
        break;
      case yt4.Testnet:
        this._network = ap2.testnet;
        break;
      case yt4.OpnetTestnet:
        this._network = ap2.opnetTestnet;
        break;
      case yt4.Regtest:
        this._network = ap2.regtest;
        break;
      default:
        throw new Error(`Invalid network: ${t}`);
    }
    const e = await this.unisat.getPublicKey();
    if (e === "")
      throw new Error("Unlock your wallet first");
    this._publicKey = ef(Mt3(e)), this._p2wpkh = P2.getP2WPKHAddress(this, this.network), this._p2tr = P2.getTaprootAddress(this, this.network), this._addresses = [this._p2wpkh, this._p2tr], this.isInitialized = true;
  }
  getPublicKey() {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    return this.publicKey;
  }
  sign(t, e) {
    throw new Error("Not implemented: sign");
  }
  signSchnorr(t) {
    throw new Error("Not implemented: signSchnorr");
  }
  verify(t, e) {
    throw new Error("Not implemented: verify");
  }
  async signTaprootInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, false);
    this.combine(t, s, e);
  }
  async signInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, true);
    this.combine(t, s, e);
  }
  async multiSignPsbt(t) {
    const e = [], i = [];
    for (const o of t) {
      const a = o.toHex();
      e.push(a);
      const c = o.data.inputs.map((u, l) => {
        let h = false, d = false;
        if (me4(u)) {
          if (u.tapLeafScript && u.tapLeafScript.length > 0) {
            for (const p of u.tapLeafScript)
              if (mr3(this.publicKey, p.script)) {
                h = true, d = false;
                break;
              }
          }
          if (!h && u.tapInternalKey) {
            const p = u.tapInternalKey, y = $e4(this.publicKey);
            P(p, y) && (h = true, d = true);
          }
        } else Te5(u, this.publicKey) && (h = true, d = false);
        return h ? {
          index: l,
          publicKey: Yt4(this.publicKey),
          disableTweakSigner: !d
        } : null;
      }).filter((u) => u !== null);
      i.push({
        autoFinalized: false,
        toSignInputs: c
      });
    }
    const r = await this.unisat.signPsbt(
      e[0],
      i[0]
    ), s = Xn2.fromHex(r);
    t[0].combine(s);
  }
  hasAlreadySignedTapScriptSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = new Uint8Array(i.pubkey);
      if (P(r, this.publicKey) && i.signature)
        return true;
    }
    return false;
  }
  hasAlreadyPartialSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = new Uint8Array(i.pubkey);
      if (P(r, this.publicKey) && i.signature)
        return true;
    }
    return false;
  }
  combine(t, e, i) {
    var _a37;
    const r = e.data.inputs[i], s = t.data.inputs[i];
    if (r.partialSig && t.updateInput(i, { partialSig: r.partialSig }), r.tapKeySig && !s.tapKeySig && t.updateInput(i, { tapKeySig: r.tapKeySig }), (_a37 = r.tapScriptSig) == null ? void 0 : _a37.length) {
      const o = s.tapScriptSig;
      if (o) {
        const a = this.getNonDuplicateScriptSig(
          o,
          r.tapScriptSig
        );
        a.length && t.updateInput(i, { tapScriptSig: a });
      } else
        t.updateInput(i, { tapScriptSig: r.tapScriptSig });
    }
  }
  async signAllTweaked(t, e, i = false) {
    const r = Yt4(this.publicKey), o = {
      autoFinalized: false,
      toSignInputs: t.data.inputs.map((u, l) => [
        {
          index: l,
          publicKey: r,
          sighashTypes: e,
          disableTweakSigner: i
        }
      ]).flat()
    }, a = t.toHex(), c = await this.unisat.signPsbt(a, o);
    return Xn2.fromHex(c);
  }
  getNonDuplicateScriptSig(t, e) {
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      t.find((a) => P(a.pubkey, s.pubkey)) || i.push(s);
    }
    return i;
  }
};
function mr3(n, t) {
  return Tr3(n, t) !== -1;
}
function Tr3(n, t) {
  const e = Zh2.hash160(n), i = $e4(n), r = Vh2.decompile(t);
  if (r === null) throw new Error("Unknown script error");
  return r.findIndex((s) => typeof s == "number" ? false : s instanceof Uint8Array && (P(s, n) || P(s, e) || P(s, i)));
}
function ri3(n) {
  return new Map(n);
}
function br3(n) {
  return {
    enabled: true,
    signerMap: n instanceof Map ? n : ri3(n)
  };
}
function Ar3() {
  return {
    enabled: false,
    signerMap: /* @__PURE__ */ new Map()
  };
}
function Er3(n) {
  return {
    publicKey: n.publicKey,
    getPrivateKey() {
      if (!n.privateKey)
        throw new Error("Signer does not have a private key");
      return Xa(n.privateKey);
    },
    sign(t, e) {
      return n.sign(t, e);
    },
    signSchnorr(t) {
      if (!n.signSchnorr)
        throw new Error("Signer does not support Schnorr signing");
      return n.signSchnorr(t);
    }
  };
}
function si3(n, t) {
  return {
    publicKey: ef(n.publicKey),
    getPrivateKey() {
      if (!t.privateKey)
        throw new Error("Tweaked signer does not have a private key");
      return Xa(t.privateKey);
    },
    sign(e, i) {
      return t.sign(e, i);
    },
    signSchnorr(e) {
      if (!t.signSchnorr)
        throw new Error("Tweaked signer does not support Schnorr signing");
      return t.signSchnorr(
        e
      );
    }
  };
}
var b = ((n) => (n[n.GENERIC = 0] = "GENERIC", n[n.FUNDING = 1] = "FUNDING", n[n.DEPLOYMENT = 2] = "DEPLOYMENT", n[n.INTERACTION = 3] = "INTERACTION", n[n.MULTI_SIG = 4] = "MULTI_SIG", n[n.CUSTOM_CODE = 5] = "CUSTOM_CODE", n[n.CANCEL = 6] = "CANCEL", n[n.CONSOLIDATED_SETUP = 7] = "CONSOLIDATED_SETUP", n[n.CONSOLIDATED_REVEAL = 8] = "CONSOLIDATED_REVEAL", n))(b || {});
function ue4(n) {
  let t = new Uint8Array(0);
  function e(a, c) {
    const u = new Uint8Array(a.length + c.length);
    return u.set(a, 0), u.set(c, a.length), u;
  }
  function i(a) {
    t = e(t, a);
  }
  function r(a) {
    const c = t.length, u = hp2.encodingLength(a), l = new Uint8Array(c + u);
    l.set(t, 0), t = l, hp2.encode(a, t, c);
  }
  function s(a) {
    r(a.length), i(a);
  }
  function o(a) {
    r(a.length), a.forEach(s);
  }
  return o(n), t;
}
var ni3 = ((n) => (n[n.REPLACE_BY_FEE = 4294967293] = "REPLACE_BY_FEE", n[n.FINAL = 4294967295] = "FINAL", n))(ni3 || {});
var oi3 = ((n) => (n[n.BLOCKS = 0] = "BLOCKS", n[n.TIMESTAMPS = 1] = "TIMESTAMPS", n))(oi3 || {});
var Nt4 = class _Nt extends ky {
  constructor(t) {
    var _a37;
    super();
    __publicField(this, "logColor", "#00ffe1");
    __publicField(this, "finalized", false);
    /**
     * @description Was the transaction signed?
     */
    __publicField(this, "signer");
    /**
     * @description Tweaked signer
     */
    __publicField(this, "tweakedSigner");
    /**
     * @description The network of the transaction
     */
    __publicField(this, "network");
    /**
     * @description Was the transaction signed?
     */
    __publicField(this, "signed", false);
    /**
     * @description The sighash types of the transaction
     * @protected
     */
    __publicField(this, "sighashTypes");
    /**
     * @description The script data of the transaction
     */
    __publicField(this, "scriptData", null);
    /**
     * @description The tap data of the transaction
     */
    __publicField(this, "tapData", null);
    /**
     * @description The inputs of the transaction
     */
    __publicField(this, "inputs", []);
    /**
     * @description The sequence of the transaction
     * @protected
     */
    __publicField(this, "sequence", 4294967293);
    /**
     * The tap leaf script
     * @protected
     */
    __publicField(this, "tapLeafScript", null);
    /**
     * Add a non-witness utxo to the transaction
     * @protected
     */
    __publicField(this, "nonWitnessUtxo");
    /**
     * Is the transaction being generated inside a browser?
     * @protected
     */
    __publicField(this, "isBrowser", false);
    /**
     * Track which inputs contain CSV scripts
     * @protected
     */
    __publicField(this, "csvInputIndices", /* @__PURE__ */ new Set());
    __publicField(this, "anchorInputIndices", /* @__PURE__ */ new Set());
    __publicField(this, "regenerated", false);
    __publicField(this, "ignoreSignatureErrors", false);
    __publicField(this, "noSignatures", false);
    __publicField(this, "unlockScript");
    __publicField(this, "txVersion", 2);
    __publicField(this, "_mldsaSigner", null);
    __publicField(this, "_hashedPublicKey", null);
    /**
     * Whether address rotation mode is enabled.
     * When true, each UTXO can be signed by a different signer.
     */
    __publicField(this, "addressRotationEnabled", false);
    /**
     * Map of addresses to their respective signers for address rotation mode.
     */
    __publicField(this, "signerMap", /* @__PURE__ */ new Map());
    /**
     * Map of input indices to their signers (resolved from UTXOs or signerMap).
     * Populated during input addition.
     */
    __publicField(this, "inputSignerMap", /* @__PURE__ */ new Map());
    /**
     * Cache of tweaked signers per input for address rotation mode.
     */
    __publicField(this, "tweakedSignerCache", /* @__PURE__ */ new Map());
    /**
     * Parallel signing configuration using worker threads.
     * When set, key-path taproot inputs are signed in parallel via workers.
     */
    __publicField(this, "parallelSigningConfig");
    /**
     * Whether to use P2MR (Pay-to-Merkle-Root, BIP 360) instead of P2TR.
     */
    __publicField(this, "useP2MR", false);
    __publicField(this, "customFinalizerP2SH", (t, e, i, r, s, o, a) => {
      const c = this.inputs[t];
      if (s && e.partialSig && c && c.redeemScript) {
        const u = e.partialSig.map((h) => h.signature) || [];
        return {
          finalScriptSig: Vh2.compile([...u, c.redeemScript]),
          finalScriptWitness: void 0
        };
      }
      if (this.anchorInputIndices.has(t))
        return {
          finalScriptSig: void 0,
          finalScriptWitness: Uint8Array.from([0])
        };
      if (o && r && e.witnessScript) {
        if (!e.partialSig || e.partialSig.length === 0)
          throw new Error(`No signatures for P2WSH input #${t}`);
        if (Z2.isP2WDAWitnessScript(e.witnessScript))
          return this.finalizeSecondaryP2WDA(t, e);
        if (this.csvInputIndices.has(t)) {
          const h = [
            e.partialSig[0].signature,
            e.witnessScript
          ];
          return {
            finalScriptSig: void 0,
            finalScriptWitness: ue4(h)
          };
        }
      }
      return op2(
        t,
        e,
        i,
        r,
        s,
        o,
        true,
        this.unlockScript
      );
    });
    this.signer = t.signer, this.network = t.network, this.noSignatures = t.noSignatures || false, t.nonWitnessUtxo !== void 0 && (this.nonWitnessUtxo = t.nonWitnessUtxo), t.unlockScript !== void 0 && (this.unlockScript = t.unlockScript), this.isBrowser = typeof window < "u", t.txVersion && (this.txVersion = t.txVersion), t.mldsaSigner && (this._mldsaSigner = t.mldsaSigner, this._hashedPublicKey = ct4.sha256(this._mldsaSigner.publicKey)), ((_a37 = t.addressRotation) == null ? void 0 : _a37.enabled) && (this.addressRotationEnabled = true, this.signerMap = t.addressRotation.signerMap), t.parallelSigning && (this.parallelSigningConfig = t.parallelSigning), t.useP2MR && (this.useP2MR = true);
  }
  /**
   * Get the MLDSA signer
   * @protected
   */
  get mldsaSigner() {
    if (!this._mldsaSigner)
      throw new Error("MLDSA Signer is not set");
    return this._mldsaSigner;
  }
  /**
   * Get the hashed public key
   * @protected
   */
  get hashedPublicKey() {
    if (!this._hashedPublicKey)
      throw new Error("Hashed public key is not set");
    return this._hashedPublicKey;
  }
  /**
   * Whether parallel signing can be used for this transaction.
   * Requires parallelSigningConfig and excludes browser, address rotation, and no-signature modes.
   */
  get canUseParallelSigning() {
    return !!this.parallelSigningConfig && !this.addressRotationEnabled && !this.noSignatures;
  }
  /**
   * Read witnesses
   * @protected
   */
  static readScriptWitnessToWitnessStack(t) {
    let e = 0;
    function i(a) {
      const c = new Uint8Array(t.subarray(e, e + a));
      return e += a, c;
    }
    function r() {
      const a = hp2.decode(t, e);
      return e += a.bytes, a.numberValue || 0;
    }
    function s() {
      const a = r();
      return i(a);
    }
    function o() {
      const a = r(), c = [];
      for (let u = 0; u < a; u++)
        c.push(s());
      return c;
    }
    return o();
  }
  /**
   * Pre-estimate the transaction fees for a Taproot transaction
   * @param {bigint} feeRate - The fee rate in satoshis per virtual byte
   * @param {bigint} numInputs - The number of inputs
   * @param {bigint} numOutputs - The number of outputs
   * @param {bigint} numWitnessElements - The number of witness elements (e.g., number of control blocks and witnesses)
   * @param {bigint} witnessElementSize - The average size of each witness element in bytes
   * @param {bigint} emptyWitness - The amount of empty witnesses
   * @param {bigint} [taprootControlWitnessSize=139n] - The size of the control block witness in bytes
   * @param {bigint} [taprootScriptSize=32n] - The size of the taproot script in bytes
   * @returns {bigint} - The estimated transaction fees
   */
  static preEstimateTaprootTransactionFees(t, e, i, r, s, o, a = 32n, c = 139n) {
    const u = 10n, l = 41n, h = 68n, d = 1n, p = u + l * e + h * i, y = e * d + r * s + a * e + c * e + o;
    return (p * 3n + (p + y)) / 4n * t;
  }
  static signInput(t, e, i, r, s) {
    s && s[0] && (e.sighashType = s[0]), t.signInput(i, r, s.length ? s : void 0);
  }
  /**
   * Calculate the sign hash number
   * @description Calculates the sign hash
   * @protected
   * @returns {number}
   */
  static calculateSignHash(t) {
    if (!t)
      throw new Error("Sighash types are required");
    let e = 0;
    for (const i of t)
      e |= i;
    return e || 0;
  }
  [Symbol.dispose]() {
    this.inputs.length = 0, this.scriptData = null, this.tapData = null, this.tapLeafScript = null, delete this.tweakedSigner, this.csvInputIndices.clear(), this.anchorInputIndices.clear(), this.inputSignerMap.clear(), this.tweakedSignerCache.clear(), delete this.parallelSigningConfig;
  }
  /**
   * Check if address rotation mode is enabled.
   */
  isAddressRotationEnabled() {
    return this.addressRotationEnabled;
  }
  ignoreSignatureError() {
    this.ignoreSignatureErrors = true;
  }
  /**
   * @description Returns the script address
   * @returns {string}
   */
  getScriptAddress() {
    if (!this.scriptData || !this.scriptData.address)
      throw new Error("Tap data is required");
    return this.scriptData.address;
  }
  /**
   * @description Returns the transaction
   * @returns {Transaction}
   */
  getTransaction() {
    return this.transaction.extractTransaction(false);
  }
  /**
   * @description Returns the tap address
   * @returns {string}
   * @throws {Error} - If tap data is not set
   */
  getTapAddress() {
    if (!this.tapData || !this.tapData.address)
      throw new Error("Tap data is required");
    return this.tapData.address;
  }
  /**
   * @description Disables replace by fee on the transaction
   */
  disableRBF() {
    if (this.signed) throw new Error("Transaction is already signed");
    this.sequence = 4294967295;
    for (const t of this.inputs)
      this.csvInputIndices.has(this.inputs.indexOf(t)) || (t.sequence = 4294967295);
  }
  /**
   * Get the tweaked hash
   * @private
   *
   * @returns {Uint8Array | undefined} The tweaked hash
   */
  getTweakerHash() {
    var _a37;
    return (_a37 = this.tapData) == null ? void 0 : _a37.hash;
  }
  /**
   * Pre-estimate the transaction fees
   * @param {bigint} feeRate - The fee rate
   * @param {bigint} numInputs - The number of inputs
   * @param {bigint} numOutputs - The number of outputs
   * @param {bigint} numSignatures - The number of signatures
   * @param {bigint} numPubkeys - The number of public keys
   * @returns {bigint} - The estimated transaction fees
   */
  preEstimateTransactionFees(t, e, i, r, s) {
    const o = 10n, a = 41n, c = 68n, u = 144n, l = 34n, h = o + a * e + c * i, d = 1n + s * (1n + l) + 1n + r, p = r * u + s * l + d;
    return (h * 3n + (h + p)) / 4n * t;
  }
  /**
   * Get the signer for a specific input index.
   * Returns the input-specific signer if in rotation mode, otherwise the default signer.
   * @param inputIndex - The index of the input
   */
  getSignerForInput(t) {
    if (this.addressRotationEnabled) {
      const e = this.inputSignerMap.get(t);
      if (e)
        return e;
    }
    return this.signer;
  }
  /**
   * Register a signer for a specific input index.
   * Called during UTXO processing to map each input to its signer.
   * @param inputIndex - The index of the input
   * @param utxo - The UTXO being added
   */
  registerInputSigner(t, e) {
    var _a37;
    if (!this.addressRotationEnabled)
      return;
    if (e.signer) {
      this.inputSignerMap.set(t, e.signer);
      return;
    }
    const i = (_a37 = e.scriptPubKey) == null ? void 0 : _a37.address;
    if (i && this.signerMap.has(i)) {
      const r = this.signerMap.get(i);
      if (r) {
        this.inputSignerMap.set(t, r);
        return;
      }
    }
  }
  /**
   * Get the x-only public key for a specific input's signer.
   * Used for taproot inputs in address rotation mode.
   * @param inputIndex - The index of the input
   */
  internalPubKeyToXOnlyForInput(t) {
    const e = this.getSignerForInput(t);
    return $e4(e.publicKey);
  }
  /**
   * Get the tweaked signer for a specific input.
   * Caches the result for efficiency.
   * @param inputIndex - The index of the input
   * @param useTweakedHash - Whether to use the tweaked hash
   */
  getTweakedSignerForInput(t, e = false) {
    if (!this.addressRotationEnabled)
      return e ? (this.tweakSigner(), this.tweakedSigner) : this.getTweakedSigner(e);
    const i = t * 2 + (e ? 1 : 0);
    if (this.tweakedSignerCache.has(i))
      return this.tweakedSignerCache.get(i);
    const r = this.getSignerForInput(t), s = this.getTweakedSigner(e, r);
    return this.tweakedSignerCache.set(i, s), s;
  }
  generateTapData() {
    return this.useP2MR ? {
      network: this.network,
      name: ft4.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      name: ft4.P2TR
    };
  }
  /**
   * Generates the script address.
   * @protected
   * @returns {TapPayment}
   */
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      name: ft4.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      name: ft4.P2TR
    };
  }
  /**
   * Returns the signer key.
   * @protected
   * @returns {Signer | UniversalSigner}
   */
  getSignerKey() {
    return this.signer;
  }
  /**
   * Signs an input of the transaction.
   * @param {Psbt} transaction - The transaction to sign
   * @param {PsbtInput} input - The input to sign
   * @param {number} i - The index of the input
   * @param {Signer} signer - The signer to use
   * @param {boolean} [reverse=false] - Should the input be signed in reverse
   * @param {boolean} [errored=false] - Was there an error
   * @protected
   */
  async signInput(t, e, i, r, s = false, o = false) {
    if (this.anchorInputIndices.has(i)) return;
    const a = r.publicKey;
    let c = me4(e);
    s && (c = !c);
    let u = false, l = false;
    if (c)
      try {
        await this.attemptSignTaproot(t, e, i, r, a), u = true;
      } catch (h) {
        this.error(
          `Failed to sign Taproot script path input ${i} (reverse: ${s}): ${h.message}`
        ), l = true;
      }
    else if (s || Te5(e, a))
      try {
        await this.signNonTaprootInput(r, t, i), u = true;
      } catch (h) {
        this.error(`Failed to sign non-Taproot input ${i}: ${h.stack}`), l = true;
      }
    if (!u) {
      if (l && o)
        throw new Error(`Failed to sign input ${i} with the provided signer.`);
      try {
        await this.signInput(t, e, i, r, true, l);
      } catch {
        throw new Error(`Cannot sign input ${i} with the provided signer.`);
      }
    }
  }
  splitArray(t, e) {
    if (e <= 0)
      throw new Error("Chunk size must be greater than 0.");
    const i = [];
    for (let r = 0; r < t.length; r += e)
      i.push(t.slice(r, r + e));
    return i;
  }
  /**
   * Signs all the inputs of the transaction.
   * @param {Psbt} transaction - The transaction to sign
   * @protected
   * @returns {Promise<void>}
   */
  async signInputs(t) {
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(t);
      return;
    }
    await this.signInputsNonWalletBased(t);
  }
  async signInputsNonWalletBased(t) {
    if (!this.noSignatures)
      if (this.canUseParallelSigning && pt4(this.signer)) {
        let e = /* @__PURE__ */ new Set();
        try {
          const i = await this.signKeyPathInputsParallel(t);
          i.success && (e = new Set(i.signatures.keys()));
        } catch (i) {
          this.error(
            `Parallel signing failed, falling back to sequential: ${i.message}`
          );
        }
        await this.signRemainingInputsSequential(t, e);
      } else
        await this.signInputsSequential(t);
    for (let e = 0; e < t.data.inputs.length; e++)
      t.finalizeInput(e, this.customFinalizerP2SH.bind(this));
    this.finalized = true;
  }
  /**
   * Signs all inputs sequentially in batches of 20.
   * This is the original signing logic, used as fallback when parallel signing is unavailable.
   */
  async signInputsSequential(t) {
    const e = t.data.inputs, i = 20, r = this.splitArray(e, i);
    for (let s = 0; s < r.length; s++) {
      const o = r[s], a = [], c = s * i;
      for (let u = 0; u < o.length; u++) {
        const l = c + u, h = o[u];
        try {
          const d = this.getSignerForInput(l);
          a.push(this.signInput(t, h, l, d));
        } catch (d) {
          this.log(`Failed to sign input ${l}: ${d.stack}`);
        }
      }
      await Promise.all(a);
    }
  }
  /**
   * Signs inputs that were not handled by parallel signing.
   * After parallel key-path signing, script-path taproot inputs, non-taproot inputs,
   * and any inputs that failed parallel signing need sequential signing.
   */
  async signRemainingInputsSequential(t, e) {
    const i = t.data.inputs, r = [];
    for (let a = 0; a < i.length; a++)
      e.has(a) || r.push(a);
    if (r.length === 0) return;
    const o = this.splitArray(r, 20);
    for (const a of o) {
      const c = [];
      for (const u of a) {
        const l = i[u];
        try {
          const h = this.getSignerForInput(u);
          c.push(this.signInput(t, l, u, h));
        } catch (h) {
          this.log(`Failed to sign input ${u}: ${h.stack}`);
        }
      }
      await Promise.all(c);
    }
  }
  /**
   * Converts the public key to x-only.
   * @protected
   * @returns {Uint8Array}
   */
  internalPubKeyToXOnly() {
    return $e4(this.signer.publicKey);
  }
  /**
   * Internal init.
   * @protected
   */
  internalInit() {
    const t = this.generateScriptAddress(), e = this.generateTapData();
    t.name === ft4.P2MR ? this.scriptData = Xf2.p2mr(t) : this.scriptData = Xf2.p2tr(t), e.name === ft4.P2MR ? this.tapData = Xf2.p2mr(e) : this.tapData = Xf2.p2tr(e);
  }
  /**
   * Tweak the signer for the interaction
   * @protected
   */
  tweakSigner() {
    if (this.tweakedSigner) return;
    const t = this.getTweakedSigner(true);
    t !== void 0 && (this.tweakedSigner = t);
  }
  /**
   * Get the tweaked signer
   * @private
   * @returns {UniversalSigner} The tweaked signer
   */
  getTweakedSigner(t = false, e = this.signer) {
    const i = {
      network: this.network
    };
    if (t) {
      const r = this.getTweakerHash();
      r !== void 0 && (i.tweakHash = r);
    }
    if (pt4(e))
      return Se4.tweakSigner(e, i);
  }
  /**
   * Signs key-path taproot inputs in parallel using worker threads.
   * @param transaction - The PSBT to sign
   * @param excludeIndices - Input indices to skip (e.g., script-path inputs already signed)
   * @returns The parallel signing result
   */
  async signKeyPathInputsParallel(t, e) {
    const i = this.signer, r = this.getTweakedSigner(true);
    if (!r)
      throw new Error("Cannot create tweaked signer for parallel signing");
    const s = si3(i, r), o = mp2(t, s), a = e ? o.filter((l) => !e.has(l.inputIndex)) : o;
    if (a.length === 0)
      return {
        success: true,
        signatures: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map(),
        durationMs: 0
      };
    let c, u = false;
    this.parallelSigningConfig && "signBatch" in this.parallelSigningConfig ? c = this.parallelSigningConfig : (c = bp2.getInstance(this.parallelSigningConfig), c.isPreservingWorkers || (u = true));
    try {
      await c.initialize();
      const l = await c.signBatch(a, s);
      if (l.success)
        Ep2(t, l, s);
      else {
        const d = [...l.errors.entries()].map(([p, y]) => `Input ${p}: ${y}`).join(", ");
        this.error(`Parallel signing had errors: ${d}`);
      }
      return l;
    } finally {
      u && await c.shutdown();
    }
  }
  generateP2SHRedeemScript(t) {
    const e = Xf2.p2wsh({
      redeem: { output: t },
      network: this.network
    });
    return Xf2.p2sh({
      redeem: e,
      network: this.network
    }).output;
  }
  generateP2SHRedeemScriptLegacy(t) {
    const e = Zh2.hash160(this.signer.publicKey), i = Vh2.compile([
      q2.OP_DUP,
      q2.OP_HASH160,
      e,
      q2.OP_EQUALVERIFY,
      q2.OP_CHECKSIG
    ]), r = Zh2.hash160(i), s = Vh2.compile([
      q2.OP_HASH160,
      r,
      q2.OP_EQUAL
    ]), o = Xf2.p2wsh({
      redeem: { output: i },
      // Use the custom redeem script
      network: this.network
    }), a = Xf2.p2sh({
      redeem: o,
      // The P2WSH is wrapped inside the P2SH
      network: this.network
    });
    if (Ip2.fromOutputScript(s, this.network) === t && a.redeem && a.redeem.output)
      return {
        redeemScript: i,
        outputScript: a.redeem.output
      };
  }
  generateP2SHP2PKHRedeemScript(t, e) {
    var _a37;
    const r = (this.addressRotationEnabled && e !== void 0 ? this.getSignerForInput(e) : this.signer).publicKey, s = Xf2.p2wpkh({
      pubkey: r,
      network: this.network
    }), o = Xf2.p2sh({
      redeem: s,
      network: this.network
    }), a = o.address;
    if (!((_a37 = o.redeem) == null ? void 0 : _a37.output))
      throw new Error("Failed to generate P2SH-P2WPKH redeem script");
    if (a === t && o.redeem && o.redeem.output && o.output)
      return {
        redeemScript: o.redeem.output,
        outputScript: o.output
      };
  }
  /**
   * Generate the PSBT input extended, supporting various script types
   * @param {UTXO} utxo The UTXO
   * @param {number} i The index of the input
   * @param {UTXO} _extra Extra UTXO
   * @protected
   * @returns {PsbtInputExtended} The PSBT input extended
   */
  generatePsbtInputExtended(t, e, i = false) {
    var _a37;
    const r = Mt3(t.scriptPubKey.hex), s = {
      hash: t.transactionId,
      index: t.outputIndex,
      sequence: this.sequence,
      witnessUtxo: {
        value: t.value,
        script: r
      }
    };
    if (mf2(r))
      if (t.nonWitnessUtxo)
        s.nonWitnessUtxo = t.nonWitnessUtxo instanceof Uint8Array ? t.nonWitnessUtxo : Mt3(t.nonWitnessUtxo);
      else
        throw new Error("Missing nonWitnessUtxo for P2PKH UTXO");
    else if (!(pn2(r) || Qo2(r))) if (ps2(r))
      this.processP2WSHInput(t, s, e);
    else if (Go2(r)) {
      let o;
      if (t.redeemScript)
        o = t.redeemScript instanceof Uint8Array ? t.redeemScript : Mt3(t.redeemScript);
      else {
        if (!t.scriptPubKey.address)
          throw new Error(
            "Missing redeemScript and no address to regenerate it for P2SH UTXO"
          );
        const u = this.generateP2SHP2PKHRedeemScript(
          t.scriptPubKey.address,
          e
        );
        if (!u)
          throw new Error("Missing redeemScript for P2SH UTXO and unable to regenerate");
        o = u.redeemScript;
      }
      s.redeemScript = o;
      const a = Xf2.p2sh({ redeem: { output: s.redeemScript } });
      if (!a.redeem)
        throw new Error("Failed to extract redeem script from P2SH UTXO");
      const c = a.redeem.output;
      if (!c)
        throw new Error("Failed to extract redeem output from P2SH UTXO");
      t.nonWitnessUtxo && (s.nonWitnessUtxo = t.nonWitnessUtxo instanceof Uint8Array ? t.nonWitnessUtxo : Mt3(t.nonWitnessUtxo)), pn2(c) ? Reflect.deleteProperty(s, "nonWitnessUtxo") : ps2(c) ? (Reflect.deleteProperty(s, "nonWitnessUtxo"), this.processP2WSHInput(t, s, e)) : Reflect.deleteProperty(s, "witnessUtxo");
    } else if (jo2(r)) {
      if (this.sighashTypes) {
        const o = _Nt.calculateSignHash(this.sighashTypes);
        o && (s.sighashType = o);
      }
      this.addressRotationEnabled ? s.tapInternalKey = this.internalPubKeyToXOnlyForInput(e) : (this.tweakSigner(), s.tapInternalKey = this.internalPubKeyToXOnly());
    } else if (zo2(r)) {
      if (this.sighashTypes) {
        const o = _Nt.calculateSignHash(this.sighashTypes);
        o && (s.sighashType = o);
      }
      e === 0 && ((_a37 = this.tapData) == null ? void 0 : _a37.hash) && (s.tapMerkleRoot = this.tapData.hash);
    } else if (yp2(r))
      this.anchorInputIndices.add(e), s.isPayToAnchor = true;
    else if (bf2(r) || yf2(r))
      if (t.nonWitnessUtxo)
        s.nonWitnessUtxo = t.nonWitnessUtxo instanceof Uint8Array ? t.nonWitnessUtxo : Mt3(t.nonWitnessUtxo);
      else
        throw new Error("Missing nonWitnessUtxo for P2PK or P2MS UTXO");
    else
      this.error(`Unknown or unsupported script type for output: ${t.scriptPubKey.hex}`);
    return e === 0 && (this.tapLeafScript && (s.tapLeafScript = [this.tapLeafScript]), this.nonWitnessUtxo && (s.nonWitnessUtxo = this.nonWitnessUtxo)), s;
  }
  processP2WSHInput(t, e, i) {
    if (!t.witnessScript)
      throw new Error("Missing witnessScript for P2WSH UTXO");
    e.witnessScript = t.witnessScript instanceof Uint8Array ? t.witnessScript : Mt3(t.witnessScript);
    const r = Vh2.decompile(e.witnessScript);
    if (r && this.isCSVScript(r)) {
      const s = Vh2.decompile(e.witnessScript);
      if (s && this.isCSVScript(s)) {
        this.csvInputIndices.add(i);
        const o = this.extractCSVBlocks(s);
        e.sequence = this.setCSVSequence(
          o,
          this.sequence
        );
      }
    }
  }
  secondsToCSVTimeUnits(t) {
    return Math.floor(t / 512);
  }
  createTimeBasedCSV(t) {
    const e = this.secondsToCSVTimeUnits(t);
    if (e > 65535)
      throw new Error(`Time units ${e} exceeds maximum of 65,535`);
    return e | 1 << 22;
  }
  isCSVEnabled(t) {
    return (t & 1 << 31) === 0;
  }
  extractCSVValue(t) {
    return t & 65535;
  }
  /**
   * Finalize secondary P2WDA inputs with empty data
   */
  finalizeSecondaryP2WDA(t, e) {
    if (!e.partialSig || e.partialSig.length === 0)
      throw new Error(`No signature for P2WDA input #${t}`);
    if (!e.witnessScript)
      throw new Error(`No witness script for P2WDA input #${t}`);
    const i = Z2.createSimpleP2WDAWitness(
      e.partialSig[0].signature,
      e.witnessScript
    );
    return {
      finalScriptSig: void 0,
      finalScriptWitness: ue4(i)
    };
  }
  async signInputsWalletBased(t) {
    await this.signer.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
    this.finalized = true;
  }
  isCSVScript(t) {
    return t.some((e) => e === q2.OP_CHECKSEQUENCEVERIFY);
  }
  setCSVSequence(t, e) {
    if (this.txVersion < 2)
      throw new Error("CSV requires transaction version 2 or higher");
    if (t > 65535)
      throw new Error(`CSV blocks ${t} exceeds maximum of 65,535`);
    const i = (t & 1 << 22) !== 0;
    let r = t & 65535;
    return i && (r |= 1 << 22), e === 4294967293 && (r |= 1 << 25), r = r & 2147483647, r;
  }
  getCSVType(t) {
    return t & 1 << 22 ? 1 : 0;
  }
  extractCSVBlocks(t) {
    for (let e = 0; e < t.length; e++)
      if (t[e] === q2.OP_CHECKSEQUENCEVERIFY && e > 0) {
        const i = t[e - 1];
        if (i instanceof Uint8Array)
          return Vh2.number.decode(i);
        if (typeof i == "number") {
          if (i === q2.OP_0 || i === q2.OP_FALSE)
            return 0;
          if (i === q2.OP_1NEGATE)
            return -1;
          if (i >= q2.OP_1 && i <= q2.OP_16)
            return i - q2.OP_1 + 1;
          throw new Error(`Unexpected raw number in script: ${i}`);
        }
      }
    return 0;
  }
  async attemptSignTaproot(t, e, i, r, s) {
    if (this.isTaprootScriptSpend(e, s))
      await this.signTaprootInput(r, t, i);
    else {
      let a;
      if (r !== this.signer ? a = this.getTweakedSigner(true, r) : (this.tweakedSigner || this.tweakSigner(), a = this.tweakedSigner), a)
        try {
          await this.signTaprootInput(a, t, i);
        } catch (c) {
          if (a = this.getTweakedSigner(false, this.signer), !a)
            throw new Error(`Failed to obtain tweaked signer for input ${i}.`, {
              cause: c
            });
          await this.signTaprootInput(a, t, i);
        }
      else
        this.error(`Failed to obtain tweaked signer for input ${i}.`);
    }
  }
  isTaprootScriptSpend(t, e) {
    if (t.tapLeafScript && t.tapLeafScript.length > 0) {
      for (const i of t.tapLeafScript)
        if (be3(e, i.script))
          return true;
    }
    return false;
  }
  async signTaprootInput(t, e, i, r) {
    if ("signTaprootInput" in t)
      try {
        await t.signTaprootInput(e, i, r);
      } catch {
        throw new Error("Failed to sign Taproot input with provided signer.");
      }
    else
      e.signTaprootInput(i, t);
  }
  async signNonTaprootInput(t, e, i) {
    "signInput" in t ? await t.signInput(e, i) : e.signInput(i, t);
  }
};
function vt5(n) {
  return `${n.messagePrefix}|${n.bech32}`;
}
var Ir3 = /* @__PURE__ */ new Map([
  [
    vt5(ap2.bitcoin),
    new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      25,
      214,
      104,
      156,
      8,
      90,
      225,
      101,
      131,
      30,
      147,
      79,
      247,
      99,
      174,
      70,
      162,
      166,
      193,
      114,
      179,
      241,
      182,
      10,
      140,
      226,
      111
    ])
  ],
  [
    vt5(ap2.testnet),
    new Uint8Array([
      0,
      0,
      0,
      0,
      9,
      51,
      234,
      1,
      173,
      14,
      233,
      132,
      32,
      151,
      121,
      186,
      174,
      195,
      206,
      217,
      15,
      163,
      244,
      8,
      113,
      149,
      38,
      248,
      215,
      127,
      73,
      67
    ])
  ],
  [
    vt5(ap2.opnetTestnet),
    new Uint8Array([
      0,
      0,
      1,
      127,
      133,
      16,
      107,
      31,
      238,
      175,
      47,
      112,
      241,
      226,
      184,
      5,
      152,
      91,
      181,
      117,
      248,
      143,
      155,
      11,
      165,
      117,
      61,
      47,
      60,
      241,
      50,
      115
    ])
  ],
  [
    vt5(ap2.regtest),
    new Uint8Array([
      15,
      145,
      136,
      241,
      60,
      183,
      178,
      199,
      31,
      42,
      51,
      94,
      58,
      79,
      195,
      40,
      191,
      91,
      235,
      67,
      96,
      18,
      175,
      202,
      89,
      11,
      26,
      17,
      70,
      110,
      34,
      6
    ])
  ]
]);
function Ce5(n) {
  const t = Ir3.get(vt5(n));
  if (!t) throw new Error("Unsupported network for chain ID retrieval");
  return t.slice();
}
var Ne3 = new Uint8Array([
  231,
  132,
  153,
  90,
  65,
  45,
  119,
  57,
  136,
  196,
  184,
  227,
  51,
  215,
  179,
  157,
  251,
  60,
  171,
  241,
  24,
  208,
  214,
  69,
  65,
  26,
  145,
  108,
  162,
  64,
  121,
  57
]);
var j3 = 330n;
var Ot4 = 297n;
var le3 = Mt3("51024e73");
var _E8 = class _E8 extends Nt4 {
  constructor(t) {
    super(t);
    __publicField(this, "logColor", "#785def");
    __publicField(this, "debugFees", false);
    // Cancel script
    __publicField(this, "LOCK_LEAF_SCRIPT");
    /**
     * @description The overflow fees of the transaction
     * @public
     */
    __publicField(this, "overflowFees", 0n);
    /**
     * @description Cost in satoshis of the transaction fee
     */
    __publicField(this, "transactionFee", 0n);
    /**
     * @description The estimated fees of the transaction
     */
    __publicField(this, "estimatedFees", 0n);
    /**
     * @param {ITransactionParameters} parameters - The transaction parameters
     */
    __publicField(this, "optionalOutputs");
    /**
     * @description The transaction itself.
     */
    __publicField(this, "transaction");
    /**
     * @description Inputs to update later on.
     */
    __publicField(this, "updateInputs", []);
    /**
     * @description The outputs of the transaction
     */
    __publicField(this, "outputs", []);
    /**
     * @description Output that will be used to pay the fees
     */
    __publicField(this, "feeOutput", null);
    /**
     * @description The total amount of satoshis in the inputs
     */
    __publicField(this, "totalInputAmount");
    /**
     * @description The signer of the transaction
     */
    __publicField(this, "signer");
    /**
     * @description The network where the transaction will be broadcasted
     */
    __publicField(this, "network");
    /**
     * @description The fee rate of the transaction
     */
    __publicField(this, "feeRate");
    /**
     * @description The opnet priority fee of the transaction
     */
    __publicField(this, "priorityFee");
    __publicField(this, "gasSatFee");
    /**
     * @description The utxos used in the transaction
     */
    __publicField(this, "utxos");
    /**
     * @description The inputs of the transaction
     * @protected
     */
    __publicField(this, "optionalInputs");
    /**
     * @description The address where the transaction is sent to
     * @protected
     */
    __publicField(this, "to");
    /**
     * @description The address where the transaction is sent from
     * @protected
     */
    __publicField(this, "from");
    /**
     * @description The maximum fee rate of the transaction
     */
    __publicField(this, "_maximumFeeRate", 1e8);
    /**
     * @description Is the destionation P2PK
     * @protected
     */
    __publicField(this, "isPubKeyDestination");
    /**
     * @description If the transaction need an anchor output
     * @protected
     */
    __publicField(this, "anchor");
    __publicField(this, "note");
    __publicField(this, "optionalOutputsAdded", false);
    if (t.estimatedFees && (this.estimatedFees = t.estimatedFees), this.signer = t.signer, this.network = t.network, this.feeRate = t.feeRate, this.priorityFee = t.priorityFee ?? 0n, this.gasSatFee = t.gasSatFee ?? 0n, this.utxos = t.utxos, this.optionalInputs = t.optionalInputs || [], this.to = t.to || void 0, this.debugFees = t.debugFees || false, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), t.note && (typeof t.note == "string" ? this.note = new TextEncoder().encode(t.note) : this.note = t.note), this.anchor = t.anchor ?? false, this.isPubKeyDestination = this.to ? Q2.isValidPublicKey(this.to, this.network) : false, this.optionalOutputs = t.optionalOutputs, this.from = _E8.getFrom(t.from, this.signer, this.network), this.totalInputAmount = this.calculateTotalUTXOAmount(), this.calculateTotalVOutAmount() < this.totalInputAmount)
      throw new Error("Vout value is less than the value to send");
    this.transaction = new Xn2({
      network: this.network,
      version: this.txVersion
    });
  }
  static getFrom(t, e, i) {
    return t || P2.getTaprootAddress(e, i);
  }
  /**
   * @description Converts the witness stack to a script witness
   * @param {Uint8Array[]} witness - The witness stack
   * @protected
   * @returns {Uint8Array}
   */
  static witnessStackToScriptWitness(t) {
    return ue4(t);
  }
  [Symbol.dispose]() {
    super[Symbol.dispose](), this.updateInputs.length = 0, this.outputs.length = 0, this.feeOutput = null, this.optionalOutputs = void 0, this.utxos = [], this.optionalInputs = [];
  }
  addOPReturn(t) {
    const e = Vh2.compile([q2.OP_RETURN, t]);
    this.addOutput({
      value: dp2(0n),
      script: e
    });
  }
  addAnchor() {
    this.addOutput({
      value: dp2(0n),
      script: le3
    });
  }
  async getFundingTransactionParameters() {
    return this.estimatedFees || (this.estimatedFees = await this.estimateTransactionFees()), {
      utxos: this.utxos,
      to: this.getScriptAddress(),
      signer: this.signer,
      network: this.network,
      feeRate: this.feeRate,
      priorityFee: this.priorityFee ?? 0n,
      gasSatFee: this.gasSatFee ?? 0n,
      from: this.from,
      amount: this.estimatedFees,
      optionalInputs: this.optionalInputs,
      mldsaSigner: null,
      ...this.optionalOutputs !== void 0 ? { optionalOutputs: this.optionalOutputs } : {}
    };
  }
  /**
   * Set the destination address of the transaction
   * @param {string} address - The address to set
   */
  setDestinationAddress(t) {
    this.to = t;
  }
  /**
   * Set the maximum fee rate of the transaction in satoshis per byte
   * @param {number} feeRate - The fee rate to set
   * @public
   */
  setMaximumFeeRate(t) {
    this._maximumFeeRate = t;
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Transaction>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signTransaction() {
    if (!this.utxos.length)
      throw new Error("No UTXOs specified");
    if (this.to && !this.isPubKeyDestination && !P2.verifyContractAddress(this.to, this.network))
      throw new Error(
        "Invalid contract address. The contract address must be a taproot address."
      );
    if (this.signed) throw new Error("Transaction is already signed");
    if (this.signed = true, await this.buildTransaction(), await this.internalBuildTransaction(this.transaction)) {
      if (this.regenerated)
        throw new Error("Transaction was regenerated");
      return this.transaction.extractTransaction(true, true);
    }
    throw new Error("Could not sign transaction");
  }
  /**
   * @description Generates the transaction minimal signatures
   * @public
   */
  async generateTransactionMinimalSignatures(t = false) {
    if (this.to && !this.isPubKeyDestination && !P2.verifyContractAddress(this.to, this.network))
      throw new Error(
        "Invalid contract address. The contract address must be a taproot address."
      );
    if (await this.buildTransaction(), this.transaction.data.inputs.length === 0) {
      const e = this.getInputs(), i = this.getOutputs();
      this.transaction.setMaximumFeeRate(this._maximumFeeRate), this.transaction.addInputs(e, t);
      for (let r = 0; r < this.updateInputs.length; r++)
        this.transaction.updateInput(r, this.updateInputs[r]);
      this.transaction.addOutputs(i);
    }
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Psbt>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signPSBT() {
    if (await this.signTransaction())
      return this.transaction;
    throw new Error("Could not sign transaction");
  }
  /**
   * Add an input to the transaction.
   * @param {PsbtInputExtended} input - The input to add
   * @public
   * @returns {void}
   */
  addInput(t) {
    this.inputs.push(t);
  }
  /**
   * Add an output to the transaction.
   * @param {PsbtOutputExtended} output - The output to add
   * @param bypassMinCheck
   * @public
   * @returns {void}
   */
  addOutput(t, e = false) {
    if (t.value === dp2(0n)) {
      const i = t;
      if (!i.script || i.script.length === 0)
        throw new Error("Output value is 0 and no script provided");
      if (i.script.length < 2)
        throw new Error("Output script is too short");
      if (i.script[0] !== q2.OP_RETURN && !P(i.script, le3))
        throw new Error(
          "Output script must start with OP_RETURN or be an ANCHOR when value is 0"
        );
    } else if (!e && BigInt(t.value) < _E8.MINIMUM_DUST)
      throw new Error(
        `Output value is less than the minimum dust ${t.value} < ${_E8.MINIMUM_DUST}`
      );
    this.outputs.push(t);
  }
  /**
   * Returns the total value of all outputs added so far (excluding the fee/change output).
   * @public
   * @returns {bigint}
   */
  getTotalOutputValue() {
    return this.outputs.reduce((t, e) => t + BigInt(e.value), 0n);
  }
  /**
   * Receiver address.
   * @public
   * @returns {string} - The receiver address
   */
  toAddress() {
    return this.to;
  }
  /**
   * @description Returns the script address
   * @returns {string} - The script address
   */
  address() {
    var _a37;
    return (_a37 = this.tapData) == null ? void 0 : _a37.address;
  }
  /**
   * Estimates the transaction fees with accurate size calculation.
   *
   * @note The P2TR estimation is made for a 2-leaf tree with both a tapScriptSig and a tapInternalKey input, which is a common case for many transactions.
   * This provides a more accurate fee estimation for typical P2TR transactions, but may not be perfectly accurate for all possible script configurations.
   * Adjustments may be needed for more complex scripts or different leaf structures.
   *
   * @public
   * @returns {Promise<bigint>}
   */
  async estimateTransactionFees() {
    await Promise.resolve();
    const t = new Xn2({ network: this.network }), e = this.getInputs(), i = this.getOutputs();
    t.addInputs(e), t.addOutputs(i);
    const r = new Uint8Array(64), s = new Uint8Array(72), o = new Uint8Array(33).fill(2), a = (d, p) => {
      var _a37, _b9;
      if (p.isPayToAnchor || this.anchorInputIndices.has(d))
        return {
          finalScriptSig: void 0,
          finalScriptWitness: Uint8Array.from([0])
        };
      if (p.witnessScript && Z2.isP2WDAWitnessScript(p.witnessScript)) {
        const m = [];
        for (let x = 0; x < 10; x++)
          m.push(new Uint8Array(0));
        const A = new Uint8Array(72);
        return {
          finalScriptWitness: _E8.witnessStackToScriptWitness([
            ...m,
            A,
            p.witnessScript
          ])
        };
      }
      if (d === 0 && this.tapLeafScript) {
        const m = new Uint8Array(32), A = this.tapLeafScript.script, x = this.useP2MR ? 33 : 65, W3 = new Uint8Array(x);
        return {
          finalScriptWitness: _E8.witnessStackToScriptWitness([
            m,
            r,
            // It's a tapScriptSig, which is Schnorr
            r,
            // Second Schnorr signature
            A,
            W3
          ])
        };
      }
      if (p.witnessUtxo) {
        const m = p.witnessUtxo.script, A = vp2.script.decompile(m);
        if (A && A.length === 5 && A[0] === q2.OP_DUP && A[1] === q2.OP_HASH160 && A[3] === q2.OP_EQUALVERIFY && A[4] === q2.OP_CHECKSIG)
          return {
            finalScriptSig: vp2.script.compile([
              s,
              o
            ]),
            finalScriptWitness: void 0
          };
      }
      if (p.witnessScript) {
        if (this.csvInputIndices.has(d))
          return {
            finalScriptWitness: _E8.witnessStackToScriptWitness([
              s,
              p.witnessScript
            ])
          };
        if (p.redeemScript) {
          const A = [s, p.witnessScript];
          return {
            finalScriptSig: p.redeemScript,
            finalScriptWitness: _E8.witnessStackToScriptWitness(A)
          };
        }
        const m = vp2.script.decompile(p.witnessScript);
        if (m && m.length >= 4) {
          const A = m[0], x = m[m.length - 1];
          if (typeof A == "number" && A >= q2.OP_1 && x === q2.OP_CHECKMULTISIG) {
            const W3 = A - q2.OP_1 + 1, ut4 = [];
            for (let ft5 = 0; ft5 < W3; ft5++)
              ut4.push(s);
            return {
              finalScriptWitness: _E8.witnessStackToScriptWitness([
                new Uint8Array(0),
                // OP_0 due to multisig bug
                ...ut4,
                p.witnessScript
              ])
            };
          }
        }
        return {
          finalScriptWitness: _E8.witnessStackToScriptWitness([
            s,
            p.witnessScript
          ])
        };
      } else if (p.redeemScript) {
        const m = vp2.script.decompile(p.redeemScript);
        if (m && m.length === 2 && m[0] === q2.OP_0 && m[1] instanceof Uint8Array && m[1].length === 20)
          return {
            finalScriptSig: p.redeemScript,
            finalScriptWitness: _E8.witnessStackToScriptWitness([
              s,
              o
            ])
          };
      }
      if (p.redeemScript && !p.witnessScript && !p.witnessUtxo)
        return {
          finalScriptSig: vp2.script.compile([s, p.redeemScript]),
          finalScriptWitness: void 0
        };
      const y = (_a37 = p.witnessUtxo) == null ? void 0 : _a37.script;
      return y ? p.tapInternalKey ? {
        finalScriptWitness: _E8.witnessStackToScriptWitness([
          r
        ])
      } : y.length === 22 && y[0] === q2.OP_0 ? {
        finalScriptWitness: _E8.witnessStackToScriptWitness([
          s,
          o
        ])
      } : ((_b9 = p.redeemScript) == null ? void 0 : _b9.length) === 22 && p.redeemScript[0] === q2.OP_0 ? {
        finalScriptWitness: _E8.witnessStackToScriptWitness([
          s,
          o
        ])
      } : op2(
        d,
        p,
        y,
        true,
        !!p.redeemScript,
        !!p.witnessScript
      ) : { finalScriptSig: void 0, finalScriptWitness: void 0 };
    };
    try {
      for (let d = 0; d < t.data.inputs.length; d++) {
        const p = e[d];
        p && t.finalizeInput(d, (y) => a(y, p));
      }
    } catch (d) {
      this.warn(`Could not finalize dummy tx: ${d.message}`);
    }
    const u = t.extractTransaction(true, true).virtualSize(), l = this.feeRate * u, h = BigInt(Math.ceil(l));
    return this.debugFees && this.log(
      `Estimating fees: feeRate=${this.feeRate}, accurate_vSize=${u}, fee=${h}n`
    ), h;
  }
  async rebuildFromBase64(t) {
    return this.transaction = Xn2.fromBase64(t, {
      network: this.network,
      version: this.txVersion
    }), this.signed = false, this.sighashTypes = [rt4.SIGHASH_ANYONECANPAY, rt4.SIGHASH_ALL], await this.signPSBT();
  }
  setPSBT(t) {
    this.transaction = t;
  }
  /**
   * Returns the inputs of the transaction.
   * @protected
   * @returns {PsbtInputExtended[]}
   */
  getInputs() {
    return this.inputs;
  }
  /**
   * Returns the outputs of the transaction.
   * @protected
   * @returns {PsbtOutputExtended[]}
   */
  getOutputs() {
    const t = [...this.outputs];
    return this.feeOutput && t.push(this.feeOutput), t;
  }
  getOptionalOutputValue() {
    if (!this.optionalOutputs) return 0n;
    let t = 0n;
    for (let e = 0; e < this.optionalOutputs.length; e++)
      t += BigInt(this.optionalOutputs[e].value);
    return t;
  }
  async addRefundOutput(t, e = false) {
    this.note && this.addOPReturn(this.note), this.anchor && this.addAnchor(), this.feeOutput = this.createChangeOutput(_E8.MINIMUM_DUST);
    const i = await this.estimateTransactionFees(), r = this.totalInputAmount - t - i;
    if (this.debugFees && this.log(
      `Fee with change: ${i} sats, inputAmount=${this.totalInputAmount}, amountSpent=${t}, sendBackAmount=${r}`
    ), r >= _E8.MINIMUM_DUST)
      this.feeOutput = this.createChangeOutput(r), this.overflowFees = r, this.transactionFee = i;
    else {
      this.feeOutput = null, this.overflowFees = 0n;
      const s = await this.estimateTransactionFees();
      if (this.transactionFee = s, this.debugFees && this.warn(
        `Amount to send back (${r} sat) is less than minimum dust. Fee without change: ${s} sats`
      ), this.totalInputAmount <= t)
        throw new Error(
          `Insufficient funds: need ${t + s} sats but only have ${this.totalInputAmount} sats`
        );
      if (e && r < 0n)
        throw new Error(
          `Insufficient funds: need at least ${-r} more sats to cover fees.`
        );
    }
    this.debugFees && this.log(
      `Final fee: ${this.transactionFee} sats, Change output: ${this.feeOutput ? `${this.feeOutput.value} sats` : "none"}`
    );
  }
  defineLockScript() {
    return Vh2.compile([$e4(this.signer.publicKey), q2.OP_CHECKSIG]);
  }
  /**
   * @description Adds the value to the output
   * @param {number | bigint} value - The value to add
   * @protected
   * @returns {void}
   */
  addValueToToOutput(t) {
    if (BigInt(t) < _E8.MINIMUM_DUST)
      throw new Error(
        `Value to send is less than the minimum dust ${t} < ${_E8.MINIMUM_DUST}`
      );
    for (let e = 0; e < this.outputs.length; e++) {
      const i = this.outputs[e];
      if ("address" in i && i.address === this.to) {
        this.outputs[e] = {
          ...i,
          value: dp2(BigInt(i.value) + BigInt(t))
        };
        return;
      }
    }
    throw new Error("Output not found");
  }
  generateLegacySignature() {
    if (this.tweakSigner(), !this.tweakedSigner)
      throw new Error("Tweaked signer is not defined");
    const t = $e4(this.tweakedSigner.publicKey), e = this.signer.publicKey;
    if (e.length !== 33)
      throw new Error("Original public key must be compressed (33 bytes)");
    const i = Ce5(this.network), r = new V();
    r.writeU8($b.MLDSASecurityLevel.LEVEL2), r.writeBytes(this.hashedPublicKey), r.writeBytes(t), r.writeBytes(e), r.writeBytes(Ne3), r.writeBytes(i);
    const s = r.getBuffer(), o = ct4.signMessage(this.tweakedSigner, s);
    if (!ct4.verifySignature(t, s, o.signature))
      throw new Error("Could not verify generated legacy signature for MLDSA link request");
    return new Uint8Array(o.signature);
  }
  generateMLDSASignature() {
    if (!this.mldsaSigner)
      throw new Error("MLDSA signer is not defined");
    if (this.tweakSigner(), !this.tweakedSigner)
      throw new Error("Tweaked signer is not defined");
    const t = $e4(this.tweakedSigner.publicKey), e = this.signer.publicKey;
    if (e.length !== 33)
      throw new Error("Original public key must be compressed (33 bytes)");
    const i = Ce5(this.network), r = ce4(this.mldsaSigner.publicKey.length);
    if (r !== $b.MLDSASecurityLevel.LEVEL2)
      throw new Error("Only MLDSA level 2 is supported for link requests");
    const s = new V();
    s.writeU8(r), s.writeBytes(this.hashedPublicKey), s.writeBytes(this.mldsaSigner.publicKey), s.writeBytes(t), s.writeBytes(e), s.writeBytes(Ne3), s.writeBytes(i);
    const o = s.getBuffer(), a = ct4.signMLDSAMessage(this.mldsaSigner, o);
    if (!ct4.verifyMLDSASignature(
      this.mldsaSigner,
      o,
      a.signature
    ))
      throw new Error("Could not verify generated MLDSA signature for link request");
    return new Uint8Array(a.signature);
  }
  generateMLDSALinkRequest(t, e) {
    const i = this.mldsaSigner, r = this.generateLegacySignature();
    let s = null;
    t.revealMLDSAPublicKey && (s = this.generateMLDSASignature());
    const o = {
      priority: et4.MLDSA_LINK_PUBKEY,
      opcode: $3.MLDSA_LINK_PUBKEY,
      data: {
        verifyRequest: !!t.revealMLDSAPublicKey,
        publicKey: i.publicKey,
        hashedPublicKey: this.hashedPublicKey,
        level: ce4(i.publicKey.length),
        legacySignature: r,
        mldsaSignature: s
      }
    };
    e.push(o);
  }
  /**
   * @description Returns the transaction opnet fee
   * @protected
   * @returns {bigint}
   */
  getTransactionOPNetFee() {
    const t = this.priorityFee + this.gasSatFee;
    return t > _E8.MINIMUM_DUST ? t : _E8.MINIMUM_DUST;
  }
  /**
   * @description Returns the total amount of satoshis in the inputs
   * @protected
   * @returns {bigint}
   */
  calculateTotalUTXOAmount() {
    let t = 0n;
    for (const e of this.utxos)
      t += e.value;
    for (const e of this.optionalInputs)
      t += e.value;
    return t;
  }
  /**
   * @description Returns the total amount of satoshis in the outputs
   * @protected
   * @returns {bigint}
   */
  calculateTotalVOutAmount() {
    let t = 0n;
    for (const e of this.utxos)
      t += e.value;
    for (const e of this.optionalInputs)
      t += e.value;
    return t;
  }
  /**
   * @description Adds optional outputs to transaction and returns their total value in satoshi to calculate refund transaction
   * @protected
   * @returns {bigint}
   */
  addOptionalOutputsAndGetAmount() {
    if (!this.optionalOutputs || this.optionalOutputsAdded) return 0n;
    let t = 0n;
    for (let e = 0; e < this.optionalOutputs.length; e++)
      this.addOutput(this.optionalOutputs[e]), t += BigInt(
        this.optionalOutputs[e].value
      );
    return this.optionalOutputsAdded = true, t;
  }
  /**
   * @description Adds the inputs from the utxos
   * @protected
   * @returns {void}
   */
  addInputsFromUTXO() {
    if (this.utxos.length) {
      if (this.totalInputAmount < _E8.MINIMUM_DUST)
        throw new Error(
          `Total input amount is ${this.totalInputAmount} sat which is less than the minimum dust ${_E8.MINIMUM_DUST} sat.`
        );
      for (let t = 0; t < this.utxos.length; t++) {
        const e = this.utxos[t];
        this.registerInputSigner(t, e);
        const i = this.generatePsbtInputExtended(e, t);
        this.addInput(i);
      }
    }
    if (this.optionalInputs)
      for (let t = this.utxos.length; t < this.optionalInputs.length + this.utxos.length; t++) {
        const e = this.optionalInputs[t - this.utxos.length];
        this.registerInputSigner(t, e);
        const i = this.generatePsbtInputExtended(e, t, true);
        this.addInput(i);
      }
  }
  /**
   * Internal init.
   * @protected
   */
  internalInit() {
    this.verifyUTXOValidity(), super.internalInit();
  }
  /**
   * Add an input update
   * @param {UpdateInput} input - The input to update
   * @protected
   * @returns {void}
   */
  updateInput(t) {
    this.updateInputs.push(t);
  }
  /**
   * Adds the fee to the output.
   * @param amountSpent
   * @param contractAddress
   * @param epochChallenge
   * @param addContractOutput
   * @protected
   */
  addFeeToOutput(t, e, i, r) {
    if (r) {
      let s;
      t > j3 + Ot4 ? s = Ot4 : s = t, this.addOutput(
        {
          value: dp2(s),
          address: e
        },
        true
      ), s === Ot4 && t - Ot4 > j3 && this.addOutput(
        {
          value: dp2(t - s),
          address: i.address
        },
        true
      );
    } else {
      const s = t < j3 ? j3 : t;
      this.addOutput(
        {
          value: dp2(s),
          address: i.address
        },
        true
      );
    }
  }
  /**
   * Returns the witness of the tap transaction.
   * @protected
   * @returns {Uint8Array}
   */
  getWitness() {
    if (!this.tapData || !this.tapData.witness)
      throw new Error("Witness is required");
    if (this.tapData.witness.length === 0)
      throw new Error("Witness is empty");
    return this.tapData.witness[this.tapData.witness.length - 1];
  }
  /**
   * Returns the tap output.
   * @protected
   * @returns {Uint8Array}
   */
  getTapOutput() {
    if (!this.tapData || !this.tapData.output)
      throw new Error("Tap data is required");
    return this.tapData.output;
  }
  /**
   * Verifies that the utxos are valid.
   * @protected
   */
  verifyUTXOValidity() {
    for (const t of this.utxos)
      if (!t.scriptPubKey)
        throw new Error("Address is required");
    for (const t of this.optionalInputs)
      if (!t.scriptPubKey)
        throw new Error("Address is required");
  }
  /**
   * Builds the transaction.
   * @param {Psbt} transaction - The transaction to build
   * @param checkPartialSigs
   * @protected
   * @returns {Promise<boolean>}
   * @throws {Error} - If something went wrong while building the transaction
   */
  async internalBuildTransaction(t, e = false) {
    if (t.data.inputs.length === 0) {
      const i = this.getInputs(), r = this.getOutputs();
      t.setMaximumFeeRate(this._maximumFeeRate), t.addInputs(i, e);
      for (let s = 0; s < this.updateInputs.length; s++)
        t.updateInput(s, this.updateInputs[s]);
      t.addOutputs(r);
    }
    try {
      return await this.signInputs(t), this.finalized && (this.transactionFee = BigInt(t.getFee())), true;
    } catch (i) {
      const r = i;
      this.error(
        `[internalBuildTransaction] Something went wrong while getting building the transaction: ${r.stack}`
      );
    }
    return false;
  }
  createChangeOutput(t) {
    if (Q2.isValidP2TRAddress(this.from, this.network))
      return {
        value: dp2(t),
        address: this.from,
        tapInternalKey: this.internalPubKeyToXOnly()
      };
    if (Q2.isValidPublicKey(this.from, this.network)) {
      const e = Vh2.compile([
        Mt3(this.from.startsWith("0x") ? this.from.slice(2) : this.from),
        q2.OP_CHECKSIG
      ]);
      return {
        value: dp2(t),
        script: e
      };
    } else
      return {
        value: dp2(t),
        address: this.from
      };
  }
};
__publicField(_E8, "MINIMUM_DUST", 330n);
var E = _E8;
var Yt5 = class extends E {
  constructor(t) {
    super(t);
    __publicField(this, "type", b.CUSTOM_CODE);
    /**
     * The contract address
     * @protected
     */
    __publicField(this, "_scriptAddress");
    /**
     * The tap leaf script
     * @private
     */
    __publicField(this, "tapLeafScript", null);
    /**
     * The target script redeem
     * @private
     */
    __publicField(this, "targetScriptRedeem", null);
    /**
     * The left over funds script redeem
     * @private
     */
    __publicField(this, "leftOverFundsScriptRedeem", null);
    /**
     * The compiled target script
     * @private
     */
    __publicField(this, "compiledTargetScript");
    /**
     * The script tree
     * @private
     */
    __publicField(this, "scriptTree");
    /**
     * The deployment bitcoin generator
     * @private
     */
    __publicField(this, "generator");
    /**
     * The contract seed
     * @private
     */
    __publicField(this, "scriptSeed");
    /**
     * The contract signer
     * @private
     */
    __publicField(this, "contractSigner");
    /**
     * The contract salt random bytes
     * @private
     */
    __publicField(this, "randomBytes");
    /**
     * The witnesses
     * @private
     */
    __publicField(this, "witnesses");
    __publicField(this, "annexData");
    /**
     * Finalize the transaction
     * @param _inputIndex
     * @param input
     */
    __publicField(this, "customFinalizer", (t, e) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      const r = this.getScriptSolution(e).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      if (this.annexData && this.annexData.length > 0) {
        let s;
        if (this.annexData[0] === 80)
          s = this.annexData;
        else {
          const o = new Uint8Array(this.annexData.length + 1);
          o[0] = 80, o.set(this.annexData, 1), s = o;
        }
        r.push(s);
      }
      return {
        finalScriptWitness: E.witnessStackToScriptWitness(r)
      };
    });
    if (!t.script) throw new Error("Bitcoin script is required");
    if (!t.witnesses) throw new Error("Witness(es) are required");
    this.witnesses = t.witnesses, this.randomBytes = t.randomBytes || M.rndBytes(), this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.scriptSeed = this.getContractSeed(), this.contractSigner = P2.fromSeedKeyPair(this.scriptSeed, this.network), this.generator = new Ye4(this.internalPubKeyToXOnly(), this.network), this.compiledTargetScript = this.generator.compile(t.script), this.scriptTree = this.getScriptTree(), this.internalInit(), this._scriptAddress = ge4.generatePKSH(this.scriptSeed, this.network);
  }
  /**
   * @description Get the contract address (PKSH)
   */
  get scriptAddress() {
    return this._scriptAddress;
  }
  /**
   * @description Get the P2TR address
   */
  get p2trAddress() {
    return this.to || this.getScriptAddress();
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the contract signer public key
   * @protected
   */
  contractSignerXOnlyPubKey() {
    return $e4(this.contractSigner.publicKey);
  }
  /**
   * Build the transaction
   * @protected
   */
  async buildTransaction() {
    this.to || (this.to = this.getScriptAddress());
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.getTransactionOPNetFee();
    this.addOutput({
      value: dp2(e),
      address: this.to
    }), await this.addRefundOutput(e + this.addOptionalOutputsAndGetAmount());
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.contractSigner) {
      await super.signInputs(t);
      return;
    }
    try {
      t.signInput(0, this.contractSigner);
    } catch {
    }
    t.signInput(0, this.getSignerKey()), t.finalizeInput(0, this.customFinalizer);
    const e = /* @__PURE__ */ new Set([0]);
    if (this.canUseParallelSigning && pt4(this.signer))
      try {
        const i = await this.signKeyPathInputsParallel(t, /* @__PURE__ */ new Set([0]));
        if (i.success)
          for (const r of i.signatures.keys()) e.add(r);
      } catch (i) {
        this.error(`Parallel signing failed: ${i.message}`);
      }
    for (let i = 1; i < t.data.inputs.length; i++)
      e.has(i) || t.signInput(i, this.getSignerKey());
    for (let i = 1; i < t.data.inputs.length; i++)
      try {
        t.finalizeInput(
          i,
          this.customFinalizerP2SH.bind(this)
        );
      } catch {
        t.finalizeInput(i);
      }
  }
  /**
   * Get the tap output
   * @protected
   */
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      name: ft4.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: ft4.P2TR
    };
  }
  /**
   * Generate the tap data
   * @protected
   */
  generateTapData() {
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: ft4.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: ft4.P2TR
    };
  }
  getScriptSolution(t) {
    if (!t.tapScriptSig)
      throw new Error("Tap script signature is required");
    const e = [...this.witnesses];
    if (t.tapScriptSig)
      for (const i of t.tapScriptSig)
        e.push(i.signature);
    return e;
  }
  /**
   * Generate the contract seed for the deployment
   * @private
   */
  getContractSeed() {
    return Zh2.hash256(this.randomBytes);
  }
  /**
   * Generate the redeem scripts
   * @private
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: ft4.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: ft4.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.getLeafScript(),
      redeemVersion: 192
    };
  }
  /**
   * Get the second leaf script
   * @private
   */
  getLeafScript() {
    return this.LOCK_LEAF_SCRIPT;
  }
  /**
   * Get the script tree
   * @private
   */
  getScriptTree() {
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.getLeafScript(),
        version: 192
      }
    ];
  }
};
var Ee5 = class extends E {
  constructor(t) {
    super(t);
    // 1MB
    /**
     * Random salt for the interaction
     * @type {Uint8Array}
     */
    __publicField(this, "randomBytes");
    __publicField(this, "targetScriptRedeem", null);
    __publicField(this, "leftOverFundsScriptRedeem", null);
    __publicField(this, "challenge");
    __publicField(this, "epochChallenge");
    __publicField(this, "calldataGenerator");
    /**
     * Calldata for the interaction
     * @protected
     */
    __publicField(this, "calldata");
    /**
     * Script signer for the interaction
     * @protected
     */
    __publicField(this, "scriptSigner");
    /**
     * Disable auto refund
     * @protected
     */
    __publicField(this, "disableAutoRefund");
    /**
     * Transaction finalizer
     * @param {number} _inputIndex The input index
     * @param {PsbtInput} input The input
     */
    __publicField(this, "customFinalizer", (t, e) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      if (!this.contractSecret)
        throw new Error("Contract secret is required");
      const r = this.getScriptSolution(e).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: E.witnessStackToScriptWitness(r)
      };
    });
    if (!t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    this.challenge = t.challenge, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.disableAutoRefund = t.disableAutoRefund || false, this.epochChallenge = z3.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.calldata = Y.compress(t.calldata), this.randomBytes = t.randomBytes || M.rndBytes(), this.scriptSigner = this.generateKeyPairFromSeed(), this.calldataGenerator = new pe4(
      this.signer.publicKey,
      this.scriptSignerXOnlyPubKey(),
      this.network
    );
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the contract secret
   * @returns {Uint8Array} The contract secret
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the preimage
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get the internal pubkey as an x-only key
   * @protected
   * @returns {Uint8Array} The internal pubkey as an x-only key
   */
  scriptSignerXOnlyPubKey() {
    return $e4(this.scriptSigner.publicKey);
  }
  /**
   * Generate a key pair from the seed
   * @protected
   *
   * @returns {UniversalSigner} The key pair
   */
  generateKeyPairFromSeed() {
    return P2.fromSeedKeyPair(this.randomBytes, this.network);
  }
  /**
   * Build the transaction
   * @protected
   *
   * @throws {Error} If the left over funds script redeem is required
   * @throws {Error} If the left over funds script redeem version is required
   * @throws {Error} If the left over funds script redeem output is required
   * @throws {Error} If the to address is required
   */
  async buildTransaction() {
    const t = this.scriptSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.regenerated || this.addInputsFromUTXO(), await this.createMineableRewardOutputs();
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.scriptSigner) {
      await super.signInputs(t);
      return;
    }
    "multiSignPsbt" in this.signer ? await this.signInputsWalletBased(t) : await this.signInputsNonWalletBased(t);
  }
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      name: ft4.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: ft4.P2TR
    };
  }
  generateTapData() {
    const t = this.scriptSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: ft4.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: ft4.P2TR
    };
  }
  /**
   * Generate the script solution
   * @param {PsbtInput} input The input
   * @protected
   *
   * @returns {Uint8Array[]} The script solution
   */
  getScriptSolution(t) {
    if (!t.tapScriptSig)
      throw new Error("Tap script signature is required");
    return [
      this.contractSecret,
      t.tapScriptSig[0].signature,
      t.tapScriptSig[1].signature
    ];
  }
  /**
   * Get the script tree
   * @private
   *
   * @returns {Taptree} The script tree
   */
  getScriptTree() {
    if (!this.calldata)
      throw new Error("Calldata is required");
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.LOCK_LEAF_SCRIPT,
        version: 192
      }
    ];
  }
  // custom for interactions
  async signInputsWalletBased(t) {
    const e = this.signer;
    await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.scriptSigner
    ), await e.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  async signInputsNonWalletBased(t) {
    if (await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.scriptSigner
    ), await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.getSignerKey()
    ), t.finalizeInput(0, this.customFinalizer.bind(this)), this.canUseParallelSigning && pt4(this.signer)) {
      let e = /* @__PURE__ */ new Set();
      try {
        const i = await this.signKeyPathInputsParallel(t, /* @__PURE__ */ new Set([0]));
        i.success && (e = new Set(i.signatures.keys()));
      } catch (i) {
        this.error(
          `Parallel signing failed, falling back to sequential: ${i.message}`
        );
      }
      for (let i = 1; i < t.data.inputs.length; i++)
        e.has(i) || await this.signInput(
          t,
          t.data.inputs[i],
          i,
          this.signer
        );
    } else
      for (let e = 1; e < t.data.inputs.length; e++)
        await this.signInput(
          t,
          t.data.inputs[e],
          e,
          this.signer
        );
    for (let e = 1; e < t.data.inputs.length; e++)
      try {
        t.finalizeInput(
          e,
          this.customFinalizerP2SH.bind(this)
        );
      } catch {
        t.finalizeInput(e);
      }
    this.finalized = true;
  }
  async createMineableRewardOutputs() {
    if (!this.to) throw new Error("To address is required");
    const t = this.getTransactionOPNetFee();
    this.addFeeToOutput(t, this.to, this.epochChallenge, false);
    const e = t < j3 ? j3 : t, i = this.addOptionalOutputsAndGetAmount();
    this.disableAutoRefund || await this.addRefundOutput(e + i);
  }
  /**
   * Generate the redeem scripts
   * @private
   *
   * @throws {Error} If the public keys are required
   * @throws {Error} If the leaf script is required
   * @throws {Error} If the leaf script version is required
   * @throws {Error} If the leaf script output is required
   * @throws {Error} If the target script redeem is required
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: ft4.P2TR,
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: ft4.P2TR,
      output: this.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
};
__publicField(Ee5, "MAXIMUM_CALLDATA_SIZE", 1024 * 1024);
var _Et = class _Et extends E {
  constructor(t) {
    super(t);
    __publicField(this, "type", b.DEPLOYMENT);
    __publicField(this, "challenge");
    __publicField(this, "epochChallenge");
    /**
     * The contract address
     * @protected
     */
    __publicField(this, "_contractAddress");
    /**
     * The tap leaf script
     * @private
     */
    __publicField(this, "tapLeafScript", null);
    __publicField(this, "deploymentVersion", 0);
    /**
     * The target script redeem
     * @private
     */
    __publicField(this, "targetScriptRedeem", null);
    /**
     * The left over funds script redeem
     * @private
     */
    __publicField(this, "leftOverFundsScriptRedeem", null);
    /**
     * The compiled target script
     * @private
     */
    __publicField(this, "compiledTargetScript");
    /**
     * The script tree
     * @private
     */
    __publicField(this, "scriptTree");
    /**
     * The deployment bitcoin generator
     * @private
     */
    __publicField(this, "deploymentGenerator");
    /**
     * The contract seed
     * @private
     */
    __publicField(this, "contractSeed");
    /**
     * The contract bytecode
     * @private
     */
    __publicField(this, "bytecode");
    /**
     * Constructor calldata
     * @private
     */
    __publicField(this, "calldata");
    /**
     * The contract signer
     * @private
     */
    __publicField(this, "contractSigner");
    /**
     * The contract public key
     * @private
     */
    __publicField(this, "_contractPubKey");
    /**
     * The contract salt random bytes
     * @private
     */
    __publicField(this, "randomBytes");
    __publicField(this, "_computedAddress");
    /**
     * Finalize the transaction
     * @param _inputIndex
     * @param input
     */
    __publicField(this, "customFinalizer", (t, e) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      if (!e.tapScriptSig)
        throw new Error("Tap script signature is required");
      const r = [
        this.randomBytes,
        e.tapScriptSig[0].signature,
        e.tapScriptSig[1].signature
      ].concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: E.witnessStackToScriptWitness(r)
      };
    });
    if (!this.hashedPublicKey)
      throw new Error("MLDSA signer must be defined to deploy a contract.");
    if (this.bytecode = Y.compress(
      new Uint8Array([...Qe4, ...t.bytecode])
    ), this.verifyBytecode(), t.calldata && (this.calldata = t.calldata, this.verifyCalldata()), !t.challenge) throw new Error("Challenge solution is required");
    if (this.randomBytes = t.randomBytes || M.rndBytes(), this.challenge = t.challenge, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.epochChallenge = z3.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.contractSeed = this.getContractSeed(), this.contractSigner = P2.fromSeedKeyPair(this.contractSeed, this.network), this.deploymentGenerator = new fe5(
      this.signer.publicKey,
      this.contractSignerXOnlyPubKey(),
      this.network
    ), t.compiledTargetScript)
      if (t.compiledTargetScript instanceof Uint8Array)
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = Mt3(t.compiledTargetScript);
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.deploymentGenerator.compile(
        this.bytecode,
        this.randomBytes,
        this.challenge,
        this.priorityFee,
        this.calldata,
        this.generateFeatures(t)
      );
    this.scriptTree = this.getScriptTree(), this.internalInit(), this._contractPubKey = "0x" + Yt4(this.contractSeed), this._contractAddress = new K2(this.contractSeed);
  }
  /**
   * Get the contract public key
   */
  get contractPubKey() {
    return this._contractPubKey;
  }
  /**
   * @description Get the contract address (PKSH)
   */
  get contractAddress() {
    return this._contractAddress;
  }
  /**
   * @description Get the P2TR address
   */
  get p2trAddress() {
    return this.to || this.getScriptAddress();
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the contract bytecode
   * @returns {Uint8Array} The contract bytecode
   */
  getChallenge() {
    return this.challenge;
  }
  getContractAddress() {
    return this._computedAddress ? this._computedAddress : (this._computedAddress = P2.p2op(
      this.contractSeed,
      this.network,
      this.deploymentVersion
    ), this._computedAddress);
  }
  /**
   * Get the contract signer public key
   * @protected
   */
  contractSignerXOnlyPubKey() {
    return $e4(this.contractSigner.publicKey);
  }
  /**
   * Build the transaction
   * @protected
   */
  async buildTransaction() {
    this.to || (this.to = this.getScriptAddress());
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.getTransactionOPNetFee();
    this.addFeeToOutput(e, this.getContractAddress(), this.epochChallenge, true), await this.addRefundOutput(e + this.addOptionalOutputsAndGetAmount());
  }
  async signInputsWalletBased(t) {
    const e = this.signer;
    await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.contractSigner
    ), await e.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.contractSigner) {
      await super.signInputs(t);
      return;
    }
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(t);
      return;
    }
    t.signInput(0, this.contractSigner), t.signInput(0, this.getSignerKey()), t.finalizeInput(0, this.customFinalizer.bind(this));
    const e = /* @__PURE__ */ new Set([0]);
    if (this.canUseParallelSigning && pt4(this.signer))
      try {
        const i = await this.signKeyPathInputsParallel(t, /* @__PURE__ */ new Set([0]));
        if (i.success)
          for (const r of i.signatures.keys()) e.add(r);
      } catch (i) {
        this.error(`Parallel signing failed: ${i.message}`);
      }
    for (let i = 1; i < t.data.inputs.length; i++)
      e.has(i) || t.signInput(i, this.getSignerKey());
    for (let i = 1; i < t.data.inputs.length; i++)
      try {
        t.finalizeInput(
          i,
          this.customFinalizerP2SH.bind(this)
        );
      } catch {
        t.finalizeInput(i);
      }
  }
  /**
   * Get the tap output
   * @protected
   */
  generateScriptAddress() {
    return this.useP2MR ? {
      name: ft4.P2MR,
      network: this.network,
      scriptTree: this.scriptTree
    } : {
      name: ft4.P2TR,
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree
    };
  }
  /**
   * Generate the tap data
   * @protected
   */
  generateTapData() {
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      name: ft4.P2MR,
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t
    } : {
      name: ft4.P2TR,
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t
    };
  }
  generateFeatures(t) {
    const e = [], i = t.challenge.getSubmission();
    if (i && e.push({
      priority: et4.MLDSA_LINK_PUBKEY,
      opcode: $3.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
  verifyCalldata() {
    if (this.calldata && this.calldata.length > Ee5.MAXIMUM_CALLDATA_SIZE)
      throw new Error("Calldata size overflow.");
  }
  verifyBytecode() {
    if (!this.bytecode) throw new Error("Bytecode is required");
    if (this.bytecode.length > _Et.MAXIMUM_CONTRACT_SIZE)
      throw new Error("Contract size overflow.");
  }
  /**
   * Generate the contract seed for the deployment
   * @private
   */
  getContractSeed() {
    if (!this.bytecode)
      throw new Error("Bytecode is required");
    const t = this.internalPubKeyToXOnly(), e = Zh2.hash256(this.randomBytes), i = Zh2.hash256(this.bytecode), r = _t7([t, e, i]);
    return Zh2.hash256(r);
  }
  /**
   * Generate the redeem scripts
   * @private
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: ft4.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: ft4.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.getLeafScript(),
      redeemVersion: 192
    };
  }
  /**
   * Get the second leaf script
   * @private
   */
  getLeafScript() {
    return this.LOCK_LEAF_SCRIPT;
  }
  /**
   * Get the script tree
   * @private
   */
  getScriptTree() {
    if (!this.bytecode)
      throw new Error("Contract bytecode is required");
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.getLeafScript(),
        version: 192
      }
    ];
  }
};
__publicField(_Et, "MAXIMUM_CONTRACT_SIZE", 128 * 1024);
var Et5 = _Et;
var Gt5 = class extends E {
  constructor(t) {
    var _a37;
    const e = ((_a37 = t.feeUtxos) == null ? void 0 : _a37.length) ? { ...t, utxos: [...t.utxos, ...t.feeUtxos] } : t;
    super(e);
    __publicField(this, "type", b.FUNDING);
    __publicField(this, "amount");
    __publicField(this, "splitInputsInto");
    __publicField(this, "autoAdjustAmount");
    this.amount = t.amount, this.splitInputsInto = t.splitInputsInto ?? 1, this.autoAdjustAmount = t.autoAdjustAmount ?? false, this.internalInit();
  }
  async buildTransaction() {
    if (!this.to)
      throw new Error("Recipient address is required");
    if (this.addInputsFromUTXO(), this.autoAdjustAmount && this.amount >= this.totalInputAmount) {
      if (this.isPubKeyDestination) {
        const r = this.to.startsWith("0x") ? this.to.slice(2) : this.to, s = Vh2.compile([
          Mt3(r),
          q2.OP_CHECKSIG
        ]);
        this.addOutput({
          value: dp2(this.amount),
          script: s
        });
      } else
        this.addOutput({
          value: dp2(this.amount),
          address: this.to
        });
      const e = await this.estimateTransactionFees();
      this.outputs.pop();
      const i = this.totalInputAmount - e;
      if (i < E.MINIMUM_DUST)
        throw new Error(
          `Insufficient funds: after deducting fee of ${e} sats, remaining amount ${i} sats is below minimum dust`
        );
      this.amount = i;
    }
    if (this.splitInputsInto > 1)
      this.splitInputs(this.amount);
    else if (this.isPubKeyDestination) {
      const e = this.to.startsWith("0x") ? this.to.slice(2) : this.to, i = Vh2.compile([
        Mt3(e),
        q2.OP_CHECKSIG
      ]);
      this.addOutput({
        value: dp2(this.amount),
        script: i
      });
    } else
      this.addOutput({
        value: dp2(this.amount),
        address: this.to
      });
    const t = this.amount + this.addOptionalOutputsAndGetAmount();
    await this.addRefundOutput(t);
  }
  splitInputs(t) {
    if (!this.to)
      throw new Error("Recipient address is required");
    const e = t / BigInt(this.splitInputsInto);
    for (let i = 0; i < this.splitInputsInto; i++)
      this.isPubKeyDestination ? this.addOutput({
        value: dp2(e),
        script: Mt3(this.to.slice(2))
      }) : this.addOutput({
        value: dp2(e),
        address: this.to
      });
  }
  getSignerKey() {
    return this.signer;
  }
};
var Qt4 = class extends Ee5 {
  constructor(t) {
    super(t);
    __publicField(this, "type", b.INTERACTION);
    __publicField(this, "compiledTargetScript");
    __publicField(this, "scriptTree");
    __publicField(this, "tapLeafScript", null);
    /**
     * Contract secret for the interaction
     * @protected
     */
    __publicField(this, "contractSecret");
    if (!t.contract)
      throw new Error("parameters.contract is required for interaction transaction.");
    if (this.contractSecret = Mt3(t.contract.startsWith("0x") ? t.contract.slice(2) : t.contract), this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (t.compiledTargetScript)
      if (t.compiledTargetScript instanceof Uint8Array)
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = Mt3(t.compiledTargetScript);
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.calldataGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.scriptTree = this.getScriptTree(), this.internalInit();
  }
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: et4.ACCESS_LIST,
      opcode: $3.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    if (i && e.push({
      priority: et4.EPOCH_SUBMISSION,
      opcode: $3.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
};
var _it = class _it extends E {
  constructor(t) {
    super(t);
    __publicField(this, "type", b.INTERACTION);
    __publicField(this, "epochChallenge");
    /**
     * Disable auto refund
     * @protected
     */
    __publicField(this, "disableAutoRefund");
    __publicField(this, "contractSecret");
    __publicField(this, "calldata");
    __publicField(this, "challenge");
    __publicField(this, "randomBytes");
    __publicField(this, "p2wdaGenerator");
    __publicField(this, "scriptSigner");
    __publicField(this, "p2wdaInputIndices", /* @__PURE__ */ new Set());
    /**
     * The compiled operation data from CalldataGenerator
     * This is exactly what would go in a taproot script, but we put it in witness instead
     */
    __publicField(this, "compiledOperationData", null);
    if (!t.to)
      throw new Error("Contract address (to) is required");
    if (!t.contract)
      throw new Error("Contract secret is required");
    if (!t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    if (this.disableAutoRefund = t.disableAutoRefund || false, this.contractSecret = Mt3(t.contract.startsWith("0x") ? t.contract.slice(2) : t.contract), this.calldata = Y.compress(t.calldata), this.challenge = t.challenge, this.randomBytes = t.randomBytes || M.rndBytes(), this.scriptSigner = this.generateKeyPairFromSeed(), this.p2wdaGenerator = new Ct5(
      this.signer.publicKey,
      this.scriptSignerXOnlyPubKey(),
      this.network
    ), this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (this.epochChallenge = z3.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.validateP2WDAInputs(), t.compiledTargetScript)
      if (t.compiledTargetScript instanceof Uint8Array)
        this.compiledOperationData = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledOperationData = Mt3(t.compiledTargetScript);
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledOperationData = this.p2wdaGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.validateOperationDataSize(), this.internalInit();
  }
  /**
   * Get random bytes (for compatibility if needed elsewhere)
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the challenge (for compatibility if needed elsewhere)
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get contract secret (for compatibility if needed elsewhere)
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Build the transaction
   */
  async buildTransaction() {
    this.regenerated || this.addInputsFromUTXO(), await this.createMineableRewardOutputs();
  }
  async createMineableRewardOutputs() {
    if (!this.to) throw new Error("To address is required");
    const t = this.getTransactionOPNetFee();
    this.addFeeToOutput(t, this.to, this.epochChallenge, false);
    const e = this.addOptionalOutputsAndGetAmount();
    this.disableAutoRefund || await this.addRefundOutput(t + e);
  }
  /**
   * Sign inputs with P2WDA-specific handling
   */
  async signInputs(t) {
    for (let e = 0; e < t.data.inputs.length; e++)
      await this.signInput(
        t,
        t.data.inputs[e],
        e,
        this.signer
      );
    for (let e = 0; e < t.data.inputs.length; e++)
      this.p2wdaInputIndices.has(e) ? e === 0 ? t.finalizeInput(e, this.finalizePrimaryP2WDA.bind(this)) : t.finalizeInput(e, this.finalizeSecondaryP2WDA.bind(this)) : t.finalizeInput(e, this.customFinalizerP2SH.bind(this));
    this.finalized = true;
  }
  /**
   * Generate features array (same as InteractionTransaction)
   */
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: et4.ACCESS_LIST,
      opcode: $3.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    return i && e.push({
      priority: et4.EPOCH_SUBMISSION,
      opcode: $3.EPOCH_SUBMISSION,
      data: i
    }), e;
  }
  /**
   * Generate keypair from seed (same as SharedInteractionTransaction)
   */
  generateKeyPairFromSeed() {
    return P2.fromSeedKeyPair(this.randomBytes, this.network);
  }
  /**
   * Get script signer x-only pubkey (same as SharedInteractionTransaction)
   */
  scriptSignerXOnlyPubKey() {
    return $e4(this.scriptSigner.publicKey);
  }
  /**
   * Validate that input 0 is P2WDA
   */
  validateP2WDAInputs() {
    if (this.utxos.length === 0 || !Z2.isP2WDAUTXO(this.utxos[0]))
      throw new Error("Input 0 must be a P2WDA UTXO");
    for (let t = 0; t < this.utxos.length; t++)
      Z2.isP2WDAUTXO(this.utxos[t]) && this.p2wdaInputIndices.add(t);
    for (let t = 0; t < this.optionalInputs.length; t++) {
      const e = this.utxos.length + t;
      Z2.isP2WDAUTXO(this.optionalInputs[t]) && this.p2wdaInputIndices.add(e);
    }
  }
  /**
   * Validate the compiled operation data will fit in witness fields
   */
  validateOperationDataSize() {
    if (!this.compiledOperationData)
      throw new Error("Operation data not compiled");
    const t = this.compiledOperationData.length;
    if (!Ct5.validateWitnessSize(t)) {
      const i = t + 64, r = Math.ceil(i * 0.7), s = Math.ceil(
        r / _it.MAX_BYTES_PER_WITNESS
      );
      throw new Error(
        `Please dont use P2WDA for this operation. Data too large. Raw size: ${t} bytes, estimated compressed: ${r} bytes, needs ${s} witness fields, max is ${_it.MAX_WITNESS_FIELDS}`
      );
    }
  }
  /**
   * Finalize primary P2WDA input with the operation data
   * This is where we create the signature and compress everything
   */
  finalizePrimaryP2WDA(t, e) {
    if (!e.partialSig || e.partialSig.length === 0)
      throw new Error(`No signature for P2WDA input #${t}`);
    if (!e.witnessScript)
      throw new Error(`No witness script for P2WDA input #${t}`);
    if (!this.compiledOperationData)
      throw new Error("Operation data not compiled");
    const i = e.partialSig[0].signature, r = _t7([i, this.compiledOperationData]), o = ct4.signMessage(
      this.signer,
      r
    ).signature, a = _t7([o, this.compiledOperationData]), c = Y.compress(a), u = this.splitIntoWitnessChunks(c);
    if (u.length > _it.MAX_WITNESS_FIELDS)
      throw new Error(
        `Compressed data needs ${u.length} witness fields, max is ${_it.MAX_WITNESS_FIELDS}`
      );
    const l = [i];
    for (let h = 0; h < _it.MAX_WITNESS_FIELDS; h++)
      l.push(h < u.length ? u[h] : new Uint8Array(0));
    return l.push(e.witnessScript), {
      finalScriptSig: void 0,
      finalScriptWitness: E.witnessStackToScriptWitness(l)
    };
  }
  /**
   * Split data into 80-byte chunks
   */
  splitIntoWitnessChunks(t) {
    const e = [];
    let i = 0;
    for (; i < t.length; ) {
      const r = Math.min(
        _it.MAX_BYTES_PER_WITNESS,
        t.length - i
      );
      e.push(t.slice(i, i + r)), i += r;
    }
    return e;
  }
};
__publicField(_it, "MAX_WITNESS_FIELDS", 10);
__publicField(_it, "MAX_BYTES_PER_WITNESS", 80);
var it3 = _it;
var Ie4 = class extends E {
  constructor(t) {
    super({
      ...t,
      gasSatFee: 1n,
      isCancellation: true,
      priorityFee: 1n,
      calldata: new Uint8Array(0)
    });
    __publicField(this, "type", b.CANCEL);
    /**
     * The tap leaf script for spending
     */
    __publicField(this, "tapLeafScript", null);
    __publicField(this, "compiledTargetScript");
    __publicField(this, "scriptTree");
    __publicField(this, "contractSecret");
    __publicField(this, "leftOverFundsScriptRedeem", null);
    /**
     * Custom finalizer for the tap script spend
     */
    __publicField(this, "customFinalizer", (t, e) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      if (!e.tapScriptSig || e.tapScriptSig.length === 0)
        throw new Error("Tap script signature is required");
      const r = [e.tapScriptSig[0].signature].concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: E.witnessStackToScriptWitness(r)
      };
    });
    this.contractSecret = new Uint8Array(0), t.compiledTargetScript instanceof Uint8Array ? this.compiledTargetScript = t.compiledTargetScript : this.compiledTargetScript = Mt3(t.compiledTargetScript), this.scriptTree = this.getMinimalScriptTree(), this.internalInit();
  }
  async buildTransaction() {
    if (!this.from)
      throw new Error("From address is required");
    if (!this.leftOverFundsScriptRedeem)
      throw new Error("Left over funds script redeem is required");
    if (!this.leftOverFundsScriptRedeem.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!this.leftOverFundsScriptRedeem.output)
      throw new Error("Left over funds script redeem output is required");
    if (this.tapLeafScript = {
      leafVersion: this.leftOverFundsScriptRedeem.redeemVersion,
      script: this.leftOverFundsScriptRedeem.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO(), await this.addRefundOutput(0n, true), !this.feeOutput)
      throw new Error("Must add extra UTXOs to cancel this transaction");
  }
  /*protected override async buildTransaction(): Promise<void> {
          if (!this.from) {
              throw new Error('From address is required');
          }
  
          // For key-path spend, we don't need the tap leaf script
          this.tapLeafScript = null;
  
          this.addInputsFromUTXO();
          await this.addRefundOutput(0n);
      }*/
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  /*protected async signInputs(transaction: Psbt): Promise<void> {
          for (let i = 0; i < transaction.data.inputs.length; i++) {
              if (i === 0) {
                  transaction.signInput(0, this.getSignerKey());
  
                  transaction.finalizeInput(0, this.customFinalizer.bind(this));
              } else {
                  await super.signInputs(transaction);
              }
          }
      }*/
  /**
   * Generate the script address (for verification purposes)
   */
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      name: ft4.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: ft4.P2TR
    };
  }
  /**
   * Generate the tap data for spending
   */
  generateTapData() {
    const t = this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: ft4.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: ft4.P2TR
    };
  }
  async signInputs(t) {
    "multiSignPsbt" in this.signer ? await this.signInputsWalletBased(t) : await this.signInputsNonWalletBased(t);
  }
  async signInputsWalletBased(t) {
    await this.signer.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  async signInputsNonWalletBased(t) {
    await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.getSignerKey()
    ), t.finalizeInput(0, this.customFinalizer.bind(this));
    let e = /* @__PURE__ */ new Set();
    if (this.canUseParallelSigning && pt4(this.signer))
      try {
        const i = await this.signKeyPathInputsParallel(t, /* @__PURE__ */ new Set([0]));
        i.success && (e = new Set(i.signatures.keys()));
      } catch (i) {
        this.error(
          `Parallel signing failed, falling back to sequential: ${i.message}`
        );
      }
    for (let i = 1; i < t.data.inputs.length; i++)
      e.has(i) || await this.signInput(
        t,
        t.data.inputs[i],
        i,
        this.signer
      );
    for (let i = 1; i < t.data.inputs.length; i++)
      try {
        t.finalizeInput(
          i,
          this.customFinalizerP2SH.bind(this)
        );
      } catch {
        t.finalizeInput(i);
      }
  }
  /**
   * Generate the minimal script tree needed for recovery
   * This only includes the leftover funds script
   */
  getMinimalScriptTree() {
    if (this.generateLeftoverFundsRedeem(), !this.leftOverFundsScriptRedeem || !this.leftOverFundsScriptRedeem.output)
      throw new Error("Failed to generate leftover funds redeem script");
    return [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.leftOverFundsScriptRedeem.output,
        version: 192
      }
    ];
  }
  /**
   * Generate the leftover funds redeem script
   */
  generateLeftoverFundsRedeem() {
    this.leftOverFundsScriptRedeem = {
      name: ft4.P2TR,
      output: this.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
};
var ai3 = class extends E {
  constructor(t) {
    super(t);
    __publicField(this, "type", b.INTERACTION);
    /** Random bytes for interaction (same as InteractionTransaction) */
    __publicField(this, "randomBytes");
    /** The contract address (same as InteractionTransaction.to) */
    __publicField(this, "contractAddress");
    /** The contract secret - 32 bytes (same as InteractionTransaction) */
    __publicField(this, "contractSecret");
    /** The compressed calldata (same as InteractionTransaction) */
    __publicField(this, "calldata");
    /** Challenge solution for epoch (same as InteractionTransaction) */
    __publicField(this, "challenge");
    /** Epoch challenge P2WSH address (same as InteractionTransaction) */
    __publicField(this, "epochChallenge");
    /** Script signer for interaction (same as InteractionTransaction) */
    __publicField(this, "scriptSigner");
    /** Calldata generator - produces same output as InteractionTransaction */
    __publicField(this, "calldataGenerator");
    /** Hash commitment generator for CHCT */
    __publicField(this, "hashCommitmentGenerator");
    /** The compiled operation data - SAME as InteractionTransaction's compiledTargetScript */
    __publicField(this, "compiledTargetScript");
    /** Generated hash-committed P2WSH outputs */
    __publicField(this, "commitmentOutputs");
    /** Disable auto refund (same as InteractionTransaction) */
    __publicField(this, "disableAutoRefund");
    /** Maximum chunk size (default: 80 bytes per P2WSH stack item limit) */
    __publicField(this, "maxChunkSize");
    /** Cached value per output (calculated once, used by setup and reveal) */
    __publicField(this, "cachedValuePerOutput", null);
    if (!t.to)
      throw new Error("Contract address (to) is required");
    if (!t.contract)
      throw new Error("Contract secret (contract) is required");
    if (!t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    if (this.contractAddress = t.to, this.contractSecret = Mt3(t.contract.startsWith("0x") ? t.contract.slice(2) : t.contract), this.disableAutoRefund = t.disableAutoRefund || false, this.maxChunkSize = t.maxChunkSize ?? I.MAX_CHUNK_SIZE, this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (this.calldata = Y.compress(t.calldata), this.randomBytes = t.randomBytes || M.rndBytes(), this.scriptSigner = P2.fromSeedKeyPair(this.randomBytes, this.network), this.challenge = t.challenge, this.epochChallenge = z3.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.calldataGenerator = new pe4(
      this.signer.publicKey,
      $e4(this.scriptSigner.publicKey),
      this.network
    ), t.compiledTargetScript)
      if (t.compiledTargetScript instanceof Uint8Array)
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = Mt3(t.compiledTargetScript);
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.calldataGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.hashCommitmentGenerator = new I(
      this.signer.publicKey,
      this.network
    ), this.commitmentOutputs = this.hashCommitmentGenerator.prepareChunks(
      this.compiledTargetScript,
      this.maxChunkSize
    ), this.validateOutputCount();
    const e = this.commitmentOutputs.reduce(
      (i, r) => i + r.dataChunks.length,
      0
    );
    this.log(
      `ConsolidatedInteractionTransaction: ${this.commitmentOutputs.length} outputs, ${e} chunks from ${this.compiledTargetScript.length} bytes compiled data`
    ), this.internalInit();
  }
  /**
   * Get the compiled target script (same as InteractionTransaction).
   */
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the contract secret (same as InteractionTransaction).
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Get the random bytes (same as InteractionTransaction).
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the challenge solution (same as InteractionTransaction).
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get the commitment outputs for the setup transaction.
   */
  getCommitmentOutputs() {
    return this.commitmentOutputs;
  }
  /**
   * Get the number of P2WSH outputs.
   */
  getOutputCount() {
    return this.commitmentOutputs.length;
  }
  /**
   * Get the total number of 80-byte chunks across all outputs.
   */
  getTotalChunkCount() {
    return this.commitmentOutputs.reduce((t, e) => t + e.dataChunks.length, 0);
  }
  /**
   * Build both setup and reveal transactions.
   *
   * @returns Complete result with both transactions
   */
  async build() {
    const t = await this.signTransaction(), e = t.getId(), i = {
      txHex: t.toHex(),
      txId: e,
      outputs: this.commitmentOutputs,
      feesPaid: this.transactionFee,
      chunkCount: this.getTotalChunkCount(),
      totalDataSize: this.compiledTargetScript.length
    };
    this.log(`Setup transaction: ${i.txId}`);
    const r = this.buildRevealTransaction(e);
    return {
      setup: i,
      reveal: r,
      totalFees: i.feesPaid + r.feesPaid
    };
  }
  /**
   * Build the reveal transaction.
   * Spends the P2WSH commitment outputs, revealing the compiled data in witnesses.
   *
   * Output structure matches InteractionTransaction:
   * - Output to epochChallenge.address (miner reward)
   * - Change output (if any)
   *
   * @param setupTxId The transaction ID of the setup transaction
   */
  buildRevealTransaction(t) {
    const e = new Xn2({ network: this.network }), i = this.calculateValuePerOutput();
    for (let d = 0; d < this.commitmentOutputs.length; d++) {
      const p = this.commitmentOutputs[d];
      e.addInput({
        hash: t,
        index: d,
        witnessUtxo: {
          script: p.scriptPubKey,
          value: dp2(i)
        },
        witnessScript: p.witnessScript
      });
    }
    const r = BigInt(this.commitmentOutputs.length) * i, s = this.getTransactionOPNetFee(), o = s < j3 ? j3 : s;
    e.addOutput({
      address: this.epochChallenge.address,
      value: dp2(o)
    });
    const a = this.estimateRevealVBytes(), c = BigInt(Math.ceil(a * this.feeRate)), u = r - o - c;
    if (u > E.MINIMUM_DUST) {
      const d = this.getRefundAddress();
      e.addOutput({
        address: d,
        value: dp2(u)
      });
    }
    for (let d = 0; d < this.commitmentOutputs.length; d++)
      e.signInput(d, this.signer);
    for (let d = 0; d < this.commitmentOutputs.length; d++) {
      const p = this.commitmentOutputs[d];
      e.finalizeInput(d, (y, m) => this.finalizeCommitmentInput(m, p));
    }
    const l = e.extractTransaction(), h = {
      txHex: l.toHex(),
      txId: l.getId(),
      dataSize: this.compiledTargetScript.length,
      feesPaid: c,
      inputCount: this.commitmentOutputs.length
    };
    return this.log(`Reveal transaction: ${h.txId}`), h;
  }
  /**
   * Get the value per commitment output (for external access).
   */
  getValuePerOutput() {
    return this.calculateValuePerOutput();
  }
  /**
   * Build the setup transaction.
   * Creates P2WSH outputs with hash commitments to the compiled data chunks.
   * This is called by signTransaction() in the base class.
   */
  async buildTransaction() {
    this.addInputsFromUTXO();
    const t = this.calculateValuePerOutput();
    for (const r of this.commitmentOutputs)
      this.addOutput({
        value: dp2(t),
        address: r.address
      });
    const e = BigInt(this.commitmentOutputs.length) * t, i = this.addOptionalOutputsAndGetAmount();
    await this.addRefundOutput(e + i);
  }
  /**
   * Finalize a commitment input.
   *
   * Witness stack: [signature, data_1, data_2, ..., data_N, witnessScript]
   *
   * The witness script verifies each data chunk against its committed hash.
   * If any data is wrong or missing, the transaction is INVALID at consensus level.
   */
  finalizeCommitmentInput(t, e) {
    if (!t.partialSig || t.partialSig.length === 0)
      throw new Error("No signature for commitment input");
    if (!t.witnessScript)
      throw new Error("No witness script for commitment input");
    const i = [
      t.partialSig[0].signature,
      // Signature for OP_CHECKSIG
      ...e.dataChunks,
      // All data chunks for OP_HASH160 verification
      t.witnessScript
      // The witness script
    ];
    return {
      finalScriptSig: void 0,
      finalScriptWitness: E.witnessStackToScriptWitness(i)
    };
  }
  /**
   * Estimate reveal transaction vBytes.
   */
  estimateRevealVBytes() {
    let t = 0;
    for (const i of this.commitmentOutputs) {
      const r = i.dataChunks.length, s = r * 80, o = r * 23 + 35;
      t += 164 + s + o + 72 + 20;
    }
    const e = 40 + t + 200;
    return Math.ceil(e / 4);
  }
  /**
   * Calculate the required value per commitment output.
   * This must cover: dust minimum + share of reveal fee + share of OPNet fee
   */
  calculateValuePerOutput() {
    if (this.cachedValuePerOutput !== null)
      return this.cachedValuePerOutput;
    const t = this.commitmentOutputs.length, e = this.getTransactionOPNetFee(), i = e < j3 ? j3 : e, r = this.estimateRevealVBytes(), s = BigInt(Math.ceil(r * this.feeRate)), o = i + s + E.MINIMUM_DUST, a = BigInt(Math.ceil(Number(o) / t)), c = I.MIN_OUTPUT_VALUE;
    return this.cachedValuePerOutput = a > c ? a : c, this.cachedValuePerOutput;
  }
  /**
   * Get refund address.
   */
  getRefundAddress() {
    return this.from ? this.from : ge4.generatePKSH(this.signer.publicKey, this.network);
  }
  /**
   * Generate features (same as InteractionTransaction).
   */
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: et4.ACCESS_LIST,
      opcode: $3.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    if (i && e.push({
      priority: et4.EPOCH_SUBMISSION,
      opcode: $3.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
  /**
   * Validate output count is within standard tx limits.
   */
  validateOutputCount() {
    const t = I.calculateMaxInputsPerTx();
    if (this.commitmentOutputs.length > t) {
      const e = I.calculateMaxDataPerTx();
      throw new Error(
        `Data too large: ${this.commitmentOutputs.length} P2WSH outputs needed, max ${t} per standard transaction (~${Math.floor(e / 1024)}KB). Compiled data: ${this.compiledTargetScript.length} bytes.`
      );
    }
  }
};
var ci3 = class {
  constructor() {
    __publicField(this, "debug", false);
    __publicField(this, "DUMMY_PUBKEY", new Uint8Array(32).fill(1));
    __publicField(this, "P2TR_SCRIPT", Uint8Array.from([81, 32, ...this.DUMMY_PUBKEY]));
    __publicField(this, "INITIAL_FUNDING_ESTIMATE", 2000n);
    __publicField(this, "MAX_ITERATIONS", 10);
  }
  /**
   * @description Creates a cancellable transaction.
   * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} params - The cancel transaction parameters
   * @returns {Promise<CancelledTransaction>} - The cancelled transaction result
   */
  async createCancellableTransaction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    const e = await this.detectCancelOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const r = await new Ie4(t).signTransaction();
    return {
      transaction: r.toHex(),
      nextUTXOs: this.getUTXOAsTransaction(r, t.from, 0),
      inputUtxos: t.utxos
    };
  }
  /**
   * @description Generate a transaction with a custom script.
   * @param {ICustomTransactionParameters | ICustomTransactionWithoutSigner} interactionParameters - The custom transaction parameters
   * @returns {Promise<[string, string, UTXO[], UTXO[]]>} - The signed transaction tuple [fundingTx, customTx, nextUTXOs, inputUtxos]
   */
  async createCustomScriptTransaction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const e = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: i, estimatedAmount: r } = await this.iterateFundingAmount(
      { ...t, optionalInputs: e },
      Yt5,
      async (h) => {
        const d = await h.estimateTransactionFees(), p = this.getPriorityFee(t), y = h.getOptionalOutputValue();
        return d + p + y;
      },
      "CustomScript"
    ), s = await i.getFundingTransactionParameters();
    s.utxos = t.utxos, s.amount = r;
    const o = await this.createFundTransaction({
      ...s,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!o)
      throw new Error("Could not sign funding transaction.");
    s.estimatedFees = o.estimatedFees;
    const a = await this.createFundTransaction({
      ...s,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!a)
      throw new Error("Could not sign funding transaction.");
    const c = {
      ...t,
      utxos: this.getUTXOAsTransaction(a.tx, t.to, 0),
      randomBytes: i.getRndBytes(),
      nonWitnessUtxo: a.tx.toBuffer(),
      estimatedFees: i.estimatedFees,
      compiledTargetScript: i.exportCompiledTargetScript(),
      optionalInputs: e
    }, l = await new Yt5(c).signTransaction();
    return [
      a.tx.toHex(),
      l.toHex(),
      this.getUTXOAsTransaction(a.tx, t.from, 1),
      t.utxos
    ];
  }
  /**
   * @description Generates the required transactions.
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse>} - The signed transaction
   */
  async signInteraction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    const e = await this.detectInteractionOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    if (this.hasP2WDAInputs(t.utxos))
      return this.signP2WDAInteraction(t);
    const r = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: s, estimatedAmount: o, challenge: a } = await this.iterateFundingAmount(
      { ...t, optionalInputs: r },
      Qt4,
      async (m) => {
        const A = await m.estimateTransactionFees(), x = m.getTotalOutputValue(), W3 = A + x;
        if (t.subtractExtraUTXOFromAmountRequired && t.optionalInputs && t.optionalInputs.length > 0) {
          const ut4 = t.optionalInputs.reduce(
            (ft5, ee4) => ft5 + ee4.value,
            0n
          );
          return W3 > ut4 ? W3 - ut4 : 0n;
        }
        return W3;
      },
      "Interaction"
    );
    if (!a)
      throw new Error("Failed to get challenge from interaction transaction");
    const c = await s.getFundingTransactionParameters();
    c.utxos = t.utxos, c.amount = o;
    const u = await this.createFundTransaction({
      ...c,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!u)
      throw new Error("Could not sign funding transaction.");
    c.estimatedFees = u.estimatedFees;
    const l = await this.createFundTransaction({
      ...c,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!l)
      throw new Error("Could not sign funding transaction.");
    const h = this.getUTXOAsTransaction(
      l.tx,
      s.getScriptAddress(),
      0
    ), d = {
      ...t,
      utxos: h,
      randomBytes: s.getRndBytes(),
      challenge: a,
      compiledTargetScript: s.exportCompiledTargetScript(),
      nonWitnessUtxo: l.tx.toBuffer(),
      estimatedFees: s.estimatedFees,
      optionalInputs: r
    }, p = new Qt4(d), y = await p.signTransaction();
    return {
      interactionAddress: s.getScriptAddress(),
      fundingTransaction: l.tx.toHex(),
      interactionTransaction: y.toHex(),
      estimatedFees: p.transactionFee,
      nextUTXOs: this.getUTXOAsTransaction(
        l.tx,
        t.from,
        1
      ),
      challenge: a.toRaw(),
      fundingUTXOs: h,
      fundingInputUtxos: t.utxos,
      compiledTargetScript: Yt4(p.exportCompiledTargetScript())
    };
  }
  /**
   * @description Generates a consolidated interaction transaction (CHCT system).
   *
   * Drop-in replacement for signInteraction that bypasses BIP110/Bitcoin Knots censorship.
   * Uses P2WSH with HASH160 commitments instead of Tapscript (which uses OP_IF and gets censored).
   *
   * Returns two transactions:
   * - Setup: Creates P2WSH outputs with hash commitments to data chunks
   * - Reveal: Spends those outputs, revealing data in witnesses
   *
   * Data integrity is consensus-enforced - if data is stripped/modified,
   * HASH160(data) != committed_hash and the transaction is INVALID.
   *
   * @param {IConsolidatedInteractionParameters} interactionParameters - Same parameters as signInteraction
   * @returns {Promise<ConsolidatedInteractionResponse>} - Both setup and reveal transactions
   */
  async signConsolidatedInteraction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    if (!("signer" in t))
      throw new Error('Field "signer" not provided.');
    if (!t.challenge)
      throw new Error('Field "challenge" not provided.');
    const e = this.parseOptionalInputs(t.optionalInputs), i = new ai3({
      ...t,
      optionalInputs: e
    }), r = await i.build();
    return {
      setupTransaction: r.setup.txHex,
      revealTransaction: r.reveal.txHex,
      setupTxId: r.setup.txId,
      revealTxId: r.reveal.txId,
      totalFees: r.totalFees,
      chunkCount: r.setup.chunkCount,
      dataSize: r.setup.totalDataSize,
      challenge: i.getChallenge().toRaw(),
      inputUtxos: t.utxos,
      compiledTargetScript: Yt4(i.exportCompiledTargetScript())
    };
  }
  /**
   * @description Generates the required transactions.
   * @param {IDeploymentParameters} deploymentParameters - The deployment parameters
   * @returns {Promise<DeploymentResult>} - The signed transaction
   */
  async signDeployment(t) {
    const e = await this.detectDeploymentOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const i = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: r, estimatedAmount: s, challenge: o } = await this.iterateFundingAmount(
      { ...t, optionalInputs: i },
      Et5,
      async (W3) => {
        const ut4 = await W3.estimateTransactionFees(), ft5 = this.getPriorityFee(t), ee4 = W3.getOptionalOutputValue();
        return ut4 + ft5 + ee4;
      },
      "Deployment"
    );
    if (!o)
      throw new Error("Failed to get challenge from deployment transaction");
    const a = await r.getFundingTransactionParameters();
    a.utxos = t.utxos, a.amount = s;
    const c = await this.createFundTransaction({
      ...a,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!c)
      throw new Error("Could not sign funding transaction.");
    a.estimatedFees = c.estimatedFees;
    const l = await new Gt5({
      ...a,
      optionalInputs: [],
      optionalOutputs: []
    }).signTransaction();
    if (!l)
      throw new Error("Could not sign funding transaction.");
    const h = l.outs[0], d = {
      transactionId: l.getId(),
      outputIndex: 0,
      scriptPubKey: {
        hex: Yt4(h.script),
        address: r.getScriptAddress()
      },
      value: BigInt(h.value)
    }, p = {
      ...t,
      utxos: [d],
      randomBytes: r.getRndBytes(),
      compiledTargetScript: r.exportCompiledTargetScript(),
      challenge: o,
      nonWitnessUtxo: l.toBuffer(),
      estimatedFees: r.estimatedFees,
      optionalInputs: i
    }, y = new Et5(p), m = await y.signTransaction(), A = l.outs[1], x = {
      transactionId: l.getId(),
      outputIndex: 1,
      scriptPubKey: {
        hex: Yt4(A.script),
        address: t.from
      },
      value: BigInt(A.value)
    };
    return {
      transaction: [l.toHex(), m.toHex()],
      contractAddress: y.getContractAddress(),
      contractPubKey: y.contractPubKey,
      utxos: [x],
      challenge: o.toRaw(),
      inputUtxos: t.utxos
    };
  }
  /**
   * @description Creates a funding transaction.
   * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
   * @returns {Promise<BitcoinTransferResponse>} - The signed transaction
   */
  async createBTCTransfer(t) {
    if (!t.from)
      throw new Error('Field "from" not provided.');
    const e = await this.createFundTransaction(t);
    return {
      estimatedFees: e.estimatedFees,
      original: e.original,
      tx: e.tx.toHex(),
      nextUTXOs: this.getAllNewUTXOs(e.original, e.tx, t.from),
      inputUtxos: t.utxos
    };
  }
  /**
   * Get all new UTXOs of a generated transaction.
   * @param {TransactionBuilder<TransactionType>} original - The original transaction
   * @param {Transaction} tx - The transaction
   * @param {string} to - The address to filter
   * @returns {UTXO[]} - The new UTXOs belonging to the specified address
   */
  getAllNewUTXOs(t, e, i) {
    const r = t.getOutputs(), s = [];
    for (let o = 0; o < e.outs.length; o++) {
      const a = r[o];
      if ("address" in a) {
        if (a.address !== i) continue;
      } else
        continue;
      s.push(...this.getUTXOAsTransaction(e, i, o));
    }
    return s;
  }
  /**
   * Parse optional inputs and normalize nonWitnessUtxo format.
   * @param {UTXO[]} optionalInputs - The optional inputs to parse
   * @returns {UTXO[]} - The parsed inputs with normalized nonWitnessUtxo
   */
  parseOptionalInputs(t) {
    return (t || []).map((e) => {
      let i = e.nonWitnessUtxo;
      return i && !(i instanceof Uint8Array) && typeof i == "object" && (i = Uint8Array.from(Object.values(i))), {
        ...e,
        nonWitnessUtxo: i
      };
    });
  }
  /**
   * Detect and use OP_WALLET for cancel transactions if available.
   * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} interactionParameters - The cancel parameters
   * @returns {Promise<CancelledTransaction | null>} - The cancelled transaction or null if OP_WALLET not available
   */
  async detectCancelOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.cancelTransaction({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      inputUtxos: r.inputUtxos ?? t.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for interaction transactions if available.
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse | null>} - The interaction response or null if OP_WALLET not available
   */
  async detectInteractionOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.signInteraction({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      fundingInputUtxos: r.fundingInputUtxos ?? t.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for deployment transactions if available.
   * @param {IDeploymentParameters | IDeploymentParametersWithoutSigner} deploymentParameters - The deployment parameters
   * @returns {Promise<DeploymentResult | null>} - The deployment result or null if OP_WALLET not available
   */
  async detectDeploymentOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.deployContract({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      inputUtxos: r.inputUtxos ?? t.utxos
    };
  }
  /**
   * Create and sign a funding transaction.
   * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
   * @returns {Promise<FundingTransactionResponse>} - The funding transaction response
   */
  async createFundTransaction(t) {
    if (!t.to) throw new Error('Field "to" not provided.');
    const e = new Gt5(t), i = await e.signTransaction();
    if (!i)
      throw new Error("Could not sign funding transaction.");
    return {
      tx: i,
      original: e,
      estimatedFees: e.estimatedFees,
      nextUTXOs: this.getUTXOAsTransaction(i, t.to, 0),
      inputUtxos: t.utxos
    };
  }
  /**
   * Check if the UTXOs contain any P2WDA inputs
   *
   * This method examines both main UTXOs and optional inputs to determine
   * if any of them are P2WDA addresses. P2WDA detection is based on the
   * witness script pattern: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   *
   * @param {UTXO[]} utxos - The main UTXOs to check
   * @returns {boolean} - true if any UTXO is P2WDA, false otherwise
   */
  hasP2WDAInputs(t) {
    return t.some((e) => Z2.isP2WDAUTXO(e));
  }
  /**
   * Sign a P2WDA interaction transaction
   *
   * P2WDA interactions are fundamentally different from standard OP_NET interactions.
   * Instead of using a two-transaction model (funding + interaction), P2WDA embeds
   * the operation data directly in the witness field of a single transaction.
   * This achieves significant cost savings through the witness discount.
   *
   * Key differences:
   * - Single transaction instead of two
   * - Operation data in witness field instead of taproot script
   * - 75% cost reduction for data storage
   * - No separate funding transaction needed
   *
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse>} - The signed P2WDA interaction response
   */
  async signP2WDAInteraction(t) {
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!("signer" in t))
      throw new Error(
        "P2WDA interactions require a signer. OP_WALLET is not supported for P2WDA."
      );
    const e = this.parseOptionalInputs(t.optionalInputs), i = new it3({
      ...t,
      optionalInputs: e
    }), r = await i.signTransaction();
    return {
      interactionAddress: null,
      fundingTransaction: null,
      interactionTransaction: r.toHex(),
      estimatedFees: i.estimatedFees,
      nextUTXOs: this.getUTXOAsTransaction(
        r,
        t.from,
        r.outs.length - 1
      ),
      fundingUTXOs: [...t.utxos, ...e],
      fundingInputUtxos: t.utxos,
      challenge: t.challenge.toRaw(),
      compiledTargetScript: null
    };
  }
  /**
   * Get the priority fee from transaction parameters.
   * @param {ITransactionParameters} params - The transaction parameters
   * @returns {bigint} - The priority fee, minimum dust if below threshold
   */
  getPriorityFee(t) {
    const e = t.priorityFee + t.gasSatFee;
    return e < E.MINIMUM_DUST ? E.MINIMUM_DUST : e;
  }
  /**
   * Common iteration logic for finding the correct funding amount.
   *
   * This method iteratively estimates the required funding amount by simulating
   * transactions until the amount converges or max iterations is reached.
   *
   * @param {P extends IInteractionParameters | IDeploymentParameters | ICustomTransactionParameters} params - The transaction parameters
   * @param {new (params: P) => T} TransactionClass - The transaction class constructor
   * @param {(tx: T extends InteractionTransaction | DeploymentTransaction | CustomScriptTransaction) => Promise<bigint>} calculateAmount - Function to calculate required amount
   * @param {string} debugPrefix - Prefix for debug logging
   * @returns {Promise<{finalTransaction: T extends InteractionTransaction | DeploymentTransaction | CustomScriptTransaction, estimatedAmount: bigint, challenge: IChallengeSolution | null}>} - The final transaction and estimated amount
   */
  async iterateFundingAmount(t, e, i, r) {
    const s = "randomBytes" in t ? t.randomBytes ?? M.rndBytes() : M.rndBytes(), o = K2.dead().p2tr(t.network);
    let a = this.INITIAL_FUNDING_ESTIMATE, c = 0n, u = 0, l = null, h = null;
    for (; u < this.MAX_ITERATIONS && a !== c; ) {
      c = a;
      const d = new rt4();
      d.addOutput(this.P2TR_SCRIPT, dp2(a));
      const p = {
        transactionId: Yt4(new Uint8Array(32)),
        outputIndex: 0,
        scriptPubKey: {
          hex: Yt4(this.P2TR_SCRIPT),
          address: o
        },
        value: a,
        nonWitnessUtxo: d.toBuffer()
      };
      let y;
      "challenge" in t && t.challenge ? y = {
        ...t,
        utxos: [p],
        randomBytes: s,
        challenge: h ?? t.challenge
      } : y = {
        ...t,
        utxos: [p],
        randomBytes: s
      };
      const m = new e(y);
      try {
        await m.generateTransactionMinimalSignatures(), a = await i(m);
      } catch (A) {
        if (A instanceof Error) {
          const x = A.message.match(/need (\d+) sats but only have (\d+) sats/);
          if (x)
            a = BigInt(x[1]), this.debug && console.log(
              `${r}: Caught insufficient funds, updating to ${a}`
            );
          else
            throw A;
        } else
          throw new Error("Unknown error during fee estimation", { cause: A });
      }
      l = m, "getChallenge" in m && typeof m.getChallenge == "function" && (h = m.getChallenge()), u++, this.debug && console.log(
        `${r} Iteration ${u}: Previous=${c}, New=${a}`
      );
    }
    if (!l)
      throw new Error(`Failed to converge on ${r} funding amount`);
    return {
      finalTransaction: l,
      estimatedAmount: a,
      challenge: h
    };
  }
  /**
   * Convert a transaction output to a UTXO.
   * @param {Transaction} tx - The transaction
   * @param {string} to - The address
   * @param {number} index - The output index
   * @returns {UTXO[]} - The UTXO array (empty if output doesn't exist)
   */
  getUTXOAsTransaction(t, e, i) {
    if (!t.outs[i]) return [];
    const r = t.outs[i];
    return [{
      transactionId: t.getId(),
      outputIndex: i,
      scriptPubKey: {
        hex: Yt4(r.script),
        address: e
      },
      value: BigInt(r.value)
    }];
  }
};
var _R2 = class _R2 extends E {
  constructor(t) {
    if (!t.refundVault)
      throw new Error("Refund vault is required");
    if (!t.requestedAmount)
      throw new Error("Requested amount is required");
    if (!t.receiver)
      throw new Error("Receiver is required");
    super({
      ...t,
      signer: P2.fromPrivateKey(
        Zh2.sha256(new TextEncoder().encode("aaaaaaaa"))
      ),
      priorityFee: 0n,
      gasSatFee: 0n
    });
    __publicField(this, "type", b.MULTI_SIG);
    __publicField(this, "targetScriptRedeem", null);
    __publicField(this, "leftOverFundsScriptRedeem", null);
    __publicField(this, "compiledTargetScript");
    __publicField(this, "scriptTree");
    __publicField(this, "publicKeys");
    __publicField(this, "minimumSignatures");
    __publicField(this, "originalInputCount", 0);
    __publicField(this, "requestedAmount");
    __publicField(this, "receiver");
    __publicField(this, "refundVault");
    /**
     * @description Sign hash types
     * @protected
     */
    __publicField(this, "sighashTypes", _R2.signHashTypesArray);
    /**
     * Transaction finalizer
     * @param {number} _inputIndex The input index
     * @param {PsbtInput} input The input
     */
    __publicField(this, "customFinalizer", (t, e) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      const r = this.getScriptSolution(e).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: E.witnessStackToScriptWitness(r)
      };
    });
    if (!t.pubkeys)
      throw new Error("Pubkeys are required");
    t.psbt && (this.log("Using provided PSBT."), this.transaction = t.psbt, this.originalInputCount = this.transaction.data.inputs.length), this.refundVault = t.refundVault, this.requestedAmount = t.requestedAmount, this.receiver = t.receiver, this.publicKeys = t.pubkeys, this.minimumSignatures = t.minimumSignatures, this.compiledTargetScript = Dt5.compile(
      t.pubkeys,
      this.minimumSignatures
    ), this.scriptTree = this.getScriptTree(), this.internalInit();
  }
  /**
   * Generate a multisig transaction from a base64 psbt.
   * @param {MultiSignFromBase64Params} params The parameters
   * @returns {MultiSignTransaction} The multisig transaction
   */
  static fromBase64(t) {
    const e = Xn2.fromBase64(t.psbt, { network: t.network });
    return new _R2({
      ...t,
      psbt: e
    });
  }
  /**
   * Verify if that public key already signed the transaction
   * @param {Psbt} psbt The psbt
   * @param {Uint8Array} signerPubKey The signer public key
   * @returns {boolean} True if the public key signed the transaction
   */
  static verifyIfSigned(t, e) {
    let i = false;
    for (let r = 1; r < t.data.inputs.length; r++) {
      const s = t.data.inputs[r];
      if (!s.finalScriptWitness)
        continue;
      const o = E.readScriptWitnessToWitnessStack(
        s.finalScriptWitness
      );
      if (!(o.length < 3))
        for (let a = 0; a < o.length - 2; a += 3) {
          const c = o[a + 2];
          if (P(c, e)) {
            i = true;
            break;
          }
        }
    }
    return i;
  }
  /**
   * Partially sign the transaction
   * @returns {boolean} True if the transaction was signed
   * @public
   */
  static signPartial(t, e, i, r) {
    let s = false, o = true;
    for (let a = i; a < t.data.inputs.length; a++) {
      const c = t.data.inputs[a];
      c.tapInternalKey || (c.tapInternalKey = $e4(_R2.numsPoint));
      const u = [];
      if (c.finalScriptWitness) {
        const h = E.readScriptWitnessToWitnessStack(
          c.finalScriptWitness
        );
        c.tapLeafScript = [
          {
            leafVersion: 192,
            script: h[h.length - 2],
            controlBlock: h[h.length - 1]
          }
        ];
        for (let d = 0; d < h.length - 2; d += 3)
          u.push({
            signature: h[d],
            leafHash: h[d + 1],
            pubkey: h[d + 2]
          });
        c.tapScriptSig = (c.tapScriptSig || []).concat(u);
      }
      Reflect.deleteProperty(c, "finalScriptWitness");
      const l = _R2.signHashTypesArray ? [_R2.calculateSignHash(_R2.signHashTypesArray)] : [];
      try {
        _R2.signInput(t, c, a, e, l), s = true;
      } catch (h) {
        console.log(h);
      }
      if (s) {
        if (!c.tapScriptSig) throw new Error("No new signatures for input");
        c.tapScriptSig.length !== r[a - i] && (o = false);
      }
    }
    return {
      signed: s,
      final: s ? o : false
    };
  }
  /**
   * Dedupe signatures
   * @param {TapScriptSig[]} original The original signatures
   * @param {TapScriptSig[]} partial The partial signatures
   * @returns {TapScriptSig[]} The deduped signatures
   */
  static dedupeSignatures(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const r of t)
      i.set(Yt4(r.pubkey), r);
    for (const r of e)
      i.has(Yt4(r.pubkey)) || i.set(Yt4(r.pubkey), r);
    return Array.from(i.values());
  }
  /**
   * Attempt to finalize the inputs
   * @param {Psbt} psbt The psbt
   * @param {number} startIndex The start index
   * @param {Uint8Array[]} orderedPubKeys The ordered public keys
   * @param {boolean} isFinal If the transaction is final
   * @returns {boolean} True if the inputs were finalized
   */
  static attemptFinalizeInputs(t, e, i, r) {
    let s = 0;
    for (let o = e; o < t.data.inputs.length; o++)
      try {
        const a = t.data.inputs[o];
        a.tapInternalKey || (a.tapInternalKey = $e4(_R2.numsPoint));
        const c = [];
        if (a.finalScriptWitness) {
          const u = E.readScriptWitnessToWitnessStack(
            a.finalScriptWitness
          );
          for (let l = 0; l < u.length - 2; l += 3)
            c.push({
              signature: u[l],
              leafHash: u[l + 1],
              pubkey: u[l + 2]
            });
          a.tapLeafScript = [
            {
              leafVersion: 192,
              script: u[u.length - 2],
              controlBlock: u[u.length - 1]
            }
          ], a.tapScriptSig = _R2.dedupeSignatures(
            a.tapScriptSig || [],
            c
          );
        }
        Reflect.deleteProperty(a, "finalScriptWitness"), t.finalizeInput(
          o,
          (u, l) => _R2.partialFinalizer(
            u,
            l,
            [],
            i[o - e],
            r
          )
        ), s++;
      } catch {
      }
    return s === t.data.inputs.length - e;
  }
  /**
   * Finalize the psbt multisig transaction
   */
  finalizeTransactionInputs() {
    let t = false;
    try {
      for (let e = this.originalInputCount; e < this.transaction.data.inputs.length; e++)
        this.transaction.finalizeInput(e, this.customFinalizer.bind(this));
      t = true;
    } catch (e) {
      this.error(`Error finalizing transaction inputs: ${e.stack}`);
    }
    return t;
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Psbt>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signPSBT() {
    if (await this.signTransaction())
      return this.transaction;
    throw new Error("Could not sign transaction");
  }
  /**
   * Build the transaction
   * @protected
   *
   * @throws {Error} If the left over funds script redeem is required
   * @throws {Error} If the left over funds script redeem version is required
   * @throws {Error} If the left over funds script redeem output is required
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async buildTransaction() {
    const t = this.targetScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.calculateOutputLeftAmountFromVaults(this.utxos);
    if (e < 0)
      throw new Error(`Output value left is negative ${e}.`);
    this.addOutput({
      address: this.refundVault,
      value: dp2(e)
    }), this.addOutput({
      address: this.receiver,
      value: dp2(this.requestedAmount)
    });
  }
  /**
   * Builds the transaction.
   * @param {Psbt} transaction - The transaction to build
   * @param checkPartialSigs
   * @protected
   * @returns {Promise<boolean>}
   * @throws {Error} - If something went wrong while building the transaction
   */
  async internalBuildTransaction(t, e = false) {
    const i = this.getInputs(), r = this.getOutputs();
    t.setMaximumFeeRate(this._maximumFeeRate), t.addInputs(i, e);
    for (let s = 0; s < this.updateInputs.length; s++)
      t.updateInput(s, this.updateInputs[s]);
    t.addOutputs(r);
    try {
      return await this.signInputs(t), this.finalizeTransactionInputs();
    } catch (s) {
      const o = s;
      this.error(
        `[internalBuildTransaction] Something went wrong while getting building the transaction: ${o.stack}`
      );
    }
    return false;
  }
  /**
   * Sign the inputs
   * @protected
   */
  async signInputs(t) {
  }
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      name: ft4.P2MR
    } : {
      internalPubkey: $e4(_R2.numsPoint),
      network: this.network,
      scriptTree: this.scriptTree,
      name: ft4.P2TR
    };
  }
  generateTapData() {
    const t = this.targetScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: ft4.P2MR
    } : {
      internalPubkey: $e4(_R2.numsPoint),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: ft4.P2TR
    };
  }
  /**
   * Generate the script solution
   * @param {PsbtInput} input The input
   * @protected
   *
   * @returns {Uint8Array[]} The script solution
   */
  getScriptSolution(t) {
    return t.tapScriptSig ? t.tapScriptSig.map((e) => e.signature) : [];
  }
  /**
   * Get the script tree
   * @private
   *
   * @returns {Taptree} The script tree
   */
  getScriptTree() {
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: _R2.LOCK_LEAF_SCRIPT,
        version: 192
      }
    ];
  }
  getTotalOutputAmount(t) {
    let e = 0n;
    for (const i of t)
      e += i.value;
    return e;
  }
  /**
   * @description Calculate the amount left to refund to the first vault.
   * @private
   * @returns {bigint} The amount left
   */
  calculateOutputLeftAmountFromVaults(t) {
    return this.getTotalOutputAmount(t) - this.requestedAmount;
  }
  /**
   * Generate the redeem scripts
   * @private
   *
   * @throws {Error} If the public keys are required
   * @throws {Error} If the leaf script is required
   * @throws {Error} If the leaf script version is required
   * @throws {Error} If the leaf script output is required
   * @throws {Error} If the target script redeem is required
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: ft4.P2TR,
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: ft4.P2TR,
      output: _R2.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
};
__publicField(_R2, "LOCK_LEAF_SCRIPT", Vh2.compile([
  q2.OP_XOR,
  q2.OP_NOP,
  q2.OP_CODESEPARATOR
]));
__publicField(_R2, "signHashTypesArray", [
  //Transaction.SIGHASH_ALL,
  //Transaction.SIGHASH_ANYONECANPAY,
]);
__publicField(_R2, "numsPoint", Mt3(
  "50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0"
));
/**
 * Partially finalize a P2TR MS transaction
 * @param {number} inputIndex The input index
 * @param {PsbtInput} input The input
 * @param {Uint8Array[]} partialSignatures The partial signatures
 * @param {Uint8Array[]} orderedPubKeys The ordered public keys
 * @param {boolean} isFinal If the transaction is final
 */
__publicField(_R2, "partialFinalizer", (t, e, i, r, s) => {
  var _a37, _b9;
  if (!e.tapLeafScript || !((_a37 = e.tapLeafScript[0]) == null ? void 0 : _a37.script) || !((_b9 = e.tapLeafScript[0]) == null ? void 0 : _b9.controlBlock))
    throw new Error("Tap leaf script is required");
  if (!e.tapScriptSig)
    throw new Error(`No new signatures for input ${t}.`);
  let o = [];
  if (!s)
    o = e.tapScriptSig.map((u) => [u.signature, u.leafHash, u.pubkey]).flat();
  else {
    for (const u of r) {
      let l = false;
      for (const h of e.tapScriptSig)
        P(h.pubkey, $e4(u)) && (o.push(h.signature), l = true);
      l || o.push(new Uint8Array(0));
    }
    o = o.reverse();
  }
  i.length > 0 && (o = o.concat(i));
  const a = e.tapLeafScript[0], c = o.concat(a.script).concat(a.controlBlock);
  return {
    finalScriptWitness: E.witnessStackToScriptWitness(c)
  };
});
var R2 = _R2;
var Pe3 = 1;
var Ht5 = 66;
function ui3(n) {
  return n.type === b.FUNDING;
}
function li3(n) {
  return n.type === b.DEPLOYMENT;
}
function hi3(n) {
  return n.type === b.INTERACTION;
}
function ot4(n) {
  return n.type === b.MULTI_SIG;
}
function di3(n) {
  return n.type === b.CUSTOM_CODE;
}
function pi3(n) {
  return n.type === b.CANCEL;
}
function G2(n) {
  return n.startsWith("0x") ? n.slice(2) : n;
}
var k = class {
  /**
   * Serialize transaction state to binary format
   * @param state - The transaction state to serialize
   * @returns Uint8Array containing serialized state with checksum
   */
  static serialize(t) {
    const e = new V();
    this.writeHeader(e, t.header), this.writeBaseParams(e, t.baseParams), this.writeUTXOArray(e, t.utxos), this.writeUTXOArray(e, t.optionalInputs), this.writeOutputArray(e, t.optionalOutputs), e.writeBoolean(t.addressRotationEnabled), this.writeSignerMappings(e, t.signerMappings), this.writeTypeSpecificData(e, t.typeSpecificData), this.writePrecomputedData(e, t.precomputedData);
    const i = e.getBuffer(), r = this.calculateChecksum(i), s = new Uint8Array(i.length + r.length);
    return s.set(i, 0), s.set(r, i.length), s;
  }
  /**
   * Deserialize binary format to transaction state
   * @param data - Uint8Array containing serialized state
   * @returns Deserialized transaction state
   * @throws Error if checksum validation fails or format is invalid
   */
  static deserialize(t) {
    if (t.length < 32)
      throw new Error("Invalid serialized data: too short");
    const e = t.subarray(-32), i = t.subarray(0, -32), r = this.calculateChecksum(i);
    if (!this.bytesEqual(e, r))
      throw new Error("Invalid checksum - data may be corrupted");
    const s = new te4(i), o = this.readHeader(s);
    if (o.formatVersion > Pe3)
      throw new Error(`Unsupported format version: ${o.formatVersion}`);
    const a = this.readBaseParams(s), c = this.readUTXOArray(s), u = this.readUTXOArray(s), l = this.readOutputArray(s), h = s.readBoolean(), d = this.readSignerMappings(s), p = this.readTypeSpecificData(s, o.transactionType), y = this.readPrecomputedData(s);
    return {
      header: o,
      baseParams: a,
      utxos: c,
      optionalInputs: u,
      optionalOutputs: l,
      addressRotationEnabled: h,
      signerMappings: d,
      typeSpecificData: p,
      precomputedData: y
    };
  }
  /**
   * Export state as base64 string (for transport)
   * @param state - Transaction state to export
   * @returns Base64-encoded string
   */
  static toBase64(t) {
    const e = this.serialize(t);
    return this.uint8ArrayToBase64(e);
  }
  /**
   * Import state from base64 string
   * @param base64 - Base64-encoded state
   * @returns Deserialized transaction state
   */
  static fromBase64(t) {
    return this.deserialize(this.base64ToUint8Array(t));
  }
  /**
   * Export state as hex string
   * @param state - Transaction state to export
   * @returns Hex-encoded string
   */
  static toHex(t) {
    return Yt4(this.serialize(t));
  }
  /**
   * Import state from hex string
   * @param hex - Hex-encoded state
   * @returns Deserialized transaction state
   */
  static fromHex(t) {
    return this.deserialize(Mt3(t));
  }
  static writeHeader(t, e) {
    t.writeU8(Ht5), t.writeU8(e.formatVersion), t.writeU8(e.consensusVersion), t.writeU8(e.transactionType), t.writeU32(e.chainId), t.writeU64(BigInt(e.timestamp));
  }
  static readHeader(t) {
    const e = t.readU8();
    if (e !== Ht5)
      throw new Error(
        `Invalid magic byte: expected 0x${Ht5.toString(16)}, got 0x${e.toString(16)}`
      );
    return {
      formatVersion: t.readU8(),
      consensusVersion: t.readU8(),
      transactionType: t.readU8(),
      chainId: t.readU32(),
      timestamp: Number(t.readU64())
    };
  }
  static writeBaseParams(t, e) {
    t.writeStringWithLength(e.from), t.writeBoolean(e.to !== void 0), e.to !== void 0 && t.writeStringWithLength(e.to), t.writeU32(Math.floor(e.feeRate * 1e3)), t.writeU64(BigInt(e.priorityFee)), t.writeU64(BigInt(e.gasSatFee)), t.writeU8(this.networkNameToU8(e.networkName)), t.writeU8(e.txVersion), t.writeBoolean(e.note !== void 0), e.note !== void 0 && t.writeBytesWithLength(Mt3(e.note)), t.writeBoolean(e.anchor), t.writeBoolean(e.debugFees ?? false);
  }
  static readBaseParams(t) {
    const e = t.readStringWithLength(), r = t.readBoolean() ? t.readStringWithLength() : void 0, s = t.readU32() / 1e3, o = t.readU64().toString(), a = t.readU64().toString(), c = this.u8ToNetworkName(t.readU8()), u = t.readU8(), h = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0, d = t.readBoolean(), p = t.readBoolean();
    return {
      from: e,
      feeRate: s,
      priorityFee: o,
      gasSatFee: a,
      networkName: c,
      txVersion: u,
      anchor: d,
      debugFees: p,
      ...r !== void 0 ? { to: r } : {},
      ...h !== void 0 ? { note: h } : {}
    };
  }
  static writeUTXOArray(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      this.writeUTXO(t, i);
  }
  static writeUTXO(t, e) {
    t.writeBytes(Mt3(e.transactionId)), t.writeU32(e.outputIndex), t.writeU64(BigInt(e.value)), t.writeBytesWithLength(Mt3(e.scriptPubKeyHex)), t.writeBoolean(e.scriptPubKeyAddress !== void 0), e.scriptPubKeyAddress !== void 0 && t.writeStringWithLength(e.scriptPubKeyAddress), t.writeBoolean(e.redeemScript !== void 0), e.redeemScript !== void 0 && t.writeBytesWithLength(Mt3(e.redeemScript)), t.writeBoolean(e.witnessScript !== void 0), e.witnessScript !== void 0 && t.writeBytesWithLength(Mt3(e.witnessScript)), t.writeBoolean(e.nonWitnessUtxo !== void 0), e.nonWitnessUtxo !== void 0 && t.writeBytesWithLength(Mt3(e.nonWitnessUtxo));
  }
  static readUTXOArray(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++)
      i.push(this.readUTXO(t));
    return i;
  }
  static readUTXO(t) {
    const e = Yt4(t.readBytes(32)), i = t.readU32(), r = t.readU64().toString(), s = Yt4(t.readBytesWithLength()), a = t.readBoolean() ? t.readStringWithLength() : void 0, u = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0, h = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0, p = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0;
    return {
      transactionId: e,
      outputIndex: i,
      value: r,
      scriptPubKeyHex: s,
      ...a !== void 0 ? { scriptPubKeyAddress: a } : {},
      ...u !== void 0 ? { redeemScript: u } : {},
      ...h !== void 0 ? { witnessScript: h } : {},
      ...p !== void 0 ? { nonWitnessUtxo: p } : {}
    };
  }
  static writeOutputArray(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      this.writeOutput(t, i);
  }
  static writeOutput(t, e) {
    t.writeU64(BigInt(e.value)), t.writeBoolean(e.address !== void 0), e.address !== void 0 && t.writeStringWithLength(e.address), t.writeBoolean(e.script !== void 0), e.script !== void 0 && t.writeBytesWithLength(Mt3(e.script)), t.writeBoolean(e.tapInternalKey !== void 0), e.tapInternalKey !== void 0 && t.writeBytesWithLength(Mt3(e.tapInternalKey));
  }
  static readOutputArray(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++)
      i.push(this.readOutput(t));
    return i;
  }
  static readOutput(t) {
    const e = Number(t.readU64()), r = t.readBoolean() ? t.readStringWithLength() : void 0, o = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0, c = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0;
    return {
      value: e,
      ...r !== void 0 ? { address: r } : {},
      ...o !== void 0 ? { script: o } : {},
      ...c !== void 0 ? { tapInternalKey: c } : {}
    };
  }
  static writeSignerMappings(t, e) {
    t.writeU16(e.length);
    for (const i of e) {
      t.writeStringWithLength(i.address), t.writeU16(i.inputIndices.length);
      for (const r of i.inputIndices)
        t.writeU16(r);
    }
  }
  static readSignerMappings(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++) {
      const s = t.readStringWithLength(), o = t.readU16(), a = [];
      for (let c = 0; c < o; c++)
        a.push(t.readU16());
      i.push({ address: s, inputIndices: a });
    }
    return i;
  }
  static writeTypeSpecificData(t, e) {
    switch (e.type) {
      case b.FUNDING:
        this.writeFundingData(t, e);
        break;
      case b.DEPLOYMENT:
        this.writeDeploymentData(t, e);
        break;
      case b.INTERACTION:
        this.writeInteractionData(t, e);
        break;
      case b.MULTI_SIG:
        this.writeMultiSigData(t, e);
        break;
      case b.CUSTOM_CODE:
        this.writeCustomScriptData(t, e);
        break;
      case b.CANCEL:
        this.writeCancelData(t, e);
        break;
      default:
        throw new Error(`Unsupported transaction type: ${e.type}`);
    }
  }
  static readTypeSpecificData(t, e) {
    switch (e) {
      case b.FUNDING:
        return this.readFundingData(t);
      case b.DEPLOYMENT:
        return this.readDeploymentData(t);
      case b.INTERACTION:
        return this.readInteractionData(t);
      case b.MULTI_SIG:
        return this.readMultiSigData(t);
      case b.CUSTOM_CODE:
        return this.readCustomScriptData(t);
      case b.CANCEL:
        return this.readCancelData(t);
      default:
        throw new Error(`Unsupported transaction type: ${e}`);
    }
  }
  // Funding
  static writeFundingData(t, e) {
    t.writeU64(BigInt(e.amount)), t.writeU16(e.splitInputsInto);
  }
  static readFundingData(t) {
    return {
      type: b.FUNDING,
      amount: t.readU64().toString(),
      splitInputsInto: t.readU16()
    };
  }
  // Deployment
  static writeDeploymentData(t, e) {
    t.writeBytesWithLength(Mt3(e.bytecode)), t.writeBoolean(e.calldata !== void 0), e.calldata !== void 0 && t.writeBytesWithLength(Mt3(e.calldata)), this.writeChallenge(t, e.challenge), t.writeBoolean(e.revealMLDSAPublicKey ?? false), t.writeBoolean(e.linkMLDSAPublicKeyToAddress ?? false), t.writeBoolean(e.hashedPublicKey !== void 0), e.hashedPublicKey !== void 0 && t.writeBytesWithLength(Mt3(e.hashedPublicKey));
  }
  static readDeploymentData(t) {
    const e = Yt4(t.readBytesWithLength()), r = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0, s = this.readChallenge(t), o = t.readBoolean(), a = t.readBoolean(), u = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0;
    return {
      type: b.DEPLOYMENT,
      bytecode: e,
      challenge: s,
      revealMLDSAPublicKey: o,
      linkMLDSAPublicKeyToAddress: a,
      ...r !== void 0 ? { calldata: r } : {},
      ...u !== void 0 ? { hashedPublicKey: u } : {}
    };
  }
  // Interaction
  static writeInteractionData(t, e) {
    t.writeBytesWithLength(Mt3(e.calldata)), t.writeBoolean(e.contract !== void 0), e.contract !== void 0 && t.writeStringWithLength(e.contract), this.writeChallenge(t, e.challenge), t.writeBoolean(e.loadedStorage !== void 0), e.loadedStorage !== void 0 && this.writeLoadedStorage(t, e.loadedStorage), t.writeBoolean(e.isCancellation ?? false), t.writeBoolean(e.disableAutoRefund ?? false), t.writeBoolean(e.revealMLDSAPublicKey ?? false), t.writeBoolean(e.linkMLDSAPublicKeyToAddress ?? false), t.writeBoolean(e.hashedPublicKey !== void 0), e.hashedPublicKey !== void 0 && t.writeBytesWithLength(Mt3(e.hashedPublicKey));
  }
  static readInteractionData(t) {
    const e = Yt4(t.readBytesWithLength()), r = t.readBoolean() ? t.readStringWithLength() : void 0, s = this.readChallenge(t), a = t.readBoolean() ? this.readLoadedStorage(t) : void 0, c = t.readBoolean(), u = t.readBoolean(), l = t.readBoolean(), h = t.readBoolean(), p = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0;
    return {
      type: b.INTERACTION,
      calldata: e,
      challenge: s,
      isCancellation: c,
      disableAutoRefund: u,
      revealMLDSAPublicKey: l,
      linkMLDSAPublicKeyToAddress: h,
      ...r !== void 0 ? { contract: r } : {},
      ...a !== void 0 ? { loadedStorage: a } : {},
      ...p !== void 0 ? { hashedPublicKey: p } : {}
    };
  }
  // MultiSig
  static writeMultiSigData(t, e) {
    t.writeU16(e.pubkeys.length);
    for (const i of e.pubkeys)
      t.writeBytesWithLength(Mt3(i));
    t.writeU8(e.minimumSignatures), t.writeStringWithLength(e.receiver), t.writeU64(BigInt(e.requestedAmount)), t.writeStringWithLength(e.refundVault), t.writeU16(e.originalInputCount), t.writeBoolean(e.existingPsbtBase64 !== void 0), e.existingPsbtBase64 !== void 0 && t.writeStringWithLength(e.existingPsbtBase64);
  }
  static readMultiSigData(t) {
    const e = t.readU16(), i = [];
    for (let h = 0; h < e; h++)
      i.push(Yt4(t.readBytesWithLength()));
    const r = t.readU8(), s = t.readStringWithLength(), o = t.readU64().toString(), a = t.readStringWithLength(), c = t.readU16(), l = t.readBoolean() ? t.readStringWithLength() : void 0;
    return {
      type: b.MULTI_SIG,
      pubkeys: i,
      minimumSignatures: r,
      receiver: s,
      requestedAmount: o,
      refundVault: a,
      originalInputCount: c,
      ...l !== void 0 ? { existingPsbtBase64: l } : {}
    };
  }
  // Custom Script
  static writeCustomScriptData(t, e) {
    t.writeU16(e.scriptElements.length);
    for (const i of e.scriptElements)
      this.writeScriptElement(t, i);
    t.writeU16(e.witnesses.length);
    for (const i of e.witnesses)
      t.writeBytesWithLength(Mt3(i));
    t.writeBoolean(e.annex !== void 0), e.annex !== void 0 && t.writeBytesWithLength(Mt3(e.annex));
  }
  static writeScriptElement(t, e) {
    t.writeU8(e.elementType === "buffer" ? 0 : 1), e.elementType === "buffer" ? t.writeBytesWithLength(Mt3(e.value)) : t.writeU32(e.value);
  }
  static readCustomScriptData(t) {
    const e = t.readU16(), i = [];
    for (let c = 0; c < e; c++)
      i.push(this.readScriptElement(t));
    const r = t.readU16(), s = [];
    for (let c = 0; c < r; c++)
      s.push(Yt4(t.readBytesWithLength()));
    const a = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0;
    return {
      type: b.CUSTOM_CODE,
      scriptElements: i,
      witnesses: s,
      ...a !== void 0 ? { annex: a } : {}
    };
  }
  static readScriptElement(t) {
    return t.readU8() === 0 ? {
      elementType: "buffer",
      value: Yt4(t.readBytesWithLength())
    } : {
      elementType: "opcode",
      value: t.readU32()
    };
  }
  // Cancel
  static writeCancelData(t, e) {
    t.writeBytesWithLength(Mt3(e.compiledTargetScript));
  }
  static readCancelData(t) {
    return {
      type: b.CANCEL,
      compiledTargetScript: Yt4(t.readBytesWithLength())
    };
  }
  static writeChallenge(t, e) {
    t.writeU64(BigInt(e.epochNumber)), t.writeStringWithLength(e.mldsaPublicKey), t.writeStringWithLength(e.legacyPublicKey), t.writeBytesWithLength(Mt3(G2(e.solution))), t.writeBytesWithLength(Mt3(G2(e.salt))), t.writeBytesWithLength(Mt3(G2(e.graffiti))), t.writeU8(e.difficulty), this.writeChallengeVerification(t, e.verification), t.writeBoolean(e.submission !== void 0), e.submission !== void 0 && (t.writeStringWithLength(e.submission.mldsaPublicKey), t.writeStringWithLength(e.submission.legacyPublicKey), t.writeBytesWithLength(Mt3(G2(e.submission.solution))), t.writeBoolean(e.submission.graffiti !== void 0), e.submission.graffiti !== void 0 && t.writeBytesWithLength(
      Mt3(G2(e.submission.graffiti))
    ), t.writeBytesWithLength(Mt3(G2(e.submission.signature))));
  }
  static writeChallengeVerification(t, e) {
    t.writeBytesWithLength(Mt3(G2(e.epochHash))), t.writeBytesWithLength(Mt3(G2(e.epochRoot))), t.writeBytesWithLength(Mt3(G2(e.targetHash))), t.writeBytesWithLength(Mt3(G2(e.targetChecksum))), t.writeU64(BigInt(e.startBlock)), t.writeU64(BigInt(e.endBlock)), t.writeU16(e.proofs.length);
    for (const i of e.proofs)
      t.writeBytesWithLength(Mt3(G2(i)));
  }
  static readChallenge(t) {
    const e = t.readU64().toString(), i = t.readStringWithLength(), r = t.readStringWithLength(), s = "0x" + Yt4(t.readBytesWithLength()), o = "0x" + Yt4(t.readBytesWithLength()), a = "0x" + Yt4(t.readBytesWithLength()), c = t.readU8(), u = this.readChallengeVerification(t), l = t.readBoolean();
    let h;
    if (l) {
      const d = t.readStringWithLength(), p = t.readStringWithLength(), y = "0x" + Yt4(t.readBytesWithLength()), A = t.readBoolean() ? "0x" + Yt4(t.readBytesWithLength()) : void 0, x = "0x" + Yt4(t.readBytesWithLength());
      h = {
        mldsaPublicKey: d,
        legacyPublicKey: p,
        solution: y,
        signature: x,
        ...A !== void 0 ? { graffiti: A } : {}
      };
    }
    return {
      epochNumber: e,
      mldsaPublicKey: i,
      legacyPublicKey: r,
      solution: s,
      salt: o,
      graffiti: a,
      difficulty: c,
      verification: u,
      ...h !== void 0 ? { submission: h } : {}
    };
  }
  static readChallengeVerification(t) {
    const e = "0x" + Yt4(t.readBytesWithLength()), i = "0x" + Yt4(t.readBytesWithLength()), r = "0x" + Yt4(t.readBytesWithLength()), s = "0x" + Yt4(t.readBytesWithLength()), o = t.readU64().toString(), a = t.readU64().toString(), c = t.readU16(), u = [];
    for (let l = 0; l < c; l++)
      u.push("0x" + Yt4(t.readBytesWithLength()));
    return {
      epochHash: e,
      epochRoot: i,
      targetHash: r,
      targetChecksum: s,
      startBlock: o,
      endBlock: a,
      proofs: u
    };
  }
  static writeLoadedStorage(t, e) {
    const i = Object.keys(e);
    t.writeU16(i.length);
    for (const r of i)
      t.writeStringWithLength(r), t.writeStringArray(e[r]);
  }
  static readLoadedStorage(t) {
    const e = t.readU16(), i = {};
    for (let r = 0; r < e; r++) {
      const s = t.readStringWithLength();
      i[s] = t.readStringArray();
    }
    return i;
  }
  static writePrecomputedData(t, e) {
    t.writeBoolean(e.compiledTargetScript !== void 0), e.compiledTargetScript !== void 0 && t.writeBytesWithLength(Mt3(e.compiledTargetScript)), t.writeBoolean(e.randomBytes !== void 0), e.randomBytes !== void 0 && t.writeBytesWithLength(Mt3(e.randomBytes)), t.writeBoolean(e.estimatedFees !== void 0), e.estimatedFees !== void 0 && t.writeU64(BigInt(e.estimatedFees)), t.writeBoolean(e.contractSeed !== void 0), e.contractSeed !== void 0 && t.writeStringWithLength(e.contractSeed), t.writeBoolean(e.contractAddress !== void 0), e.contractAddress !== void 0 && t.writeStringWithLength(e.contractAddress);
  }
  static readPrecomputedData(t) {
    const i = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0, s = t.readBoolean() ? Yt4(t.readBytesWithLength()) : void 0, a = t.readBoolean() ? t.readU64().toString() : void 0, u = t.readBoolean() ? t.readStringWithLength() : void 0, h = t.readBoolean() ? t.readStringWithLength() : void 0;
    return {
      ...i !== void 0 ? { compiledTargetScript: i } : {},
      ...s !== void 0 ? { randomBytes: s } : {},
      ...a !== void 0 ? { estimatedFees: a } : {},
      ...u !== void 0 ? { contractSeed: u } : {},
      ...h !== void 0 ? { contractAddress: h } : {}
    };
  }
  /**
   * Calculate double SHA256 checksum (Bitcoin standard)
   */
  static calculateChecksum(t) {
    const e = oe4("sha256").update(t).digest();
    return new Uint8Array(oe4("sha256").update(e).digest());
  }
  /**
   * Compare two Uint8Arrays for equality
   */
  static bytesEqual(t, e) {
    if (t.length !== e.length) return false;
    for (let i = 0; i < t.length; i++)
      if (t[i] !== e[i]) return false;
    return true;
  }
  /**
   * Encode Uint8Array to base64 string
   */
  static uint8ArrayToBase64(t) {
    let e = "";
    for (let i = 0; i < t.length; i++)
      e += String.fromCharCode(t[i]);
    return btoa(e);
  }
  /**
   * Decode base64 string to Uint8Array
   */
  static base64ToUint8Array(t) {
    const e = atob(t), i = new Uint8Array(e.length);
    for (let r = 0; r < e.length; r++)
      i[r] = e.charCodeAt(r);
    return i;
  }
  static networkNameToU8(t) {
    switch (t) {
      case "mainnet":
        return 0;
      case "testnet":
        return 1;
      case "regtest":
        return 2;
      case "opnetTestnet":
        return 3;
      default:
        throw new Error(`Unknown network: ${t}`);
    }
  }
  static u8ToNetworkName(t) {
    switch (t) {
      case 0:
        return "mainnet";
      case 1:
        return "testnet";
      case 2:
        return "regtest";
      case 3:
        return "opnetTestnet";
      default:
        throw new Error(`Unknown network value: ${t}`);
    }
  }
};
var Ft4 = ((n) => (n[n.Roswell = 0] = "Roswell", n[n.Rachel = 1] = "Rachel", n[n.Kecksburg = 2] = "Kecksburg", n[n.Phoenix = 3] = "Phoenix", n[n.Aurora = 4] = "Aurora", n[n.Rendlesham = 5] = "Rendlesham", n[n.Lazar = 6] = "Lazar", n[n.ShagHarbor = 7] = "ShagHarbor", n[n.Exeter = 8] = "Exeter", n[n.Stephenville = 9] = "Stephenville", n[n.Valensole = 10] = "Valensole", n[n.Socorro = 11] = "Socorro", n[n.Pascagoula = 12] = "Pascagoula", n[n.Tehran = 13] = "Tehran", n[n.Westall = 14] = "Westall", n[n.Hopkinsville = 15] = "Hopkinsville", n[n.Belgium = 16] = "Belgium", n[n.Breeze = 17] = "Breeze", n[n.Flatwoods = 18] = "Flatwoods", n[n.Maury = 20] = "Maury", n[n.Varginha = 21] = "Varginha", n[n.Trindade = 22] = "Trindade", n[n.Levelland = 23] = "Levelland", n[n.Wanaque = 24] = "Wanaque", n[n.Coyame = 25] = "Coyame", n[n.Delphos = 26] = "Delphos", n))(Ft4 || {});
var fi3 = {
  CONSENSUS: Ft4.Roswell,
  CONSENSUS_NAME: "Roswell",
  // The block height at which this consensus was enabled.
  ENABLED_AT_BLOCK: 0n
};
var gi3 = {
  [Ft4.Roswell]: fi3
};
var ve4 = Ft4.Roswell;
var Pr3 = gi3[ve4];
var tt4 = class {
  /**
   * Capture state from a FundingTransaction
   */
  static fromFunding(t, e) {
    return this.captureState({
      params: t,
      type: b.FUNDING,
      ...e !== void 0 ? { precomputed: e } : {}
    });
  }
  /**
   * Capture state from a DeploymentTransaction
   */
  static fromDeployment(t, e) {
    return this.captureState({
      params: t,
      type: b.DEPLOYMENT,
      precomputed: e
    });
  }
  /**
   * Capture state from an InteractionTransaction
   */
  static fromInteraction(t, e) {
    return this.captureState({
      params: t,
      type: b.INTERACTION,
      precomputed: e
    });
  }
  /**
   * Capture state from a MultiSignTransaction
   */
  static fromMultiSig(t, e) {
    return this.captureState({
      params: t,
      type: b.MULTI_SIG,
      ...e !== void 0 ? { precomputed: e } : {}
    });
  }
  /**
   * Capture state from a CustomScriptTransaction
   */
  static fromCustomScript(t, e) {
    return this.captureState({
      params: t,
      type: b.CUSTOM_CODE,
      ...e !== void 0 ? { precomputed: e } : {}
    });
  }
  /**
   * Capture state from a CancelTransaction
   */
  static fromCancel(t, e) {
    return this.captureState({
      params: t,
      type: b.CANCEL,
      ...e !== void 0 ? { precomputed: e } : {}
    });
  }
  /**
   * Main state capture method
   */
  static captureState(t) {
    var _a37;
    const { params: e, type: i, precomputed: r } = t;
    return {
      header: this.createHeader(i, e.network, e.chainId),
      baseParams: this.extractBaseParams(e),
      utxos: this.serializeUTXOs(e.utxos),
      optionalInputs: this.serializeUTXOs(e.optionalInputs || []),
      optionalOutputs: this.serializeOutputs(e.optionalOutputs || []),
      addressRotationEnabled: ((_a37 = e.addressRotation) == null ? void 0 : _a37.enabled) ?? false,
      signerMappings: this.extractSignerMappings(e),
      typeSpecificData: this.extractTypeSpecificData(i, e),
      precomputedData: this.buildPrecomputedData(r)
    };
  }
  /**
   * Create serialization header
   */
  static createHeader(t, e, i) {
    return {
      formatVersion: Pe3,
      consensusVersion: ve4,
      transactionType: t,
      chainId: i ?? this.networkToChainId(e),
      timestamp: Date.now()
    };
  }
  /**
   * Extract base parameters common to all transaction types
   */
  static extractBaseParams(t) {
    const e = t.note ? t.note instanceof Uint8Array ? Yt4(t.note) : Yt4(new TextEncoder().encode(t.note)) : void 0, i = t.priorityFee ?? 0n, r = t.gasSatFee ?? 0n;
    return {
      from: t.from || "",
      feeRate: t.feeRate,
      priorityFee: i.toString(),
      gasSatFee: r.toString(),
      networkName: this.networkToName(t.network),
      txVersion: t.txVersion ?? 2,
      anchor: t.anchor ?? false,
      ...t.to !== void 0 ? { to: t.to } : {},
      ...e !== void 0 ? { note: e } : {},
      ...t.debugFees !== void 0 ? { debugFees: t.debugFees } : {}
    };
  }
  /**
   * Extract signer mappings for address rotation mode
   */
  static extractSignerMappings(t) {
    var _a37;
    if (!((_a37 = t.addressRotation) == null ? void 0 : _a37.enabled))
      return [];
    const e = [], i = /* @__PURE__ */ new Map();
    t.utxos.forEach((s, o) => {
      var _a38;
      const a = (_a38 = s.scriptPubKey) == null ? void 0 : _a38.address;
      if (a) {
        const c = i.get(a);
        c ? c.push(o) : i.set(a, [o]);
      }
    });
    const r = t.utxos.length;
    return (t.optionalInputs || []).forEach((s, o) => {
      var _a38;
      const a = (_a38 = s.scriptPubKey) == null ? void 0 : _a38.address;
      if (a) {
        const c = i.get(a);
        c ? c.push(r + o) : i.set(a, [r + o]);
      }
    }), i.forEach((s, o) => {
      e.push({ address: o, inputIndices: s });
    }), e;
  }
  /**
   * Extract type-specific data based on transaction type
   */
  static extractTypeSpecificData(t, e) {
    switch (t) {
      case b.FUNDING:
        return this.extractFundingData(e);
      case b.DEPLOYMENT:
        return this.extractDeploymentData(e);
      case b.INTERACTION:
        return this.extractInteractionData(e);
      case b.MULTI_SIG:
        return this.extractMultiSigData(e);
      case b.CUSTOM_CODE:
        return this.extractCustomScriptData(e);
      case b.CANCEL:
        return this.extractCancelData(e);
      default:
        throw new Error(`Unsupported transaction type: ${t}`);
    }
  }
  static extractFundingData(t) {
    return {
      type: b.FUNDING,
      amount: t.amount.toString(),
      splitInputsInto: t.splitInputsInto ?? 1
    };
  }
  static extractDeploymentData(t) {
    return {
      type: b.DEPLOYMENT,
      bytecode: Yt4(t.bytecode),
      challenge: t.challenge.toRaw(),
      ...t.calldata ? { calldata: Yt4(t.calldata) } : {},
      ...t.revealMLDSAPublicKey !== void 0 ? { revealMLDSAPublicKey: t.revealMLDSAPublicKey } : {},
      ...t.linkMLDSAPublicKeyToAddress !== void 0 ? { linkMLDSAPublicKeyToAddress: t.linkMLDSAPublicKeyToAddress } : {}
    };
  }
  static extractInteractionData(t) {
    return {
      type: b.INTERACTION,
      calldata: Yt4(t.calldata),
      challenge: t.challenge.toRaw(),
      ...t.contract !== void 0 ? { contract: t.contract } : {},
      ...t.loadedStorage !== void 0 ? { loadedStorage: t.loadedStorage } : {},
      ...t.isCancellation !== void 0 ? { isCancellation: t.isCancellation } : {},
      ...t.disableAutoRefund !== void 0 ? { disableAutoRefund: t.disableAutoRefund } : {},
      ...t.revealMLDSAPublicKey !== void 0 ? { revealMLDSAPublicKey: t.revealMLDSAPublicKey } : {},
      ...t.linkMLDSAPublicKeyToAddress !== void 0 ? { linkMLDSAPublicKeyToAddress: t.linkMLDSAPublicKeyToAddress } : {}
    };
  }
  static extractMultiSigData(t) {
    return {
      type: b.MULTI_SIG,
      pubkeys: (t.pubkeys || []).map((e) => Yt4(e)),
      minimumSignatures: t.minimumSignatures || 0,
      receiver: t.receiver || "",
      requestedAmount: (t.requestedAmount || 0n).toString(),
      refundVault: t.refundVault || "",
      originalInputCount: t.originalInputCount || t.utxos.length,
      ...t.existingPsbtBase64 !== void 0 ? { existingPsbtBase64: t.existingPsbtBase64 } : {}
    };
  }
  static extractCustomScriptData(t) {
    const e = (t.scriptElements || []).map(
      (i) => i instanceof Uint8Array ? {
        elementType: "buffer",
        value: Yt4(i)
      } : {
        elementType: "opcode",
        value: i
      }
    );
    return {
      type: b.CUSTOM_CODE,
      scriptElements: e,
      witnesses: (t.witnesses || []).map((i) => Yt4(i)),
      ...t.annex ? { annex: Yt4(t.annex) } : {}
    };
  }
  static extractCancelData(t) {
    const e = t.compiledTargetScript, i = e ? e instanceof Uint8Array ? Yt4(e) : e : "";
    return {
      type: b.CANCEL,
      compiledTargetScript: i
    };
  }
  /**
   * Build precomputed data object
   */
  static buildPrecomputedData(t) {
    return {
      ...(t == null ? void 0 : t.compiledTargetScript) !== void 0 ? { compiledTargetScript: t.compiledTargetScript } : {},
      ...(t == null ? void 0 : t.randomBytes) !== void 0 ? { randomBytes: t.randomBytes } : {},
      ...(t == null ? void 0 : t.estimatedFees) !== void 0 ? { estimatedFees: t.estimatedFees } : {},
      ...(t == null ? void 0 : t.contractSeed) !== void 0 ? { contractSeed: t.contractSeed } : {},
      ...(t == null ? void 0 : t.contractAddress) !== void 0 ? { contractAddress: t.contractAddress } : {}
    };
  }
  /**
   * Serialize UTXOs array
   */
  static serializeUTXOs(t) {
    return t.map((e) => {
      const i = e.redeemScript ? e.redeemScript instanceof Uint8Array ? Yt4(e.redeemScript) : e.redeemScript : void 0, r = e.witnessScript ? e.witnessScript instanceof Uint8Array ? Yt4(e.witnessScript) : e.witnessScript : void 0, s = e.nonWitnessUtxo ? e.nonWitnessUtxo instanceof Uint8Array ? Yt4(e.nonWitnessUtxo) : e.nonWitnessUtxo : void 0;
      return {
        transactionId: e.transactionId,
        outputIndex: e.outputIndex,
        value: e.value.toString(),
        scriptPubKeyHex: e.scriptPubKey.hex,
        ...e.scriptPubKey.address !== void 0 ? { scriptPubKeyAddress: e.scriptPubKey.address } : {},
        ...i !== void 0 ? { redeemScript: i } : {},
        ...r !== void 0 ? { witnessScript: r } : {},
        ...s !== void 0 ? { nonWitnessUtxo: s } : {}
      };
    });
  }
  /**
   * Serialize outputs array
   */
  static serializeOutputs(t) {
    return t.map((e) => {
      const i = "address" in e ? e.address : void 0, r = "script" in e ? e.script : void 0, s = r ? Yt4(r) : void 0, o = e.tapInternalKey ? Yt4(e.tapInternalKey) : void 0;
      return {
        value: Number(e.value),
        ...i !== void 0 ? { address: i } : {},
        ...s !== void 0 ? { script: s } : {},
        ...o !== void 0 ? { tapInternalKey: o } : {}
      };
    });
  }
  /**
   * Convert network to name string
   */
  static networkToName(t) {
    return t.bech32 === "bc" ? "mainnet" : t.bech32 === "tb" ? "testnet" : t.bech32 === "opt" ? "opnetTestnet" : "regtest";
  }
  /**
   * Convert network to chain ID
   */
  static networkToChainId(t) {
    return ye4.Bitcoin;
  }
};
function F2(n) {
  return Mt3(n.startsWith("0x") ? n.slice(2) : n);
}
var St4 = class {
  /**
   * Calculate SHA-1 hash
   */
  static sha1(t) {
    return Zh2.sha1(t);
  }
  /**
   * Calculate mining preimage
   */
  static calculatePreimage(t, e, i) {
    if (t.length !== 32 || e.length !== 32 || i.length !== 32)
      throw new Error("All inputs must be 32 bytes");
    const r = new Uint8Array(32);
    for (let s = 0; s < 32; s++)
      r[s] = t[s] ^ e[s] ^ i[s];
    return r;
  }
  /**
   * Count matching bits between two hashes
   */
  static countMatchingBits(t, e) {
    let i = 0;
    if (t.length !== e.length)
      throw new Error("Hashes must be of the same length");
    const r = Math.min(t.length, e.length);
    for (let s = 0; s < r; s++) {
      const o = t[s], a = e[s];
      if (o === a)
        i += 8;
      else
        for (let c = 7; c >= 0; c--)
          if ((o >> c & 1) === (a >> c & 1))
            i++;
          else
            return i;
    }
    return i;
  }
  /**
   * Verify an epoch solution using IPreimage
   */
  static verifySolution(t, e = false) {
    try {
      const i = t.verification, r = this.calculatePreimage(
        i.targetChecksum,
        t.publicKey.toBuffer(),
        t.salt
      ), s = this.sha1(r);
      if (!P(s, t.solution) || this.countMatchingBits(s, i.targetHash) !== t.difficulty)
        return false;
      const a = t.epochNumber * this.BLOCKS_PER_EPOCH, c = a + this.BLOCKS_PER_EPOCH - 1n;
      return !(i.startBlock !== a || i.endBlock !== c);
    } catch (i) {
      return e && console.error("Verification error:", i), false;
    }
  }
  /**
   * Get the mining target block for an epoch
   */
  static getMiningTargetBlock(t) {
    return t === 0n ? null : t * this.BLOCKS_PER_EPOCH - 1n;
  }
  /**
   * Validate epoch winner from raw data
   */
  static validateEpochWinner(t) {
    try {
      const e = BigInt(t.epochNumber), i = K2.fromString(
        t.mldsaPublicKey,
        t.legacyPublicKey
      ), r = F2(t.solution), s = F2(t.salt), o = t.difficulty, a = {
        epochHash: F2(t.verification.epochHash),
        epochRoot: F2(t.verification.epochRoot),
        targetHash: F2(t.verification.targetHash),
        targetChecksum: F2(t.verification.targetChecksum),
        startBlock: BigInt(t.verification.startBlock),
        endBlock: BigInt(t.verification.endBlock),
        proofs: Object.freeze(t.verification.proofs.map((p) => F2(p)))
      }, c = this.calculatePreimage(
        a.targetChecksum,
        i.toBuffer(),
        s
      ), u = this.sha1(c);
      if (!P(u, r) || this.countMatchingBits(u, a.targetHash) !== o)
        return false;
      const h = e * this.BLOCKS_PER_EPOCH, d = h + this.BLOCKS_PER_EPOCH - 1n;
      return !(a.startBlock !== h || a.endBlock !== d);
    } catch {
      return false;
    }
  }
  /**
   * Validate epoch winner from Preimage instance
   */
  static validateChallengeSolution(t) {
    return this.verifySolution(t);
  }
  /**
   * Calculate solution hash from preimage components
   * @param targetChecksum The target checksum (32 bytes)
   * @param publicKey The public key buffer (32 bytes)
   * @param salt The salt buffer (32 bytes)
   * @returns The SHA-1 hash of the preimage
   */
  static calculateSolution(t, e, i) {
    const r = this.calculatePreimage(t, e, i);
    return this.sha1(r);
  }
  /**
   * Check if a solution meets the minimum difficulty requirement
   */
  static checkDifficulty(t, e, i) {
    const r = this.countMatchingBits(t, e);
    return {
      valid: r >= i,
      difficulty: r
    };
  }
};
__publicField(St4, "BLOCKS_PER_EPOCH", 5n);
var Si2 = class {
  constructor(t) {
    __publicField(this, "epochHash");
    __publicField(this, "epochRoot");
    __publicField(this, "targetHash");
    __publicField(this, "targetChecksum");
    __publicField(this, "startBlock");
    __publicField(this, "endBlock");
    __publicField(this, "proofs");
    this.epochHash = F2(t.epochHash), this.epochRoot = F2(t.epochRoot), this.targetHash = F2(t.targetHash), this.targetChecksum = F2(t.targetChecksum), this.startBlock = BigInt(t.startBlock), this.endBlock = BigInt(t.endBlock), this.proofs = Object.freeze(t.proofs.map((e) => F2(e)));
  }
};
var wi3 = class {
  constructor(t, e) {
    __publicField(this, "publicKey");
    __publicField(this, "solution");
    __publicField(this, "graffiti");
    __publicField(this, "signature");
    this.epochNumber = e, this.publicKey = K2.fromString(t.mldsaPublicKey, t.legacyPublicKey), this.solution = F2(t.solution), this.graffiti = t.graffiti ? F2(t.graffiti) : void 0, this.signature = F2(t.signature);
  }
  verifySignature() {
    const t = new V();
    t.writeAddress(this.publicKey), t.writeU64(this.epochNumber), t.writeBytes(this.solution), this.graffiti && t.writeBytes(this.graffiti);
    const e = t.getBuffer();
    return ct4.verifySignature(
      this.publicKey.tweakedPublicKeyToBuffer(),
      e,
      this.signature
    );
  }
};
var he3 = class {
  constructor(t) {
    __publicField(this, "epochNumber");
    __publicField(this, "publicKey");
    __publicField(this, "solution");
    __publicField(this, "salt");
    __publicField(this, "graffiti");
    __publicField(this, "difficulty");
    __publicField(this, "verification");
    __publicField(this, "submission");
    this.epochNumber = BigInt(t.epochNumber), this.publicKey = K2.fromString(t.mldsaPublicKey, t.legacyPublicKey), this.solution = F2(t.solution), this.salt = F2(t.salt), this.graffiti = F2(t.graffiti), this.difficulty = t.difficulty, this.verification = new Si2(t.verification), this.submission = t.submission ? new wi3(t.submission, this.epochNumber + 2n) : t.submission;
  }
  /**
   * Static method to validate from raw data directly
   */
  static validateRaw(t) {
    return St4.validateEpochWinner(t);
  }
  verifySubmissionSignature() {
    if (!this.submission)
      throw new Error("No submission provided in request.");
    return this.submission.verifySignature();
  }
  getSubmission() {
    if (this.submission) {
      if (!this.verifySubmissionSignature())
        throw new Error("Invalid submission signature.");
      return this.submission;
    }
  }
  /**
   * Verify this challenge
   * @returns {boolean} True if the challenge is valid
   */
  verify() {
    return St4.validateChallengeSolution(this);
  }
  /**
   * Get the preimage challenge
   * @returns {Uint8Array} The solution/challenge as a Uint8Array
   */
  toBuffer() {
    return this.solution;
  }
  /**
   * Get the solution as a hex string
   * @returns {string} The solution as a hex string with 0x prefix
   */
  toHex() {
    return "0x" + Yt4(this.solution);
  }
  /**
   * Convert to raw format for serialization
   */
  toRaw() {
    return {
      epochNumber: this.epochNumber.toString(),
      mldsaPublicKey: this.publicKey.toHex(),
      legacyPublicKey: this.publicKey.tweakedToHex(),
      solution: this.toHex(),
      salt: "0x" + Yt4(this.salt),
      graffiti: "0x" + Yt4(this.graffiti),
      difficulty: this.difficulty,
      verification: {
        epochHash: "0x" + Yt4(this.verification.epochHash),
        epochRoot: "0x" + Yt4(this.verification.epochRoot),
        targetHash: "0x" + Yt4(this.verification.targetHash),
        targetChecksum: "0x" + Yt4(this.verification.targetChecksum),
        startBlock: this.verification.startBlock.toString(),
        endBlock: this.verification.endBlock.toString(),
        proofs: this.verification.proofs.map((t) => "0x" + Yt4(t))
      }
    };
  }
  /**
   * Calculate the expected solution hash for this challenge
   * @returns {Uint8Array} The calculated solution hash
   */
  calculateSolution() {
    return St4.calculateSolution(
      this.verification.targetChecksum,
      this.publicKey.toBuffer(),
      this.salt
    );
  }
  /**
   * Check if the challenge meets a specific difficulty requirement
   * @param {number} minDifficulty The minimum difficulty required
   * @returns {Promise<{valid: boolean; difficulty: number}>} Validation result
   */
  checkDifficulty(t) {
    return St4.checkDifficulty(
      this.solution,
      this.verification.targetHash,
      t
    );
  }
  /**
   * Get the mining target block for this epoch
   * @returns {bigint | null} The target block number or null if epoch 0
   */
  getMiningTargetBlock() {
    return St4.getMiningTargetBlock(this.epochNumber);
  }
};
var wt5 = class {
  /**
   * Reconstruct and optionally rebuild transaction with new parameters
   * @param state - Serialized transaction state
   * @param options - Signer(s) and optional fee overrides
   * @returns Reconstructed transaction builder ready for signing
   */
  static reconstruct(t, e) {
    const i = this.nameToNetwork(t.baseParams.networkName), r = this.deserializeUTXOs(t.utxos), s = this.deserializeUTXOs(t.optionalInputs), o = this.deserializeOutputs(t.optionalOutputs), a = this.buildAddressRotationConfig(
      t.addressRotationEnabled,
      e.signerMap
    ), c = e.newFeeRate ?? t.baseParams.feeRate, u = e.newPriorityFee ?? BigInt(t.baseParams.priorityFee), l = e.newGasSatFee ?? BigInt(t.baseParams.gasSatFee), h = {
      signer: e.signer,
      mldsaSigner: e.mldsaSigner ?? null,
      network: i,
      utxos: r,
      optionalInputs: s,
      optionalOutputs: o,
      from: t.baseParams.from,
      feeRate: c,
      priorityFee: u,
      gasSatFee: l,
      anchor: t.baseParams.anchor,
      ...t.header.chainId !== void 0 ? { chainId: t.header.chainId } : {},
      ...t.baseParams.to !== void 0 ? { to: t.baseParams.to } : {},
      ...t.baseParams.txVersion !== void 0 ? { txVersion: t.baseParams.txVersion } : {},
      ...t.baseParams.note !== void 0 ? { note: Mt3(t.baseParams.note) } : {},
      ...t.baseParams.debugFees !== void 0 ? { debugFees: t.baseParams.debugFees } : {},
      ...a !== void 0 ? { addressRotation: a } : {},
      ...t.precomputedData.estimatedFees !== void 0 ? { estimatedFees: BigInt(t.precomputedData.estimatedFees) } : {},
      ...t.precomputedData.compiledTargetScript !== void 0 ? { compiledTargetScript: Mt3(t.precomputedData.compiledTargetScript) } : {}
    }, d = t.typeSpecificData;
    if (ui3(d))
      return this.reconstructFunding(h, d);
    if (li3(d))
      return this.reconstructDeployment(h, d, t);
    if (hi3(d))
      return this.reconstructInteraction(h, d, t);
    if (ot4(d))
      return this.reconstructMultiSig(h, d);
    if (di3(d))
      return this.reconstructCustomScript(h, d, t);
    if (pi3(d))
      return this.reconstructCancel(h, d);
    throw new Error(`Unsupported transaction type: ${t.header.transactionType}`);
  }
  /**
   * Reconstruct a FundingTransaction
   */
  static reconstructFunding(t, e) {
    const i = {
      ...t,
      amount: BigInt(e.amount),
      splitInputsInto: e.splitInputsInto
    };
    return new Gt5(i);
  }
  /**
   * Reconstruct a DeploymentTransaction
   */
  static reconstructDeployment(t, e, i) {
    const r = new he3(e.challenge), s = {
      ...t,
      bytecode: Mt3(e.bytecode),
      challenge: r,
      ...e.calldata !== void 0 ? { calldata: Mt3(e.calldata) } : {},
      ...i.precomputedData.randomBytes !== void 0 ? { randomBytes: Mt3(i.precomputedData.randomBytes) } : {},
      ...e.revealMLDSAPublicKey !== void 0 ? { revealMLDSAPublicKey: e.revealMLDSAPublicKey } : {},
      ...e.linkMLDSAPublicKeyToAddress !== void 0 ? { linkMLDSAPublicKeyToAddress: e.linkMLDSAPublicKeyToAddress } : {}
    };
    return new Et5(s);
  }
  /**
   * Reconstruct an InteractionTransaction
   */
  static reconstructInteraction(t, e, i) {
    const r = new he3(e.challenge);
    if (!t.to)
      throw new Error('InteractionTransaction requires a "to" address');
    const s = {
      ...t,
      to: t.to,
      calldata: Mt3(e.calldata),
      challenge: r,
      ...e.contract !== void 0 ? { contract: e.contract } : {},
      ...i.precomputedData.randomBytes !== void 0 ? { randomBytes: Mt3(i.precomputedData.randomBytes) } : {},
      ...e.loadedStorage !== void 0 ? { loadedStorage: e.loadedStorage } : {},
      ...e.isCancellation !== void 0 ? { isCancellation: e.isCancellation } : {},
      ...e.disableAutoRefund !== void 0 ? { disableAutoRefund: e.disableAutoRefund } : {},
      ...e.revealMLDSAPublicKey !== void 0 ? { revealMLDSAPublicKey: e.revealMLDSAPublicKey } : {},
      ...e.linkMLDSAPublicKeyToAddress !== void 0 ? { linkMLDSAPublicKeyToAddress: e.linkMLDSAPublicKeyToAddress } : {}
    };
    return new Qt4(s);
  }
  /**
   * Reconstruct a MultiSignTransaction
   */
  static reconstructMultiSig(t, e) {
    const i = e.pubkeys.map((s) => Mt3(s));
    if (e.existingPsbtBase64)
      return R2.fromBase64({
        mldsaSigner: t.mldsaSigner,
        network: t.network,
        utxos: t.utxos,
        feeRate: t.feeRate,
        pubkeys: i,
        minimumSignatures: e.minimumSignatures,
        receiver: e.receiver,
        requestedAmount: BigInt(e.requestedAmount),
        refundVault: e.refundVault,
        psbt: e.existingPsbtBase64,
        ...t.chainId !== void 0 ? { chainId: t.chainId } : {},
        ...t.optionalInputs !== void 0 ? { optionalInputs: t.optionalInputs } : {},
        ...t.optionalOutputs !== void 0 ? { optionalOutputs: t.optionalOutputs } : {}
      });
    const r = {
      mldsaSigner: t.mldsaSigner,
      network: t.network,
      utxos: t.utxos,
      feeRate: t.feeRate,
      pubkeys: i,
      minimumSignatures: e.minimumSignatures,
      receiver: e.receiver,
      requestedAmount: BigInt(e.requestedAmount),
      refundVault: e.refundVault,
      ...t.chainId !== void 0 ? { chainId: t.chainId } : {},
      ...t.optionalInputs !== void 0 ? { optionalInputs: t.optionalInputs } : {},
      ...t.optionalOutputs !== void 0 ? { optionalOutputs: t.optionalOutputs } : {}
    };
    return new R2(r);
  }
  /**
   * Reconstruct a CustomScriptTransaction
   */
  static reconstructCustomScript(t, e, i) {
    const r = e.scriptElements.map((a) => a.elementType === "buffer" ? Mt3(a.value) : [a.value]), s = e.witnesses.map((a) => Mt3(a));
    if (!t.to)
      throw new Error('CustomScriptTransaction requires a "to" address');
    const o = {
      ...t,
      to: t.to,
      script: r,
      witnesses: s,
      ...e.annex !== void 0 ? { annex: Mt3(e.annex) } : {},
      ...i.precomputedData.randomBytes !== void 0 ? { randomBytes: Mt3(i.precomputedData.randomBytes) } : {}
    };
    return new Yt5(o);
  }
  /**
   * Reconstruct a CancelTransaction
   */
  static reconstructCancel(t, e) {
    const i = {
      ...t,
      compiledTargetScript: Mt3(e.compiledTargetScript)
    };
    return new Ie4(i);
  }
  /**
   * Build address rotation config from options
   */
  static buildAddressRotationConfig(t, e) {
    if (t) {
      if (!e || e.size === 0)
        throw new Error(
          "Address rotation enabled but no signerMap provided in reconstruction options"
        );
      return {
        enabled: true,
        signerMap: e
      };
    }
  }
  /**
   * Deserialize UTXOs from serialized format
   */
  static deserializeUTXOs(t) {
    return t.map((e) => {
      const i = {
        transactionId: e.transactionId,
        outputIndex: e.outputIndex,
        value: BigInt(e.value),
        scriptPubKey: {
          hex: e.scriptPubKeyHex,
          ...e.scriptPubKeyAddress !== void 0 ? { address: e.scriptPubKeyAddress } : {}
        }
      };
      return e.redeemScript !== void 0 && (i.redeemScript = Mt3(e.redeemScript)), e.witnessScript !== void 0 && (i.witnessScript = Mt3(e.witnessScript)), e.nonWitnessUtxo !== void 0 && (i.nonWitnessUtxo = Mt3(e.nonWitnessUtxo)), i;
    });
  }
  /**
   * Deserialize outputs from serialized format
   */
  static deserializeOutputs(t) {
    return t.map((e) => {
      const i = { value: dp2(BigInt(e.value)) }, r = e.tapInternalKey !== void 0 ? { tapInternalKey: Mt3(e.tapInternalKey) } : {};
      return e.address ? { ...i, address: e.address, ...r } : e.script ? { ...i, script: Mt3(e.script), ...r } : { ...i, address: "", ...r };
    });
  }
  /**
   * Convert network name to Network object
   */
  static nameToNetwork(t) {
    switch (t) {
      case "mainnet":
        return ap2.bitcoin;
      case "testnet":
        return ap2.testnet;
      case "opnetTestnet":
        return ap2.opnetTestnet;
      case "regtest":
        return ap2.regtest;
      default:
        throw new Error(`Unknown network: ${t}`);
    }
  }
};
var vr3 = class {
  /**
   * Export a FundingTransaction for offline signing
   * @param params - Funding transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportFunding(t, e) {
    const i = tt4.fromFunding(t, e);
    return k.toBase64(i);
  }
  /**
   * Export a DeploymentTransaction for offline signing
   * @param params - Deployment transaction parameters
   * @param precomputed - Required precomputed data (randomBytes, compiledTargetScript)
   * @returns Base64-encoded serialized state
   */
  static exportDeployment(t, e) {
    const i = tt4.fromDeployment(t, e);
    return k.toBase64(i);
  }
  /**
   * Export an InteractionTransaction for offline signing
   * @param params - Interaction transaction parameters
   * @param precomputed - Required precomputed data (randomBytes, compiledTargetScript)
   * @returns Base64-encoded serialized state
   */
  static exportInteraction(t, e) {
    const i = tt4.fromInteraction(t, e);
    return k.toBase64(i);
  }
  /**
   * Export a MultiSignTransaction for offline signing
   * @param params - MultiSig transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportMultiSig(t, e) {
    const i = tt4.fromMultiSig(t, e);
    return k.toBase64(i);
  }
  /**
   * Export a CustomScriptTransaction for offline signing
   * @param params - Custom script transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportCustomScript(t, e) {
    const i = tt4.fromCustomScript(t, e);
    return k.toBase64(i);
  }
  /**
   * Export a CancelTransaction for offline signing
   * @param params - Cancel transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportCancel(t, e) {
    const i = tt4.fromCancel(t, e);
    return k.toBase64(i);
  }
  /**
   * Export transaction state from a builder instance.
   * The builder must have been built but not yet signed.
   * @param builder - Transaction builder instance
   * @param params - Original construction parameters
   * @param precomputed - Precomputed data from the builder
   * @returns Base64-encoded serialized state
   */
  static exportFromBuilder(t, e, i) {
    const r = t.type;
    let s;
    switch (r) {
      case b.FUNDING:
        s = tt4.fromFunding(
          e,
          i
        );
        break;
      case b.DEPLOYMENT:
        s = tt4.fromDeployment(
          e,
          i
        );
        break;
      case b.INTERACTION:
        s = tt4.fromInteraction(
          e,
          i
        );
        break;
      default:
        throw new Error(`Unsupported transaction type for export: ${r}`);
    }
    return k.toBase64(s);
  }
  /**
   * Import and reconstruct transaction for signing
   * @param serializedState - Base64-encoded state from Phase 1
   * @param options - Signer(s) and optional fee overrides
   * @returns Reconstructed transaction builder ready for signing
   */
  static importForSigning(t, e) {
    const i = k.fromBase64(t);
    return wt5.reconstruct(i, e);
  }
  /**
   * Complete signing and export signed transaction
   * @param builder - Reconstructed builder from importForSigning
   * @returns Signed transaction hex ready for broadcast
   */
  static async signAndExport(t) {
    return (await t.signTransaction()).toHex();
  }
  /**
   * Convenience: Full Phase 2 in one call - import, sign, and export
   * @param serializedState - Base64-encoded state
   * @param options - Signer(s) and optional fee overrides
   * @returns Signed transaction hex ready for broadcast
   */
  static async importSignAndExport(t, e) {
    const i = this.importForSigning(t, e);
    return this.signAndExport(i);
  }
  /**
   * Rebuild transaction with new fee rate (fee bumping)
   * @param serializedState - Original state
   * @param newFeeRate - New fee rate in sat/vB
   * @returns New serialized state with updated fees (not signed yet)
   */
  static rebuildWithNewFees(t, e) {
    const i = k.fromBase64(t), r = {
      ...i,
      baseParams: {
        ...i.baseParams,
        feeRate: e
      }
    };
    return k.toBase64(r);
  }
  /**
   * Rebuild and immediately sign with new fee rate
   * @param serializedState - Original state
   * @param newFeeRate - New fee rate in sat/vB
   * @param options - Signer options
   * @returns Signed transaction hex with new fees
   */
  static async rebuildSignAndExport(t, e, i) {
    const r = this.importForSigning(t, {
      ...i,
      newFeeRate: e
    });
    return this.signAndExport(r);
  }
  /**
   * Inspect serialized state without signing
   * @param serializedState - Base64-encoded state
   * @returns Parsed state object for inspection
   */
  static inspect(t) {
    return k.fromBase64(t);
  }
  /**
   * Validate serialized state integrity
   * @param serializedState - Base64-encoded state
   * @returns True if checksum and format are valid
   */
  static validate(t) {
    try {
      return k.fromBase64(t), true;
    } catch {
      return false;
    }
  }
  /**
   * Get transaction type from serialized state
   * @param serializedState - Base64-encoded state
   * @returns Transaction type enum value
   */
  static getType(t) {
    return k.fromBase64(t).header.transactionType;
  }
  /**
   * Parse base64-encoded state into state object
   * @param base64State - Base64-encoded state
   * @returns Parsed state object
   */
  static fromBase64(t) {
    return k.fromBase64(t);
  }
  /**
   * Serialize state object to base64
   * @param state - State object to serialize
   * @returns Base64-encoded state
   */
  static toBase64(t) {
    return k.toBase64(t);
  }
  /**
   * Convert serialized state to hex format
   * @param serializedState - Base64-encoded state
   * @returns Hex-encoded state
   */
  static toHex(t) {
    const e = k.fromBase64(t);
    return k.toHex(e);
  }
  /**
   * Convert hex format back to base64
   * @param hexState - Hex-encoded state
   * @returns Base64-encoded state
   */
  static fromHex(t) {
    const e = k.fromHex(t);
    return k.toBase64(e);
  }
  /**
   * Add a partial signature to a multisig transaction state.
   * This method signs the transaction with the provided signer and returns
   * updated state with the new signature included.
   *
   * @param serializedState - Base64-encoded multisig state
   * @param signer - The signer to add a signature with
   * @returns Updated state with new signature, and signing result
   */
  static async multiSigAddSignature(t, e) {
    const i = k.fromBase64(t);
    if (!ot4(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = i.typeSpecificData, s = r.pubkeys.map((p) => Mt3(p));
    let o;
    const a = wt5.nameToNetwork(i.baseParams.networkName);
    r.existingPsbtBase64 ? o = Xn2.fromBase64(r.existingPsbtBase64, { network: a }) : o = await this.importForSigning(t, {
      signer: e
    }).signPSBT();
    const c = [];
    for (let p = r.originalInputCount; p < o.data.inputs.length; p++)
      c.push(r.minimumSignatures);
    const u = R2.signPartial(
      o,
      e,
      r.originalInputCount,
      c
    ), l = [];
    for (let p = r.originalInputCount; p < o.data.inputs.length; p++)
      l.push(s);
    R2.attemptFinalizeInputs(
      o,
      r.originalInputCount,
      l,
      u.final
    );
    const h = o.toBase64(), d = {
      ...i,
      typeSpecificData: {
        ...r,
        existingPsbtBase64: h
      }
    };
    return {
      state: k.toBase64(d),
      signed: u.signed,
      final: u.final,
      psbtBase64: h
    };
  }
  /**
   * Check if a public key has already signed a multisig transaction
   *
   * @param serializedState - Base64-encoded multisig state
   * @param signerPubKey - Public key to check (Uint8Array or hex string)
   * @returns True if the public key has already signed
   */
  static multiSigHasSigned(t, e) {
    const i = k.fromBase64(t);
    if (!ot4(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = i.typeSpecificData;
    if (!r.existingPsbtBase64)
      return false;
    const s = wt5.nameToNetwork(i.baseParams.networkName), o = Xn2.fromBase64(r.existingPsbtBase64, { network: s }), a = e instanceof Uint8Array ? e : Mt3(e);
    return R2.verifyIfSigned(o, a);
  }
  /**
   * Get the current signature count for a multisig transaction
   *
   * @param serializedState - Base64-encoded multisig state
   * @returns Object with signature count info
   */
  static multiSigGetSignatureStatus(t) {
    const e = k.fromBase64(t);
    if (!ot4(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const i = e.typeSpecificData, r = i.minimumSignatures;
    if (!i.existingPsbtBase64)
      return {
        required: r,
        collected: 0,
        isComplete: false,
        signers: []
      };
    const s = wt5.nameToNetwork(e.baseParams.networkName), o = Xn2.fromBase64(i.existingPsbtBase64, { network: s }), a = /* @__PURE__ */ new Set();
    for (let u = i.originalInputCount; u < o.data.inputs.length; u++) {
      const l = o.data.inputs[u];
      if (l.tapScriptSig)
        for (const h of l.tapScriptSig)
          a.add(Yt4(h.pubkey));
      if (l.finalScriptWitness) {
        const h = E.readScriptWitnessToWitnessStack(
          l.finalScriptWitness
        );
        for (let d = 0; d < h.length - 2; d += 3) {
          const p = h[d + 2];
          a.add(Yt4(p));
        }
      }
    }
    const c = Array.from(a);
    return {
      required: r,
      collected: c.length,
      isComplete: c.length >= r,
      signers: c
    };
  }
  /**
   * Finalize a multisig transaction and extract the signed transaction hex.
   * Only call this when all required signatures have been collected.
   *
   * @param serializedState - Base64-encoded multisig state with all signatures
   * @returns Signed transaction hex ready for broadcast
   */
  static multiSigFinalize(t) {
    const e = k.fromBase64(t);
    if (!ot4(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const i = e.typeSpecificData;
    if (!i.existingPsbtBase64)
      throw new Error("No PSBT found in state - transaction has not been signed");
    const r = wt5.nameToNetwork(e.baseParams.networkName), s = Xn2.fromBase64(i.existingPsbtBase64, { network: r }), o = i.pubkeys.map((u) => Mt3(u)), a = [];
    for (let u = i.originalInputCount; u < s.data.inputs.length; u++)
      a.push(o);
    if (!R2.attemptFinalizeInputs(
      s,
      i.originalInputCount,
      a,
      true
      // isFinal = true
    ))
      throw new Error("Failed to finalize multisig transaction - not enough signatures");
    return s.extractTransaction(true, true).toHex();
  }
  /**
   * Get the PSBT from a multisig state (for external signing tools)
   *
   * @param serializedState - Base64-encoded multisig state
   * @returns PSBT in base64 format, or null if not yet built
   */
  static multiSigGetPsbt(t) {
    const e = k.fromBase64(t);
    if (!ot4(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    return e.typeSpecificData.existingPsbtBase64 || null;
  }
  /**
   * Update the PSBT in a multisig state (after external signing)
   *
   * @param serializedState - Base64-encoded multisig state
   * @param psbtBase64 - New PSBT with additional signatures
   * @returns Updated state
   */
  static multiSigUpdatePsbt(t, e) {
    const i = k.fromBase64(t);
    if (!ot4(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = {
      ...i,
      typeSpecificData: {
        ...i.typeSpecificData,
        existingPsbtBase64: e
      }
    };
    return k.toBase64(r);
  }
};
var Or3 = class {
  constructor(t) {
    __publicField(this, "utxoPath", "address/utxos");
    __publicField(this, "rpc", "json-rpc");
    this.opnetAPIUrl = t;
  }
  /**
   * Fetches UTXO data from the OPNET node
   * @param {FetchUTXOParams} settings - The settings to fetch UTXO data
   * @returns {Promise<UTXO[]>} - The UTXOs fetched
   * @throws {Error} - If UTXOs could not be fetched
   */
  async fetchUTXO(t) {
    t.usePendingUTXO === void 0 && (t.usePendingUTXO = true), t.optimized === void 0 && (t.optimized = true);
    const e = {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    }, i = `${this.opnetAPIUrl}/api/v1/${this.utxoPath}?address=${t.address}&optimize=${t.optimized ?? false}`, r = await fetch(i, e);
    if (!r.ok)
      throw new Error(`Failed to fetch UTXO data: ${r.statusText}`);
    const s = await r.json(), o = s.raw ?? [], a = t.usePendingUTXO ? [...s.confirmed, ...s.pending] : s.confirmed, c = [];
    for (const y of a)
      s.spentTransactions.some(
        (m) => m.transactionId === y.transactionId && m.outputIndex === y.outputIndex
      ) || c.push(y);
    if (c.length === 0)
      throw new Error("No UTXO found");
    const u = c.filter((y) => BigInt(y.value) >= t.minAmount);
    if (u.length === 0)
      throw new Error("No UTXO found (minAmount)");
    const l = [];
    let h = 0n;
    const d = t.requestedAmount, p = /* @__PURE__ */ new Map();
    for (const y of u) {
      const m = BigInt(y.value);
      if (m <= 0n)
        continue;
      const A = Number(y.raw);
      if (!Number.isInteger(A) || A < 0 || A >= o.length)
        throw new Error(
          `Invalid raw index for UTXO ${y.transactionId}:${y.outputIndex}`
        );
      const x = o[A];
      if (!x)
        throw new Error(
          `Invalid raw index ${A} - not found in raw transactions array`
        );
      let W3 = p.get(A);
      if (W3 === void 0 && (W3 = zf2(x), p.set(A, W3)), h += m, l.push({
        transactionId: y.transactionId,
        outputIndex: y.outputIndex,
        value: m,
        scriptPubKey: y.scriptPubKey,
        nonWitnessUtxo: W3
      }), h > d)
        break;
    }
    return p.clear(), l;
  }
  /**
   * Fetches UTXO data from the OPNET node for multiple addresses
   * @param {FetchUTXOParamsMultiAddress} settings - The settings to fetch UTXO data
   * @returns {Promise<UTXO[]>} - The UTXOs fetched
   * @throws {Error} - If UTXOs could not be fetched
   */
  async fetchUTXOMultiAddr(t) {
    const e = [];
    for (const a of t.addresses) {
      const c = {
        address: a,
        minAmount: t.minAmount,
        requestedAmount: t.requestedAmount,
        optimized: t.optimized,
        usePendingUTXO: t.usePendingUTXO
      }, u = this.fetchUTXO(c).catch(() => []);
      e.push(u);
    }
    const r = (await Promise.all(e)).flat(), s = [];
    let o = 0n;
    for (let a = 0; a < r.length; a++) {
      const c = r[a];
      if (o >= t.requestedAmount)
        break;
      o += c.value, s.push(c);
    }
    return s;
  }
  /**
   * Broadcasts a transaction to the OPNET node
   * @param {string} transaction - The transaction to broadcast
   * @param {boolean} psbt - Whether the transaction is a PSBT
   * @returns {Promise<BroadcastResponse>} - The response from the OPNET node
   */
  async broadcastTransaction(t, e) {
    const i = [t, e], r = await this.rpcMethod("btc_sendRawTransaction", i);
    if (r)
      return r;
  }
  /**
   * Splits UTXOs into smaller UTXOs
   * @param {Wallet} wallet - The wallet to split UTXOs
   * @param {Network} network - The network to split UTXOs
   * @param {number} splitInputsInto - The number of UTXOs to split into
   * @param {bigint} amountPerUTXO - The amount per UTXO
   * @returns {Promise<BroadcastResponse | { error: string }>} - The response from the OPNET node or an error
   */
  async splitUTXOs(t, e, i, r) {
    const s = {
      addresses: [t.p2wpkh, t.p2tr],
      minAmount: 330n,
      requestedAmount: 1000000000000000n
    }, o = await this.fetchUTXOMultiAddr(s);
    if (!o || !o.length) return { error: "No UTXOs found" };
    const c = {
      amount: BigInt(i) * r,
      feeRate: 500,
      from: t.p2tr,
      utxos: o,
      signer: t.keypair,
      network: e,
      to: t.p2tr,
      splitInputsInto: i,
      priorityFee: 0n,
      gasSatFee: 330n,
      mldsaSigner: null
    }, l = await new ci3().createBTCTransfer(c), h = await this.broadcastTransaction(l.tx, false);
    return h || { error: "Could not broadcast transaction" };
  }
  /**
   * Fetches to the OPNET node
   * @param {string} method
   * @param {unknown[]} paramsMethod
   * @returns {Promise<unknown>}
   */
  async rpcMethod(t, e) {
    const i = {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: t,
        params: e,
        id: 1
      })
    }, r = `${this.opnetAPIUrl}/api/v1/${this.rpc}`, s = await fetch(r, i);
    if (!s.ok)
      throw new Error(`Failed to fetch to rpc: ${s.statusText}`);
    const o = await s.json();
    if (!o)
      throw new Error("No data fetched");
    const a = o.result;
    if (!a)
      throw new Error("No rpc parameters found");
    if ("error" in a)
      throw new Error(`Error in fetching to rpc ${a.error}`);
    return a;
  }
  /**
   * Fetches the wrap parameters from the OPNET node
   * @param {bigint} amount - The amount to wrap
   * @returns {Promise<WrappedGeneration | undefined>} - The wrap parameters fetched
   * @throws {Error} - If wrap parameters could not be fetched
   */
  /*public async fetchWrapParameters(amount: bigint): Promise<WrappedGeneration | undefined> {
          if (amount < currentConsensusConfig.VAULT_MINIMUM_AMOUNT) {
              throw new Error(
                  `Amount must be greater than the minimum consolidation amount ${currentConsensusConfig.VAULT_MINIMUM_AMOUNT}sat.`,
              );
          }
  
          const params = [0, amount.toString()];
          const result = await this.rpcMethod('btc_generate', params);
  
          if (!result) {
              return;
          }
  
          return new WrappedGeneration(result as WrappedGenerationParameters);
      }*/
  /**
   * Fetches the wrap parameters from the OPNET node
   * @param {bigint} amount - The amount to wrap
   * @param {string} receiver - The receiver address
   * @returns {Promise<UnwrapGeneration | undefined>} - The wrap parameters fetched
   * @throws {Error} - If wrap parameters could not be fetched
   */
  /*public async fetchUnWrapParameters(
          amount: bigint,
          receiver: Address,
      ): Promise<UnwrapGeneration | undefined> {
          if (amount < 330n) {
              throw new Error(
                  `Amount must be greater than the minimum consolidation amount ${currentConsensusConfig.VAULT_MINIMUM_AMOUNT}sat.`,
              );
          }
  
          if (receiver.length < 50) {
              throw new Error('Invalid receiver address');
          }
  
          const params = [1, amount.toString(), receiver.toHex()];
          const result = await this.rpcMethod('btc_generate', params);
  
          if (!result) {
              return;
          }
  
          return new UnwrapGeneration(result as UnwrappedGenerationParameters);
      }*/
};
var yi3 = ((n) => (n[n.UNWRAP = 0] = "UNWRAP", n))(yi3 || {});
var Ur3 = class {
  /**
   * Generate a multi-sig address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(t, e, i = ap2.bitcoin) {
    if (P2.verifyPubKeys(t, i).length !== t.length) throw new Error("Contains invalid public keys");
    const s = {
      network: i,
      utxos: [],
      pubkeys: t,
      minimumSignatures: e,
      feeRate: 100,
      receiver: "a",
      requestedAmount: 1n,
      refundVault: "a",
      mldsaSigner: null
    }, o = new R2(s).getScriptAddress();
    if (!o)
      throw new Error("Failed to generate address");
    return o;
  }
};
var Br3 = class {
  /**
   * Generate a multi-sig P2MR address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(t, e, i = ap2.bitcoin) {
    const r = P2.verifyPubKeys(t, i);
    if (r.length !== t.length) throw new Error("Contains invalid public keys");
    const s = {
      network: i,
      utxos: [],
      pubkeys: r,
      minimumSignatures: e,
      feeRate: 100,
      receiver: "a",
      requestedAmount: 1n,
      refundVault: "a",
      mldsaSigner: null,
      useP2MR: true
    }, o = new R2(s).getScriptAddress();
    if (!o)
      throw new Error("Failed to generate address");
    return o;
  }
};
var S = ((n) => (n.UINT8 = "UINT8", n.UINT16 = "UINT16", n.UINT32 = "UINT32", n.UINT64 = "UINT64", n.UINT128 = "UINT128", n.UINT256 = "UINT256", n.INT8 = "INT8", n.INT16 = "INT16", n.INT32 = "INT32", n.INT64 = "INT64", n.INT128 = "INT128", n.BOOL = "BOOL", n.ADDRESS = "ADDRESS", n.EXTENDED_ADDRESS = "EXTENDED_ADDRESS", n.STRING = "STRING", n.BYTES4 = "BYTES4", n.BYTES32 = "BYTES32", n.BYTES = "BYTES", n.ADDRESS_UINT256_TUPLE = "ADDRESS_UINT256_TUPLE", n.EXTENDED_ADDRESS_UINT256_TUPLE = "EXTENDED_ADDRESS_UINT256_TUPLE", n.SCHNORR_SIGNATURE = "SCHNORR_SIGNATURE", n.ARRAY_OF_ADDRESSES = "ARRAY_OF_ADDRESSES", n.ARRAY_OF_EXTENDED_ADDRESSES = "ARRAY_OF_EXTENDED_ADDRESSES", n.ARRAY_OF_UINT256 = "ARRAY_OF_UINT256", n.ARRAY_OF_UINT128 = "ARRAY_OF_UINT128", n.ARRAY_OF_UINT64 = "ARRAY_OF_UINT64", n.ARRAY_OF_UINT32 = "ARRAY_OF_UINT32", n.ARRAY_OF_UINT16 = "ARRAY_OF_UINT16", n.ARRAY_OF_UINT8 = "ARRAY_OF_UINT8", n.ARRAY_OF_STRING = "ARRAY_OF_STRING", n.ARRAY_OF_BYTES = "ARRAY_OF_BYTES", n.ARRAY_OF_BUFFERS = "ARRAY_OF_BUFFERS", n))(S || {});
var _r16 = {
  address: S.ADDRESS,
  extendedAddress: S.EXTENDED_ADDRESS,
  bool: S.BOOL,
  bytes: S.BYTES,
  uint256: S.UINT256,
  uint128: S.UINT128,
  uint64: S.UINT64,
  uint32: S.UINT32,
  uint16: S.UINT16,
  uint8: S.UINT8,
  int128: S.INT128,
  int64: S.INT64,
  int32: S.INT32,
  int16: S.INT16,
  int8: S.INT8,
  string: S.STRING,
  bytes4: S.BYTES4,
  bytes32: S.BYTES32,
  schnorrSignature: S.SCHNORR_SIGNATURE,
  "tuple(address,uint256)[]": S.ADDRESS_UINT256_TUPLE,
  "tuple(extendedAddress,uint256)[]": S.EXTENDED_ADDRESS_UINT256_TUPLE,
  "address[]": S.ARRAY_OF_ADDRESSES,
  "extendedAddress[]": S.ARRAY_OF_EXTENDED_ADDRESSES,
  "uint256[]": S.ARRAY_OF_UINT256,
  "uint128[]": S.ARRAY_OF_UINT128,
  "uint64[]": S.ARRAY_OF_UINT64,
  "uint32[]": S.ARRAY_OF_UINT32,
  "uint16[]": S.ARRAY_OF_UINT16,
  "uint8[]": S.ARRAY_OF_UINT8,
  "bytes[]": S.ARRAY_OF_BYTES,
  "buffer[]": S.ARRAY_OF_BUFFERS,
  "string[]": S.ARRAY_OF_STRING,
  boolean: S.BOOL
};
var mi3 = {
  [S.ADDRESS]: "address",
  [S.EXTENDED_ADDRESS]: "extendedAddress",
  [S.BOOL]: "bool",
  [S.BYTES]: "bytes",
  [S.BYTES32]: "bytes32",
  [S.BYTES4]: "bytes4",
  [S.UINT256]: "uint256",
  [S.UINT128]: "uint128",
  [S.UINT64]: "uint64",
  [S.UINT32]: "uint32",
  [S.UINT16]: "uint16",
  [S.UINT8]: "uint8",
  [S.INT128]: "int128",
  [S.INT64]: "int64",
  [S.INT32]: "int32",
  [S.INT16]: "int16",
  [S.INT8]: "int8",
  [S.STRING]: "string",
  [S.ADDRESS_UINT256_TUPLE]: "tuple(address,uint256)[]",
  [S.EXTENDED_ADDRESS_UINT256_TUPLE]: "tuple(extendedAddress,uint256)[]",
  [S.SCHNORR_SIGNATURE]: "schnorrSignature",
  [S.ARRAY_OF_ADDRESSES]: "address[]",
  [S.ARRAY_OF_EXTENDED_ADDRESSES]: "extendedAddress[]",
  [S.ARRAY_OF_UINT256]: "uint256[]",
  [S.ARRAY_OF_UINT128]: "uint128[]",
  [S.ARRAY_OF_UINT64]: "uint64[]",
  [S.ARRAY_OF_UINT32]: "uint32[]",
  [S.ARRAY_OF_UINT16]: "uint16[]",
  [S.ARRAY_OF_UINT8]: "uint8[]",
  [S.ARRAY_OF_BYTES]: "bytes[]",
  [S.ARRAY_OF_STRING]: "string[]",
  [S.ARRAY_OF_BUFFERS]: "buffer[]"
};
function Ti3(n) {
  return Array.isArray(n);
}
function Oe4(n) {
  return typeof n == "object" && n !== null && !Array.isArray(n);
}
function bi3(n) {
  return typeof n == "string";
}
function Vt5(n) {
  if (bi3(n)) {
    const i = mi3[n];
    if (!i)
      throw new Error(`Unknown ABI type: ${n}`);
    return i;
  }
  if (Oe4(n))
    return `tuple(${Object.values(n).map((r) => Vt5(r)).join(",")})`;
  const t = n[0];
  return n.length === 1 && t !== void 0 ? `${Vt5(t)}[]` : `tuple(${n.map((i) => Vt5(i)).join(",")})[]`;
}
var kr3 = class {
  decodeData(t, e) {
    const i = new te4(t), r = [];
    for (const s of e)
      r.push(this.decodeSingleValue(i, s));
    return r;
  }
  encodeSelector(t) {
    const i = this.sha256(t).subarray(0, 4);
    return Array.from(i, (r) => r.toString(16).padStart(2, "0")).join("");
  }
  numericSelectorToHex(t) {
    return t.toString(16);
  }
  /**
   * Decodes a single value from the reader based on the ABI type.
   * Supports ABIDataTypes enum values, tuple arrays, and struct objects.
   */
  decodeSingleValue(t, e) {
    if (Ti3(e)) {
      const i = e[0];
      return e.length === 1 && i !== void 0 ? this.decodeArray(t, i) : this.decodeTuple(t, e);
    }
    if (Oe4(e))
      return this.decodeStruct(t, e);
    switch (e) {
      case S.UINT8:
        return t.readU8();
      case S.UINT16:
        return t.readU16();
      case S.UINT32:
        return t.readU32();
      case S.BYTES4:
        return t.readBytes(4);
      case S.BYTES32:
        return t.readBytes(32);
      case S.BOOL:
        return t.readBoolean();
      case S.ADDRESS:
        return t.readAddress();
      case S.STRING:
        return t.readStringWithLength();
      case S.UINT128:
        return t.readU128();
      case S.UINT256:
        return t.readU256();
      case S.INT8:
        return t.readI8();
      case S.INT16:
        return t.readI16();
      case S.INT32:
        return t.readI32();
      case S.INT64:
        return t.readI64();
      case S.INT128:
        return t.readI128();
      case S.EXTENDED_ADDRESS:
        return t.readExtendedAddress();
      case S.ADDRESS_UINT256_TUPLE:
        return t.readAddressValueTuple();
      case S.EXTENDED_ADDRESS_UINT256_TUPLE:
        return t.readExtendedAddressMapU256();
      case S.SCHNORR_SIGNATURE:
        return t.readSchnorrSignature();
      case S.BYTES:
        return t.readBytesWithLength();
      case S.UINT64:
        return t.readU64();
      case S.ARRAY_OF_ADDRESSES:
        return t.readAddressArray();
      case S.ARRAY_OF_EXTENDED_ADDRESSES:
        return t.readExtendedAddressArray();
      case S.ARRAY_OF_UINT256:
        return t.readU256Array();
      case S.ARRAY_OF_UINT128:
        return t.readU128Array();
      case S.ARRAY_OF_UINT64:
        return t.readU64Array();
      case S.ARRAY_OF_UINT32:
        return t.readU32Array();
      case S.ARRAY_OF_UINT16:
        return t.readU16Array();
      case S.ARRAY_OF_UINT8:
        return t.readU8Array();
      case S.ARRAY_OF_STRING:
        return t.readStringArray();
      case S.ARRAY_OF_BYTES:
        return t.readBytesArray();
      case S.ARRAY_OF_BUFFERS:
        return t.readArrayOfBuffer();
      default:
        throw new Error(`Unsupported ABI type: ${e}`);
    }
  }
  /** Decodes a single-element tuple as a flat typed array (u16 count + values). */
  decodeArray(t, e) {
    const i = t.readU16(), r = [];
    for (let s = 0; s < i; s++)
      r.push(this.decodeSingleValue(t, e));
    return r;
  }
  /** Decodes a multi-element tuple as array of tuple entries (u16 count + entries). */
  decodeTuple(t, e) {
    const i = t.readU16(), r = [];
    for (let s = 0; s < i; s++) {
      const o = [];
      for (const a of e)
        o.push(this.decodeSingleValue(t, a));
      r.push(o);
    }
    return r;
  }
  /** Decodes a struct as a single object with named fields (inline, no count prefix). */
  decodeStruct(t, e) {
    const i = {};
    for (const [r, s] of Object.entries(e))
      i[r] = this.decodeSingleValue(t, s);
    return i;
  }
  sha256(t) {
    return new Uint8Array(new zy.sha256().update(t).digest());
  }
};
var Ue5 = class _Ue {
  constructor(t = []) {
    __publicField(this, "items");
    __publicField(this, "keys");
    this.items = /* @__PURE__ */ new Set(), this.keys = [];
    for (const e of t)
      this.add(e);
  }
  get size() {
    return this.keys.length;
  }
  add(t) {
    const e = t.toBigInt();
    this.items.has(e) || (this.items.add(e), this.keys.push(t));
  }
  has(t) {
    return this.items.has(t.toBigInt());
  }
  remove(t) {
    const e = t.toBigInt();
    this.items.delete(e) && (this.keys = this.keys.filter((i) => i.toBigInt() !== e));
  }
  clone() {
    return new _Ue(this.keys);
  }
  clear() {
    this.items.clear(), this.keys = [];
  }
  [Symbol.dispose]() {
    this.clear();
  }
  combine(t) {
    const e = this.clone();
    for (const i of t.keys)
      e.add(i);
    return e;
  }
  *[Symbol.iterator]() {
    yield* this.keys;
  }
};
var _t25;
var _Be = class _Be {
  constructor(t) {
    __publicField(this, "map");
    __privateAdd(this, _t25);
    this.compareFn = t, this.map = new It5(), __privateSet(this, _t25, []);
  }
  get size() {
    return this.map.size;
  }
  static fromMap(t, e) {
    const i = new _Be(e);
    for (const [r, s] of t)
      i.set(r, s);
    return i;
  }
  set(t, e) {
    if (!this.map.has(t)) {
      let i = 0, r = __privateGet(this, _t25).length;
      for (; i < r; ) {
        const s = Math.floor((i + r) / 2);
        this.compareFn(__privateGet(this, _t25)[s], t) < 0 ? i = s + 1 : r = s;
      }
      __privateGet(this, _t25).splice(i, 0, t);
    }
    this.map.set(t, e);
  }
  get(t) {
    return this.map.get(t);
  }
  *entries() {
    for (const t of __privateGet(this, _t25))
      yield [t, this.map.get(t)];
  }
  *keys() {
    yield* __privateGet(this, _t25);
  }
  *values() {
    for (const t of __privateGet(this, _t25)) {
      const e = this.map.get(t);
      if (e === void 0 && !this.map.has(t))
        throw new Error("Value not found");
      yield e;
    }
  }
  has(t) {
    return this.map.has(t);
  }
  delete(t) {
    if (this.map.has(t)) {
      this.map.delete(t);
      let e = 0, i = __privateGet(this, _t25).length - 1;
      for (; e <= i; ) {
        const r = Math.floor((e + i) / 2), s = this.compareFn(__privateGet(this, _t25)[r], t);
        if (s === 0)
          return __privateGet(this, _t25).splice(r, 1), true;
        s < 0 ? e = r + 1 : i = r - 1;
      }
    }
    return false;
  }
  clear() {
    this.map.clear(), __privateSet(this, _t25, []);
  }
  [Symbol.dispose]() {
    this.clear();
  }
  forEach(t) {
    for (const e of __privateGet(this, _t25)) {
      const i = this.map.get(e);
      t(i, e, this);
    }
  }
  *[Symbol.iterator]() {
    for (const t of __privateGet(this, _t25))
      yield [t, this.map.get(t)];
  }
};
_t25 = new WeakMap();
var Be4 = _Be;
var _e23 = class __e {
  constructor(t) {
    __publicField(this, "elements");
    this.compareFn = t, this.elements = [];
  }
  get size() {
    return this.elements.length;
  }
  static fromSet(t, e) {
    const i = new __e(e);
    for (const r of t)
      i.add(r);
    return i;
  }
  add(t) {
    const { found: e, index: i } = this.binarySearch(t);
    e || this.elements.splice(i, 0, t);
  }
  delete(t) {
    const { found: e, index: i } = this.binarySearch(t);
    return e ? (this.elements.splice(i, 1), true) : false;
  }
  has(t) {
    return this.binarySearch(t).found;
  }
  clear() {
    this.elements = [];
  }
  [Symbol.dispose]() {
    this.clear();
  }
  forEach(t) {
    for (const e of this.elements)
      t(e, this);
  }
  *values() {
    yield* this.elements;
  }
  *[Symbol.iterator]() {
    yield* this.elements;
  }
  binarySearch(t) {
    let e = 0, i = this.elements.length;
    for (; e < i; ) {
      const r = Math.floor((e + i) / 2), s = this.compareFn(this.elements[r], t);
      if (s === 0)
        return { found: true, index: r };
      s < 0 ? e = r + 1 : i = r;
    }
    return { found: false, index: e };
  }
};
var Lr3 = class {
  constructor(t, e) {
    this.type = t, this.data = e;
  }
};
var Ai2 = ((n) => (n.mainnet = "mainnet", n.testnet = "testnet", n.signet = "Signet", n))(Ai2 || {});
var Ei2 = ((n) => (n.ECDSA = "ECDSA", n.BIP322 = "BIP322", n))(Ei2 || {});
var Rr3 = class extends Ae5 {
  constructor() {
    super();
    __publicField(this, "isInitialized", false);
    __publicField(this, "_p2tr");
    __publicField(this, "_p2wpkh");
    __publicField(this, "_addresses");
    __publicField(this, "_publicKey");
    __publicField(this, "_network");
    if (!window)
      throw new Error("XverseSigner can only be used in a browser environment");
  }
  get p2tr() {
    if (!this._p2tr)
      throw new Error("P2TR address not set");
    return this._p2tr;
  }
  get p2wpkh() {
    if (!this._p2wpkh)
      throw new Error("P2PKH address not set");
    return this._p2wpkh;
  }
  get addresses() {
    if (!this._addresses)
      throw new Error("Addresses not set");
    return this._addresses;
  }
  get publicKey() {
    if (!this._publicKey)
      throw new Error("Public key not set");
    return this._publicKey;
  }
  get network() {
    if (!this._network)
      throw new Error("Network not set");
    return this._network;
  }
  get BitcoinProvider() {
    const t = window.BitcoinProvider;
    if (!t)
      throw new Error("Xverse Wallet extension not found");
    return t;
  }
  async init() {
    if (this.isInitialized) return;
    const t = await this.BitcoinProvider.request("wallet_connect", null);
    if ("error" in t) throw new Error(t.error.message);
    const e = t.result.addresses.find(
      (r) => r.purpose === "payment"
    );
    if (!e)
      throw new Error("Payment address not found");
    const i = e.address.startsWith("opt") ? ap2.opnetTestnet : e.address.startsWith("tb") ? ap2.testnet : e.address.startsWith("bc") ? ap2.bitcoin : null;
    if (!i) throw new Error("Network not supported");
    this._network = i, this._publicKey = ef(Mt3(e.publicKey)), this._p2wpkh = P2.getP2WPKHAddress(this, this.network), this._p2tr = P2.getTaprootAddress(this, this.network), this._addresses = [this._p2wpkh, this._p2tr], this.isInitialized = true;
  }
  async signData(t, e, i) {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    const r = await this.BitcoinProvider.request("signMessage", {
      address: e,
      message: new TextDecoder().decode(t),
      protocol: i
    });
    if ("error" in r) throw new Error(r.error.message);
    const s = r.result;
    if (!s.signature)
      throw new Error("Signature not found");
    return Mt3(s.signature);
  }
  getPublicKey() {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    return this.publicKey;
  }
  sign(t, e) {
    throw new Error("Not implemented: sign");
  }
  signSchnorr(t) {
    throw new Error("Not implemented: signSchnorr");
  }
  verify(t, e) {
    throw new Error("Not implemented: verify");
  }
  async signTaprootInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, false);
    this.combine(t, s, e);
  }
  async signInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, true);
    this.combine(t, s, e);
  }
  async multiSignPsbt(t) {
    var _a37;
    const e = [], i = [];
    for (const a of t) {
      const c = a.toBase64();
      e.push(c);
      const u = a.data.inputs.map((l, h) => {
        let d = false, p = false;
        if (me4(l)) {
          if (l.tapLeafScript && l.tapLeafScript.length > 0) {
            for (const y of l.tapLeafScript)
              if (be3(this.publicKey, y.script)) {
                d = true, p = false;
                break;
              }
          }
          if (!d && l.tapInternalKey) {
            const y = l.tapInternalKey, m = $e4(this.publicKey);
            P(y, m) && (d = true, p = true);
          }
        } else Te5(l, this.publicKey) && (d = true, p = false);
        return d ? {
          index: h,
          publicKey: Yt4(this.publicKey),
          disableTweakSigner: !p
        } : null;
      }).filter((l) => l !== null);
      i.push({
        autoFinalized: false,
        toSignInputs: u
      });
    }
    const r = {
      [this.p2wpkh]: ((_a37 = i[0].toSignInputs) == null ? void 0 : _a37.map((a) => a.index)) || []
    }, s = await this.BitcoinProvider.request("signPsbt", {
      psbt: e[0],
      signInputs: r
    });
    if ("error" in s) throw new Error(s.error.message);
    const o = Xn2.fromBase64(s.result.psbt);
    t[0].combine(o);
  }
  hasAlreadySignedTapScriptSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = new Uint8Array(i.pubkey);
      if (P(r, this.publicKey) && i.signature)
        return true;
    }
    return false;
  }
  hasAlreadyPartialSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = new Uint8Array(i.pubkey);
      if (P(r, this.publicKey) && i.signature)
        return true;
    }
    return false;
  }
  combine(t, e, i) {
    var _a37;
    const r = e.data.inputs[i], s = t.data.inputs[i];
    if (r.partialSig && t.updateInput(i, { partialSig: r.partialSig }), r.tapKeySig && !s.tapKeySig && t.updateInput(i, { tapKeySig: r.tapKeySig }), (_a37 = r.tapScriptSig) == null ? void 0 : _a37.length) {
      const o = s.tapScriptSig;
      if (o) {
        const a = this.getNonDuplicateScriptSig(
          o,
          r.tapScriptSig
        );
        a.length && t.updateInput(i, { tapScriptSig: a });
      } else
        t.updateInput(i, { tapScriptSig: r.tapScriptSig });
    }
  }
  async signAllTweaked(t, e, i = false) {
    var _a37;
    const r = Yt4(this.publicKey), o = {
      toSignInputs: t.data.inputs.map((l, h) => [
        {
          index: h,
          publicKey: r,
          sighashTypes: e,
          disableTweakSigner: i
        }
      ]).flat()
    }, a = t.toBase64(), c = {
      [this.p2wpkh]: ((_a37 = o.toSignInputs) == null ? void 0 : _a37.map((l) => l.index)) || []
    }, u = await this.BitcoinProvider.request("signPsbt", {
      psbt: a,
      signInputs: c
    });
    if ("error" in u) throw new Error(u.error.message);
    return Xn2.fromBase64(u.result.psbt);
  }
  getNonDuplicateScriptSig(t, e) {
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      t.find((a) => P(a.pubkey, s.pubkey)) || i.push(s);
    }
    return i;
  }
};
var _t26, _e24;
var _jt = class _jt {
  constructor() {
    __privateAdd(this, _t26);
    __privateAdd(this, _e24);
    __publicField(this, "deleted");
    __publicField(this, "capacity");
    __publicField(this, "_size", 0);
    this.capacity = _jt.INITIAL_CAPACITY, __privateSet(this, _t26, new Array(this.capacity)), __privateSet(this, _e24, new Array(this.capacity)), this.deleted = new Array(this.capacity).fill(false);
  }
  get size() {
    return this._size;
  }
  set(t, e) {
    let i = true;
    const r = this.findInsertIndex(t);
    return (__privateGet(this, _t26)[r] === void 0 || this.deleted[r]) && (this._size++, i = false), __privateGet(this, _t26)[r] = t, __privateGet(this, _e24)[r] = e, this.deleted[r] = false, this._size > this.capacity * _jt.LOAD_FACTOR && this.resize(), i;
  }
  get(t) {
    const e = this.findIndex(t);
    return e === -1 ? void 0 : __privateGet(this, _e24)[e];
  }
  has(t) {
    return this.findIndex(t) !== -1;
  }
  indexOf(t) {
    return this.findIndex(t);
  }
  delete(t) {
    const e = this.findIndex(t);
    return e === -1 ? false : (__privateGet(this, _t26)[e] = void 0, __privateGet(this, _e24)[e] = void 0, this.deleted[e] = true, this._size--, true);
  }
  clear() {
    __privateSet(this, _t26, new Array(this.capacity)), __privateSet(this, _e24, new Array(this.capacity)), this.deleted = new Array(this.capacity).fill(false), this._size = 0;
  }
  [Symbol.dispose]() {
    this.clear();
  }
  *entries() {
    for (let t = 0; t < this.capacity; t++)
      __privateGet(this, _t26)[t] !== void 0 && !this.deleted[t] && (yield [__privateGet(this, _t26)[t], __privateGet(this, _e24)[t]]);
  }
  *keys() {
    for (let t = 0; t < this.capacity; t++)
      __privateGet(this, _t26)[t] !== void 0 && !this.deleted[t] && (yield __privateGet(this, _t26)[t]);
  }
  *values() {
    for (let t = 0; t < this.capacity; t++)
      __privateGet(this, _t26)[t] !== void 0 && !this.deleted[t] && (yield __privateGet(this, _e24)[t]);
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  hashBigInt(t) {
    if (t >= -2147483648n && t <= 2147483647n)
      return Number(t) | 0;
    let e = 2166136261, i = t < 0n ? -t : t;
    for (; i > 0n; ) {
      const r = Number(i & 0xffffffffn);
      e ^= r, e = Math.imul(e, 16777619), i = i >> 32n;
    }
    return t < 0n && (e ^= 2147483648, e = Math.imul(e, 16777619)), Math.abs(e);
  }
  hash(t) {
    let e = 0;
    switch (typeof t) {
      case "number":
        if (t !== t) return 9221120237041091e3;
        if (!isFinite(t)) return t > 0 ? 9218868437227405e3 : 18442240474082181e3;
        e = t | 0;
        break;
      case "string":
        e = 2166136261;
        for (let i = 0; i < t.length; i++)
          e ^= t.charCodeAt(i), e = Math.imul(e, 16777619);
        break;
      case "boolean":
        e = t ? 1231 : 1237;
        break;
      case "symbol": {
        const i = t.description || "";
        e = this.hash(i);
        break;
      }
      case "bigint":
        e = this.hashBigInt(t);
        break;
      case "undefined":
        e = 0;
        break;
      case "object":
        if (t === null)
          e = 0;
        else if (t instanceof Date)
          e = t.getTime() | 0;
        else if (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
          e = this.hashBuffer(t);
        else if (Array.isArray(t)) {
          e = 1;
          for (const i of t)
            e = Math.imul(e, 31) + this.hash(i);
        } else
          throw new Error("Raw object not supported.");
        break;
      case "function":
        e = this.hash(t.toString());
        break;
    }
    return Math.abs(e) % this.capacity;
  }
  hashBuffer(t) {
    let e;
    if (t instanceof ArrayBuffer)
      e = new Uint8Array(t);
    else if (ArrayBuffer.isView(t))
      e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    else
      return 0;
    let i = 2166136261;
    for (let r = 0; r < Math.min(e.length, 100); r++)
      i ^= e[r], i = Math.imul(i, 16777619);
    return i;
  }
  equals(t, e) {
    return t === e || typeof t == "number" && typeof e == "number" && t !== t && e !== e ? true : (ArrayBuffer.isView(t) || t instanceof ArrayBuffer) && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer) ? this.buffersEqual(t, e) : false;
  }
  buffersEqual(t, e) {
    const i = this.getBytes(t), r = this.getBytes(e);
    if (i.length !== r.length) return false;
    for (let s = 0; s < i.length; s++)
      if (i[s] !== r[s]) return false;
    return true;
  }
  getBytes(t) {
    return t instanceof ArrayBuffer ? new Uint8Array(t) : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(0);
  }
  findIndex(t) {
    let e = this.hash(t);
    for (; __privateGet(this, _t26)[e] !== void 0 || this.deleted[e]; ) {
      if (__privateGet(this, _t26)[e] !== void 0 && this.equals(__privateGet(this, _t26)[e], t))
        return e;
      e = (e + 1) % this.capacity;
    }
    return -1;
  }
  findInsertIndex(t) {
    let e = this.hash(t);
    for (; __privateGet(this, _t26)[e] !== void 0 && !this.deleted[e]; ) {
      if (this.equals(__privateGet(this, _t26)[e], t))
        return e;
      e = (e + 1) % this.capacity;
    }
    return e;
  }
  resize() {
    const t = __privateGet(this, _t26), e = __privateGet(this, _e24);
    this.capacity *= 2, __privateSet(this, _t26, new Array(this.capacity)), __privateSet(this, _e24, new Array(this.capacity)), this.deleted = new Array(this.capacity).fill(false), this._size = 0;
    for (let i = 0; i < t.length; i++)
      t[i] !== void 0 && !this.deleted[i] && this.set(t[i], e[i]);
  }
};
_t26 = new WeakMap();
_e24 = new WeakMap();
__publicField(_jt, "INITIAL_CAPACITY", 16);
__publicField(_jt, "LOAD_FACTOR", 0.75);
var jt5 = _jt;
var Nr3 = Object.freeze(Object.defineProperty({
  __proto__: null,
  ABICoder: kr3,
  ABIDataTypes: S,
  ADDRESS_BYTE_LENGTH: D,
  ANCHOR_SCRIPT: le3,
  AbiTypeToStr: mi3,
  Address: K2,
  AddressGenerator: ge4,
  AddressMap: Xe3,
  AddressSet: Ue5,
  AddressTypes: st3,
  AddressVerificator: Q2,
  BIPStandard: _t24,
  BOOLEAN_BYTE_LENGTH: or2,
  BinaryReader: te4,
  BinaryWriter: V,
  BitcoinUtils: M,
  BufferHelper: Wt5,
  CSVModes: oi3,
  CalldataGenerator: pe4,
  CancelTransaction: Ie4,
  ChainId: ye4,
  ChallengeSolution: he3,
  ChallengeSubmission: wi3,
  ChallengeVerification: Si2,
  Compressor: Y,
  Consensus: Ft4,
  ConsolidatedInteractionTransaction: ai3,
  ContractAddress: ae3,
  ContractBaseMetadata: Sr,
  CustomGenerator: Ye4,
  CustomKeypair: Ae5,
  CustomMap: jt5,
  CustomScriptTransaction: Yt5,
  DeploymentGenerator: fe5,
  DeploymentTransaction: Et5,
  DeterministicMap: Be4,
  DeterministicSet: _e23,
  EXTENDED_ADDRESS_BYTE_LENGTH: mt5,
  EcKeyPair: P2,
  EpochValidator: St4,
  ExtendedAddressMap: $e5,
  FastMap: It5,
  FeaturePriority: et4,
  Features: $3,
  FundingTransaction: Gt5,
  Generator: J3,
  HashCommitmentGenerator: I,
  I128_BYTE_LENGTH: Bt5,
  I16_BYTE_LENGTH: Kt3,
  I256_BYTE_LENGTH: nr,
  I32_BYTE_LENGTH: Rt4,
  I64_BYTE_LENGTH: Lt4,
  I8_BYTE_LENGTH: xt5,
  InteractionTransaction: Qt4,
  InteractionTransactionP2WDA: it3,
  LegacyCalldataGenerator: dr3,
  MINIMUM_AMOUNT_CA: Ot4,
  MINIMUM_AMOUNT_REWARD: j3,
  MLDSAPublicKeyMetadata: Je4,
  MLDSASecurityLevel: $b.MLDSASecurityLevel,
  MessageSigner: ct4,
  MessageType: ei3,
  Mnemonic: we5,
  MnemonicStrength: $t5,
  MultiSignGenerator: Dt5,
  MultiSignTransaction: R2,
  NetEvent: Lr3,
  OPNET_DEPLOYMENT_VERSION: Ge4,
  OPNetConsensusConfig: gi3,
  OPNetLimitedProvider: Or3,
  OfflineTransactionManager: vr3,
  P2MR_MS: Br3,
  P2TR_MS: Ur3,
  P2WDADetector: Z2,
  P2WDAGenerator: Ct5,
  PSBTTypes: yi3,
  QuantumBIP32Factory: $b.QuantumBIP32Factory,
  QuantumDerivationPath: $b.QuantumDerivationPath,
  RoswellConsensus: fi3,
  SCHNORR_SIGNATURE_BYTE_LENGTH: Tt5,
  SELECTOR_BYTE_LENGTH: sr2,
  SERIALIZATION_FORMAT_VERSION: Pe3,
  SERIALIZATION_MAGIC_BYTE: Ht5,
  Secp256k1PointDeriver: qe4,
  SharedInteractionTransaction: Ee5,
  SignatureType: ii3,
  SigningProtocol: Ei2,
  StrToAbiType: _r16,
  TapscriptVerificator: nt4,
  TimeLockGenerator: z3,
  TransactionBuilder: E,
  TransactionFactory: ci3,
  TransactionReconstructor: wt5,
  TransactionSequence: ni3,
  TransactionSerializer: k,
  TransactionStateCapture: tt4,
  TransactionType: b,
  TweakedSigner: Se4,
  TweakedTransaction: Nt4,
  U128_BYTE_LENGTH: Ut5,
  U16_BYTE_LENGTH: At4,
  U256_BYTE_LENGTH: kt4,
  U32_BYTE_LENGTH: bt4,
  U64_BYTE_LENGTH: qt5,
  U8_BYTE_LENGTH: Xt5,
  UnisatChainType: ti3,
  UnisatSigner: yr3,
  Wallet: rt5,
  WalletNetworks: yt4,
  XverseNetwork: Ai2,
  XverseSigner: Rr3,
  abiTypeToSelectorString: Vt5,
  buildBIPPath: Ze5,
  createAddressRotation: br3,
  createSignerMap: ri3,
  currentConsensus: ve4,
  currentConsensusConfig: Pr3,
  disabledAddressRotation: Ar3,
  getBIPDescription: fr3,
  getLevelFromPublicKeyLength: ce4,
  isAbiStruct: Oe4,
  isAbiTuple: Ti3,
  isCancelSpecificData: pi3,
  isCustomScriptSpecificData: di3,
  isDeploymentSpecificData: li3,
  isFundingSpecificData: ui3,
  isInteractionSpecificData: hi3,
  isMultiSigSpecificData: ot4,
  isOPWallet: je5,
  isSimpleAbiType: bi3,
  isUniversalSigner: pt4,
  toParallelKeyPair: Er3,
  toTweakedParallelKeyPair: si3,
  version: Gi3,
  versionBuffer: Qe4
}, Symbol.toStringTag, { value: "Module" }));
var Fr3 = $b.MLDSASecurityLevel;
var Mr3 = $b.QuantumBIP32Factory;
var Wr3 = $b.QuantumDerivationPath;

export {
  Gi3 as Gi,
  Y,
  P2 as P,
  $3 as $,
  et4 as et,
  D,
  mt5 as mt,
  Tt5 as Tt,
  sr2 as sr,
  kt4 as kt,
  Ut5 as Ut,
  qt5 as qt,
  bt4 as bt,
  At4 as At,
  Xt5 as Xt,
  nr,
  Bt5 as Bt,
  Lt4 as Lt,
  Rt4 as Rt,
  Kt3 as Kt,
  xt5 as xt,
  or2 as or,
  M,
  Z2 as Z,
  st3 as st,
  Q2 as Q,
  qe4 as qe,
  ae3 as ae,
  z3 as z,
  K2 as K,
  It5 as It,
  Xe3 as Xe,
  $e5 as $e,
  Wt5 as Wt,
  te4 as te,
  V,
  J3 as J,
  pe4 as pe,
  Ye4 as Ye,
  Ge4 as Ge,
  Qe4 as Qe,
  fe5 as fe,
  I,
  dr3 as dr,
  Dt5 as Dt,
  Ct5 as Ct,
  ge4 as ge,
  nt4 as nt,
  pt4 as pt,
  Se4 as Se,
  je5 as je,
  ct4 as ct,
  rt5 as rt,
  $t5 as $t,
  _t24 as _t,
  fr3 as fr,
  Ze5 as Ze,
  we5 as we,
  Je4 as Je,
  ce4 as ce,
  Sr,
  ye4 as ye,
  Ae5 as Ae,
  yt4 as yt,
  ti3 as ti,
  ei3 as ei,
  ii3 as ii,
  yr3 as yr,
  ri3 as ri,
  br3 as br,
  Ar3 as Ar,
  Er3 as Er,
  si3 as si,
  b,
  ni3 as ni,
  oi3 as oi,
  Nt4 as Nt,
  j3 as j,
  Ot4 as Ot,
  le3 as le,
  E,
  Yt5 as Yt,
  Ee5 as Ee,
  Et5 as Et,
  Gt5 as Gt,
  Qt4 as Qt,
  it3 as it,
  Ie4 as Ie,
  ai3 as ai,
  ci3 as ci,
  R2 as R,
  Pe3 as Pe,
  Ht5 as Ht,
  ui3 as ui,
  li3 as li,
  hi3 as hi,
  ot4 as ot,
  di3 as di,
  pi3 as pi,
  k,
  Ft4 as Ft,
  fi3 as fi,
  gi3 as gi,
  ve4 as ve,
  Pr3 as Pr,
  tt4 as tt,
  St4 as St,
  Si2 as Si,
  wi3 as wi,
  he3 as he,
  wt5 as wt,
  vr3 as vr,
  Or3 as Or,
  yi3 as yi,
  Ur3 as Ur,
  Br3 as Br,
  S,
  _r16 as _r,
  mi3 as mi,
  Ti3 as Ti,
  Oe4 as Oe,
  bi3 as bi,
  Vt5 as Vt,
  kr3 as kr,
  Ue5 as Ue,
  Be4 as Be,
  _e23 as _e,
  Lr3 as Lr,
  Ai2 as Ai,
  Ei2 as Ei,
  Rr3 as Rr,
  jt5 as jt,
  Nr3 as Nr,
  Fr3 as Fr,
  Mr3 as Mr,
  Wr3 as Wr
};
//# sourceMappingURL=chunk-5BTEJNJL.js.map
