import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-QWN5BXRD.js";

// node_modules/opnet/browser/noble-hashes.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n2, title = "") {
  if (!Number.isSafeInteger(n2) || n2 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n2}`);
  }
}
function abytes(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "digestInto() output");
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error('"digestInto() output" expected to be of length >=' + min2);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u) => u : byteSwap32;
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex += hexes[bytes[i2]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a = arrays[i2];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a = arrays[i2];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function createHasher(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes(bytesLength = 32) {
  const cr2 = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof (cr2 == null ? void 0 : cr2.getRandomValues) !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr2.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h, l } = fromBig(lst[i2], le2);
    [Ah[i2], Al[i2]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var SHA256_K = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = new Uint32Array(64);
var SHA2_32B = class extends HashMD {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A, B, C: C2, D: D2, E, F: F2, G: G2, H } = this;
    return [A, B, C2, D2, E, F2, G2, H];
  }
  // prettier-ignore
  set(A, B, C2, D2, E, F2, G2, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C: C2, D: D2, E, F: F2, G: G2, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F2, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C2) | 0;
      H = G2;
      G2 = F2;
      F2 = E;
      E = D2 + T1 | 0;
      D2 = C2;
      C2 = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E = E + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C2, D2, E, F2, G2, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var _SHA256 = class extends SHA2_32B {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", SHA256_IV[0] | 0);
    __publicField(this, "B", SHA256_IV[1] | 0);
    __publicField(this, "C", SHA256_IV[2] | 0);
    __publicField(this, "D", SHA256_IV[3] | 0);
    __publicField(this, "E", SHA256_IV[4] | 0);
    __publicField(this, "F", SHA256_IV[5] | 0);
    __publicField(this, "G", SHA256_IV[6] | 0);
    __publicField(this, "H", SHA256_IV[7] | 0);
  }
};
var _SHA224 = class extends SHA2_32B {
  constructor() {
    super(28);
    __publicField(this, "A", SHA224_IV[0] | 0);
    __publicField(this, "B", SHA224_IV[1] | 0);
    __publicField(this, "C", SHA224_IV[2] | 0);
    __publicField(this, "D", SHA224_IV[3] | 0);
    __publicField(this, "E", SHA224_IV[4] | 0);
    __publicField(this, "F", SHA224_IV[5] | 0);
    __publicField(this, "G", SHA224_IV[6] | 0);
    __publicField(this, "H", SHA224_IV[7] | 0);
  }
};
var K512 = (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh = (() => K512[0])();
var SHA512_Kl = (() => K512[1])();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA2_64B = class extends HashMD {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var _SHA512 = class extends SHA2_64B {
  constructor() {
    super(64);
    __publicField(this, "Ah", SHA512_IV[0] | 0);
    __publicField(this, "Al", SHA512_IV[1] | 0);
    __publicField(this, "Bh", SHA512_IV[2] | 0);
    __publicField(this, "Bl", SHA512_IV[3] | 0);
    __publicField(this, "Ch", SHA512_IV[4] | 0);
    __publicField(this, "Cl", SHA512_IV[5] | 0);
    __publicField(this, "Dh", SHA512_IV[6] | 0);
    __publicField(this, "Dl", SHA512_IV[7] | 0);
    __publicField(this, "Eh", SHA512_IV[8] | 0);
    __publicField(this, "El", SHA512_IV[9] | 0);
    __publicField(this, "Fh", SHA512_IV[10] | 0);
    __publicField(this, "Fl", SHA512_IV[11] | 0);
    __publicField(this, "Gh", SHA512_IV[12] | 0);
    __publicField(this, "Gl", SHA512_IV[13] | 0);
    __publicField(this, "Hh", SHA512_IV[14] | 0);
    __publicField(this, "Hl", SHA512_IV[15] | 0);
  }
};
var _SHA384 = class extends SHA2_64B {
  constructor() {
    super(48);
    __publicField(this, "Ah", SHA384_IV[0] | 0);
    __publicField(this, "Al", SHA384_IV[1] | 0);
    __publicField(this, "Bh", SHA384_IV[2] | 0);
    __publicField(this, "Bl", SHA384_IV[3] | 0);
    __publicField(this, "Ch", SHA384_IV[4] | 0);
    __publicField(this, "Cl", SHA384_IV[5] | 0);
    __publicField(this, "Dh", SHA384_IV[6] | 0);
    __publicField(this, "Dl", SHA384_IV[7] | 0);
    __publicField(this, "Eh", SHA384_IV[8] | 0);
    __publicField(this, "El", SHA384_IV[9] | 0);
    __publicField(this, "Fh", SHA384_IV[10] | 0);
    __publicField(this, "Fl", SHA384_IV[11] | 0);
    __publicField(this, "Gh", SHA384_IV[12] | 0);
    __publicField(this, "Gl", SHA384_IV[13] | 0);
    __publicField(this, "Hh", SHA384_IV[14] | 0);
    __publicField(this, "Hl", SHA384_IV[15] | 0);
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var _SHA512_224 = class extends SHA2_64B {
  constructor() {
    super(28);
    __publicField(this, "Ah", T224_IV[0] | 0);
    __publicField(this, "Al", T224_IV[1] | 0);
    __publicField(this, "Bh", T224_IV[2] | 0);
    __publicField(this, "Bl", T224_IV[3] | 0);
    __publicField(this, "Ch", T224_IV[4] | 0);
    __publicField(this, "Cl", T224_IV[5] | 0);
    __publicField(this, "Dh", T224_IV[6] | 0);
    __publicField(this, "Dl", T224_IV[7] | 0);
    __publicField(this, "Eh", T224_IV[8] | 0);
    __publicField(this, "El", T224_IV[9] | 0);
    __publicField(this, "Fh", T224_IV[10] | 0);
    __publicField(this, "Fl", T224_IV[11] | 0);
    __publicField(this, "Gh", T224_IV[12] | 0);
    __publicField(this, "Gl", T224_IV[13] | 0);
    __publicField(this, "Hh", T224_IV[14] | 0);
    __publicField(this, "Hl", T224_IV[15] | 0);
  }
};
var _SHA512_256 = class extends SHA2_64B {
  constructor() {
    super(32);
    __publicField(this, "Ah", T256_IV[0] | 0);
    __publicField(this, "Al", T256_IV[1] | 0);
    __publicField(this, "Bh", T256_IV[2] | 0);
    __publicField(this, "Bl", T256_IV[3] | 0);
    __publicField(this, "Ch", T256_IV[4] | 0);
    __publicField(this, "Cl", T256_IV[5] | 0);
    __publicField(this, "Dh", T256_IV[6] | 0);
    __publicField(this, "Dl", T256_IV[7] | 0);
    __publicField(this, "Eh", T256_IV[8] | 0);
    __publicField(this, "El", T256_IV[9] | 0);
    __publicField(this, "Fh", T256_IV[10] | 0);
    __publicField(this, "Fl", T256_IV[11] | 0);
    __publicField(this, "Gh", T256_IV[12] | 0);
    __publicField(this, "Gl", T256_IV[13] | 0);
    __publicField(this, "Hh", T256_IV[14] | 0);
    __publicField(this, "Hl", T256_IV[15] | 0);
  }
};
var sha256$1 = createHasher(
  () => new _SHA256(),
  oidNist(1)
);
var sha224 = createHasher(
  () => new _SHA224(),
  oidNist(4)
);
var sha512$1 = createHasher(
  () => new _SHA512(),
  oidNist(3)
);
var sha384 = createHasher(
  () => new _SHA384(),
  oidNist(2)
);
var sha512_256 = createHasher(
  () => new _SHA512_256(),
  oidNist(6)
);
var sha512_224 = createHasher(
  () => new _SHA512_224(),
  oidNist(5)
);
var sha2$1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  _SHA224,
  _SHA256,
  _SHA384,
  _SHA512,
  _SHA512_224,
  _SHA512_256,
  sha224,
  sha256: sha256$1,
  sha384,
  sha512: sha512$1,
  sha512_224,
  sha512_256
}, Symbol.toStringTag, { value: "Module" }));
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var _SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    __publicField(this, "A", SHA1_IV[0] | 0);
    __publicField(this, "B", SHA1_IV[1] | 0);
    __publicField(this, "C", SHA1_IV[2] | 0);
    __publicField(this, "D", SHA1_IV[3] | 0);
    __publicField(this, "E", SHA1_IV[4] | 0);
  }
  get() {
    const { A, B, C: C2, D: D2, E } = this;
    return [A, B, C2, D2, E];
  }
  set(A, B, C2, D2, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA1_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 80; i2++)
      SHA1_W[i2] = rotl(SHA1_W[i2 - 3] ^ SHA1_W[i2 - 8] ^ SHA1_W[i2 - 14] ^ SHA1_W[i2 - 16], 1);
    let { A, B, C: C2, D: D2, E } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      let F2, K2;
      if (i2 < 20) {
        F2 = Chi(B, C2, D2);
        K2 = 1518500249;
      } else if (i2 < 40) {
        F2 = B ^ C2 ^ D2;
        K2 = 1859775393;
      } else if (i2 < 60) {
        F2 = Maj(B, C2, D2);
        K2 = 2400959708;
      } else {
        F2 = B ^ C2 ^ D2;
        K2 = 3395469782;
      }
      const T = rotl(A, 5) + F2 + E + K2 + SHA1_W[i2] | 0;
      E = D2;
      D2 = C2;
      C2 = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C2, D2, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = createHasher(() => new _SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_2, i2) => Math.floor(p32 * Math.abs(Math.sin(i2 + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var _MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    __publicField(this, "A", MD5_IV[0] | 0);
    __publicField(this, "B", MD5_IV[1] | 0);
    __publicField(this, "C", MD5_IV[2] | 0);
    __publicField(this, "D", MD5_IV[3] | 0);
  }
  get() {
    const { A, B, C: C2, D: D2 } = this;
    return [A, B, C2, D2];
  }
  set(A, B, C2, D2) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      MD5_W[i2] = view.getUint32(offset, true);
    let { A, B, C: C2, D: D2 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      let F2, g, s;
      if (i2 < 16) {
        F2 = Chi(B, C2, D2);
        g = i2;
        s = [7, 12, 17, 22];
      } else if (i2 < 32) {
        F2 = Chi(D2, B, C2);
        g = (5 * i2 + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i2 < 48) {
        F2 = B ^ C2 ^ D2;
        g = (3 * i2 + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F2 = C2 ^ (B | ~D2);
        g = 7 * i2 % 16;
        s = [6, 10, 15, 21];
      }
      F2 = F2 + A + K[i2] + MD5_W[g];
      A = D2;
      D2 = C2;
      C2 = B;
      B = B + rotl(F2, s[i2 % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    this.set(A, B, C2, D2);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = createHasher(() => new _MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_2, i2) => i2)))();
var Pi160 = (() => Id160.map((i2) => (9 * i2 + 5) % 16))();
var idxLR = (() => {
  const L3 = [Id160];
  const R = [Pi160];
  const res = [L3, R];
  for (let i2 = 0; i2 < 4; i2++)
    for (let j of res)
      j.push(j[i2].map((k) => Rho160[k]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => Uint8Array.from(i2));
var shiftsL160 = idxL.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var shiftsR160 = idxR.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z2) {
  if (group === 0)
    return x ^ y ^ z2;
  if (group === 1)
    return x & y | ~x & z2;
  if (group === 2)
    return (x | ~y) ^ z2;
  if (group === 3)
    return x & z2 | y & ~z2;
  return x ^ (y | ~z2);
}
var BUF_160 = new Uint32Array(16);
var _RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    __publicField(this, "h0", 1732584193 | 0);
    __publicField(this, "h1", 4023233417 | 0);
    __publicField(this, "h2", 2562383102 | 0);
    __publicField(this, "h3", 271733878 | 0);
    __publicField(this, "h4", 3285377520 | 0);
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF_160[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar2 = al, bl = this.h1 | 0, br2 = bl, cl = this.h2 | 0, cr2 = cl, dl = this.h3 | 0, dr2 = dl, el = this.h4 | 0, er2 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr2 = idxR[group];
      const sl = shiftsL160[group], sr2 = shiftsR160[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr2 = rotl(ar2 + ripemd_f(rGroup, br2, cr2, dr2) + BUF_160[rr2[i2]] + hbr, sr2[i2]) + er2 | 0;
        ar2 = er2, er2 = dr2, dr2 = rotl(cr2, 10) | 0, cr2 = br2, br2 = tr2;
      }
    }
    this.set(this.h1 + cl + dr2 | 0, this.h2 + dl + er2 | 0, this.h3 + el + ar2 | 0, this.h4 + al + br2 | 0, this.h0 + bl + cr2 | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new _RIPEMD160());
var legacy = Object.freeze(Object.defineProperty({
  __proto__: null,
  _MD5,
  _RIPEMD160,
  _SHA1,
  md5,
  ripemd160,
  sha1
}, Symbol.toStringTag, { value: "Module" }));
var _HMAC = class {
  constructor(hash2, key) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    ahash(hash2);
    abytes(key, void 0, "key");
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac$1 = (hash2, key, message) => new _HMAC(hash2, key).update(message).digest();
hmac$1.create = (hash2, key) => new _HMAC(hash2, key);
var hmac$2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  _HMAC,
  hmac: hmac$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = getAugmentedNamespace(hmac$2);
var require$$1 = getAugmentedNamespace(legacy);
var require$$2 = getAugmentedNamespace(sha2$1);
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round2 = 0, R = _1n, x = 1, y = 0; round2 < 24; round2++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t2 ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t2);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round2];
    s[1] ^= SHA3_IOTA_L[round2];
  }
  clean(B);
}
var Keccak = class _Keccak {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    __publicField(this, "state");
    __publicField(this, "pos", 0);
    __publicField(this, "posOut", 0);
    __publicField(this, "finished", false);
    __publicField(this, "state32");
    __publicField(this, "destroyed", false);
    __publicField(this, "blockLen");
    __publicField(this, "suffix");
    __publicField(this, "outputLen");
    __publicField(this, "enableXOF", false);
    __publicField(this, "rounds");
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen, "outputLen");
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i2 = 0; i2 < take; i2++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var genShake = (suffix, blockLen, outputLen, info = {}) => createHasher((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true), info);
var shake128 = genShake(31, 168, 16, oidNist(11));
var shake256 = genShake(31, 136, 32, oidNist(12));
var sha256 = {};
var sha2 = {};
var _md = {};
var utils = {};
var crypto2 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto2;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto2, "__esModule", { value: true });
  crypto2.crypto = void 0;
  crypto2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  return crypto2;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.wrapXOFConstructorWithOpts = exports$1.wrapConstructorWithOpts = exports$1.wrapConstructor = exports$1.Hash = exports$1.nextTick = exports$1.swap32IfBE = exports$1.byteSwapIfBE = exports$1.swap8IfBE = exports$1.isLE = void 0;
    exports$1.isBytes = isBytes3;
    exports$1.anumber = anumber2;
    exports$1.abytes = abytes3;
    exports$1.ahash = ahash2;
    exports$1.aexists = aexists2;
    exports$1.aoutput = aoutput2;
    exports$1.u8 = u8;
    exports$1.u32 = u322;
    exports$1.clean = clean2;
    exports$1.createView = createView2;
    exports$1.rotr = rotr2;
    exports$1.rotl = rotl2;
    exports$1.byteSwap = byteSwap2;
    exports$1.byteSwap32 = byteSwap322;
    exports$1.bytesToHex = bytesToHex3;
    exports$1.hexToBytes = hexToBytes3;
    exports$1.asyncLoop = asyncLoop;
    exports$1.utf8ToBytes = utf8ToBytes;
    exports$1.bytesToUtf8 = bytesToUtf8;
    exports$1.toBytes = toBytes2;
    exports$1.kdfInputToBytes = kdfInputToBytes;
    exports$1.concatBytes = concatBytes3;
    exports$1.checkOpts = checkOpts;
    exports$1.createHasher = createHasher2;
    exports$1.createOptHasher = createOptHasher;
    exports$1.createXOFer = createXOFer;
    exports$1.randomBytes = randomBytes3;
    const crypto_1 = requireCrypto();
    function isBytes3(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber2(n2) {
      if (!Number.isSafeInteger(n2) || n2 < 0)
        throw new Error("positive integer expected, got " + n2);
    }
    function abytes3(b, ...lengths2) {
      if (!isBytes3(b))
        throw new Error("Uint8Array expected");
      if (lengths2.length > 0 && !lengths2.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths2 + ", got length=" + b.length);
    }
    function ahash2(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber2(h.outputLen);
      anumber2(h.blockLen);
    }
    function aexists2(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput2(out, instance) {
      abytes3(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error("digestInto() expects output buffer of length at least " + min2);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u322(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean2(...arrays) {
      for (let i2 = 0; i2 < arrays.length; i2++) {
        arrays[i2].fill(0);
      }
    }
    function createView2(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr2(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl2(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports$1.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap2(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports$1.swap8IfBE = exports$1.isLE ? (n2) => n2 : (n2) => byteSwap2(n2);
    exports$1.byteSwapIfBE = exports$1.swap8IfBE;
    function byteSwap322(arr) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        arr[i2] = byteSwap2(arr[i2]);
      }
      return arr;
    }
    exports$1.swap32IfBE = exports$1.isLE ? (u) => u : byteSwap322;
    const hasHexBuiltin2 = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    const hexes2 = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex3(bytes) {
      abytes3(bytes);
      if (hasHexBuiltin2)
        return bytes.toHex();
      let hex = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        hex += hexes2[bytes[i2]];
      }
      return hex;
    }
    const asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase162(ch) {
      if (ch >= asciis2._0 && ch <= asciis2._9)
        return ch - asciis2._0;
      if (ch >= asciis2.A && ch <= asciis2.F)
        return ch - (asciis2.A - 10);
      if (ch >= asciis2.a && ch <= asciis2.f)
        return ch - (asciis2.a - 10);
      return;
    }
    function hexToBytes3(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin2)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase162(hex.charCodeAt(hi));
        const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    const nextTick = async () => {
    };
    exports$1.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb(i2);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports$1.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes3(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes3(data);
      return data;
    }
    function concatBytes3(...arrays) {
      let sum = 0;
      for (let i2 = 0; i2 < arrays.length; i2++) {
        const a = arrays[i2];
        abytes3(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
        const a = arrays[i2];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    class Hash {
    }
    exports$1.Hash = Hash;
    function createHasher2(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports$1.wrapConstructor = createHasher2;
    exports$1.wrapConstructorWithOpts = createOptHasher;
    exports$1.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes3(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  })(utils);
  return utils;
}
var hasRequired_md;
function require_md() {
  if (hasRequired_md) return _md;
  hasRequired_md = 1;
  Object.defineProperty(_md, "__esModule", { value: true });
  _md.SHA512_IV = _md.SHA384_IV = _md.SHA224_IV = _md.SHA256_IV = _md.HashMD = void 0;
  _md.setBigUint64 = setBigUint64;
  _md.Chi = Chi2;
  _md.Maj = Maj2;
  const utils_ts_1 = requireUtils();
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  function Chi2(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj2(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  class HashMD2 extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
      (0, utils_ts_1.aexists)(this);
      data = (0, utils_ts_1.toBytes)(data);
      (0, utils_ts_1.abytes)(data);
      const { view, buffer: buffer2, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = (0, utils_ts_1.createView)(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer2.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1.aexists)(this);
      (0, utils_ts_1.aoutput)(out, this);
      this.finished = true;
      const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer2[pos++] = 128;
      (0, utils_ts_1.clean)(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i2 = pos; i2 < blockLen; i2++)
        buffer2[i2] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = (0, utils_ts_1.createView)(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i2 = 0; i2 < outLen; i2++)
        oview.setUint32(4 * i2, state[i2], isLE2);
    }
    digest() {
      const { buffer: buffer2, outputLen } = this;
      this.digestInto(buffer2);
      const res = buffer2.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer2);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  }
  _md.HashMD = HashMD2;
  _md.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  _md.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]);
  _md.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]);
  _md.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);
  return _md;
}
var _u64 = {};
var hasRequired_u64;
function require_u64() {
  if (hasRequired_u64) return _u64;
  hasRequired_u64 = 1;
  Object.defineProperty(_u64, "__esModule", { value: true });
  _u64.toBig = _u64.shrSL = _u64.shrSH = _u64.rotrSL = _u64.rotrSH = _u64.rotrBL = _u64.rotrBH = _u64.rotr32L = _u64.rotr32H = _u64.rotlSL = _u64.rotlSH = _u64.rotlBL = _u64.rotlBH = _u64.add5L = _u64.add5H = _u64.add4L = _u64.add4H = _u64.add3L = _u64.add3H = void 0;
  _u64.add = add3;
  _u64.fromBig = fromBig2;
  _u64.split = split2;
  const U32_MASK642 = BigInt(2 ** 32 - 1);
  const _32n2 = BigInt(32);
  function fromBig2(n2, le2 = false) {
    if (le2)
      return { h: Number(n2 & U32_MASK642), l: Number(n2 >> _32n2 & U32_MASK642) };
    return { h: Number(n2 >> _32n2 & U32_MASK642) | 0, l: Number(n2 & U32_MASK642) | 0 };
  }
  function split2(lst, le2 = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i2 = 0; i2 < len; i2++) {
      const { h, l } = fromBig2(lst[i2], le2);
      [Ah[i2], Al[i2]] = [h, l];
    }
    return [Ah, Al];
  }
  const toBig = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
  _u64.toBig = toBig;
  const shrSH2 = (h, _l, s) => h >>> s;
  _u64.shrSH = shrSH2;
  const shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
  _u64.shrSL = shrSL2;
  const rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
  _u64.rotrSH = rotrSH2;
  const rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
  _u64.rotrSL = rotrSL2;
  const rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
  _u64.rotrBH = rotrBH2;
  const rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
  _u64.rotrBL = rotrBL2;
  const rotr32H = (_h, l) => l;
  _u64.rotr32H = rotr32H;
  const rotr32L = (h, _l) => h;
  _u64.rotr32L = rotr32L;
  const rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
  _u64.rotlSH = rotlSH2;
  const rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
  _u64.rotlSL = rotlSL2;
  const rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
  _u64.rotlBH = rotlBH2;
  const rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
  _u64.rotlBL = rotlBL2;
  function add3(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  const add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  _u64.add3L = add3L2;
  const add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  _u64.add3H = add3H2;
  const add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  _u64.add4L = add4L2;
  const add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  _u64.add4H = add4H2;
  const add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  _u64.add5L = add5L2;
  const add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  _u64.add5H = add5H2;
  const u64 = {
    fromBig: fromBig2,
    split: split2,
    toBig,
    shrSH: shrSH2,
    shrSL: shrSL2,
    rotrSH: rotrSH2,
    rotrSL: rotrSL2,
    rotrBH: rotrBH2,
    rotrBL: rotrBL2,
    rotr32H,
    rotr32L,
    rotlSH: rotlSH2,
    rotlSL: rotlSL2,
    rotlBH: rotlBH2,
    rotlBL: rotlBL2,
    add: add3,
    add3L: add3L2,
    add3H: add3H2,
    add4L: add4L2,
    add4H: add4H2,
    add5H: add5H2,
    add5L: add5L2
  };
  _u64.default = u64;
  return _u64;
}
var hasRequiredSha2;
function requireSha2() {
  if (hasRequiredSha2) return sha2;
  hasRequiredSha2 = 1;
  Object.defineProperty(sha2, "__esModule", { value: true });
  sha2.sha512_224 = sha2.sha512_256 = sha2.sha384 = sha2.sha512 = sha2.sha224 = sha2.sha256 = sha2.SHA512_256 = sha2.SHA512_224 = sha2.SHA384 = sha2.SHA512 = sha2.SHA224 = sha2.SHA256 = void 0;
  const _md_ts_1 = require_md();
  const u64 = require_u64();
  const utils_ts_1 = requireUtils();
  const SHA256_K2 = Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  const SHA256_W2 = new Uint32Array(64);
  class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = _md_ts_1.SHA256_IV[0] | 0;
      this.B = _md_ts_1.SHA256_IV[1] | 0;
      this.C = _md_ts_1.SHA256_IV[2] | 0;
      this.D = _md_ts_1.SHA256_IV[3] | 0;
      this.E = _md_ts_1.SHA256_IV[4] | 0;
      this.F = _md_ts_1.SHA256_IV[5] | 0;
      this.G = _md_ts_1.SHA256_IV[6] | 0;
      this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C: C2, D: D2, E, F: F2, G: G2, H } = this;
      return [A, B, C2, D2, E, F2, G2, H];
    }
    // prettier-ignore
    set(A, B, C2, D2, E, F2, G2, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C2 | 0;
      this.D = D2 | 0;
      this.E = E | 0;
      this.F = F2 | 0;
      this.G = G2 | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4)
        SHA256_W2[i2] = view.getUint32(offset, false);
      for (let i2 = 16; i2 < 64; i2++) {
        const W15 = SHA256_W2[i2 - 15];
        const W2 = SHA256_W2[i2 - 2];
        const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
      }
      let { A, B, C: C2, D: D2, E, F: F2, G: G2, H } = this;
      for (let i2 = 0; i2 < 64; i2++) {
        const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
        const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F2, G2) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
        const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
        const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C2) | 0;
        H = G2;
        G2 = F2;
        F2 = E;
        E = D2 + T1 | 0;
        D2 = C2;
        C2 = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C2 = C2 + this.C | 0;
      D2 = D2 + this.D | 0;
      E = E + this.E | 0;
      F2 = F2 + this.F | 0;
      G2 = G2 + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C2, D2, E, F2, G2, H);
    }
    roundClean() {
      (0, utils_ts_1.clean)(SHA256_W2);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      (0, utils_ts_1.clean)(this.buffer);
    }
  }
  sha2.SHA256 = SHA256;
  class SHA224 extends SHA256 {
    constructor() {
      super(28);
      this.A = _md_ts_1.SHA224_IV[0] | 0;
      this.B = _md_ts_1.SHA224_IV[1] | 0;
      this.C = _md_ts_1.SHA224_IV[2] | 0;
      this.D = _md_ts_1.SHA224_IV[3] | 0;
      this.E = _md_ts_1.SHA224_IV[4] | 0;
      this.F = _md_ts_1.SHA224_IV[5] | 0;
      this.G = _md_ts_1.SHA224_IV[6] | 0;
      this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
  }
  sha2.SHA224 = SHA224;
  const K5122 = (() => u64.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n2) => BigInt(n2))))();
  const SHA512_Kh2 = (() => K5122[0])();
  const SHA512_Kl2 = (() => K5122[1])();
  const SHA512_W_H2 = new Uint32Array(80);
  const SHA512_W_L2 = new Uint32Array(80);
  class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = _md_ts_1.SHA512_IV[0] | 0;
      this.Al = _md_ts_1.SHA512_IV[1] | 0;
      this.Bh = _md_ts_1.SHA512_IV[2] | 0;
      this.Bl = _md_ts_1.SHA512_IV[3] | 0;
      this.Ch = _md_ts_1.SHA512_IV[4] | 0;
      this.Cl = _md_ts_1.SHA512_IV[5] | 0;
      this.Dh = _md_ts_1.SHA512_IV[6] | 0;
      this.Dl = _md_ts_1.SHA512_IV[7] | 0;
      this.Eh = _md_ts_1.SHA512_IV[8] | 0;
      this.El = _md_ts_1.SHA512_IV[9] | 0;
      this.Fh = _md_ts_1.SHA512_IV[10] | 0;
      this.Fl = _md_ts_1.SHA512_IV[11] | 0;
      this.Gh = _md_ts_1.SHA512_IV[12] | 0;
      this.Gl = _md_ts_1.SHA512_IV[13] | 0;
      this.Hh = _md_ts_1.SHA512_IV[14] | 0;
      this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4) {
        SHA512_W_H2[i2] = view.getUint32(offset);
        SHA512_W_L2[i2] = view.getUint32(offset += 4);
      }
      for (let i2 = 16; i2 < 80; i2++) {
        const W15h = SHA512_W_H2[i2 - 15] | 0;
        const W15l = SHA512_W_L2[i2 - 15] | 0;
        const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
        const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H2[i2 - 2] | 0;
        const W2l = SHA512_W_L2[i2 - 2] | 0;
        const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
        const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
        const SUMl = u64.add4L(s0l, s1l, SHA512_W_L2[i2 - 7], SHA512_W_L2[i2 - 16]);
        const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H2[i2 - 7], SHA512_W_H2[i2 - 16]);
        SHA512_W_H2[i2] = SUMh | 0;
        SHA512_W_L2[i2] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i2 = 0; i2 < 80; i2++) {
        const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
        const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i2], SHA512_W_L2[i2]);
        const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i2], SHA512_W_H2[i2]);
        const T1l = T1ll | 0;
        const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
        const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64.add3L(T1l, sigma0l, MAJl);
        Ah = u64.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      (0, utils_ts_1.clean)(SHA512_W_H2, SHA512_W_L2);
    }
    destroy() {
      (0, utils_ts_1.clean)(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  sha2.SHA512 = SHA512;
  class SHA384 extends SHA512 {
    constructor() {
      super(48);
      this.Ah = _md_ts_1.SHA384_IV[0] | 0;
      this.Al = _md_ts_1.SHA384_IV[1] | 0;
      this.Bh = _md_ts_1.SHA384_IV[2] | 0;
      this.Bl = _md_ts_1.SHA384_IV[3] | 0;
      this.Ch = _md_ts_1.SHA384_IV[4] | 0;
      this.Cl = _md_ts_1.SHA384_IV[5] | 0;
      this.Dh = _md_ts_1.SHA384_IV[6] | 0;
      this.Dl = _md_ts_1.SHA384_IV[7] | 0;
      this.Eh = _md_ts_1.SHA384_IV[8] | 0;
      this.El = _md_ts_1.SHA384_IV[9] | 0;
      this.Fh = _md_ts_1.SHA384_IV[10] | 0;
      this.Fl = _md_ts_1.SHA384_IV[11] | 0;
      this.Gh = _md_ts_1.SHA384_IV[12] | 0;
      this.Gl = _md_ts_1.SHA384_IV[13] | 0;
      this.Hh = _md_ts_1.SHA384_IV[14] | 0;
      this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
  }
  sha2.SHA384 = SHA384;
  const T224_IV2 = Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]);
  const T256_IV2 = Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  class SHA512_224 extends SHA512 {
    constructor() {
      super(28);
      this.Ah = T224_IV2[0] | 0;
      this.Al = T224_IV2[1] | 0;
      this.Bh = T224_IV2[2] | 0;
      this.Bl = T224_IV2[3] | 0;
      this.Ch = T224_IV2[4] | 0;
      this.Cl = T224_IV2[5] | 0;
      this.Dh = T224_IV2[6] | 0;
      this.Dl = T224_IV2[7] | 0;
      this.Eh = T224_IV2[8] | 0;
      this.El = T224_IV2[9] | 0;
      this.Fh = T224_IV2[10] | 0;
      this.Fl = T224_IV2[11] | 0;
      this.Gh = T224_IV2[12] | 0;
      this.Gl = T224_IV2[13] | 0;
      this.Hh = T224_IV2[14] | 0;
      this.Hl = T224_IV2[15] | 0;
    }
  }
  sha2.SHA512_224 = SHA512_224;
  class SHA512_256 extends SHA512 {
    constructor() {
      super(32);
      this.Ah = T256_IV2[0] | 0;
      this.Al = T256_IV2[1] | 0;
      this.Bh = T256_IV2[2] | 0;
      this.Bl = T256_IV2[3] | 0;
      this.Ch = T256_IV2[4] | 0;
      this.Cl = T256_IV2[5] | 0;
      this.Dh = T256_IV2[6] | 0;
      this.Dl = T256_IV2[7] | 0;
      this.Eh = T256_IV2[8] | 0;
      this.El = T256_IV2[9] | 0;
      this.Fh = T256_IV2[10] | 0;
      this.Fl = T256_IV2[11] | 0;
      this.Gh = T256_IV2[12] | 0;
      this.Gl = T256_IV2[13] | 0;
      this.Hh = T256_IV2[14] | 0;
      this.Hl = T256_IV2[15] | 0;
    }
  }
  sha2.SHA512_256 = SHA512_256;
  sha2.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
  sha2.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
  sha2.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
  sha2.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
  sha2.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
  sha2.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
  return sha2;
}
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256;
  hasRequiredSha256 = 1;
  Object.defineProperty(sha256, "__esModule", { value: true });
  sha256.sha224 = sha256.SHA224 = sha256.sha256 = sha256.SHA256 = void 0;
  const sha2_ts_1 = requireSha2();
  sha256.SHA256 = sha2_ts_1.SHA256;
  sha256.sha256 = sha2_ts_1.sha256;
  sha256.SHA224 = sha2_ts_1.SHA224;
  sha256.sha224 = sha2_ts_1.sha224;
  return sha256;
}
var sha512 = {};
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512;
  hasRequiredSha512 = 1;
  Object.defineProperty(sha512, "__esModule", { value: true });
  sha512.sha512_256 = sha512.SHA512_256 = sha512.sha512_224 = sha512.SHA512_224 = sha512.sha384 = sha512.SHA384 = sha512.sha512 = sha512.SHA512 = void 0;
  const sha2_ts_1 = requireSha2();
  sha512.SHA512 = sha2_ts_1.SHA512;
  sha512.sha512 = sha2_ts_1.sha512;
  sha512.SHA384 = sha2_ts_1.SHA384;
  sha512.sha384 = sha2_ts_1.sha384;
  sha512.SHA512_224 = sha2_ts_1.SHA512_224;
  sha512.sha512_224 = sha2_ts_1.sha512_224;
  sha512.SHA512_256 = sha2_ts_1.SHA512_256;
  sha512.sha512_256 = sha2_ts_1.sha512_256;
  return sha512;
}
var pbkdf2 = {};
var hmac = {};
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.hmac = exports$1.HMAC = void 0;
    const utils_ts_1 = requireUtils();
    class HMAC extends utils_ts_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash2);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54 ^ 92;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
      }
      update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    }
    exports$1.HMAC = HMAC;
    const hmac2 = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
    exports$1.hmac = hmac2;
    exports$1.hmac.create = (hash2, key) => new HMAC(hash2, key);
  })(hmac);
  return hmac;
}
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2) return pbkdf2;
  hasRequiredPbkdf2 = 1;
  Object.defineProperty(pbkdf2, "__esModule", { value: true });
  pbkdf2.pbkdf2 = pbkdf2$1;
  pbkdf2.pbkdf2Async = pbkdf2Async;
  const hmac_ts_1 = requireHmac();
  const utils_ts_1 = requireUtils();
  function pbkdf2Init(hash2, _password, _salt, _opts12) {
    (0, utils_ts_1.ahash)(hash2);
    const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts12);
    const { c, dkLen, asyncTick } = opts;
    (0, utils_ts_1.anumber)(c);
    (0, utils_ts_1.anumber)(dkLen);
    (0, utils_ts_1.anumber)(asyncTick);
    if (c < 1)
      throw new Error("iterations (c) should be >= 1");
    const password = (0, utils_ts_1.kdfInputToBytes)(_password);
    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac_ts_1.hmac.create(hash2, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    (0, utils_ts_1.clean)(u);
    return DK;
  }
  function pbkdf2$1(hash2, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i2 = 0; i2 < Ti.length; i2++)
          Ti[i2] ^= u[i2];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  async function pbkdf2Async(hash2, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = (0, utils_ts_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i2 = 0; i2 < Ti.length; i2++)
          Ti[i2] ^= u[i2];
      });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  return pbkdf2;
}

// node_modules/opnet/browser/noble-curves.js
var _0n$3 = BigInt(0);
var _1n$3 = BigInt(1);
function abool(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}" `;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function abignumber(n2) {
  if (typeof n2 === "bigint") {
    if (!isPosBig(n2))
      throw new Error("positive bigint expected, got " + n2);
  } else
    anumber(n2);
  return n2;
}
function numberToHexUnpadded(num) {
  const hex = abignumber(num).toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n$3 : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  return hexToNumber(bytesToHex(copyBytes(abytes(bytes)).reverse()));
}
function numberToBytesBE(n2, len) {
  anumber(len);
  n2 = abignumber(n2);
  const res = hexToBytes(n2.toString(16).padStart(len * 2, "0"));
  if (res.length !== len)
    throw new Error("number too large");
  return res;
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
var isPosBig = (n2) => typeof n2 === "bigint" && _0n$3 <= n2;
function inRange(n2, min2, max2) {
  return isPosBig(n2) && isPosBig(min2) && isPosBig(max2) && min2 <= n2 && n2 < max2;
}
function aInRange(title, n2, min2, max2) {
  if (!inRange(n2, min2, max2))
    throw new Error("expected valid " + title + ": " + min2 + " <= n < " + max2 + ", got " + n2);
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n$3; n2 >>= _1n$3, len += 1)
    ;
  return len;
}
var bitMask = (n2) => (_1n$3 << BigInt(n2)) - _1n$3;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  anumber(hashLen, "hashLen");
  anumber(qByteLen, "qByteLen");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n2 = (len) => new Uint8Array(len);
  const NULL = Uint8Array.of();
  const byte0 = Uint8Array.of(0);
  const byte1 = Uint8Array.of(1);
  const _maxDrbgIters = 1e3;
  let v = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...msgs) => hmacFn(k, concatBytes(v, ...msgs));
  const reseed = (seed = NULL) => {
    k = h(byte0, seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(byte1, seed);
    v = h();
  };
  const gen = () => {
    if (i2++ >= _maxDrbgIters)
      throw new Error("drbg: tried max amount of iterations");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, fields = {}, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  const iter = (f, isOpt) => Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));
  iter(fields, false);
  iter(optFields, true);
}
function memoized(fn2) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn2(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
function checkU32(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0 || n2 > 4294967295)
    throw new Error("wrong u32 integer:" + n2);
  return n2;
}
function isPowerOfTwo(x) {
  checkU32(x);
  return (x & x - 1) === 0 && x !== 0;
}
function reverseBits(n2, bits) {
  checkU32(n2);
  let reversed = 0;
  for (let i2 = 0; i2 < bits; i2++, n2 >>>= 1)
    reversed = reversed << 1 | n2 & 1;
  return reversed;
}
function log2(n2) {
  checkU32(n2);
  return 31 - Math.clz32(n2);
}
function bitReversalInplace(values) {
  const n2 = values.length;
  if (n2 < 2 || !isPowerOfTwo(n2))
    throw new Error("n must be a power of 2 and greater than 1. Got " + n2);
  const bits = log2(n2);
  for (let i2 = 0; i2 < n2; i2++) {
    const j = reverseBits(i2, bits);
    if (i2 < j) {
      const tmp = values[i2];
      values[i2] = values[j];
      values[j] = tmp;
    }
  }
  return values;
}
var FFTCore = (F2, coreOpts) => {
  const { N: N2, roots, dit, invertButterflies = false, skipStages = 0, brp = true } = coreOpts;
  const bits = log2(N2);
  if (!isPowerOfTwo(N2))
    throw new Error("FFT: Polynomial size should be power of two");
  const isDit = dit !== invertButterflies;
  return (values) => {
    if (values.length !== N2)
      throw new Error("FFT: wrong Polynomial length");
    if (dit && brp)
      bitReversalInplace(values);
    for (let i2 = 0, g = 1; i2 < bits - skipStages; i2++) {
      const s = dit ? i2 + 1 + skipStages : bits - i2;
      const m = 1 << s;
      const m2 = m >> 1;
      const stride = N2 >> s;
      for (let k = 0; k < N2; k += m) {
        for (let j = 0, grp = g++; j < m2; j++) {
          const rootPos = invertButterflies ? dit ? N2 - grp : grp : j * stride;
          const i0 = k + j;
          const i1 = k + j + m2;
          const omega = roots[rootPos];
          const b = values[i1];
          const a = values[i0];
          if (isDit) {
            const t2 = F2.mul(b, omega);
            values[i0] = F2.add(a, t2);
            values[i1] = F2.sub(a, t2);
          } else if (invertButterflies) {
            values[i0] = F2.add(b, a);
            values[i1] = F2.mul(F2.sub(b, a), omega);
          } else {
            values[i0] = F2.add(a, b);
            values[i1] = F2.mul(F2.sub(a, b), omega);
          }
        }
      }
    }
    if (!dit && brp)
      bitReversalInplace(values);
    return values;
  };
};
var _0n$2 = BigInt(0);
var _1n$2 = BigInt(1);
var _2n$2 = BigInt(2);
var _3n$1 = BigInt(3);
var _4n$1 = BigInt(4);
var _5n = BigInt(5);
var _7n2 = BigInt(7);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n$2 ? result : b + result;
}
function pow2(x, power, modulo2) {
  let res = x;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo2;
  }
  return res;
}
function invert(number2, modulo2) {
  if (number2 === _0n$2)
    throw new Error("invert: expected non-zero number");
  if (modulo2 <= _0n$2)
    throw new Error("invert: expected positive modulus, got " + modulo2);
  let a = mod(number2, modulo2);
  let b = modulo2;
  let x = _0n$2, u = _1n$2;
  while (a !== _0n$2) {
    const q = b / a;
    const r2 = b % a;
    const m = x - u * q;
    b = a, a = r2, x = u, u = m;
  }
  const gcd = b;
  if (gcd !== _1n$2)
    throw new Error("invert: does not exist");
  return mod(x, modulo2);
}
function assertIsSquare(Fp, root, n2) {
  if (!Fp.eql(Fp.sqr(root), n2))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n2) {
  const p1div4 = (Fp.ORDER + _1n$2) / _4n$1;
  const root = Fp.pow(n2, p1div4);
  assertIsSquare(Fp, root, n2);
  return root;
}
function sqrt5mod8(Fp, n2) {
  const p5div8 = (Fp.ORDER - _5n) / _8n;
  const n22 = Fp.mul(n2, _2n$2);
  const v = Fp.pow(n22, p5div8);
  const nv = Fp.mul(n2, v);
  const i2 = Fp.mul(Fp.mul(nv, _2n$2), v);
  const root = Fp.mul(nv, Fp.sub(i2, Fp.ONE));
  assertIsSquare(Fp, root, n2);
  return root;
}
function sqrt9mod16(P2) {
  const Fp_ = Field(P2);
  const tn2 = tonelliShanks(P2);
  const c1 = tn2(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn2(Fp_, c1);
  const c3 = tn2(Fp_, Fp_.neg(c1));
  const c4 = (P2 + _7n2) / _16n;
  return (Fp, n2) => {
    let tv1 = Fp.pow(n2, c4);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c2);
    const tv4 = Fp.mul(tv1, c3);
    const e1 = Fp.eql(Fp.sqr(tv2), n2);
    const e2 = Fp.eql(Fp.sqr(tv3), n2);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e2);
    const e3 = Fp.eql(Fp.sqr(tv2), n2);
    const root = Fp.cmov(tv1, tv2, e3);
    assertIsSquare(Fp, root, n2);
    return root;
  };
}
function tonelliShanks(P2) {
  if (P2 < _3n$1)
    throw new Error("sqrt is not defined for small field");
  let Q2 = P2 - _1n$2;
  let S2 = 0;
  while (Q2 % _2n$2 === _0n$2) {
    Q2 /= _2n$2;
    S2++;
  }
  let Z = _2n$2;
  const _Fp = Field(P2);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S2 === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q2);
  const Q1div2 = (Q2 + _1n$2) / _2n$2;
  return function tonelliSlow(Fp, n2) {
    if (Fp.is0(n2))
      return n2;
    if (FpLegendre(Fp, n2) !== 1)
      throw new Error("Cannot find square root");
    let M2 = S2;
    let c = Fp.mul(Fp.ONE, cc);
    let t2 = Fp.pow(n2, Q2);
    let R = Fp.pow(n2, Q1div2);
    while (!Fp.eql(t2, Fp.ONE)) {
      if (Fp.is0(t2))
        return Fp.ZERO;
      let i2 = 1;
      let t_tmp = Fp.sqr(t2);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i2++;
        t_tmp = Fp.sqr(t_tmp);
        if (i2 === M2)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n$2 << BigInt(M2 - i2 - 1);
      const b = Fp.pow(c, exponent);
      M2 = i2;
      c = Fp.sqr(b);
      t2 = Fp.mul(t2, c);
      R = Fp.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n$1 === _3n$1)
    return sqrt3mod4;
  if (P2 % _8n === _5n)
    return sqrt5mod8;
  if (P2 % _16n === _9n)
    return sqrt9mod16(P2);
  return tonelliShanks(P2);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  validateObject(field, opts);
  return field;
}
function FpPow(Fp, num, power) {
  if (power < _0n$2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n$2)
    return Fp.ONE;
  if (power === _1n$2)
    return num;
  let p = Fp.ONE;
  let d = num;
  while (power > _0n$2) {
    if (power & _1n$2)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n$2;
  }
  return p;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i2) => {
    if (Fp.is0(num))
      return acc;
    inverted[i2] = acc;
    return Fp.mul(acc, num);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num, i2) => {
    if (Fp.is0(num))
      return acc;
    inverted[i2] = Fp.mul(acc, inverted[i2]);
    return Fp.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n2) {
  const p1mod2 = (Fp.ORDER - _1n$2) / _2n$2;
  const powered = Fp.pow(n2, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero2 = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero2 && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero2 ? 0 : -1;
}
function nLength(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
var _Field = class {
  constructor(ORDER, opts = {}) {
    __publicField(this, "ORDER");
    __publicField(this, "BITS");
    __publicField(this, "BYTES");
    __publicField(this, "isLE");
    __publicField(this, "ZERO", _0n$2);
    __publicField(this, "ONE", _1n$2);
    __publicField(this, "_lengths");
    __publicField(this, "_sqrt");
    // cached sqrt
    __publicField(this, "_mod");
    var _a5;
    if (ORDER <= _0n$2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    this.isLE = false;
    if (opts != null && typeof opts === "object") {
      if (typeof opts.BITS === "number")
        _nbitLength = opts.BITS;
      if (typeof opts.sqrt === "function")
        this.sqrt = opts.sqrt;
      if (typeof opts.isLE === "boolean")
        this.isLE = opts.isLE;
      if (opts.allowedLengths)
        this._lengths = (_a5 = opts.allowedLengths) == null ? void 0 : _a5.slice();
      if (typeof opts.modFromBytes === "boolean")
        this._mod = opts.modFromBytes;
    }
    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);
    if (nByteLength > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = ORDER;
    this.BITS = nBitLength;
    this.BYTES = nByteLength;
    this._sqrt = void 0;
    Object.preventExtensions(this);
  }
  create(num) {
    return mod(num, this.ORDER);
  }
  isValid(num) {
    if (typeof num !== "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof num);
    return _0n$2 <= num && num < this.ORDER;
  }
  is0(num) {
    return num === _0n$2;
  }
  // is valid and invertible
  isValidNot0(num) {
    return !this.is0(num) && this.isValid(num);
  }
  isOdd(num) {
    return (num & _1n$2) === _1n$2;
  }
  neg(num) {
    return mod(-num, this.ORDER);
  }
  eql(lhs, rhs) {
    return lhs === rhs;
  }
  sqr(num) {
    return mod(num * num, this.ORDER);
  }
  add(lhs, rhs) {
    return mod(lhs + rhs, this.ORDER);
  }
  sub(lhs, rhs) {
    return mod(lhs - rhs, this.ORDER);
  }
  mul(lhs, rhs) {
    return mod(lhs * rhs, this.ORDER);
  }
  pow(num, power) {
    return FpPow(this, num, power);
  }
  div(lhs, rhs) {
    return mod(lhs * invert(rhs, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(num) {
    return num * num;
  }
  addN(lhs, rhs) {
    return lhs + rhs;
  }
  subN(lhs, rhs) {
    return lhs - rhs;
  }
  mulN(lhs, rhs) {
    return lhs * rhs;
  }
  inv(num) {
    return invert(num, this.ORDER);
  }
  sqrt(num) {
    if (!this._sqrt)
      this._sqrt = FpSqrt(this.ORDER);
    return this._sqrt(this, num);
  }
  toBytes(num) {
    return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);
  }
  fromBytes(bytes, skipValidation = false) {
    abytes(bytes);
    const { _lengths: allowedLengths, BYTES, isLE: isLE2, ORDER, _mod: modFromBytes } = this;
    if (allowedLengths) {
      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
        throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
      }
      const padded = new Uint8Array(BYTES);
      padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);
      bytes = padded;
    }
    if (bytes.length !== BYTES)
      throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
    let scalar = isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    if (modFromBytes)
      scalar = mod(scalar, ORDER);
    if (!skipValidation) {
      if (!this.isValid(scalar))
        throw new Error("invalid field element: outside of range 0..ORDER");
    }
    return scalar;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(lst) {
    return FpInvertBatch(this, lst);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(a, b, condition) {
    return condition ? b : a;
  }
};
function Field(ORDER, opts = {}) {
  return new _Field(ORDER, opts);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  abytes(key);
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num, fieldOrder - _1n$2) + _1n$2;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n$1 = BigInt(0);
var _1n$1 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i2) => c.fromAffine(p.toAffine(invertedZs[i2])));
}
function validateW(W2, bits) {
  if (!Number.isSafeInteger(W2) || W2 <= 0 || W2 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W2);
}
function calcWOpts(W2, scalarBits2) {
  validateW(W2, scalarBits2);
  const windows = Math.ceil(scalarBits2 / W2) + 1;
  const windowSize = 2 ** (W2 - 1);
  const maxNumber = 2 ** W2;
  const mask = bitMask(W2);
  const shiftBy = BigInt(W2);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n$1;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero3 = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero: isZero3, isNeg, isNegF, offsetF };
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P2) {
  return pointWindowSizes.get(P2) || 1;
}
function assert0(n2) {
  if (n2 !== _0n$1)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point2, bits) {
    __publicField(this, "BASE");
    __publicField(this, "ZERO");
    __publicField(this, "Fn");
    __publicField(this, "bits");
    this.BASE = Point2.BASE;
    this.ZERO = Point2.ZERO;
    this.Fn = Point2.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n2, p = this.ZERO) {
    let d = elm;
    while (n2 > _0n$1) {
      if (n2 & _1n$1)
        p = p.add(d);
      d = d.double();
      n2 >>= _1n$1;
    }
    return p;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W2) {
    const { windows, windowSize } = calcWOpts(W2, this.bits);
    const points = [];
    let p = point;
    let base2 = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base2 = p;
      points.push(base2);
      for (let i2 = 1; i2 < windowSize; i2++) {
        base2 = base2.add(p);
        points.push(base2);
      }
      p = base2.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W2, precomputes, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts(W2, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero: isZero3, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero3) {
        f = f.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n2);
    return { p, f };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W2, precomputes, n2, acc = this.ZERO) {
    const wo = calcWOpts(W2, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n2 === _0n$1)
        break;
      const { nextN, offset, isZero: isZero3, isNeg } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero3) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n2);
    return acc;
  }
  getPrecomputes(W2, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W2);
      if (W2 !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W2 = getW(point);
    return this.wNAF(W2, this.getPrecomputes(W2, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W2 = getW(point);
    if (W2 === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W2, this.getPrecomputes(W2, point, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P2, W2) {
    validateW(W2, this.bits);
    pointWindowSizes.set(P2, W2);
    pointPrecomputes.delete(P2);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function mulEndoUnsafe(Point2, point, k1, k2) {
  let acc = point;
  let p1 = Point2.ZERO;
  let p2 = Point2.ZERO;
  while (k1 > _0n$1 || k2 > _0n$1) {
    if (k1 & _1n$1)
      p1 = p1.add(acc);
    if (k2 & _1n$1)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n$1;
    k2 >>= _1n$1;
  }
  return { p1, p2 };
}
function createField(order, field, isLE2) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE: isLE2 });
  }
}
function createCurveFields(type2, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type2 === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type2} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n$1))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn2 = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b2 = "b";
  const params = ["Gx", "Gy", "a", _b2];
  for (const p of params) {
    if (!Fp.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn: Fn2 };
}
function createKeygen(randomSecretKey, getPublicKey) {
  return function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  };
}
var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n$1) / den;
function _splitEndoScalar(k, basis, n2) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n2);
  const c2 = divNearest(-b1 * k, n2);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n2;
  const k2neg = k2 < _0n2;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n2) / 2)) + _1n2;
  if (k1 < _0n2 || k1 >= MAX_NUM || k2 < _0n2 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
  if (!["compact", "recovered", "der"].includes(format))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  abool(optsn.lowS, "lowS");
  abool(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t2 = numberToHexUnpadded(tag);
      return t2 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong2 = !!(first & 128);
      let length = 0;
      if (!isLong2)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length = length << 8 | b;
        pos += lenLen;
        if (length < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E } = DER;
      if (num < _0n2)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(bytes) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = abytes(bytes, void 0, "signature");
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n$1 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
function weierstrass(params, extraOpts = {}) {
  const validated = createCurveFields("weierstrass", params, extraOpts);
  const { Fp, Fn: Fn2 } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths2 = getWLengths(Fp, Fn2);
  function assertCompressionIsSupported() {
    if (!Fp.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp.toBytes(x);
    abool(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    abytes(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths2;
    const length = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length === comp && (head === 2 || head === 3)) {
      const x = Fp.fromBytes(tail);
      if (!Fp.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp.sqrt(y2);
      } catch (sqrtError) {
        const err2 = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err2);
      }
      assertCompressionIsSupported();
      const evenY = Fp.isOdd(y);
      const evenH = (head & 1) === 1;
      if (evenH !== evenY)
        y = Fp.neg(y);
      return { x, y };
    } else if (length === uncomp && head === 4) {
      const L3 = Fp.BYTES;
      const x = Fp.fromBytes(tail.subarray(0, L3));
      const y = Fp.fromBytes(tail.subarray(L3, L3 * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
  }
  function isValidXY(x, y) {
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    return Fp.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp.isValid(n2) || banZero && Fp.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("Weierstrass Point expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn2.ORDER);
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X: X2, Y: Y2, Z } = p;
    if (Fp.eql(Z, Fp.ONE))
      return { x: X2, y: Y2 };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(Z);
    const x = Fp.mul(X2, iz);
    const y = Fp.mul(Y2, iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  const _Point = class _Point {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X2, Y2, Z) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      this.X = acoord("x", X2);
      this.Y = acoord("y", Y2, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof _Point)
        throw new Error("projective point not allowed");
      if (Fp.is0(x) && Fp.is0(y))
        return _Point.ZERO;
      return new _Point(x, y, Fp.ONE);
    }
    static fromBytes(bytes) {
      const P2 = _Point.fromAffine(decodePoint(abytes(bytes, void 0, "point")));
      P2.assertValidity();
      return P2;
    }
    static fromHex(hex) {
      return _Point.fromBytes(hexToBytes(hex));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _Point(this.X, Fp.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new _Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new _Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(_Point.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn2.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n2) => wnaf.cached(this, n2, (p) => normalizeZ(_Point, p));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul(scalar);
        point = p;
        fake = f;
      }
      return normalizeZ(_Point, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p = this;
      if (!Fn2.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n2 || p.is0())
        return _Point.ZERO;
      if (sc === _1n2)
        return p;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2 } = mulEndoUnsafe(_Point, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p, sc);
      }
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n2)
        return true;
      if (isTorsionFree)
        return isTorsionFree(_Point, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n2)
        return this;
      if (clearCofactor)
        return clearCofactor(_Point, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      abool(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(_Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_Point, "BASE", new _Point(CURVE.Gx, CURVE.Gy, Fp.ONE));
  // zero / infinity / identity point
  __publicField(_Point, "ZERO", new _Point(Fp.ZERO, Fp.ONE, Fp.ZERO));
  // 0, 1, 0
  // math field
  __publicField(_Point, "Fp", Fp);
  // scalar field
  __publicField(_Point, "Fn", Fn2);
  let Point2 = _Point;
  const bits = Fn2.BITS;
  const wnaf = new wNAF(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point2.BASE.precompute(8);
  return Point2;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function getWLengths(Fp, Fn2) {
  return {
    secretKey: Fn2.BYTES,
    publicKey: 1 + Fp.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn2.BYTES
  };
}
function ecdh(Point2, ecdhOpts = {}) {
  const { Fn: Fn2 } = Point2;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths2 = Object.assign(getWLengths(Point2.Fp, Fn2), { seed: getMinHashLength(Fn2.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      const num = Fn2.fromBytes(secretKey);
      return Fn2.isValidNot0(num);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths2;
    try {
      const l = publicKey.length;
      if (isCompressed === true && l !== comp)
        return false;
      if (isCompressed === false && l !== publicKeyUncompressed)
        return false;
      return !!Point2.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths2.seed)) {
    return mapHashToField(abytes(seed, lengths2.seed, "seed"), Fn2.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point2.BASE.multiply(Fn2.fromBytes(secretKey)).toBytes(isCompressed);
  }
  function isProbPub(item) {
    const { secretKey, publicKey, publicKeyUncompressed } = lengths2;
    if (!isBytes(item))
      return void 0;
    if ("_lengths" in Fn2 && Fn2._lengths || secretKey === publicKey)
      return void 0;
    const l = abytes(item, void 0, "key").length;
    return l === publicKey || l === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s = Fn2.fromBytes(secretKeyA);
    const b = Point2.fromBytes(publicKeyB);
    return b.multiply(s).toBytes(isCompressed);
  }
  const utils3 = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey
  };
  const keygen = createKeygen(randomSecretKey, getPublicKey);
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point: Point2, utils: utils3, lengths: lengths2 });
}
function ecdsa(Point2, hash2, ecdsaOpts = {}) {
  ahash(hash2);
  validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  ecdsaOpts = Object.assign({}, ecdsaOpts);
  const randomBytes$1 = ecdsaOpts.randomBytes || randomBytes;
  const hmac$12 = ecdsaOpts.hmac || ((key, msg) => hmac$1(hash2, key, msg));
  const { Fp, Fn: Fn2 } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn2;
  const { keygen, getPublicKey, getSharedSecret, utils: utils3, lengths: lengths2 } = ecdh(Point2, ecdsaOpts);
  const defaultSigOpts = {
    prehash: true,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : true,
    format: "compact",
    extraEntropy: false
  };
  const hasLargeCofactor = CURVE_ORDER * _2n$1 < Fp.ORDER;
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n2;
    return number2 > HALF;
  }
  function validateRS(title, num) {
    if (!Fn2.isValidNot0(num))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num;
  }
  function assertSmallCofactor() {
    if (hasLargeCofactor)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function validateSigLength(bytes, format) {
    validateSigFormat(format);
    const size = lengths2.signature;
    const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
    return abytes(bytes, sizer);
  }
  class Signature {
    constructor(r2, s, recovery) {
      __publicField(this, "r");
      __publicField(this, "s");
      __publicField(this, "recovery");
      this.r = validateRS("r", r2);
      this.s = validateRS("s", s);
      if (recovery != null) {
        assertSmallCofactor();
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("invalid recovery id");
        this.recovery = recovery;
      }
      Object.freeze(this);
    }
    static fromBytes(bytes, format = defaultSigOpts.format) {
      validateSigLength(bytes, format);
      let recid;
      if (format === "der") {
        const { r: r3, s: s2 } = DER.toSig(abytes(bytes));
        return new Signature(r3, s2);
      }
      if (format === "recovered") {
        recid = bytes[0];
        format = "compact";
        bytes = bytes.subarray(1);
      }
      const L3 = lengths2.signature / 2;
      const r2 = bytes.subarray(0, L3);
      const s = bytes.subarray(L3, L3 * 2);
      return new Signature(Fn2.fromBytes(r2), Fn2.fromBytes(s), recid);
    }
    static fromHex(hex, format) {
      return this.fromBytes(hexToBytes(hex), format);
    }
    assertRecovery() {
      const { recovery } = this;
      if (recovery == null)
        throw new Error("invalid recovery id: must be present");
      return recovery;
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const { r: r2, s } = this;
      const recovery = this.assertRecovery();
      const radj = recovery === 2 || recovery === 3 ? r2 + CURVE_ORDER : r2;
      if (!Fp.isValid(radj))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const x = Fp.toBytes(radj);
      const R = Point2.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));
      const ir2 = Fn2.inv(radj);
      const h = bits2int_modN(abytes(messageHash, void 0, "msgHash"));
      const u1 = Fn2.create(-h * ir2);
      const u2 = Fn2.create(s * ir2);
      const Q2 = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q2.is0())
        throw new Error("invalid recovery: point at infinify");
      Q2.assertValidity();
      return Q2;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format = defaultSigOpts.format) {
      validateSigFormat(format);
      if (format === "der")
        return hexToBytes(DER.hexFromSig(this));
      const { r: r2, s } = this;
      const rb = Fn2.toBytes(r2);
      const sb = Fn2.toBytes(s);
      if (format === "recovered") {
        assertSmallCofactor();
        return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);
      }
      return concatBytes(rb, sb);
    }
    toHex(format) {
      return bytesToHex(this.toBytes(format));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn2.create(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num) {
    aInRange("num < 2^" + fnBits, num, _0n2, ORDER_MASK);
    return Fn2.toBytes(num);
  }
  function validateMsgAndHash(message, prehash) {
    abytes(message, void 0, "message");
    return prehash ? abytes(hash2(message), void 0, "prehashed message") : message;
  }
  function prepSig(message, secretKey, opts) {
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    const h1int = bits2int_modN(message);
    const d = Fn2.fromBytes(secretKey);
    if (!Fn2.isValidNot0(d))
      throw new Error("invalid private key");
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e = extraEntropy === true ? randomBytes$1(lengths2.secretKey) : extraEntropy;
      seedArgs.push(abytes(e, void 0, "extraEntropy"));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn2.isValidNot0(k))
        return;
      const ik = Fn2.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r2 = Fn2.create(q.x);
      if (r2 === _0n2)
        return;
      const s = Fn2.create(ik * Fn2.create(m + r2 * d));
      if (s === _0n2)
        return;
      let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n2);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = Fn2.neg(s);
        recovery ^= 1;
      }
      return new Signature(r2, normS, hasLargeCofactor ? void 0 : recovery);
    }
    return { seed, k2sig };
  }
  function sign2(message, secretKey, opts = {}) {
    const { seed, k2sig } = prepSig(message, secretKey, opts);
    const drbg = createHmacDrbg(hash2.outputLen, Fn2.BYTES, hmac$12);
    const sig = drbg(seed, k2sig);
    return sig.toBytes(opts.format);
  }
  function verify(signature2, message, publicKey, opts = {}) {
    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
    publicKey = abytes(publicKey, void 0, "publicKey");
    message = validateMsgAndHash(message, prehash);
    if (!isBytes(signature2)) {
      const end = signature2 instanceof Signature ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + end);
    }
    validateSigLength(signature2, format);
    try {
      const sig = Signature.fromBytes(signature2, format);
      const P2 = Point2.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r: r2, s } = sig;
      const h = bits2int_modN(message);
      const is = Fn2.inv(s);
      const u1 = Fn2.create(h * is);
      const u2 = Fn2.create(r2 * is);
      const R = Point2.BASE.multiplyUnsafe(u1).add(P2.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn2.create(R.x);
      return v === r2;
    } catch (e) {
      return false;
    }
  }
  function recoverPublicKey(signature2, message, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    return Signature.fromBytes(signature2, "recovered").recoverPublicKey(message).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils: utils3,
    lengths: lengths2,
    Point: Point2,
    sign: sign2,
    verify,
    recoverPublicKey,
    Signature,
    hash: hash2
  });
}
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _2n2 = BigInt(2);
function sqrtMod(y) {
  const P2 = secp256k1_CURVE.p;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P2;
  const b3 = b2 * b2 * y % P2;
  const b6 = pow2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2(b9, _2n2, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root = pow2(t2, _2n2, P2);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var Pointk1 = weierstrass(secp256k1_CURVE, {
  Fp: Fpk1,
  endo: secp256k1_ENDO
});
var secp256k1 = ecdsa(Pointk1, sha256$1);

// node_modules/opnet/browser/vendors.js
var bitcoin$1 = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: "Bitcoin Signed Message:\n",
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  bech32Opnet: "op",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
var regtest = {
  messagePrefix: "Bitcoin Signed Message:\n",
  bech32: "bcrt",
  bech32Opnet: "opr",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var testnet = {
  messagePrefix: "Bitcoin Signed Message:\n",
  bech32: "tb",
  bech32Opnet: "opt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var opnetTestnet = {
  messagePrefix: "Bitcoin Signed Message:\n",
  bech32: "opt",
  bech32Opnet: "opt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (Object.prototype.hasOwnProperty.call(n2, "__esModule")) return n2;
  var f = n2.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var dist$1 = {};
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$1;
  hasRequiredDist$1 = 1;
  Object.defineProperty(dist$1, "__esModule", { value: true });
  dist$1.bech32m = dist$1.bech32 = void 0;
  const ALPHABET2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
  const ALPHABET_MAP = {};
  for (let z2 = 0; z2 < ALPHABET2.length; z2++) {
    const x = ALPHABET2.charAt(z2);
    ALPHABET_MAP[x] = z2;
  }
  function polymodStep(pre) {
    const b = pre >> 25;
    return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
  }
  function prefixChk(prefix) {
    let chk = 1;
    for (let i2 = 0; i2 < prefix.length; ++i2) {
      const c = prefix.charCodeAt(i2);
      if (c < 33 || c > 126)
        return "Invalid prefix (" + prefix + ")";
      chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for (let i2 = 0; i2 < prefix.length; ++i2) {
      const v = prefix.charCodeAt(i2);
      chk = polymodStep(chk) ^ v & 31;
    }
    return chk;
  }
  function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i2 = 0; i2 < data.length; ++i2) {
      value = value << inBits | data[i2];
      bits += inBits;
      while (bits >= outBits) {
        bits -= outBits;
        result.push(value >> bits & maxV);
      }
    }
    if (pad) {
      if (bits > 0) {
        result.push(value << outBits - bits & maxV);
      }
    } else {
      if (bits >= inBits)
        return "Excess padding";
      if (value << outBits - bits & maxV)
        return "Non-zero padding";
    }
    return result;
  }
  function toWords(bytes) {
    return convert(bytes, 8, 5, true);
  }
  function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
      return res;
  }
  function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
      return res;
    throw new Error(res);
  }
  function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === "bech32") {
      ENCODING_CONST = 1;
    } else {
      ENCODING_CONST = 734539939;
    }
    function encode2(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      let chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      let result = prefix + "1";
      for (let i2 = 0; i2 < words.length; ++i2) {
        const x = words[i2];
        if (x >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x;
        result += ALPHABET2.charAt(x);
      }
      for (let i2 = 0; i2 < 6; ++i2) {
        chk = polymodStep(chk);
      }
      chk ^= ENCODING_CONST;
      for (let i2 = 0; i2 < 6; ++i2) {
        const v = chk >> (5 - i2) * 5 & 31;
        result += ALPHABET2.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      const lowered = str.toLowerCase();
      const uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      const split2 = str.lastIndexOf("1");
      if (split2 === -1)
        return "No separator character for " + str;
      if (split2 === 0)
        return "Missing prefix for " + str;
      const prefix = str.slice(0, split2);
      const wordChars = str.slice(split2 + 1);
      if (wordChars.length < 6)
        return "Data too short";
      let chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      const words = [];
      for (let i2 = 0; i2 < wordChars.length; ++i2) {
        const c = wordChars.charAt(i2);
        const v = ALPHABET_MAP[c];
        if (v === void 0)
          return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i2 + 6 >= wordChars.length)
          continue;
        words.push(v);
      }
      if (chk !== ENCODING_CONST)
        return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe2(str, LIMIT) {
      const res = __decode(str, LIMIT);
      if (typeof res === "object")
        return res;
    }
    function decode2(str, LIMIT) {
      const res = __decode(str, LIMIT);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    return {
      decodeUnsafe: decodeUnsafe2,
      decode: decode2,
      encode: encode2,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
  dist$1.bech32 = getLibraryFromEncoding("bech32");
  dist$1.bech32m = getLibraryFromEncoding("bech32m");
  return dist$1;
}
var distExports = requireDist$1();
function fromBech32(address) {
  let result;
  let version2;
  try {
    result = distExports.bech32.decode(address);
  } catch (e) {
  }
  if (result) {
    version2 = result.words[0];
    if (version2 !== 0)
      throw new TypeError(address + " uses wrong encoding");
  } else {
    result = distExports.bech32m.decode(address);
    version2 = result.words[0];
    if (version2 === 0)
      throw new TypeError(address + " uses wrong encoding");
  }
  const data = distExports.bech32.fromWords(result.words.slice(1));
  return {
    version: version2,
    prefix: result.prefix,
    data: new Uint8Array(data)
  };
}
var HEX_STRINGS$1 = "0123456789abcdefABCDEF";
HEX_STRINGS$1.split("").map((c) => c.codePointAt(0));
Array(256).fill(true).map((_2, i2) => {
  const s = String.fromCodePoint(i2);
  const index = HEX_STRINGS$1.indexOf(s);
  return index < 0 ? void 0 : index < 16 ? index : index - 6;
});
new TextEncoder();
new TextDecoder();
function writeUInt16$1(buffer2, offset, value, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value > 65535) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${65535}. Received ${value}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = value & 255;
    buffer2[offset + 1] = value >> 8 & 255;
  } else {
    buffer2[offset] = value >> 8 & 255;
    buffer2[offset + 1] = value & 255;
  }
}
function writeUInt32$1(buffer2, offset, value, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value > 4294967295) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${value}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = value & 255;
    buffer2[offset + 1] = value >> 8 & 255;
    buffer2[offset + 2] = value >> 16 & 255;
    buffer2[offset + 3] = value >> 24 & 255;
  } else {
    buffer2[offset] = value >> 24 & 255;
    buffer2[offset + 1] = value >> 16 & 255;
    buffer2[offset + 2] = value >> 8 & 255;
    buffer2[offset + 3] = value & 255;
  }
}
function writeUInt64$1(buffer2, offset, value, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value > 0xffffffffffffffffn) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = Number(value & 0xffn);
    buffer2[offset + 1] = Number(value >> 8n & 0xffn);
    buffer2[offset + 2] = Number(value >> 16n & 0xffn);
    buffer2[offset + 3] = Number(value >> 24n & 0xffn);
    buffer2[offset + 4] = Number(value >> 32n & 0xffn);
    buffer2[offset + 5] = Number(value >> 40n & 0xffn);
    buffer2[offset + 6] = Number(value >> 48n & 0xffn);
    buffer2[offset + 7] = Number(value >> 56n & 0xffn);
  } else {
    buffer2[offset] = Number(value >> 56n & 0xffn);
    buffer2[offset + 1] = Number(value >> 48n & 0xffn);
    buffer2[offset + 2] = Number(value >> 40n & 0xffn);
    buffer2[offset + 3] = Number(value >> 32n & 0xffn);
    buffer2[offset + 4] = Number(value >> 24n & 0xffn);
    buffer2[offset + 5] = Number(value >> 16n & 0xffn);
    buffer2[offset + 6] = Number(value >> 8n & 0xffn);
    buffer2[offset + 7] = Number(value & 0xffn);
  }
}
function readUInt16$1(buffer2, offset, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num = 0;
    num = (num << 8) + buffer2[offset + 1];
    num = (num << 8) + buffer2[offset];
    return num;
  } else {
    let num = 0;
    num = (num << 8) + buffer2[offset];
    num = (num << 8) + buffer2[offset + 1];
    return num;
  }
}
function readUInt32$1(buffer2, offset, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num = 0;
    num = (num << 8) + buffer2[offset + 3] >>> 0;
    num = (num << 8) + buffer2[offset + 2] >>> 0;
    num = (num << 8) + buffer2[offset + 1] >>> 0;
    num = (num << 8) + buffer2[offset] >>> 0;
    return num;
  } else {
    let num = 0;
    num = (num << 8) + buffer2[offset] >>> 0;
    num = (num << 8) + buffer2[offset + 1] >>> 0;
    num = (num << 8) + buffer2[offset + 2] >>> 0;
    num = (num << 8) + buffer2[offset + 3] >>> 0;
    return num;
  }
}
function readUInt64$1(buffer2, offset, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num = 0n;
    num = (num << 8n) + BigInt(buffer2[offset + 7]);
    num = (num << 8n) + BigInt(buffer2[offset + 6]);
    num = (num << 8n) + BigInt(buffer2[offset + 5]);
    num = (num << 8n) + BigInt(buffer2[offset + 4]);
    num = (num << 8n) + BigInt(buffer2[offset + 3]);
    num = (num << 8n) + BigInt(buffer2[offset + 2]);
    num = (num << 8n) + BigInt(buffer2[offset + 1]);
    num = (num << 8n) + BigInt(buffer2[offset]);
    return num;
  } else {
    let num = 0n;
    num = (num << 8n) + BigInt(buffer2[offset]);
    num = (num << 8n) + BigInt(buffer2[offset + 1]);
    num = (num << 8n) + BigInt(buffer2[offset + 2]);
    num = (num << 8n) + BigInt(buffer2[offset + 3]);
    num = (num << 8n) + BigInt(buffer2[offset + 4]);
    num = (num << 8n) + BigInt(buffer2[offset + 5]);
    num = (num << 8n) + BigInt(buffer2[offset + 6]);
    num = (num << 8n) + BigInt(buffer2[offset + 7]);
    return num;
  }
}
var checkUInt64 = (n2) => {
  if (n2 < 0 || n2 > 0xffffffffffffffffn) {
    throw new RangeError("value out of range");
  }
};
function checkUInt53(n2) {
  if (n2 < 0 || n2 > Number.MAX_SAFE_INTEGER || n2 % 1 !== 0)
    throw new RangeError("value out of range");
}
function checkUint53OrUint64(n2) {
  if (typeof n2 === "number")
    checkUInt53(n2);
  else
    checkUInt64(n2);
}
function encode$k(n2, buffer2, offset) {
  checkUint53OrUint64(n2);
  if (offset === void 0)
    offset = 0;
  if (buffer2 === void 0) {
    buffer2 = new Uint8Array(encodingLength$1(n2));
  }
  let bytes = 0;
  if (n2 < 253) {
    buffer2.set([Number(n2)], offset);
    bytes = 1;
  } else if (n2 <= 65535) {
    buffer2.set([253], offset);
    writeUInt16$1(buffer2, offset + 1, Number(n2), "LE");
    bytes = 3;
  } else if (n2 <= 4294967295) {
    buffer2.set([254], offset);
    writeUInt32$1(buffer2, offset + 1, Number(n2), "LE");
    bytes = 5;
  } else {
    buffer2.set([255], offset);
    writeUInt64$1(buffer2, offset + 1, BigInt(n2), "LE");
    bytes = 9;
  }
  return { buffer: buffer2, bytes };
}
function decode$j(buffer2, offset) {
  if (offset === void 0)
    offset = 0;
  const first = buffer2.at(offset);
  if (first === void 0)
    throw new Error("buffer too small");
  if (first < 253) {
    return { numberValue: first, bigintValue: BigInt(first), bytes: 1 };
  } else if (first === 253) {
    const val = readUInt16$1(buffer2, offset + 1, "LE");
    return {
      numberValue: val,
      bigintValue: BigInt(val),
      bytes: 3
    };
  } else if (first === 254) {
    const val = readUInt32$1(buffer2, offset + 1, "LE");
    return {
      numberValue: val,
      bigintValue: BigInt(val),
      bytes: 5
    };
  } else {
    const number2 = readUInt64$1(buffer2, offset + 1, "LE");
    return { numberValue: number2 <= Number.MAX_SAFE_INTEGER ? Number(number2) : null, bigintValue: number2, bytes: 9 };
  }
}
function encodingLength$1(n2) {
  checkUint53OrUint64(n2);
  return n2 < 253 ? 1 : n2 <= 65535 ? 3 : n2 <= 4294967295 ? 5 : 9;
}
var BYTE_TO_HEX = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
var HEX_TO_NIBBLE = (() => {
  const table = new Array(128).fill(-1);
  for (let i2 = 0; i2 < 10; i2++) {
    table[48 + i2] = i2;
  }
  for (let i2 = 0; i2 < 6; i2++) {
    table[65 + i2] = 10 + i2;
    table[97 + i2] = 10 + i2;
  }
  return table;
})();
function toHex$1(bytes) {
  let result = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    const hex = BYTE_TO_HEX[bytes[i2]];
    result += hex;
  }
  return result;
}
function fromHex$1(hex) {
  if (hex.length >= 2 && hex[0] === "0" && (hex[1] === "x" || hex[1] === "X")) {
    hex = hex.slice(2);
  }
  const len = hex.length;
  if (len % 2 !== 0) {
    throw new TypeError("Invalid hex string: odd length");
  }
  const byteLength2 = len / 2;
  const result = new Uint8Array(byteLength2);
  for (let i2 = 0; i2 < byteLength2; i2++) {
    const charIndex = i2 * 2;
    const highCode = hex.charCodeAt(charIndex);
    const lowCode = hex.charCodeAt(charIndex + 1);
    if (highCode >= 128 || lowCode >= 128) {
      throw new TypeError(`Invalid hex character at position ${charIndex}`);
    }
    const high = HEX_TO_NIBBLE[highCode];
    const low = HEX_TO_NIBBLE[lowCode];
    if (high === -1) {
      throw new TypeError(`Invalid hex character at position ${charIndex}`);
    }
    if (low === -1) {
      throw new TypeError(`Invalid hex character at position ${charIndex + 1}`);
    }
    result[i2] = high << 4 | low;
  }
  return result;
}
var _data, _view, _offset, _a;
var BinaryReader$1 = (_a = class {
  /**
   * Creates a new BinaryReader.
   *
   * @param data - The byte array to read from
   * @param offset - Initial read position (default 0)
   *
   * @example
   * ```typescript
   * import { BinaryReader, fromHex } from '@btc-vision/bitcoin';
   *
   * const data = fromHex('01020304');
   * const reader = new BinaryReader(data);
   * ```
   */
  constructor(data, offset = 0) {
    /**
     * The underlying byte array.
     */
    __privateAdd(this, _data);
    /**
     * Single DataView instance reused for all reads.
     */
    __privateAdd(this, _view);
    /**
     * Current read position.
     */
    __privateAdd(this, _offset);
    __privateSet(this, _data, data);
    __privateSet(this, _view, new DataView(data.buffer, data.byteOffset, data.byteLength));
    __privateSet(this, _offset, offset);
  }
  /**
   * Current read position in the buffer.
   */
  get offset() {
    return __privateGet(this, _offset);
  }
  /**
   * Sets the read position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative or beyond buffer length
   */
  set offset(value) {
    if (value < 0 || value > __privateGet(this, _data).length) {
      throw new RangeError(`Offset ${value} is out of bounds [0, ${__privateGet(this, _data).length}]`);
    }
    __privateSet(this, _offset, value);
  }
  /**
   * Total length of the underlying buffer.
   */
  get length() {
    return __privateGet(this, _data).length;
  }
  /**
   * Number of bytes remaining to be read.
   */
  get remaining() {
    return __privateGet(this, _data).length - __privateGet(this, _offset);
  }
  /**
   * The underlying data buffer.
   */
  get data() {
    return __privateGet(this, _data);
  }
  /**
   * Creates a BinaryReader from a hex string.
   *
   * @param hex - Hex string (with or without 0x prefix)
   * @returns A new BinaryReader instance
   *
   * @example
   * ```typescript
   * import { BinaryReader } from '@btc-vision/bitcoin';
   *
   * const reader = BinaryReader.fromHex('01000000');
   * const version = reader.readInt32LE(); // 1
   * ```
   */
  static fromHex(hex) {
    return new _a(fromHex$1(hex));
  }
  /**
   * Reads an 8-bit unsigned integer.
   *
   * @returns The value (0-255)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('ff');
   * reader.readUInt8(); // 255
   * ```
   */
  readUInt8() {
    if (__privateGet(this, _offset) >= __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    return __privateGet(this, _data)[__privateWrapper(this, _offset)._++];
  }
  /**
   * Reads an 8-bit signed integer.
   *
   * @returns The value (-128 to 127)
   * @throws RangeError if reading past end of buffer
   */
  readInt8() {
    const value = this.readUInt8();
    return value > 127 ? value - 256 : value;
  }
  /**
   * Reads a 16-bit unsigned integer in little-endian format.
   *
   * @returns The value (0-65535)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('0100'); // 1 in LE
   * reader.readUInt16LE(); // 1
   * ```
   */
  readUInt16LE() {
    if (__privateGet(this, _offset) + 2 > __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    const value = __privateGet(this, _view).getUint16(__privateGet(this, _offset), true);
    __privateSet(this, _offset, __privateGet(this, _offset) + 2);
    return value;
  }
  /**
   * Reads a 16-bit signed integer in little-endian format.
   *
   * @returns The value (-32768 to 32767)
   * @throws RangeError if reading past end of buffer
   */
  readInt16LE() {
    if (__privateGet(this, _offset) + 2 > __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    const value = __privateGet(this, _view).getInt16(__privateGet(this, _offset), true);
    __privateSet(this, _offset, __privateGet(this, _offset) + 2);
    return value;
  }
  /**
   * Reads a 32-bit unsigned integer in little-endian format.
   *
   * @returns The value (0 to 4294967295)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('01000000'); // 1 in LE
   * reader.readUInt32LE(); // 1
   * ```
   */
  readUInt32LE() {
    if (__privateGet(this, _offset) + 4 > __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    const value = __privateGet(this, _view).getUint32(__privateGet(this, _offset), true);
    __privateSet(this, _offset, __privateGet(this, _offset) + 4);
    return value;
  }
  /**
   * Reads a 32-bit signed integer in little-endian format.
   *
   * @returns The value (-2147483648 to 2147483647)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('ffffffff'); // -1 in LE signed
   * reader.readInt32LE(); // -1
   * ```
   */
  readInt32LE() {
    if (__privateGet(this, _offset) + 4 > __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    const value = __privateGet(this, _view).getInt32(__privateGet(this, _offset), true);
    __privateSet(this, _offset, __privateGet(this, _offset) + 4);
    return value;
  }
  /**
   * Reads a 64-bit unsigned integer in little-endian format as bigint.
   *
   * @returns The value as bigint
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('0100000000000000'); // 1 in LE 64-bit
   * reader.readUInt64LE(); // 1n
   * ```
   */
  readUInt64LE() {
    if (__privateGet(this, _offset) + 8 > __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    const value = __privateGet(this, _view).getBigUint64(__privateGet(this, _offset), true);
    __privateSet(this, _offset, __privateGet(this, _offset) + 8);
    return value;
  }
  /**
   * Reads a 64-bit signed integer in little-endian format as bigint.
   *
   * @returns The value as bigint
   * @throws RangeError if reading past end of buffer
   */
  readInt64LE() {
    if (__privateGet(this, _offset) + 8 > __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    const value = __privateGet(this, _view).getBigInt64(__privateGet(this, _offset), true);
    __privateSet(this, _offset, __privateGet(this, _offset) + 8);
    return value;
  }
  /**
   * Reads a specified number of bytes.
   *
   * Returns a subarray view (no copy) for performance.
   * Use readBytesCopy() if you need an independent copy.
   *
   * @param length - Number of bytes to read
   * @returns Uint8Array view into the buffer
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('deadbeefcafebabe');
   * const first4 = reader.readBytes(4); // deadbeef
   * const next4 = reader.readBytes(4); // cafebabe
   * ```
   */
  readBytes(length) {
    if (__privateGet(this, _offset) + length > __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    const value = __privateGet(this, _data).subarray(__privateGet(this, _offset), __privateGet(this, _offset) + length);
    __privateSet(this, _offset, __privateGet(this, _offset) + length);
    return value;
  }
  /**
   * Reads a specified number of bytes as an independent copy.
   *
   * @param length - Number of bytes to read
   * @returns New Uint8Array with copied data
   * @throws RangeError if reading past end of buffer
   */
  readBytesCopy(length) {
    if (__privateGet(this, _offset) + length > __privateGet(this, _data).length) {
      throw new RangeError("Read past end of buffer");
    }
    const value = __privateGet(this, _data).slice(__privateGet(this, _offset), __privateGet(this, _offset) + length);
    __privateSet(this, _offset, __privateGet(this, _offset) + length);
    return value;
  }
  /**
   * Reads a Bitcoin CompactSize variable-length integer.
   *
   * CompactSize encoding:
   * - 0x00-0xFC: 1 byte (value as-is)
   * - 0xFD: 3 bytes (0xFD + 2-byte LE uint16)
   * - 0xFE: 5 bytes (0xFE + 4-byte LE uint32)
   * - 0xFF: 9 bytes (0xFF + 8-byte LE uint64)
   *
   * @returns The decoded integer value
   * @throws RangeError if reading past end of buffer
   * @throws RangeError if value exceeds MAX_SAFE_INTEGER
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('fd0302'); // 515 encoded
   * reader.readVarInt(); // 515
   * ```
   */
  readVarInt() {
    const first = this.readUInt8();
    if (first < 253) {
      return first;
    }
    if (first === 253) {
      return this.readUInt16LE();
    }
    if (first === 254) {
      return this.readUInt32LE();
    }
    const value = this.readUInt64LE();
    if (value > BigInt(Number.MAX_SAFE_INTEGER)) {
      throw new RangeError("VarInt value exceeds MAX_SAFE_INTEGER");
    }
    return Number(value);
  }
  /**
   * Reads a Bitcoin CompactSize variable-length integer as bigint.
   *
   * Use this when you need the full 64-bit range.
   *
   * @returns The decoded integer value as bigint
   * @throws RangeError if reading past end of buffer
   */
  readVarIntBig() {
    const first = this.readUInt8();
    if (first < 253) {
      return BigInt(first);
    }
    if (first === 253) {
      return BigInt(this.readUInt16LE());
    }
    if (first === 254) {
      return BigInt(this.readUInt32LE());
    }
    return this.readUInt64LE();
  }
  /**
   * Reads a length-prefixed byte array (VarInt length + bytes).
   *
   * @returns Uint8Array view into the buffer
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('04deadbeef');
   * reader.readVarBytes(); // Uint8Array [0xde, 0xad, 0xbe, 0xef]
   * ```
   */
  readVarBytes() {
    const length = this.readVarInt();
    return this.readBytes(length);
  }
  /**
   * Reads an array of length-prefixed byte arrays.
   *
   * Format: VarInt count + (VarInt length + bytes) for each item.
   *
   * @returns Array of Uint8Array views
   * @throws RangeError if reading past end of buffer
   */
  readVector() {
    const count = this.readVarInt();
    const result = [];
    for (let i2 = 0; i2 < count; i2++) {
      result.push(this.readVarBytes());
    }
    return result;
  }
  /**
   * Peeks at the next byte without advancing the position.
   *
   * @returns The next byte value, or undefined if at end
   */
  peek() {
    if (__privateGet(this, _offset) >= __privateGet(this, _data).length) {
      return void 0;
    }
    return __privateGet(this, _data)[__privateGet(this, _offset)];
  }
  /**
   * Skips a specified number of bytes.
   *
   * @param length - Number of bytes to skip
   * @throws RangeError if skipping past end of buffer
   */
  skip(length) {
    if (__privateGet(this, _offset) + length > __privateGet(this, _data).length) {
      throw new RangeError("Skip past end of buffer");
    }
    __privateSet(this, _offset, __privateGet(this, _offset) + length);
  }
  /**
   * Resets the read position to the beginning.
   */
  reset() {
    __privateSet(this, _offset, 0);
  }
  /**
   * Checks if there are more bytes to read.
   *
   * @returns True if there are remaining bytes
   */
  hasMore() {
    return __privateGet(this, _offset) < __privateGet(this, _data).length;
  }
}, _data = new WeakMap(), _view = new WeakMap(), _offset = new WeakMap(), _a);
var _data2, _view2, _offset2, _a2;
var BinaryWriter$1 = (_a2 = class {
  constructor(arg, offset = 0) {
    /**
     * The underlying byte array.
     */
    __privateAdd(this, _data2);
    /**
     * Single DataView instance reused for all writes.
     */
    __privateAdd(this, _view2);
    /**
     * Current write position.
     */
    __privateAdd(this, _offset2);
    if (typeof arg === "number") {
      __privateSet(this, _data2, new Uint8Array(arg));
      __privateSet(this, _offset2, 0);
    } else {
      __privateSet(this, _data2, arg);
      __privateSet(this, _offset2, offset);
    }
    __privateSet(this, _view2, new DataView(__privateGet(this, _data2).buffer, __privateGet(this, _data2).byteOffset, __privateGet(this, _data2).byteLength));
  }
  /**
   * Current write position in the buffer.
   */
  get offset() {
    return __privateGet(this, _offset2);
  }
  /**
   * Sets the write position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative or beyond buffer length
   */
  set offset(value) {
    if (value < 0 || value > __privateGet(this, _data2).length) {
      throw new RangeError(`Offset ${value} is out of bounds [0, ${__privateGet(this, _data2).length}]`);
    }
    __privateSet(this, _offset2, value);
  }
  /**
   * Total capacity of the underlying buffer.
   */
  get capacity() {
    return __privateGet(this, _data2).length;
  }
  /**
   * Number of bytes remaining in the buffer.
   */
  get remaining() {
    return __privateGet(this, _data2).length - __privateGet(this, _offset2);
  }
  /**
   * The underlying data buffer.
   */
  get data() {
    return __privateGet(this, _data2);
  }
  /**
   * Creates a BinaryWriter with automatic capacity management.
   *
   * Initial capacity is 256 bytes, grows as needed.
   *
   * @returns A new GrowableBinaryWriter instance
   *
   * @example
   * ```typescript
   * import { BinaryWriter } from '@btc-vision/bitcoin';
   *
   * const writer = BinaryWriter.growable();
   * writer.writeUInt32LE(1);
   * writer.writeBytes(new Uint8Array(1000)); // Automatically grows
   * ```
   */
  static growable(initialCapacity = 256) {
    return new GrowableBinaryWriter(initialCapacity);
  }
  /**
   * Writes an 8-bit unsigned integer.
   *
   * @param value - Value to write (0-255)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt8(255);
   * ```
   */
  writeUInt8(value) {
    if (__privateGet(this, _offset2) >= __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _data2)[__privateWrapper(this, _offset2)._++] = value & 255;
    return this;
  }
  /**
   * Writes an 8-bit signed integer.
   *
   * @param value - Value to write (-128 to 127)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt8(value) {
    return this.writeUInt8(value < 0 ? value + 256 : value);
  }
  /**
   * Writes a 16-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write (0-65535)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt16LE(1); // Writes 01 00
   * ```
   */
  writeUInt16LE(value) {
    if (__privateGet(this, _offset2) + 2 > __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _view2).setUint16(__privateGet(this, _offset2), value, true);
    __privateSet(this, _offset2, __privateGet(this, _offset2) + 2);
    return this;
  }
  /**
   * Writes a 16-bit signed integer in little-endian format.
   *
   * @param value - Value to write (-32768 to 32767)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt16LE(value) {
    if (__privateGet(this, _offset2) + 2 > __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _view2).setInt16(__privateGet(this, _offset2), value, true);
    __privateSet(this, _offset2, __privateGet(this, _offset2) + 2);
    return this;
  }
  /**
   * Writes a 32-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write (0 to 4294967295)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt32LE(1); // Writes 01 00 00 00
   * ```
   */
  writeUInt32LE(value) {
    if (__privateGet(this, _offset2) + 4 > __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _view2).setUint32(__privateGet(this, _offset2), value, true);
    __privateSet(this, _offset2, __privateGet(this, _offset2) + 4);
    return this;
  }
  /**
   * Writes a 32-bit signed integer in little-endian format.
   *
   * @param value - Value to write (-2147483648 to 2147483647)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeInt32LE(-1); // Writes ff ff ff ff
   * ```
   */
  writeInt32LE(value) {
    if (__privateGet(this, _offset2) + 4 > __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _view2).setInt32(__privateGet(this, _offset2), value, true);
    __privateSet(this, _offset2, __privateGet(this, _offset2) + 4);
    return this;
  }
  /**
   * Writes a 64-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt64LE(50000n); // Writes 50 c3 00 00 00 00 00 00
   * ```
   */
  writeUInt64LE(value) {
    if (__privateGet(this, _offset2) + 8 > __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _view2).setBigUint64(__privateGet(this, _offset2), value, true);
    __privateSet(this, _offset2, __privateGet(this, _offset2) + 8);
    return this;
  }
  /**
   * Writes a 64-bit signed integer in little-endian format.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt64LE(value) {
    if (__privateGet(this, _offset2) + 8 > __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _view2).setBigInt64(__privateGet(this, _offset2), value, true);
    __privateSet(this, _offset2, __privateGet(this, _offset2) + 8);
    return this;
  }
  /**
   * Writes raw bytes.
   *
   * @param bytes - Bytes to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeBytes(new Uint8Array([0xde, 0xad, 0xbe, 0xef]));
   * ```
   */
  writeBytes(bytes) {
    if (__privateGet(this, _offset2) + bytes.length > __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _data2).set(bytes, __privateGet(this, _offset2));
    __privateSet(this, _offset2, __privateGet(this, _offset2) + bytes.length);
    return this;
  }
  /**
   * Writes a Bitcoin CompactSize variable-length integer.
   *
   * CompactSize encoding:
   * - 0x00-0xFC: 1 byte (value as-is)
   * - 0xFD-0xFFFF: 3 bytes (0xFD + 2-byte LE uint16)
   * - 0x10000-0xFFFFFFFF: 5 bytes (0xFE + 4-byte LE uint32)
   * - Larger: 9 bytes (0xFF + 8-byte LE uint64)
   *
   * @param value - Value to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeVarInt(252);    // Writes fc
   * writer.writeVarInt(253);    // Writes fd fd 00
   * writer.writeVarInt(65535);  // Writes fd ff ff
   * writer.writeVarInt(65536);  // Writes fe 00 00 01 00
   * ```
   */
  writeVarInt(value) {
    if (value < 253) {
      return this.writeUInt8(value);
    }
    if (value <= 65535) {
      this.writeUInt8(253);
      return this.writeUInt16LE(value);
    }
    if (value <= 4294967295) {
      this.writeUInt8(254);
      return this.writeUInt32LE(value);
    }
    this.writeUInt8(255);
    return this.writeUInt64LE(BigInt(value));
  }
  /**
   * Writes a Bitcoin CompactSize variable-length integer from bigint.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeVarIntBig(value) {
    if (value < 0xfdn) {
      return this.writeUInt8(Number(value));
    }
    if (value <= 0xffffn) {
      this.writeUInt8(253);
      return this.writeUInt16LE(Number(value));
    }
    if (value <= 0xffffffffn) {
      this.writeUInt8(254);
      return this.writeUInt32LE(Number(value));
    }
    this.writeUInt8(255);
    return this.writeUInt64LE(value);
  }
  /**
   * Writes a length-prefixed byte array (VarInt length + bytes).
   *
   * @param bytes - Bytes to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeVarBytes(new Uint8Array([0xde, 0xad])); // Writes 02 de ad
   * ```
   */
  writeVarBytes(bytes) {
    this.writeVarInt(bytes.length);
    return this.writeBytes(bytes);
  }
  /**
   * Writes an array of length-prefixed byte arrays.
   *
   * Format: VarInt count + (VarInt length + bytes) for each item.
   *
   * @param vector - Array of byte arrays to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeVector(vector) {
    this.writeVarInt(vector.length);
    for (const item of vector) {
      this.writeVarBytes(item);
    }
    return this;
  }
  /**
   * Fills a region with a specific byte value.
   *
   * @param value - Byte value to fill with
   * @param length - Number of bytes to fill
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  fill(value, length) {
    if (__privateGet(this, _offset2) + length > __privateGet(this, _data2).length) {
      throw new RangeError("Write past end of buffer");
    }
    __privateGet(this, _data2).fill(value, __privateGet(this, _offset2), __privateGet(this, _offset2) + length);
    __privateSet(this, _offset2, __privateGet(this, _offset2) + length);
    return this;
  }
  /**
   * Skips a specified number of bytes (leaves them unchanged).
   *
   * @param length - Number of bytes to skip
   * @returns This writer for chaining
   * @throws RangeError if skipping past end of buffer
   */
  skip(length) {
    if (__privateGet(this, _offset2) + length > __privateGet(this, _data2).length) {
      throw new RangeError("Skip past end of buffer");
    }
    __privateSet(this, _offset2, __privateGet(this, _offset2) + length);
    return this;
  }
  /**
   * Resets the write position to the beginning.
   *
   * @returns This writer for chaining
   */
  reset() {
    __privateSet(this, _offset2, 0);
    return this;
  }
  /**
   * Verifies the buffer was fully written and returns it.
   *
   * Unlike {@link finish}, this method throws if the writer has not
   * written exactly to the end of the buffer.
   *
   * @returns The underlying buffer
   * @throws Error if the buffer was not fully written
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(8);
   * writer.writeUInt32LE(1);
   * writer.writeUInt32LE(2);
   * const bytes = writer.end(); // OK: wrote exactly 8 bytes
   *
   * const writer2 = new BinaryWriter(8);
   * writer2.writeUInt32LE(1);
   * writer2.end(); // throws: buffer size 8, offset 4
   * ```
   */
  end() {
    if (__privateGet(this, _offset2) === __privateGet(this, _data2).length) {
      return __privateGet(this, _data2);
    }
    throw new Error(`buffer size ${__privateGet(this, _data2).length}, offset ${__privateGet(this, _offset2)}`);
  }
  /**
   * Returns the written portion of the buffer.
   *
   * If the entire buffer was written, returns the buffer directly (no copy).
   * Otherwise, returns a subarray view.
   *
   * @returns Uint8Array containing the written data
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(100);
   * writer.writeUInt32LE(42);
   * const bytes = writer.finish(); // 4 bytes
   * ```
   */
  finish() {
    return __privateGet(this, _offset2) === __privateGet(this, _data2).length ? __privateGet(this, _data2) : __privateGet(this, _data2).subarray(0, __privateGet(this, _offset2));
  }
  /**
   * Returns the written portion as a hex string.
   *
   * @returns Hex string representation
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(4);
   * writer.writeUInt32LE(1);
   * writer.toHex(); // '01000000'
   * ```
   */
  toHex() {
    return toHex$1(this.finish());
  }
}, _data2 = new WeakMap(), _view2 = new WeakMap(), _offset2 = new WeakMap(), _a2);
var _data3, _view3, _offset3, _GrowableBinaryWriter_instances, ensureCapacity_fn;
var GrowableBinaryWriter = class {
  /**
   * Creates a new GrowableBinaryWriter.
   *
   * @param initialCapacity - Initial buffer size (default 256)
   */
  constructor(initialCapacity = 256) {
    __privateAdd(this, _GrowableBinaryWriter_instances);
    __privateAdd(this, _data3);
    __privateAdd(this, _view3);
    __privateAdd(this, _offset3, 0);
    __privateSet(this, _data3, new Uint8Array(initialCapacity));
    __privateSet(this, _view3, new DataView(__privateGet(this, _data3).buffer));
  }
  /**
   * Current write position.
   */
  get offset() {
    return __privateGet(this, _offset3);
  }
  /**
   * Sets the write position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative
   */
  set offset(value) {
    if (value < 0) {
      throw new RangeError(`Offset ${value} cannot be negative`);
    }
    __privateSet(this, _offset3, value);
  }
  /**
   * Current buffer capacity.
   */
  get capacity() {
    return __privateGet(this, _data3).length;
  }
  writeUInt8(value) {
    __privateMethod(this, _GrowableBinaryWriter_instances, ensureCapacity_fn).call(this, 1);
    __privateGet(this, _data3)[__privateWrapper(this, _offset3)._++] = value & 255;
    return this;
  }
  writeUInt16LE(value) {
    __privateMethod(this, _GrowableBinaryWriter_instances, ensureCapacity_fn).call(this, 2);
    __privateGet(this, _view3).setUint16(__privateGet(this, _offset3), value, true);
    __privateSet(this, _offset3, __privateGet(this, _offset3) + 2);
    return this;
  }
  writeUInt32LE(value) {
    __privateMethod(this, _GrowableBinaryWriter_instances, ensureCapacity_fn).call(this, 4);
    __privateGet(this, _view3).setUint32(__privateGet(this, _offset3), value, true);
    __privateSet(this, _offset3, __privateGet(this, _offset3) + 4);
    return this;
  }
  writeInt32LE(value) {
    __privateMethod(this, _GrowableBinaryWriter_instances, ensureCapacity_fn).call(this, 4);
    __privateGet(this, _view3).setInt32(__privateGet(this, _offset3), value, true);
    __privateSet(this, _offset3, __privateGet(this, _offset3) + 4);
    return this;
  }
  writeUInt64LE(value) {
    __privateMethod(this, _GrowableBinaryWriter_instances, ensureCapacity_fn).call(this, 8);
    __privateGet(this, _view3).setBigUint64(__privateGet(this, _offset3), value, true);
    __privateSet(this, _offset3, __privateGet(this, _offset3) + 8);
    return this;
  }
  writeBytes(bytes) {
    __privateMethod(this, _GrowableBinaryWriter_instances, ensureCapacity_fn).call(this, bytes.length);
    __privateGet(this, _data3).set(bytes, __privateGet(this, _offset3));
    __privateSet(this, _offset3, __privateGet(this, _offset3) + bytes.length);
    return this;
  }
  writeVarInt(value) {
    if (value < 253) {
      return this.writeUInt8(value);
    }
    if (value <= 65535) {
      this.writeUInt8(253);
      return this.writeUInt16LE(value);
    }
    if (value <= 4294967295) {
      this.writeUInt8(254);
      return this.writeUInt32LE(value);
    }
    this.writeUInt8(255);
    return this.writeUInt64LE(BigInt(value));
  }
  writeVarBytes(bytes) {
    this.writeVarInt(bytes.length);
    return this.writeBytes(bytes);
  }
  writeVector(vector) {
    this.writeVarInt(vector.length);
    for (const item of vector) {
      this.writeVarBytes(item);
    }
    return this;
  }
  /**
   * Returns the written data as a new Uint8Array.
   *
   * @returns Copy of the written data
   */
  finish() {
    return __privateGet(this, _data3).slice(0, __privateGet(this, _offset3));
  }
  /**
   * Returns the written data as a hex string.
   *
   * @returns Hex string representation
   */
  toHex() {
    return toHex$1(this.finish());
  }
};
_data3 = new WeakMap();
_view3 = new WeakMap();
_offset3 = new WeakMap();
_GrowableBinaryWriter_instances = new WeakSet();
/**
 * Ensures the buffer has enough space for additional bytes.
 *
 * @param additionalBytes - Number of additional bytes needed
 */
ensureCapacity_fn = function(additionalBytes) {
  const required = __privateGet(this, _offset3) + additionalBytes;
  if (required <= __privateGet(this, _data3).length) {
    return;
  }
  let newCapacity = __privateGet(this, _data3).length * 2;
  while (newCapacity < required) {
    newCapacity *= 2;
  }
  const newData = new Uint8Array(newCapacity);
  newData.set(__privateGet(this, _data3).subarray(0, __privateGet(this, _offset3)));
  __privateSet(this, _data3, newData);
  __privateSet(this, _view3, new DataView(__privateGet(this, _data3).buffer));
};
function fromBase64$1(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i2 = 0; i2 < binaryString.length; i2++) {
    bytes[i2] = binaryString.charCodeAt(i2);
  }
  return bytes;
}
function toBase64$1(bytes) {
  let binaryString = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    binaryString += String.fromCharCode(bytes[i2]);
  }
  return btoa(binaryString);
}
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i2 = 0; i2 < ALPHABET2.length; i2++) {
    const x = ALPHABET2.charAt(i2);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  const BASE2 = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE2) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode2(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i2 = 0;
      for (let it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe2(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i2 = 0;
      for (let it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i2;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string) {
    const buffer2 = decodeUnsafe2(string);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE2 + " character");
  }
  return {
    encode: encode2,
    decodeUnsafe: decodeUnsafe2,
    decode: decode2
  };
}
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var base58 = base(ALPHABET);
function bs58checkBase(checksumFn) {
  function encode2(payload) {
    const checksum = checksumFn(payload);
    const length = payload.length + 4;
    const both = new Uint8Array(length);
    both.set(payload, 0);
    both.set(checksum.subarray(0, 4), payload.length);
    return base58.encode(both);
  }
  function decodeRaw2(buffer2) {
    const payload = buffer2.slice(0, -4);
    const checksum = buffer2.slice(-4);
    const newChecksum = checksumFn(payload);
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) {
      return void 0;
    }
    return payload;
  }
  function decodeUnsafe2(str) {
    const buffer2 = base58.decodeUnsafe(str);
    if (buffer2 === void 0)
      return void 0;
    return decodeRaw2(buffer2);
  }
  function decode2(str) {
    const buffer2 = base58.decode(str);
    const payload = decodeRaw2(buffer2);
    if (payload === void 0)
      throw new Error("Invalid checksum");
    return payload;
  }
  return {
    encode: encode2,
    decode: decode2,
    decodeUnsafe: decodeUnsafe2
  };
}
function sha256x2(payload) {
  return sha256$1(sha256$1(payload));
}
var { encode: encode$j, decode: decode$i, decodeUnsafe } = bs58checkBase(sha256x2);
var bs58check = { encode: encode$j, decode: decode$i, decodeUnsafe };
var build$1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  bs58checkBase,
  decode: decode$i,
  decodeUnsafe,
  default: bs58check,
  encode: encode$j
}, Symbol.toStringTag, { value: "Module" }));
function concat$1(arrays) {
  let totalLength = 0;
  for (const arr of arrays) {
    totalLength += arr.length;
  }
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function equals(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i2 = 0; i2 < a.length; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
function compare$2(a, b) {
  const minLength = Math.min(a.length, b.length);
  for (let i2 = 0; i2 < minLength; i2++) {
    const diff = a[i2] - b[i2];
    if (diff !== 0) {
      return diff;
    }
  }
  return a.length - b.length;
}
function isZero(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2++) {
    if (bytes[i2] !== 0) {
      return false;
    }
  }
  return true;
}
function clone$1(bytes) {
  const copy = new Uint8Array(bytes.length);
  copy.set(bytes);
  return copy;
}
function reverse(bytes) {
  bytes.reverse();
  return bytes;
}
function alloc(size, fill = 0) {
  const result = new Uint8Array(size);
  if (fill !== 0) {
    result.fill(fill);
  }
  return result;
}
function fromUtf8$1(str) {
  return new TextEncoder().encode(str);
}
function check$d(buffer2) {
  if (buffer2.length < 8)
    return false;
  if (buffer2.length > 72)
    return false;
  if (buffer2[0] !== 48)
    return false;
  if (buffer2[1] !== buffer2.length - 2)
    return false;
  if (buffer2[2] !== 2)
    return false;
  const lenR = buffer2[3];
  if (lenR === 0)
    return false;
  if (5 + lenR >= buffer2.length)
    return false;
  if (buffer2[4 + lenR] !== 2)
    return false;
  const lenS = buffer2[5 + lenR];
  if (lenS === 0)
    return false;
  if (6 + lenR + lenS !== buffer2.length)
    return false;
  if (buffer2[4] & 128)
    return false;
  if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128))
    return false;
  if (buffer2[lenR + 6] & 128)
    return false;
  if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
    return false;
  return true;
}
function decode$h(buffer2) {
  if (buffer2.length < 8)
    throw new Error("DER sequence length is too short");
  if (buffer2.length > 72)
    throw new Error("DER sequence length is too long");
  if (buffer2[0] !== 48)
    throw new Error("Expected DER sequence");
  if (buffer2[1] !== buffer2.length - 2)
    throw new Error("DER sequence length is invalid");
  if (buffer2[2] !== 2)
    throw new Error("Expected DER integer");
  const lenR = buffer2[3];
  if (lenR === 0)
    throw new Error("R length is zero");
  if (5 + lenR >= buffer2.length)
    throw new Error("R length is too long");
  if (buffer2[4 + lenR] !== 2)
    throw new Error("Expected DER integer (2)");
  const lenS = buffer2[5 + lenR];
  if (lenS === 0)
    throw new Error("S length is zero");
  if (6 + lenR + lenS !== buffer2.length)
    throw new Error("S length is invalid");
  if (buffer2[4] & 128)
    throw new Error("R value is negative");
  if (lenR > 1 && buffer2[4] === 0 && !(buffer2[5] & 128))
    throw new Error("R value excessively padded");
  if (buffer2[lenR + 6] & 128)
    throw new Error("S value is negative");
  if (lenS > 1 && buffer2[lenR + 6] === 0 && !(buffer2[lenR + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: buffer2.subarray(4, 4 + lenR),
    s: buffer2.subarray(6 + lenR)
  };
}
function encode$i(r2, s) {
  const lenR = r2.length;
  const lenS = s.length;
  if (lenR === 0)
    throw new Error("R length is zero");
  if (lenS === 0)
    throw new Error("S length is zero");
  if (lenR > 33)
    throw new Error("R length is too long");
  if (lenS > 33)
    throw new Error("S length is too long");
  if (r2[0] & 128)
    throw new Error("R value is negative");
  if (s[0] & 128)
    throw new Error("S value is negative");
  if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128))
    throw new Error("R value excessively padded");
  if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
    throw new Error("S value excessively padded");
  const signature2 = alloc(6 + lenR + lenS);
  signature2[0] = 48;
  signature2[1] = signature2.length - 2;
  signature2[2] = 2;
  signature2[3] = r2.length;
  signature2.set(r2, 4);
  signature2[4 + lenR] = 2;
  signature2[5 + lenR] = s.length;
  signature2.set(s, 6 + lenR);
  return signature2;
}
var opcodes = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
var _reverseOps;
function getReverseOps() {
  if (!_reverseOps) {
    _reverseOps = {};
    for (const op of Object.keys(opcodes)) {
      const code2 = opcodes[op];
      _reverseOps[code2] = op;
    }
  }
  return _reverseOps;
}
getReverseOps();
function encodingLength(i2) {
  return i2 < opcodes.OP_PUSHDATA1 ? 1 : i2 <= 255 ? 2 : i2 <= 65535 ? 3 : 5;
}
function encode$h(buffer2, num, offset) {
  const size = encodingLength(num);
  const view = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
  if (size === 1) {
    buffer2[offset] = num;
  } else if (size === 2) {
    buffer2[offset] = opcodes.OP_PUSHDATA1;
    buffer2[offset + 1] = num;
  } else if (size === 3) {
    buffer2[offset] = opcodes.OP_PUSHDATA2;
    view.setUint16(offset + 1, num, true);
  } else {
    buffer2[offset] = opcodes.OP_PUSHDATA4;
    view.setUint32(offset + 1, num, true);
  }
  return size;
}
function decode$g(buffer2, offset) {
  const view = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
  const opcode = buffer2[offset];
  let num;
  let size;
  if (opcode < opcodes.OP_PUSHDATA1) {
    num = opcode;
    size = 1;
  } else if (opcode === opcodes.OP_PUSHDATA1) {
    if (offset + 2 > buffer2.length)
      return null;
    num = buffer2[offset + 1];
    size = 2;
  } else if (opcode === opcodes.OP_PUSHDATA2) {
    if (offset + 3 > buffer2.length)
      return null;
    num = view.getUint16(offset + 1, true);
    size = 3;
  } else {
    if (offset + 5 > buffer2.length)
      return null;
    if (opcode !== opcodes.OP_PUSHDATA4)
      throw new Error("Unexpected opcode");
    num = view.getUint32(offset + 1, true);
    size = 5;
  }
  return {
    opcode,
    number: num,
    size
  };
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (i2 = 0, len = code.length; i2 < len; ++i2) {
  lookup[i2] = code[i2];
  revLookup[code.charCodeAt(i2)] = i2;
}
var i2;
var len;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
ieee754.read = function(buffer2, offset, isLE2, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE2 ? nBytes - 1 : 0;
  var d = isLE2 ? -1 : 1;
  var s = buffer2[offset + i2];
  i2 += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE2, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE2 ? 0 : nBytes - 1;
  var d = isLE2 ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt2 / c;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d] |= s * 128;
};
(function(exports$1) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer2;
  exports$1.SlowBuffer = SlowBuffer2;
  exports$1.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto2 = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto2, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto2);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc2(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc2(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString2(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer2(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare3(a, b) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, GlobalUint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
      if (a[i2] !== b[i2]) {
        x = a[i2];
        y = b[i2];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n2, m) {
    const i2 = b[n2];
    b[n2] = b[m];
    b[m] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals3(b) {
    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2];
        y = targetCopy[i2];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i22) {
      if (indexSize === 1) {
        return buf[i22];
      } else {
        return buf.readUInt16BE(i22 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1) foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i2 + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      const parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed)) return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt82(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt82(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage2, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage2.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n2 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i2);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length) {
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length) break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = (function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i2] + alphabet[j];
      }
    }
    return table;
  })();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
var Buffer = buffer.Buffer;
function decode$f(buffer2, maxLength, minimal) {
  maxLength = maxLength || 4;
  minimal = minimal === void 0 ? true : minimal;
  const length = buffer2.length;
  if (length === 0)
    return 0;
  if (length > maxLength)
    throw new TypeError("Script number overflow");
  if (minimal) {
    if ((buffer2[length - 1] & 127) === 0) {
      if (length <= 1 || (buffer2[length - 2] & 128) === 0)
        throw new Error("Non-minimally encoded script number");
    }
  }
  if (length === 5) {
    const a = buffer2.readUInt32LE(0);
    const b = buffer2.readUInt8(4);
    if (b & 128)
      return -((b & -129) * 4294967296 + a);
    return b * 4294967296 + a;
  }
  let result = 0;
  for (let i2 = 0; i2 < length; ++i2) {
    result |= buffer2[i2] << 8 * i2;
  }
  if (buffer2[length - 1] & 128)
    return -(result & ~(128 << 8 * (length - 1)));
  return result;
}
function scriptNumSize(i2) {
  return i2 > 2147483647 ? 5 : i2 > 8388607 ? 4 : i2 > 32767 ? 3 : i2 > 127 ? 2 : i2 > 0 ? 1 : 0;
}
function encode$g(_number) {
  let value = Math.abs(_number);
  const size = scriptNumSize(value);
  const buffer2 = Buffer.allocUnsafe(size);
  const negative = _number < 0;
  for (let i2 = 0; i2 < size; ++i2) {
    buffer2.writeUInt8(value & 255, i2);
    value >>= 8;
  }
  if (buffer2[size - 1] & 128) {
    buffer2.writeUInt8(negative ? 128 : 0, size - 1);
  } else if (negative) {
    buffer2[size - 1] = buffer2[size - 1] | 128;
  }
  return buffer2;
}
var scriptNumber = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: decode$f,
  encode: encode$g
}, Symbol.toStringTag, { value: "Module" }));
var EC_P = fromHex$1("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
fromHex$1("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var SATOSHI_MAX = 21n * 10n ** 14n;
var TAPLEAF_VERSION_MASK = 254;
function isUInt8(value) {
  return typeof value === "number" && Number.isInteger(value) && value >= 0 && value <= 255;
}
function isNumber(value) {
  return typeof value === "number" && Number.isFinite(value);
}
function isUint8ArrayN(value, n2) {
  return value instanceof Uint8Array && value.length === n2;
}
function isArray(value) {
  return Array.isArray(value);
}
function isHex(value) {
  if (typeof value !== "string")
    return false;
  if (value.length % 2 !== 0)
    return false;
  return /^[0-9a-fA-F]*$/.test(value);
}
function isBytes32(value) {
  return value instanceof Uint8Array && value.length === 32;
}
function isBytes20(value) {
  return value instanceof Uint8Array && value.length === 20;
}
function isXOnlyPublicKey(value) {
  if (!(value instanceof Uint8Array) || value.length !== 32)
    return false;
  if (isZero(value))
    return false;
  return compare$2(value, EC_P) < 0;
}
function isPoint(value) {
  if (!(value instanceof Uint8Array))
    return false;
  if (value.length < 33)
    return false;
  const prefix = value[0];
  const x = value.subarray(1, 33);
  if (isZero(x))
    return false;
  if (compare$2(x, EC_P) >= 0)
    return false;
  if ((prefix === 2 || prefix === 3) && value.length === 33) {
    return true;
  }
  if (value.length !== 65)
    return false;
  const y = value.subarray(33);
  if (isZero(y))
    return false;
  if (compare$2(y, EC_P) >= 0)
    return false;
  return prefix === 4 || prefix === 6 || prefix === 7;
}
function isTapleaf(value) {
  if (!value || typeof value !== "object")
    return false;
  const obj = value;
  if (!("output" in obj))
    return false;
  if (!(obj["output"] instanceof Uint8Array))
    return false;
  if (obj["version"] !== void 0) {
    if (typeof obj["version"] !== "number")
      return false;
    if ((obj["version"] & TAPLEAF_VERSION_MASK) !== obj["version"])
      return false;
  }
  return true;
}
function stacksEqual(a, b) {
  if (a.length !== b.length)
    return false;
  return a.every((x, i2) => equals(x, b[i2]));
}
function toBytes32(value) {
  if (!isBytes32(value)) {
    throw new TypeError(`Expected 32-byte Uint8Array, got ${value.length} bytes`);
  }
  return value;
}
function isMessageHash(value) {
  return value instanceof Uint8Array && value.length === 32;
}
function toMessageHash(value) {
  if (!isMessageHash(value)) {
    throw new TypeError(`Expected 32-byte Uint8Array, got ${value.length} bytes`);
  }
  return value;
}
function toBytes20(value) {
  if (!isBytes20(value)) {
    throw new TypeError(`Expected 20-byte Uint8Array, got ${value.length} bytes`);
  }
  return value;
}
function toSatoshi(value) {
  if (value < 0n) {
    throw new RangeError(`Satoshi cannot be negative, got ${value}`);
  }
  if (value > SATOSHI_MAX) {
    throw new RangeError(`Satoshi exceeds maximum supply (${SATOSHI_MAX}), got ${value}`);
  }
  return value;
}
var ZERO$2 = new Uint8Array([0]);
function isDefinedHashType(hashType) {
  const hashTypeMod = hashType & -129;
  return hashTypeMod > 0 && hashTypeMod < 4;
}
function toDER(x) {
  let i2 = 0;
  while (x[i2] === 0)
    ++i2;
  if (i2 === x.length)
    return ZERO$2;
  x = x.subarray(i2);
  if (x[0] & 128)
    return concat$1([ZERO$2, x]);
  return x;
}
function fromDER(x) {
  if (x[0] === 0)
    x = x.subarray(1);
  const buffer2 = alloc(32);
  const bstart = Math.max(0, 32 - x.length);
  buffer2.set(x, bstart);
  return buffer2;
}
function decode$e(buffer2) {
  const hashType = buffer2[buffer2.length - 1];
  if (!isDefinedHashType(hashType)) {
    throw new Error(`Invalid hashType ${hashType}`);
  }
  const decoded = decode$h(buffer2.subarray(0, -1));
  const r2 = fromDER(decoded.r);
  const s = fromDER(decoded.s);
  const signature2 = concat$1([r2, s]);
  return { signature: signature2, hashType };
}
function encode$f(signature2, hashType) {
  if (!isUint8ArrayN(signature2, 64)) {
    throw new TypeError("Expected signature to be a 64-byte Uint8Array");
  }
  if (!isUInt8(hashType)) {
    throw new TypeError("Expected hashType to be a UInt8");
  }
  if (!isDefinedHashType(hashType)) {
    throw new Error(`Invalid hashType ${hashType}`);
  }
  const hashTypeBuffer = new Uint8Array([hashType]);
  const r2 = toDER(signature2.subarray(0, 32));
  const s = toDER(signature2.subarray(32, 64));
  return concat$1([encode$i(r2, s), hashTypeBuffer]);
}
var scriptSignature = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: decode$e,
  encode: encode$f,
  isDefinedHashType
}, Symbol.toStringTag, { value: "Module" }));
var OP_INT_BASE$1 = opcodes.OP_RESERVED;
function isOPInt(value) {
  return isNumber(value) && (value === opcodes.OP_0 || value >= opcodes.OP_1 && value <= opcodes.OP_16 || value === opcodes.OP_1NEGATE);
}
function isPushOnlyChunk(value) {
  if (value instanceof Uint8Array)
    return true;
  return isOPInt(value);
}
function isPushOnly(value) {
  return isArray(value) && value.every(isPushOnlyChunk);
}
function countNonPushOnlyOPs(value) {
  return value.length - value.filter(isPushOnlyChunk).length;
}
function asMinimalOP(buffer2) {
  if (buffer2.length === 0)
    return opcodes.OP_0;
  if (buffer2.length !== 1)
    return void 0;
  const firstByte = buffer2[0];
  if (firstByte >= 1 && firstByte <= 16)
    return OP_INT_BASE$1 + firstByte;
  if (firstByte === 129)
    return opcodes.OP_1NEGATE;
  return void 0;
}
function chunksIsUint8Array(buf) {
  return buf instanceof Uint8Array;
}
function chunksIsArray(buf) {
  return isArray(buf);
}
function singleChunkIsUint8Array(buf) {
  return buf instanceof Uint8Array;
}
function compile(chunks) {
  if (chunksIsUint8Array(chunks))
    return chunks;
  if (!isArray(chunks)) {
    throw new TypeError("Expected an array");
  }
  const bufferSize = chunks.reduce((accum, chunk) => {
    if (singleChunkIsUint8Array(chunk)) {
      if (chunk.length === 1 && asMinimalOP(chunk) !== void 0) {
        return accum + 1;
      }
      return accum + encodingLength(chunk.length) + chunk.length;
    }
    return accum + 1;
  }, 0);
  const buffer2 = new Uint8Array(bufferSize);
  let offset = 0;
  chunks.forEach((chunk) => {
    if (singleChunkIsUint8Array(chunk)) {
      const opcode = asMinimalOP(chunk);
      if (opcode !== void 0) {
        buffer2[offset] = opcode;
        offset += 1;
        return;
      }
      offset += encode$h(buffer2, chunk.length, offset);
      buffer2.set(chunk, offset);
      offset += chunk.length;
    } else {
      buffer2[offset] = chunk;
      offset += 1;
    }
  });
  if (offset !== buffer2.length)
    throw new Error("Could not decode chunks");
  return buffer2;
}
function decompile(buffer2) {
  if (chunksIsArray(buffer2))
    return buffer2;
  if (!(buffer2 instanceof Uint8Array)) {
    throw new TypeError("Expected a Uint8Array");
  }
  const chunks = [];
  let i2 = 0;
  while (i2 < buffer2.length) {
    const opcode = buffer2[i2];
    if (opcode > opcodes.OP_0 && opcode <= opcodes.OP_PUSHDATA4) {
      const d = decode$g(buffer2, i2);
      if (d === null)
        return null;
      i2 += d.size;
      if (i2 + d.number > buffer2.length)
        return null;
      const data = buffer2.subarray(i2, i2 + d.number);
      i2 += d.number;
      const op = asMinimalOP(data);
      if (op !== void 0) {
        chunks.push(op);
      } else {
        chunks.push(data);
      }
    } else {
      chunks.push(opcode);
      i2 += 1;
    }
  }
  return chunks;
}
function toASM(chunks) {
  let resolved;
  if (chunksIsUint8Array(chunks)) {
    const decompiled = decompile(chunks);
    if (!decompiled) {
      throw new Error("Could not convert invalid chunks to ASM");
    }
    resolved = decompiled;
  } else {
    resolved = chunks;
  }
  return resolved.map((chunk) => {
    if (singleChunkIsUint8Array(chunk)) {
      const op = asMinimalOP(chunk);
      if (op === void 0)
        return toHex$1(chunk);
      chunk = op;
    }
    return getReverseOps()[chunk];
  }).join(" ");
}
function fromASM(asm) {
  if (typeof asm !== "string") {
    throw new TypeError("Expected a string");
  }
  return compile(asm.split(" ").map((chunkStr) => {
    if (opcodes[chunkStr] !== void 0) {
      return opcodes[chunkStr];
    }
    if (!isHex(chunkStr)) {
      throw new TypeError("Expected hex string");
    }
    return fromHex$1(chunkStr);
  }));
}
function toStack(chunks) {
  const resolved = chunksIsUint8Array(chunks) ? decompile(chunks) : chunks;
  if (!resolved || !isPushOnly(resolved)) {
    throw new TypeError("Expected push-only script");
  }
  return resolved.map((op) => {
    if (singleChunkIsUint8Array(op))
      return op;
    if (op === opcodes.OP_0)
      return alloc(0);
    return encode$g(op - OP_INT_BASE$1);
  });
}
function isCanonicalPubKey(buffer2) {
  return isPoint(buffer2);
}
function isCanonicalScriptSignature(buffer2) {
  if (!(buffer2 instanceof Uint8Array))
    return false;
  if (!isDefinedHashType(buffer2[buffer2.length - 1]))
    return false;
  return check$d(buffer2.subarray(0, -1));
}
var number = scriptNumber;
var signature = scriptSignature;
var script = Object.freeze(Object.defineProperty({
  __proto__: null,
  compile,
  countNonPushOnlyOPs,
  decompile,
  fromASM,
  isCanonicalPubKey,
  isCanonicalScriptSignature,
  isPushOnly,
  number,
  opcodes,
  signature,
  toASM,
  toStack
}, Symbol.toStringTag, { value: "Module" }));
var PaymentType = {
  P2PK: "p2pk",
  P2PKH: "p2pkh",
  P2SH: "p2sh",
  P2MS: "p2ms",
  P2WPKH: "p2wpkh",
  P2WSH: "p2wsh",
  P2TR: "p2tr",
  P2MR: "p2mr",
  P2OP: "p2op",
  Embed: "embed",
  ScriptRedeem: "scriptRedeem"
};
var OPS$9 = opcodes;
var P2OP_WITNESS_VERSION = 16;
var MIN_SIZE = 2;
var MAX_SIZE = 40;
var _network, _opts, _inputAddress, _inputProgram, _inputDeploymentVersion, _inputHash160, _inputOutput, _address, _program, _deploymentVersion, _hash160, _output, _addressComputed, _programComputed, _deploymentVersionComputed, _hash160Computed, _outputComputed, _decodedAddress, _decodedAddressComputed, _P2OP_instances, getDecodedAddress_fn, makeProgramFromParts_fn, computeAddress_fn, computeProgram_fn, computeDeploymentVersion_fn, computeHash160_fn, computeOutput_fn, validate_fn;
var _P2OP = class _P2OP {
  /**
   * Creates a new P2OP payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded OPNet address
   * @param params.program - Witness program (2-40 bytes)
   * @param params.deploymentVersion - Deployment version (0-255)
   * @param params.hash160 - 20-byte hash
   * @param params.output - The scriptPubKey
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2OP_instances);
    // Private instance fields
    __privateAdd(this, _network);
    __privateAdd(this, _opts);
    // Input data (provided by user)
    __privateAdd(this, _inputAddress);
    __privateAdd(this, _inputProgram);
    __privateAdd(this, _inputDeploymentVersion);
    __privateAdd(this, _inputHash160);
    __privateAdd(this, _inputOutput);
    // Cached computed values
    __privateAdd(this, _address);
    __privateAdd(this, _program);
    __privateAdd(this, _deploymentVersion);
    __privateAdd(this, _hash160);
    __privateAdd(this, _output);
    // Cache flags
    __privateAdd(this, _addressComputed, false);
    __privateAdd(this, _programComputed, false);
    __privateAdd(this, _deploymentVersionComputed, false);
    __privateAdd(this, _hash160Computed, false);
    __privateAdd(this, _outputComputed, false);
    // Decoded address cache
    __privateAdd(this, _decodedAddress);
    __privateAdd(this, _decodedAddressComputed, false);
    __privateSet(this, _network, params.network ?? bitcoin$1);
    __privateSet(this, _opts, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputAddress, params.address);
    __privateSet(this, _inputProgram, params.program);
    __privateSet(this, _inputDeploymentVersion, params.deploymentVersion);
    __privateSet(this, _inputHash160, params.hash160);
    __privateSet(this, _inputOutput, params.output);
    if (__privateGet(this, _opts).validate) {
      __privateMethod(this, _P2OP_instances, validate_fn).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return PaymentType.P2OP;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network);
  }
  /**
   * Bech32m encoded OPNet address.
   */
  get address() {
    if (!__privateGet(this, _addressComputed)) {
      __privateSet(this, _address, __privateMethod(this, _P2OP_instances, computeAddress_fn).call(this));
      __privateSet(this, _addressComputed, true);
    }
    return __privateGet(this, _address);
  }
  /**
   * Witness program (2-40 bytes).
   * Format: `{deploymentVersion:uint8}{hash160:20-bytes|...}`
   */
  get program() {
    if (!__privateGet(this, _programComputed)) {
      __privateSet(this, _program, __privateMethod(this, _P2OP_instances, computeProgram_fn).call(this));
      __privateSet(this, _programComputed, true);
    }
    return __privateGet(this, _program);
  }
  /**
   * Deployment version (first byte of program).
   */
  get deploymentVersion() {
    if (!__privateGet(this, _deploymentVersionComputed)) {
      __privateSet(this, _deploymentVersion, __privateMethod(this, _P2OP_instances, computeDeploymentVersion_fn).call(this));
      __privateSet(this, _deploymentVersionComputed, true);
    }
    return __privateGet(this, _deploymentVersion);
  }
  /**
   * Hash160 (remaining bytes of program).
   */
  get hash160() {
    if (!__privateGet(this, _hash160Computed)) {
      __privateSet(this, _hash160, __privateMethod(this, _P2OP_instances, computeHash160_fn).call(this));
      __privateSet(this, _hash160Computed, true);
    }
    return __privateGet(this, _hash160);
  }
  /**
   * The scriptPubKey: `OP_16 {program}`
   */
  get output() {
    if (!__privateGet(this, _outputComputed)) {
      __privateSet(this, _output, __privateMethod(this, _P2OP_instances, computeOutput_fn).call(this));
      __privateSet(this, _outputComputed, true);
    }
    return __privateGet(this, _output);
  }
  // Static factory methods
  /**
   * Creates a P2OP payment from a witness program.
   *
   * @param program - Witness program (2-40 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromProgram(program, network) {
    return new _P2OP({ program, network });
  }
  /**
   * Creates a P2OP payment from deployment version and hash160.
   *
   * @param deploymentVersion - Deployment version (0-255)
   * @param hash160 - 20-byte hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromParts(deploymentVersion, hash1602, network) {
    return new _P2OP({ deploymentVersion, hash160: hash1602, network });
  }
  /**
   * Creates a P2OP payment from an OPNet address.
   *
   * @param address - Bech32m encoded OPNet address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromAddress(address, network) {
    return new _P2OP({ address, network });
  }
  /**
   * Creates a P2OP payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromOutput(output, network) {
    return new _P2OP({ output, network });
  }
  // Private helper methods
  /**
   * Converts to a plain P2OPPayment object for backwards compatibility.
   *
   * @returns A P2OPPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      program: this.program,
      deploymentVersion: this.deploymentVersion,
      hash160: this.hash160,
      output: this.output
    };
  }
};
_network = new WeakMap();
_opts = new WeakMap();
_inputAddress = new WeakMap();
_inputProgram = new WeakMap();
_inputDeploymentVersion = new WeakMap();
_inputHash160 = new WeakMap();
_inputOutput = new WeakMap();
_address = new WeakMap();
_program = new WeakMap();
_deploymentVersion = new WeakMap();
_hash160 = new WeakMap();
_output = new WeakMap();
_addressComputed = new WeakMap();
_programComputed = new WeakMap();
_deploymentVersionComputed = new WeakMap();
_hash160Computed = new WeakMap();
_outputComputed = new WeakMap();
_decodedAddress = new WeakMap();
_decodedAddressComputed = new WeakMap();
_P2OP_instances = new WeakSet();
getDecodedAddress_fn = function() {
  if (!__privateGet(this, _decodedAddressComputed)) {
    if (__privateGet(this, _inputAddress)) {
      const decoded = fromBech32(__privateGet(this, _inputAddress));
      if (decoded) {
        __privateSet(this, _decodedAddress, {
          version: decoded.version,
          prefix: decoded.prefix,
          data: decoded.data
        });
      }
    }
    __privateSet(this, _decodedAddressComputed, true);
  }
  return __privateGet(this, _decodedAddress);
};
// Private computation methods
makeProgramFromParts_fn = function() {
  if (typeof __privateGet(this, _inputDeploymentVersion) !== "undefined" && typeof __privateGet(this, _inputHash160) !== "undefined") {
    if (__privateGet(this, _inputHash160).length !== 20) {
      throw new TypeError("hash160 must be exactly 20 bytes");
    }
    if (__privateGet(this, _inputDeploymentVersion) < 0 || __privateGet(this, _inputDeploymentVersion) > 255) {
      throw new TypeError("deploymentVersion must fit in one byte");
    }
    return concat$1([new Uint8Array([__privateGet(this, _inputDeploymentVersion)]), __privateGet(this, _inputHash160)]);
  }
  return void 0;
};
computeAddress_fn = function() {
  if (__privateGet(this, _inputAddress)) {
    return __privateGet(this, _inputAddress);
  }
  const prog = this.program;
  if (!prog)
    return void 0;
  if (!__privateGet(this, _network).bech32Opnet) {
    throw new TypeError("Network does not support opnet");
  }
  const words = distExports.bech32m.toWords(prog);
  words.unshift(P2OP_WITNESS_VERSION);
  return distExports.bech32m.encode(__privateGet(this, _network).bech32Opnet, words);
};
computeProgram_fn = function() {
  var _a5;
  if (__privateGet(this, _inputProgram)) {
    return __privateGet(this, _inputProgram);
  }
  const fromParts = __privateMethod(this, _P2OP_instances, makeProgramFromParts_fn).call(this);
  if (fromParts) {
    return fromParts;
  }
  if (__privateGet(this, _inputOutput)) {
    if (__privateGet(this, _inputOutput)[0] !== OPS$9.OP_16) {
      throw new TypeError("Invalid P2OP script");
    }
    let pushPos = 1;
    let progLen;
    const byte1 = __privateGet(this, _inputOutput)[1];
    const byte2 = __privateGet(this, _inputOutput)[2];
    if (byte1 !== void 0 && byte1 < 76) {
      progLen = byte1;
      pushPos = 2;
    } else if (byte1 === 76 && byte2 !== void 0) {
      progLen = byte2;
      pushPos = 3;
    } else {
      throw new TypeError("Unsupported push opcode in P2OP script");
    }
    return __privateGet(this, _inputOutput).subarray(pushPos, pushPos + progLen);
  }
  if (__privateGet(this, _inputAddress)) {
    return (_a5 = __privateMethod(this, _P2OP_instances, getDecodedAddress_fn).call(this)) == null ? void 0 : _a5.data;
  }
  return void 0;
};
computeDeploymentVersion_fn = function() {
  if (__privateGet(this, _inputDeploymentVersion) !== void 0) {
    return __privateGet(this, _inputDeploymentVersion);
  }
  const prog = this.program;
  if (!prog)
    return void 0;
  return prog[0];
};
computeHash160_fn = function() {
  if (__privateGet(this, _inputHash160)) {
    return __privateGet(this, _inputHash160);
  }
  const prog = this.program;
  if (!prog)
    return void 0;
  return prog.subarray(1);
};
// Validation
computeOutput_fn = function() {
  if (__privateGet(this, _inputOutput)) {
    return __privateGet(this, _inputOutput);
  }
  const prog = this.program;
  if (!prog)
    return void 0;
  return compile([OPS$9.OP_16, prog]);
};
validate_fn = function() {
  let prog = alloc(0);
  if (__privateGet(this, _inputAddress)) {
    const dec = __privateMethod(this, _P2OP_instances, getDecodedAddress_fn).call(this);
    if (!dec) {
      throw new TypeError("Invalid address");
    }
    if (__privateGet(this, _network).bech32Opnet !== dec.prefix) {
      throw new TypeError("Invalid prefix or network mismatch");
    }
    if (dec.version !== P2OP_WITNESS_VERSION) {
      throw new TypeError("Invalid witness version for p2op");
    }
    if (dec.data.length < MIN_SIZE || dec.data.length > MAX_SIZE) {
      throw new TypeError("Invalid witness program length");
    }
    prog = dec.data;
  }
  if (__privateGet(this, _inputProgram)) {
    if (prog.length > 0 && !equals(prog, __privateGet(this, _inputProgram))) {
      throw new TypeError("Program mismatch");
    }
    prog = __privateGet(this, _inputProgram);
  }
  if (!prog.length && __privateGet(this, _inputDeploymentVersion) !== void 0 && __privateGet(this, _inputHash160)) {
    const made = __privateMethod(this, _P2OP_instances, makeProgramFromParts_fn).call(this);
    if (made)
      prog = made;
  }
  if (__privateGet(this, _inputOutput)) {
    const outProg = this.program;
    if (!outProg) {
      throw new TypeError("Output program is required");
    }
    if (prog.length > 0 && !equals(prog, outProg)) {
      throw new TypeError("Program mismatch (output vs other source)");
    }
    prog = outProg;
  }
  if (prog.length < MIN_SIZE || prog.length > MAX_SIZE) {
    throw new TypeError(`Witness program must be 240 bytes. Was ${prog.length} bytes`);
  }
  if (__privateGet(this, _inputDeploymentVersion) !== void 0 && __privateGet(this, _inputDeploymentVersion) !== prog[0]) {
    throw new TypeError("deploymentVersion mismatch");
  }
  if (__privateGet(this, _inputHash160) && !equals(__privateGet(this, _inputHash160), prog.subarray(1))) {
    throw new TypeError("hash160 mismatch");
  }
};
// Static public fields
__publicField(_P2OP, "NAME", PaymentType.P2OP);
var P2OP = _P2OP;
function p2op(a, opts) {
  if (!a.address && !a.output && !a.program && (typeof a.deploymentVersion === "undefined" || !a.hash160)) {
    throw new TypeError("At least one of address, output or program must be provided");
  }
  const instance = new P2OP({
    address: a.address,
    program: a.program,
    deploymentVersion: a.deploymentVersion,
    hash160: a.hash160,
    output: a.output,
    network: a.network
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
function ripemd1602(data) {
  return ripemd160(data);
}
function sha1$1(data) {
  return sha1(data);
}
function sha256$12(data) {
  return sha256$1(data);
}
function hash160(data) {
  return ripemd160(sha256$1(data));
}
function hash256(data) {
  return sha256$1(sha256$1(data));
}
var TAGS = [
  "BIP0340/challenge",
  "BIP0340/aux",
  "BIP0340/nonce",
  "TapLeaf",
  "TapBranch",
  "TapSighash",
  "TapTweak",
  "KeyAgg list",
  "KeyAgg coefficient"
];
var TAGGED_HASH_PREFIXES = {
  "BIP0340/challenge": new Uint8Array([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": new Uint8Array([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": new Uint8Array([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: new Uint8Array([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: new Uint8Array([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: new Uint8Array([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: new Uint8Array([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": new Uint8Array([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": new Uint8Array([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function taggedHash(prefix, data) {
  return sha256$12(concat$1([TAGGED_HASH_PREFIXES[prefix], data]));
}
var crypto$2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  TAGGED_HASH_PREFIXES,
  TAGS,
  hash160,
  hash256,
  ripemd160: ripemd1602,
  sha1: sha1$1,
  sha256: sha256$12,
  taggedHash
}, Symbol.toStringTag, { value: "Module" }));
var secp256k1_CURVE2 = {
  p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
  n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,
  h: 1n,
  a: 0n,
  b: 7n,
  Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
  Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
};
var { p: P$2, n: N$1, Gx, Gy, b: _b } = secp256k1_CURVE2;
var L = 32;
var L2 = 64;
var lengths = {
  publicKey: L + 1,
  publicKeyUncompressed: L2 + 1
};
var captureTrace = (...args) => {
  if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(...args);
  }
};
var err$1 = (message = "") => {
  const e = new Error(message);
  captureTrace(e, err$1);
  throw e;
};
var isBig = (n2) => typeof n2 === "bigint";
var isStr = (s) => typeof s === "string";
var isBytes2 = (a) => a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
var abytes2 = (value, length, title = "") => {
  const bytes = isBytes2(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    err$1(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
};
var u8n = (len) => new Uint8Array(len);
var padh = (n2, pad) => n2.toString(16).padStart(pad, "0");
var bytesToHex2 = (b) => Array.from(abytes2(b)).map((e) => padh(e, 2)).join("");
var C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
var _ch = (ch) => {
  if (ch >= C._0 && ch <= C._9)
    return ch - C._0;
  if (ch >= C.A && ch <= C.F)
    return ch - (C.A - 10);
  if (ch >= C.a && ch <= C.f)
    return ch - (C.a - 10);
  return;
};
var hexToBytes2 = (hex) => {
  const e = "hex invalid";
  if (!isStr(hex))
    return err$1(e);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    return err$1(e);
  const array = u8n(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = _ch(hex.charCodeAt(hi));
    const n2 = _ch(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0)
      return err$1(e);
    array[ai] = n1 * 16 + n2;
  }
  return array;
};
var concatBytes2 = (...arrs) => {
  const r2 = u8n(arrs.reduce((sum, a) => sum + abytes2(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r2.set(a, pad);
    pad += a.length;
  });
  return r2;
};
var big = BigInt;
var arange = (n2, min2, max2, msg = "bad number: out of range") => isBig(n2) && min2 <= n2 && n2 < max2 ? n2 : err$1(msg);
var M$1 = (a, b = P$2) => {
  const r2 = a % b;
  return r2 >= 0n ? r2 : b + r2;
};
var invert2 = (num, md) => {
  if (num === 0n || md <= 0n)
    err$1("no inverse n=" + num + " mod=" + md);
  let a = M$1(num, md), b = md, x = 0n, u = 1n;
  while (a !== 0n) {
    const q = b / a, r2 = b % a;
    const m = x - u * q;
    b = a, a = r2, x = u, u = m;
  }
  return b === 1n ? M$1(x, md) : err$1("no inverse");
};
var apoint = (p) => p instanceof Point$1 ? p : err$1("Point expected");
var koblitz = (x) => M$1(M$1(x * x) * x + _b);
var FpIsValid = (n2) => arange(n2, 0n, P$2);
var FpIsValidNot0 = (n2) => arange(n2, 1n, P$2);
var FnIsValidNot0 = (n2) => arange(n2, 1n, N$1);
var isEven = (y) => (y & 1n) === 0n;
var u8of = (n2) => Uint8Array.of(n2);
var getPrefix = (y) => u8of(isEven(y) ? 2 : 3);
var lift_x = (x) => {
  const c = koblitz(FpIsValidNot0(x));
  let r2 = 1n;
  for (let num = c, e = (P$2 + 1n) / 4n; e > 0n; e >>= 1n) {
    if (e & 1n)
      r2 = r2 * num % P$2;
    num = num * num % P$2;
  }
  return M$1(r2 * r2) === c ? r2 : err$1("sqrt invalid");
};
var _a3;
var Point$1 = (_a3 = class {
  constructor(X2, Y2, Z) {
    __publicField(this, "X");
    __publicField(this, "Y");
    __publicField(this, "Z");
    this.X = FpIsValid(X2);
    this.Y = FpIsValidNot0(Y2);
    this.Z = FpIsValid(Z);
    Object.freeze(this);
  }
  static CURVE() {
    return secp256k1_CURVE2;
  }
  /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */
  static fromAffine(ap) {
    const { x, y } = ap;
    return x === 0n && y === 0n ? I : new _a3(x, y, 1n);
  }
  /** Convert Uint8Array or hex string to Point. */
  static fromBytes(bytes) {
    abytes2(bytes);
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    let p = void 0;
    const length = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    const x = sliceBytesNumBE(tail, 0, L);
    if (length === comp && (head === 2 || head === 3)) {
      let y = lift_x(x);
      const evenY = isEven(y);
      const evenH = isEven(big(head));
      if (evenH !== evenY)
        y = M$1(-y);
      p = new _a3(x, y, 1n);
    }
    if (length === uncomp && head === 4)
      p = new _a3(x, sliceBytesNumBE(tail, L, L2), 1n);
    return p ? p.assertValidity() : err$1("bad point: not on curve");
  }
  static fromHex(hex) {
    return _a3.fromBytes(hexToBytes2(hex));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  /** Equality check: compare points P&Q. */
  equals(other) {
    const { X: X1, Y: Y1, Z: Z1 } = this;
    const { X: X2, Y: Y2, Z: Z2 } = apoint(other);
    const X1Z2 = M$1(X1 * Z2);
    const X2Z1 = M$1(X2 * Z1);
    const Y1Z2 = M$1(Y1 * Z2);
    const Y2Z1 = M$1(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  is0() {
    return this.equals(I);
  }
  /** Flip point over y coordinate. */
  negate() {
    return new _a3(this.X, M$1(-this.Y), this.Z);
  }
  /** Point doubling: P+P, complete formula. */
  double() {
    return this.add(this);
  }
  /**
   * Point addition: P+Q, complete, exception-free formula
   * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).
   * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.
   */
  // prettier-ignore
  add(other) {
    const { X: X1, Y: Y1, Z: Z1 } = this;
    const { X: X2, Y: Y2, Z: Z2 } = apoint(other);
    const a = 0n;
    const b = _b;
    let X3 = 0n, Y3 = 0n, Z3 = 0n;
    const b3 = M$1(b * 3n);
    let t0 = M$1(X1 * X2), t1 = M$1(Y1 * Y2), t2 = M$1(Z1 * Z2), t3 = M$1(X1 + Y1);
    let t4 = M$1(X2 + Y2);
    t3 = M$1(t3 * t4);
    t4 = M$1(t0 + t1);
    t3 = M$1(t3 - t4);
    t4 = M$1(X1 + Z1);
    let t5 = M$1(X2 + Z2);
    t4 = M$1(t4 * t5);
    t5 = M$1(t0 + t2);
    t4 = M$1(t4 - t5);
    t5 = M$1(Y1 + Z1);
    X3 = M$1(Y2 + Z2);
    t5 = M$1(t5 * X3);
    X3 = M$1(t1 + t2);
    t5 = M$1(t5 - X3);
    Z3 = M$1(a * t4);
    X3 = M$1(b3 * t2);
    Z3 = M$1(X3 + Z3);
    X3 = M$1(t1 - Z3);
    Z3 = M$1(t1 + Z3);
    Y3 = M$1(X3 * Z3);
    t1 = M$1(t0 + t0);
    t1 = M$1(t1 + t0);
    t2 = M$1(a * t2);
    t4 = M$1(b3 * t4);
    t1 = M$1(t1 + t2);
    t2 = M$1(t0 - t2);
    t2 = M$1(a * t2);
    t4 = M$1(t4 + t2);
    t0 = M$1(t1 * t4);
    Y3 = M$1(Y3 + t0);
    t0 = M$1(t5 * t4);
    X3 = M$1(t3 * X3);
    X3 = M$1(X3 - t0);
    t0 = M$1(t3 * t1);
    Z3 = M$1(t5 * Z3);
    Z3 = M$1(Z3 + t0);
    return new _a3(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(apoint(other).negate());
  }
  /**
   * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
   * Uses {@link wNAF} for base point.
   * Uses fake point to mitigate side-channel leakage.
   * @param n scalar by which point is multiplied
   * @param safe safe mode guards against timing attacks; unsafe mode is faster
   */
  multiply(n2, safe = true) {
    if (!safe && n2 === 0n)
      return I;
    FnIsValidNot0(n2);
    if (n2 === 1n)
      return this;
    if (this.equals(G$1))
      return wNAF2(n2).p;
    let p = I;
    let f = G$1;
    for (let d = this; n2 > 0n; d = d.double(), n2 >>= 1n) {
      if (n2 & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  multiplyUnsafe(scalar) {
    return this.multiply(scalar, false);
  }
  /** Convert point to 2d xy affine point. (X, Y, Z)  (x=X/Z, y=Y/Z) */
  toAffine() {
    const { X: x, Y: y, Z: z2 } = this;
    if (this.equals(I))
      return { x: 0n, y: 0n };
    if (z2 === 1n)
      return { x, y };
    const iz = invert2(z2, P$2);
    if (M$1(z2 * iz) !== 1n)
      err$1("inverse invalid");
    return { x: M$1(x * iz), y: M$1(y * iz) };
  }
  /** Checks if the point is valid and on-curve. */
  assertValidity() {
    const { x, y } = this.toAffine();
    FpIsValidNot0(x);
    FpIsValidNot0(y);
    return M$1(y * y) === koblitz(x) ? this : err$1("bad point: not on curve");
  }
  /** Converts point to 33/65-byte Uint8Array. */
  toBytes(isCompressed = true) {
    const { x, y } = this.assertValidity().toAffine();
    const x32b = numTo32b(x);
    if (isCompressed)
      return concatBytes2(getPrefix(y), x32b);
    return concatBytes2(u8of(4), x32b, numTo32b(y));
  }
  toHex(isCompressed) {
    return bytesToHex2(this.toBytes(isCompressed));
  }
}, __publicField(_a3, "BASE"), __publicField(_a3, "ZERO"), _a3);
var G$1 = new Point$1(Gx, Gy, 1n);
var I = new Point$1(0n, 1n, 0n);
Point$1.BASE = G$1;
Point$1.ZERO = I;
var bytesToNumBE = (b) => big("0x" + (bytesToHex2(b) || "0"));
var sliceBytesNumBE = (b, from, to) => bytesToNumBE(b.subarray(from, to));
var B256 = 2n ** 256n;
var numTo32b = (num) => hexToBytes2(padh(arange(num, 0n, B256), L2));
var W$1 = 8;
var scalarBits = 256;
var pwindows = Math.ceil(scalarBits / W$1) + 1;
var pwindowSize = 2 ** (W$1 - 1);
var precompute = () => {
  const points = [];
  let p = G$1;
  let b = p;
  for (let w2 = 0; w2 < pwindows; w2++) {
    b = p;
    points.push(b);
    for (let i2 = 1; i2 < pwindowSize; i2++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
};
var Gpows = void 0;
var ctneg = (cnd, p) => {
  const n2 = p.negate();
  return cnd ? n2 : p;
};
var wNAF2 = (n2) => {
  const comp = Gpows || (Gpows = precompute());
  let p = I;
  let f = G$1;
  const pow_2_w = 2 ** W$1;
  const maxNum = pow_2_w;
  const mask = big(pow_2_w - 1);
  const shiftBy = big(W$1);
  for (let w2 = 0; w2 < pwindows; w2++) {
    let wbits = Number(n2 & mask);
    n2 >>= shiftBy;
    if (wbits > pwindowSize) {
      wbits -= maxNum;
      n2 += 1n;
    }
    const off = w2 * pwindowSize;
    const offF = off;
    const offP = off + Math.abs(wbits) - 1;
    const isEven22 = w2 % 2 !== 0;
    const isNeg = wbits < 0;
    if (wbits === 0) {
      f = f.add(ctneg(isEven22, comp[offF]));
    } else {
      p = p.add(ctneg(isNeg, comp[offP]));
    }
  }
  if (n2 !== 0n)
    err$1("invalid wnaf");
  return { p, f };
};
var toXOnly = (pubKey) => {
  return pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
};
function bigIntTo32Bytes(num) {
  let hex = num.toString(16);
  hex = hex.padStart(64, "0");
  if (hex.length > 64) {
    hex = hex.slice(-64);
  }
  return fromHex$1(hex);
}
function decompressPublicKey(realPubKey) {
  if (realPubKey.length === 32) {
    return;
  }
  if (![33, 65].includes(realPubKey.length)) {
    console.warn(`Unsupported key length=${realPubKey.length}. Must be 33 (compressed) or 65 (uncompressed).`);
    return;
  }
  let point;
  try {
    point = Point$1.fromHex(toHex$1(realPubKey));
  } catch (err2) {
    throw new Error("Invalid secp256k1 public key bytes. Cannot parse.", { cause: err2 });
  }
  const xBuf = bigIntTo32Bytes(point.x);
  const yBuf = bigIntTo32Bytes(point.y);
  const isEven3 = point.y % 2n === 0n;
  const prefix = isEven3 ? 6 : 7;
  const hybridPubKey = alloc(65);
  hybridPubKey[0] = prefix;
  hybridPubKey.set(xBuf, 1);
  hybridPubKey.set(yBuf, 33);
  const uncompressedPubKey = concat$1([new Uint8Array([4]), xBuf, yBuf]);
  return {
    hybrid: hybridPubKey,
    uncompressed: uncompressedPubKey
  };
}
function pubkeysMatch(a, b) {
  if (equals(a, b))
    return true;
  if (a.length === 65 && b.length === 65) {
    const aCopy = new Uint8Array(a);
    const bCopy = new Uint8Array(b);
    if (aCopy[0] === 6 || aCopy[0] === 7)
      aCopy[0] = 4;
    if (bCopy[0] === 6 || bCopy[0] === 7)
      bCopy[0] = 4;
    return equals(aCopy, bCopy);
  }
  return false;
}
var OPS$8 = opcodes;
var _network2, _opts2, _inputAddress2, _inputHash, _inputPubkey, _inputSignature, _inputOutput2, _inputInput, _useHybrid, _useUncompressed, _address2, _hash, _pubkey, _signature, _output2, _input, _witness, _addressComputed2, _hashComputed, _pubkeyComputed, _signatureComputed, _outputComputed2, _inputComputed, _witnessComputed, _decodedAddress2, _decodedAddressComputed2, _inputChunks, _inputChunksComputed, _P2PKH_instances, getDecodedAddress_fn2, getInputChunks_fn, computeAddress_fn2, computeHash_fn, computePubkey_fn, computeSignature_fn, computeOutput_fn2, computeInput_fn, computeWitness_fn, validate_fn2;
var _P2PKH = class _P2PKH {
  /**
   * Creates a new P2PKH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Base58Check encoded address
   * @param params.hash - 20-byte pubkey hash (RIPEMD160(SHA256(pubkey)))
   * @param params.pubkey - The public key (33 or 65 bytes)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2PKH_instances);
    // Private instance fields
    __privateAdd(this, _network2);
    __privateAdd(this, _opts2);
    // Input data (provided by user)
    __privateAdd(this, _inputAddress2);
    __privateAdd(this, _inputHash);
    __privateAdd(this, _inputPubkey);
    __privateAdd(this, _inputSignature);
    __privateAdd(this, _inputOutput2);
    __privateAdd(this, _inputInput);
    // Hybrid/uncompressed key flags
    __privateAdd(this, _useHybrid, false);
    __privateAdd(this, _useUncompressed, false);
    // Cached computed values
    __privateAdd(this, _address2);
    __privateAdd(this, _hash);
    __privateAdd(this, _pubkey);
    __privateAdd(this, _signature);
    __privateAdd(this, _output2);
    __privateAdd(this, _input);
    __privateAdd(this, _witness);
    // Cache flags
    __privateAdd(this, _addressComputed2, false);
    __privateAdd(this, _hashComputed, false);
    __privateAdd(this, _pubkeyComputed, false);
    __privateAdd(this, _signatureComputed, false);
    __privateAdd(this, _outputComputed2, false);
    __privateAdd(this, _inputComputed, false);
    __privateAdd(this, _witnessComputed, false);
    // Decoded address cache
    __privateAdd(this, _decodedAddress2);
    __privateAdd(this, _decodedAddressComputed2, false);
    // Decoded input chunks cache
    __privateAdd(this, _inputChunks);
    __privateAdd(this, _inputChunksComputed, false);
    __privateSet(this, _network2, params.network ?? bitcoin$1);
    __privateSet(this, _opts2, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputAddress2, params.address);
    __privateSet(this, _inputHash, params.hash);
    __privateSet(this, _inputPubkey, params.pubkey);
    __privateSet(this, _inputSignature, params.signature);
    __privateSet(this, _inputOutput2, params.output);
    __privateSet(this, _inputInput, params.input);
    __privateSet(this, _useHybrid, params.useHybrid ?? false);
    __privateSet(this, _useUncompressed, params.useUncompressed ?? false);
    if (__privateGet(this, _opts2).validate) {
      __privateMethod(this, _P2PKH_instances, validate_fn2).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return PaymentType.P2PKH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network2);
  }
  /**
   * Base58Check encoded Bitcoin address.
   */
  get address() {
    if (!__privateGet(this, _addressComputed2)) {
      __privateSet(this, _address2, __privateMethod(this, _P2PKH_instances, computeAddress_fn2).call(this));
      __privateSet(this, _addressComputed2, true);
    }
    return __privateGet(this, _address2);
  }
  /**
   * 20-byte pubkey hash (RIPEMD160(SHA256(pubkey))).
   */
  get hash() {
    if (!__privateGet(this, _hashComputed)) {
      __privateSet(this, _hash, __privateMethod(this, _P2PKH_instances, computeHash_fn).call(this));
      __privateSet(this, _hashComputed, true);
    }
    return __privateGet(this, _hash);
  }
  /**
   * The public key (33 or 65 bytes).
   */
  get pubkey() {
    if (!__privateGet(this, _pubkeyComputed)) {
      __privateSet(this, _pubkey, __privateMethod(this, _P2PKH_instances, computePubkey_fn).call(this));
      __privateSet(this, _pubkeyComputed, true);
    }
    return __privateGet(this, _pubkey);
  }
  /**
   * The DER-encoded signature.
   */
  get signature() {
    if (!__privateGet(this, _signatureComputed)) {
      __privateSet(this, _signature, __privateMethod(this, _P2PKH_instances, computeSignature_fn).call(this));
      __privateSet(this, _signatureComputed, true);
    }
    return __privateGet(this, _signature);
  }
  /**
   * The scriptPubKey:
   * `OP_DUP OP_HASH160 {hash} OP_EQUALVERIFY OP_CHECKSIG`
   */
  get output() {
    if (!__privateGet(this, _outputComputed2)) {
      __privateSet(this, _output2, __privateMethod(this, _P2PKH_instances, computeOutput_fn2).call(this));
      __privateSet(this, _outputComputed2, true);
    }
    return __privateGet(this, _output2);
  }
  /**
   * The scriptSig: `{signature} {pubkey}`
   */
  get input() {
    if (!__privateGet(this, _inputComputed)) {
      __privateSet(this, _input, __privateMethod(this, _P2PKH_instances, computeInput_fn).call(this));
      __privateSet(this, _inputComputed, true);
    }
    return __privateGet(this, _input);
  }
  /**
   * Witness stack (empty for P2PKH as it's not a SegWit type).
   */
  get witness() {
    if (!__privateGet(this, _witnessComputed)) {
      __privateSet(this, _witness, __privateMethod(this, _P2PKH_instances, computeWitness_fn).call(this));
      __privateSet(this, _witnessComputed, true);
    }
    return __privateGet(this, _witness);
  }
  // Static factory methods
  /**
   * Creates a P2PKH payment from a public key.
   *
   * @param pubkey - The public key (33 or 65 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromPubkey(pubkey);
   * const address = payment.address;
   * ```
   */
  static fromPubkey(pubkey, network) {
    return new _P2PKH({ pubkey, network });
  }
  /**
   * Creates a P2PKH payment from a Base58Check address.
   *
   * @param address - Base58Check encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromAddress('1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2');
   * const hash = payment.hash;
   * ```
   */
  static fromAddress(address, network) {
    return new _P2PKH({ address, network });
  }
  /**
   * Creates a P2PKH payment from a 20-byte pubkey hash.
   *
   * @param hash - 20-byte pubkey hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromHash(hash160);
   * const address = payment.address;
   * ```
   */
  static fromHash(hash2, network) {
    return new _P2PKH({ hash: hash2, network });
  }
  /**
   * Creates a P2PKH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   */
  static fromOutput(output, network) {
    return new _P2PKH({ output, network });
  }
  // Private helper methods
  /**
   * Converts to a plain P2PKHPayment object for backwards compatibility.
   *
   * @returns A P2PKHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
};
_network2 = new WeakMap();
_opts2 = new WeakMap();
_inputAddress2 = new WeakMap();
_inputHash = new WeakMap();
_inputPubkey = new WeakMap();
_inputSignature = new WeakMap();
_inputOutput2 = new WeakMap();
_inputInput = new WeakMap();
_useHybrid = new WeakMap();
_useUncompressed = new WeakMap();
_address2 = new WeakMap();
_hash = new WeakMap();
_pubkey = new WeakMap();
_signature = new WeakMap();
_output2 = new WeakMap();
_input = new WeakMap();
_witness = new WeakMap();
_addressComputed2 = new WeakMap();
_hashComputed = new WeakMap();
_pubkeyComputed = new WeakMap();
_signatureComputed = new WeakMap();
_outputComputed2 = new WeakMap();
_inputComputed = new WeakMap();
_witnessComputed = new WeakMap();
_decodedAddress2 = new WeakMap();
_decodedAddressComputed2 = new WeakMap();
_inputChunks = new WeakMap();
_inputChunksComputed = new WeakMap();
_P2PKH_instances = new WeakSet();
getDecodedAddress_fn2 = function() {
  if (!__privateGet(this, _decodedAddressComputed2)) {
    if (__privateGet(this, _inputAddress2)) {
      const payload = new Uint8Array(decode$i(__privateGet(this, _inputAddress2)));
      __privateSet(this, _decodedAddress2, {
        version: payload[0],
        hash: payload.subarray(1)
      });
    }
    __privateSet(this, _decodedAddressComputed2, true);
  }
  return __privateGet(this, _decodedAddress2);
};
// Private computation methods
getInputChunks_fn = function() {
  if (!__privateGet(this, _inputChunksComputed)) {
    if (__privateGet(this, _inputInput)) {
      __privateSet(this, _inputChunks, decompile(__privateGet(this, _inputInput)) ?? void 0);
    }
    __privateSet(this, _inputChunksComputed, true);
  }
  return __privateGet(this, _inputChunks);
};
computeAddress_fn2 = function() {
  if (__privateGet(this, _inputAddress2)) {
    return __privateGet(this, _inputAddress2);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  const payload = alloc(21);
  payload[0] = __privateGet(this, _network2).pubKeyHash;
  payload.set(h, 1);
  return encode$j(payload);
};
computeHash_fn = function() {
  var _a5;
  if (__privateGet(this, _inputHash)) {
    return __privateGet(this, _inputHash);
  }
  if (__privateGet(this, _inputOutput2)) {
    return __privateGet(this, _inputOutput2).subarray(3, 23);
  }
  if (__privateGet(this, _inputAddress2)) {
    return (_a5 = __privateMethod(this, _P2PKH_instances, getDecodedAddress_fn2).call(this)) == null ? void 0 : _a5.hash;
  }
  const pk = this.pubkey;
  if (pk) {
    return hash160(pk);
  }
  return void 0;
};
computePubkey_fn = function() {
  if (__privateGet(this, _inputPubkey)) {
    return __privateGet(this, _inputPubkey);
  }
  if (__privateGet(this, _inputInput)) {
    const chunks = __privateMethod(this, _P2PKH_instances, getInputChunks_fn).call(this);
    if (chunks && chunks.length >= 2) {
      return chunks[1];
    }
  }
  return void 0;
};
computeSignature_fn = function() {
  if (__privateGet(this, _inputSignature)) {
    return __privateGet(this, _inputSignature);
  }
  if (__privateGet(this, _inputInput)) {
    const chunks = __privateMethod(this, _P2PKH_instances, getInputChunks_fn).call(this);
    if (chunks && chunks.length >= 1) {
      return chunks[0];
    }
  }
  return void 0;
};
computeOutput_fn2 = function() {
  if (__privateGet(this, _inputOutput2)) {
    return __privateGet(this, _inputOutput2);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  return compile([
    OPS$8.OP_DUP,
    OPS$8.OP_HASH160,
    h,
    OPS$8.OP_EQUALVERIFY,
    OPS$8.OP_CHECKSIG
  ]);
};
computeInput_fn = function() {
  if (__privateGet(this, _inputInput)) {
    return __privateGet(this, _inputInput);
  }
  if (!__privateGet(this, _inputPubkey) || !__privateGet(this, _inputSignature)) {
    return void 0;
  }
  let pubKey = __privateGet(this, _inputPubkey);
  if (__privateGet(this, _useHybrid) || __privateGet(this, _useUncompressed)) {
    const decompressed = decompressPublicKey(__privateGet(this, _inputPubkey));
    if (decompressed) {
      if (__privateGet(this, _useUncompressed)) {
        pubKey = decompressed.uncompressed;
      } else {
        pubKey = decompressed.hybrid;
      }
    }
  }
  return compile([__privateGet(this, _inputSignature), pubKey]);
};
// Validation
computeWitness_fn = function() {
  if (this.input) {
    return [];
  }
  return void 0;
};
validate_fn2 = function() {
  let hash2 = new Uint8Array(0);
  if (__privateGet(this, _inputAddress2)) {
    const addr = __privateMethod(this, _P2PKH_instances, getDecodedAddress_fn2).call(this);
    if (!addr) {
      throw new TypeError("Invalid address");
    }
    if (addr.version !== __privateGet(this, _network2).pubKeyHash) {
      throw new TypeError("Invalid version or Network mismatch");
    }
    if (addr.hash.length !== 20) {
      throw new TypeError("Invalid address");
    }
    hash2 = addr.hash;
  }
  if (__privateGet(this, _inputHash)) {
    if (hash2.length > 0 && !equals(hash2, __privateGet(this, _inputHash))) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = __privateGet(this, _inputHash);
    }
  }
  if (__privateGet(this, _inputOutput2)) {
    if (__privateGet(this, _inputOutput2).length !== 25 || __privateGet(this, _inputOutput2)[0] !== OPS$8.OP_DUP || __privateGet(this, _inputOutput2)[1] !== OPS$8.OP_HASH160 || __privateGet(this, _inputOutput2)[2] !== 20 || __privateGet(this, _inputOutput2)[23] !== OPS$8.OP_EQUALVERIFY || __privateGet(this, _inputOutput2)[24] !== OPS$8.OP_CHECKSIG) {
      throw new TypeError("Output is invalid");
    }
    const hash22 = __privateGet(this, _inputOutput2).subarray(3, 23);
    if (hash2.length > 0 && !equals(hash2, hash22)) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = hash22;
    }
  }
  if (__privateGet(this, _inputPubkey)) {
    const pkh = hash160(__privateGet(this, _inputPubkey));
    let badHash = hash2.length > 0 && !equals(hash2, pkh);
    if (badHash) {
      if (__privateGet(this, _inputPubkey).length === 33 && (__privateGet(this, _inputPubkey)[0] === 2 || __privateGet(this, _inputPubkey)[0] === 3) || __privateGet(this, _inputPubkey).length === 65 && __privateGet(this, _inputPubkey)[0] === 4) {
        const uncompressed = decompressPublicKey(__privateGet(this, _inputPubkey));
        if (uncompressed) {
          const pkh2 = hash160(uncompressed.uncompressed);
          if (!equals(hash2, pkh2)) {
            const pkh3 = hash160(uncompressed.hybrid);
            badHash = !equals(hash2, pkh3);
            if (!badHash) {
              __privateSet(this, _useHybrid, true);
            }
          } else {
            badHash = false;
            __privateSet(this, _useUncompressed, true);
          }
        }
      }
    }
    if (badHash) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = pkh;
    }
  }
  if (__privateGet(this, _inputInput)) {
    const chunks = __privateMethod(this, _P2PKH_instances, getInputChunks_fn).call(this);
    if (!chunks || chunks.length !== 2) {
      throw new TypeError("Input is invalid");
    }
    if (!isCanonicalScriptSignature(chunks[0])) {
      throw new TypeError("Input has invalid signature");
    }
    if (!isPoint(chunks[1])) {
      throw new TypeError("Input has invalid pubkey");
    }
    if (__privateGet(this, _inputSignature) && !equals(__privateGet(this, _inputSignature), chunks[0])) {
      throw new TypeError("Signature mismatch");
    }
    if (__privateGet(this, _inputPubkey) && !equals(__privateGet(this, _inputPubkey), chunks[1])) {
      throw new TypeError("Pubkey mismatch");
    }
    const pkh = hash160(chunks[1]);
    if (hash2.length > 0 && !equals(hash2, pkh)) {
      throw new TypeError("Hash mismatch (input)");
    }
  }
};
// Static public fields
__publicField(_P2PKH, "NAME", PaymentType.P2PKH);
var P2PKH = _P2PKH;
function p2pkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input) {
    throw new TypeError("Not enough data");
  }
  const instance = new P2PKH({
    address: a.address,
    hash: a.hash,
    pubkey: a.pubkey,
    signature: a.signature,
    output: a.output,
    input: a.input,
    network: a.network,
    useHybrid: a.useHybrid,
    useUncompressed: a.useUncompressed
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
var OPS$7 = opcodes;
var _network3, _opts3, _inputAddress3, _inputHash2, _inputOutput3, _inputInput2, _inputRedeem, _inputWitness, _address3, _hash2, _output3, _input2, _redeem, _witness2, _addressComputed3, _hashComputed2, _outputComputed3, _inputComputed2, _redeemComputed, _witnessComputed2, _decodedAddress3, _decodedAddressComputed3, _inputChunks2, _inputChunksComputed2, _derivedRedeem, _derivedRedeemComputed, _P2SH_instances, getDecodedAddress_fn3, getInputChunks_fn2, getDerivedRedeem_fn, computeAddress_fn3, computeHash_fn2, computeOutput_fn3, computeInput_fn2, computeRedeem_fn, computeWitness_fn2, checkRedeem_fn, validate_fn3;
var _P2SH = class _P2SH {
  /**
   * Creates a new P2SH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Base58Check encoded address (3...)
   * @param params.hash - 20-byte script hash
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.redeem - The redeem script information
   * @param params.witness - The witness stack (for wrapped SegWit)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2SH_instances);
    // Private instance fields
    __privateAdd(this, _network3);
    __privateAdd(this, _opts3);
    // Input data (provided by user)
    __privateAdd(this, _inputAddress3);
    __privateAdd(this, _inputHash2);
    __privateAdd(this, _inputOutput3);
    __privateAdd(this, _inputInput2);
    __privateAdd(this, _inputRedeem);
    __privateAdd(this, _inputWitness);
    // Cached computed values
    __privateAdd(this, _address3);
    __privateAdd(this, _hash2);
    __privateAdd(this, _output3);
    __privateAdd(this, _input2);
    __privateAdd(this, _redeem);
    __privateAdd(this, _witness2);
    // Cache flags
    __privateAdd(this, _addressComputed3, false);
    __privateAdd(this, _hashComputed2, false);
    __privateAdd(this, _outputComputed3, false);
    __privateAdd(this, _inputComputed2, false);
    __privateAdd(this, _redeemComputed, false);
    __privateAdd(this, _witnessComputed2, false);
    // Decoded address cache
    __privateAdd(this, _decodedAddress3);
    __privateAdd(this, _decodedAddressComputed3, false);
    // Decoded input chunks cache
    __privateAdd(this, _inputChunks2);
    __privateAdd(this, _inputChunksComputed2, false);
    // Derived redeem from input
    __privateAdd(this, _derivedRedeem);
    __privateAdd(this, _derivedRedeemComputed, false);
    let network = params.network;
    if (!network) {
      network = params.redeem && params.redeem.network || bitcoin$1;
    }
    __privateSet(this, _network3, network);
    __privateSet(this, _opts3, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputAddress3, params.address);
    __privateSet(this, _inputHash2, params.hash);
    __privateSet(this, _inputOutput3, params.output);
    __privateSet(this, _inputInput2, params.input);
    __privateSet(this, _inputRedeem, params.redeem);
    __privateSet(this, _inputWitness, params.witness);
    if (__privateGet(this, _opts3).validate) {
      __privateMethod(this, _P2SH_instances, validate_fn3).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const r2 = this.redeem;
    if (r2 !== void 0 && r2.name !== void 0) {
      return `p2sh-${r2.name}`;
    }
    return PaymentType.P2SH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network3);
  }
  /**
   * Base58Check encoded address (3... for mainnet).
   */
  get address() {
    if (!__privateGet(this, _addressComputed3)) {
      __privateSet(this, _address3, __privateMethod(this, _P2SH_instances, computeAddress_fn3).call(this));
      __privateSet(this, _addressComputed3, true);
    }
    return __privateGet(this, _address3);
  }
  /**
   * 20-byte script hash (HASH160 of redeem script).
   */
  get hash() {
    if (!__privateGet(this, _hashComputed2)) {
      __privateSet(this, _hash2, __privateMethod(this, _P2SH_instances, computeHash_fn2).call(this));
      __privateSet(this, _hashComputed2, true);
    }
    return __privateGet(this, _hash2);
  }
  /**
   * The scriptPubKey: `OP_HASH160 {hash} OP_EQUAL`
   */
  get output() {
    if (!__privateGet(this, _outputComputed3)) {
      __privateSet(this, _output3, __privateMethod(this, _P2SH_instances, computeOutput_fn3).call(this));
      __privateSet(this, _outputComputed3, true);
    }
    return __privateGet(this, _output3);
  }
  /**
   * The scriptSig: `{redeemScriptSig...} {redeemScript}`
   */
  get input() {
    if (!__privateGet(this, _inputComputed2)) {
      __privateSet(this, _input2, __privateMethod(this, _P2SH_instances, computeInput_fn2).call(this));
      __privateSet(this, _inputComputed2, true);
    }
    return __privateGet(this, _input2);
  }
  /**
   * The redeem script information.
   */
  get redeem() {
    if (!__privateGet(this, _redeemComputed)) {
      __privateSet(this, _redeem, __privateMethod(this, _P2SH_instances, computeRedeem_fn).call(this));
      __privateSet(this, _redeemComputed, true);
    }
    return __privateGet(this, _redeem);
  }
  /**
   * The witness stack (for wrapped SegWit).
   */
  get witness() {
    if (!__privateGet(this, _witnessComputed2)) {
      __privateSet(this, _witness2, __privateMethod(this, _P2SH_instances, computeWitness_fn2).call(this));
      __privateSet(this, _witnessComputed2, true);
    }
    return __privateGet(this, _witness2);
  }
  // Static factory methods
  /**
   * Creates a P2SH payment from a redeem script.
   *
   * @param redeem - The redeem script information
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   *
   * @example
   * ```typescript
   * const p2sh = P2SH.fromRedeem({ output: redeemScript });
   * ```
   */
  static fromRedeem(redeem, network) {
    return new _P2SH({ redeem, network });
  }
  /**
   * Creates a P2SH payment from a Base58Check address.
   *
   * @param address - Base58Check encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromAddress(address, network) {
    return new _P2SH({ address, network });
  }
  /**
   * Creates a P2SH payment from a 20-byte script hash.
   *
   * @param hash - 20-byte script hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromHash(hash2, network) {
    return new _P2SH({ hash: hash2, network });
  }
  /**
   * Creates a P2SH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromOutput(output, network) {
    return new _P2SH({ output, network });
  }
  // Private helper methods
  /**
   * Converts to a plain P2SHPayment object for backwards compatibility.
   *
   * @returns A P2SHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      output: this.output,
      input: this.input,
      redeem: this.redeem,
      witness: this.witness
    };
  }
};
_network3 = new WeakMap();
_opts3 = new WeakMap();
_inputAddress3 = new WeakMap();
_inputHash2 = new WeakMap();
_inputOutput3 = new WeakMap();
_inputInput2 = new WeakMap();
_inputRedeem = new WeakMap();
_inputWitness = new WeakMap();
_address3 = new WeakMap();
_hash2 = new WeakMap();
_output3 = new WeakMap();
_input2 = new WeakMap();
_redeem = new WeakMap();
_witness2 = new WeakMap();
_addressComputed3 = new WeakMap();
_hashComputed2 = new WeakMap();
_outputComputed3 = new WeakMap();
_inputComputed2 = new WeakMap();
_redeemComputed = new WeakMap();
_witnessComputed2 = new WeakMap();
_decodedAddress3 = new WeakMap();
_decodedAddressComputed3 = new WeakMap();
_inputChunks2 = new WeakMap();
_inputChunksComputed2 = new WeakMap();
_derivedRedeem = new WeakMap();
_derivedRedeemComputed = new WeakMap();
_P2SH_instances = new WeakSet();
getDecodedAddress_fn3 = function() {
  if (!__privateGet(this, _decodedAddressComputed3)) {
    if (__privateGet(this, _inputAddress3)) {
      const payload = new Uint8Array(decode$i(__privateGet(this, _inputAddress3)));
      __privateSet(this, _decodedAddress3, {
        version: payload[0],
        hash: payload.subarray(1)
      });
    }
    __privateSet(this, _decodedAddressComputed3, true);
  }
  return __privateGet(this, _decodedAddress3);
};
getInputChunks_fn2 = function() {
  if (!__privateGet(this, _inputChunksComputed2)) {
    if (__privateGet(this, _inputInput2)) {
      __privateSet(this, _inputChunks2, decompile(__privateGet(this, _inputInput2)) ?? void 0);
    }
    __privateSet(this, _inputChunksComputed2, true);
  }
  return __privateGet(this, _inputChunks2);
};
// Private computation methods
getDerivedRedeem_fn = function() {
  if (!__privateGet(this, _derivedRedeemComputed)) {
    const chunks = __privateMethod(this, _P2SH_instances, getInputChunks_fn2).call(this);
    if (chunks) {
      const lastChunk = chunks[chunks.length - 1];
      __privateSet(this, _derivedRedeem, {
        network: __privateGet(this, _network3),
        output: lastChunk === OPS$7.OP_FALSE ? new Uint8Array(0) : lastChunk,
        input: compile(chunks.slice(0, -1)),
        witness: __privateGet(this, _inputWitness) || []
      });
    }
    __privateSet(this, _derivedRedeemComputed, true);
  }
  return __privateGet(this, _derivedRedeem);
};
computeAddress_fn3 = function() {
  if (__privateGet(this, _inputAddress3)) {
    return __privateGet(this, _inputAddress3);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  const payload = alloc(21);
  payload[0] = __privateGet(this, _network3).scriptHash;
  payload.set(h, 1);
  return encode$j(payload);
};
computeHash_fn2 = function() {
  var _a5;
  if (__privateGet(this, _inputHash2)) {
    return __privateGet(this, _inputHash2);
  }
  if (__privateGet(this, _inputOutput3)) {
    return __privateGet(this, _inputOutput3).subarray(2, 22);
  }
  if (__privateGet(this, _inputAddress3)) {
    return (_a5 = __privateMethod(this, _P2SH_instances, getDecodedAddress_fn3).call(this)) == null ? void 0 : _a5.hash;
  }
  const r2 = this.redeem;
  if (r2 && r2.output) {
    return hash160(r2.output);
  }
  return void 0;
};
computeOutput_fn3 = function() {
  if (__privateGet(this, _inputOutput3)) {
    return __privateGet(this, _inputOutput3);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  return compile([OPS$7.OP_HASH160, h, OPS$7.OP_EQUAL]);
};
computeInput_fn2 = function() {
  if (__privateGet(this, _inputInput2)) {
    return __privateGet(this, _inputInput2);
  }
  const r2 = __privateGet(this, _inputRedeem);
  if (!r2 || !r2.input || !r2.output) {
    return void 0;
  }
  return compile([].concat(decompile(r2.input), r2.output));
};
computeRedeem_fn = function() {
  if (__privateGet(this, _inputRedeem)) {
    return __privateGet(this, _inputRedeem);
  }
  if (__privateGet(this, _inputInput2)) {
    return __privateMethod(this, _P2SH_instances, getDerivedRedeem_fn).call(this);
  }
  return void 0;
};
// Validation
computeWitness_fn2 = function() {
  if (__privateGet(this, _inputWitness)) {
    return __privateGet(this, _inputWitness);
  }
  const r2 = this.redeem;
  if (r2 && r2.witness) {
    return r2.witness;
  }
  if (this.input) {
    return [];
  }
  return void 0;
};
checkRedeem_fn = function(redeem) {
  if (redeem.output) {
    const decompile$1 = decompile(redeem.output);
    if (!decompile$1 || decompile$1.length < 1) {
      throw new TypeError("Redeem.output too short");
    }
    if (redeem.output.byteLength > 520) {
      throw new TypeError("Redeem.output unspendable if larger than 520 bytes");
    }
    if (countNonPushOnlyOPs(decompile$1) > 201) {
      throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
    }
  }
  if (redeem.input) {
    const hasInput = redeem.input.length > 0;
    const hasWitness = redeem.witness && redeem.witness.length > 0;
    if (!hasInput && !hasWitness) {
      throw new TypeError("Empty input");
    }
    if (hasInput && hasWitness) {
      throw new TypeError("Input and witness provided");
    }
    if (hasInput) {
      const richunks = decompile(redeem.input);
      if (!isPushOnly(richunks)) {
        throw new TypeError("Non push-only scriptSig");
      }
    }
  }
};
validate_fn3 = function() {
  let hash2 = new Uint8Array(0);
  if (__privateGet(this, _inputAddress3)) {
    const addr = __privateMethod(this, _P2SH_instances, getDecodedAddress_fn3).call(this);
    if (!addr) {
      throw new TypeError("Invalid address");
    }
    if (addr.version !== __privateGet(this, _network3).scriptHash) {
      throw new TypeError("Invalid version or Network mismatch");
    }
    if (addr.hash.length !== 20) {
      throw new TypeError("Invalid address");
    }
    hash2 = addr.hash;
  }
  if (__privateGet(this, _inputHash2)) {
    if (hash2.length > 0 && !equals(hash2, __privateGet(this, _inputHash2))) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = __privateGet(this, _inputHash2);
    }
  }
  if (__privateGet(this, _inputOutput3)) {
    if (__privateGet(this, _inputOutput3).length !== 23 || __privateGet(this, _inputOutput3)[0] !== OPS$7.OP_HASH160 || __privateGet(this, _inputOutput3)[1] !== 20 || __privateGet(this, _inputOutput3)[22] !== OPS$7.OP_EQUAL) {
      throw new TypeError("Output is invalid");
    }
    const hash22 = __privateGet(this, _inputOutput3).subarray(2, 22);
    if (hash2.length > 0 && !equals(hash2, hash22)) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = hash22;
    }
  }
  if (__privateGet(this, _inputInput2)) {
    const chunks = __privateMethod(this, _P2SH_instances, getInputChunks_fn2).call(this);
    if (!chunks || chunks.length < 1) {
      throw new TypeError("Input too short");
    }
    const derived = __privateMethod(this, _P2SH_instances, getDerivedRedeem_fn).call(this);
    if (!derived || !(derived.output instanceof Uint8Array)) {
      throw new TypeError("Input is invalid");
    }
    __privateMethod(this, _P2SH_instances, checkRedeem_fn).call(this, derived);
    if (derived.output) {
      const hash22 = hash160(derived.output);
      if (hash2.length > 0 && !equals(hash2, hash22)) {
        throw new TypeError("Hash mismatch");
      } else {
        hash2 = hash22;
      }
    }
  }
  if (__privateGet(this, _inputRedeem)) {
    if (__privateGet(this, _inputRedeem).network && __privateGet(this, _inputRedeem).network !== __privateGet(this, _network3)) {
      throw new TypeError("Network mismatch");
    }
    if (__privateGet(this, _inputInput2)) {
      const derived = __privateMethod(this, _P2SH_instances, getDerivedRedeem_fn).call(this);
      if (derived) {
        if (__privateGet(this, _inputRedeem).output && derived.output && !equals(__privateGet(this, _inputRedeem).output, derived.output)) {
          throw new TypeError("Redeem.output mismatch");
        }
        if (__privateGet(this, _inputRedeem).input && derived.input && !equals(__privateGet(this, _inputRedeem).input, derived.input)) {
          throw new TypeError("Redeem.input mismatch");
        }
      }
    }
    __privateMethod(this, _P2SH_instances, checkRedeem_fn).call(this, __privateGet(this, _inputRedeem));
    if (__privateGet(this, _inputRedeem).output) {
      const hash22 = hash160(__privateGet(this, _inputRedeem).output);
      if (hash2.length > 0 && !equals(hash2, hash22)) {
        throw new TypeError("Hash mismatch");
      }
    }
  }
  if (__privateGet(this, _inputWitness)) {
    if (__privateGet(this, _inputRedeem) && __privateGet(this, _inputRedeem).witness && !stacksEqual(__privateGet(this, _inputRedeem).witness, __privateGet(this, _inputWitness))) {
      throw new TypeError("Witness and redeem.witness mismatch");
    }
  }
};
// Static public fields
__publicField(_P2SH, "NAME", PaymentType.P2SH);
var P2SH = _P2SH;
function p2sh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input) {
    throw new TypeError("Not enough data");
  }
  const instance = new P2SH({
    address: a.address,
    hash: a.hash,
    output: a.output,
    input: a.input,
    redeem: a.redeem,
    witness: a.witness,
    network: a.network
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
function en(e) {
  const t2 = e.length;
  if (t2 % 2 !== 0) throw new TypeError("fromHexInternal: odd-length hex string");
  const r2 = new Uint8Array(t2 / 2);
  for (let n2 = 0; n2 < t2; n2 += 2) {
    const i2 = de(e.charCodeAt(n2)), o = de(e.charCodeAt(n2 + 1));
    if (i2 === -1 || o === -1) throw new TypeError("fromHexInternal: invalid hex character");
    r2[n2 >> 1] = i2 << 4 | o;
  }
  return r2;
}
function de(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function Lt(e) {
  for (let t2 = 0; t2 < e.length; t2++)
    if (e[t2] !== 0) return false;
  return true;
}
function pr(e, t2) {
  const r2 = Math.min(e.length, t2.length);
  for (let n2 = 0; n2 < r2; n2++) {
    const i2 = e[n2], o = t2[n2];
    if (i2 < o) return -1;
    if (i2 > o) return 1;
  }
  return e.length < t2.length ? -1 : e.length > t2.length ? 1 : 0;
}
function M(e, t2) {
  if (e.length !== t2.length) return false;
  for (let r2 = 0; r2 < e.length; r2++)
    if (e[r2] !== t2[r2]) return false;
  return true;
}
function wt(e) {
  let t2 = "";
  for (let r2 = 0; r2 < e.length; r2++)
    t2 += e[r2].toString(16).padStart(2, "0");
  return t2;
}
function nn(...e) {
  let t2 = 0;
  for (const i2 of e) t2 += i2.length;
  const r2 = new Uint8Array(t2);
  let n2 = 0;
  for (const i2 of e)
    r2.set(i2, n2), n2 += i2.length;
  return r2;
}
var Jt = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
var mr = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
var Be = 21n * 10n ** 14n;
function Se(e) {
  let t2 = 0n;
  for (let r2 = 0; r2 < e.length; r2++)
    t2 = t2 << 8n | BigInt(e[r2]);
  return t2;
}
function Er(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function xr(e) {
  return e instanceof Uint8Array && e.length === 20;
}
function vr(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 || Lt(e) ? false : Se(e) < Jt;
}
function rn(e) {
  if (!(e instanceof Uint8Array)) return false;
  const t2 = e[0];
  return e.length === 33 && (t2 === 2 || t2 === 3) || e.length === 65 && (t2 === 4 || t2 === 6 || t2 === 7);
}
function Br(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 ? false : !Lt(e);
}
function on(e) {
  return e instanceof Uint8Array && e.length >= 8 && e.length <= 73;
}
function sn(e) {
  return e instanceof Uint8Array && e.length === 64;
}
function Sr(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function fn(e) {
  return typeof e == "bigint" && e >= 0n && e <= Be;
}
function Ae(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertBytes32: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertBytes32: expected 32 bytes, got ${e.length} bytes`);
}
function cn(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPrivateKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertPrivateKey: expected 32 bytes, got ${e.length} bytes`);
  if (Lt(e))
    throw new TypeError("assertPrivateKey: key is zero");
  if (Se(e) >= Jt)
    throw new TypeError("assertPrivateKey: key not in range [1, n)");
}
function an(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPublicKey: expected Uint8Array");
  if (!rn(e))
    throw new TypeError(
      `assertPublicKey: invalid SEC1 public key (length=${e.length}, prefix=0x${(e[0] ?? 0).toString(16).padStart(2, "0")})`
    );
}
function dn(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertXOnlyPublicKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertXOnlyPublicKey: expected 32 bytes, got ${e.length} bytes`);
  if (Lt(e))
    throw new TypeError("assertXOnlyPublicKey: key is zero");
}
function un(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertMessageHash: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertMessageHash: expected 32 bytes, got ${e.length} bytes`);
}
function Ar(e) {
  return Ae(e), e;
}
function Or(e) {
  if (!(e instanceof Uint8Array) || e.length !== 20)
    throw new TypeError("createBytes20: expected 20 bytes Uint8Array");
  return e;
}
function zt(e) {
  return cn(e), e;
}
function ln(e) {
  return an(e), e;
}
function hn(e) {
  return dn(e), e;
}
function Rr(e) {
  if (!on(e))
    throw new TypeError(`createSignature: expected 8-73 bytes, got ${e.length} bytes`);
  return e;
}
function Ir(e) {
  if (!sn(e))
    throw new TypeError(`createSchnorrSignature: expected 64 bytes, got ${e.length} bytes`);
  return e;
}
function Ur(e) {
  return un(e), e;
}
function Pr(e) {
  if (!fn(e))
    throw new TypeError(`createSatoshi: value out of range [0, ${Be}]`);
  return e;
}
var lt = {
  /** Can produce ECDSA signatures (requires a private key). */
  EcdsaSign: 1,
  /** Can verify ECDSA signatures. */
  EcdsaVerify: 2,
  /** Can produce BIP-340 Schnorr signatures (requires a private key and backend support). */
  SchnorrSign: 4,
  /** Can verify BIP-340 Schnorr signatures (requires backend support). */
  SchnorrVerify: 8,
  /** Can export the raw private key bytes. */
  PrivateKeyExport: 16,
  /** Can derive a tweaked child key via Taproot-style tweaking. */
  PublicKeyTweak: 32,
  /** Supports BIP-32 hierarchical deterministic derivation. */
  HdDerivation: 64
};
function te(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function dt(e, t2 = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const r2 = t2 && `"${t2}" `;
    throw new Error(`${r2}expected integer >= 0, got ${e}`);
  }
}
function _(e, t2, r2 = "") {
  const n2 = te(e), i2 = e == null ? void 0 : e.length, o = t2 !== void 0;
  if (!n2 || o && i2 !== t2) {
    const s = r2 && `"${r2}" `, f = o ? ` of length ${t2}` : "", c = n2 ? `length=${i2}` : `type=${typeof e}`;
    throw new Error(s + "expected Uint8Array" + f + ", got " + c);
  }
  return e;
}
function Oe(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  dt(e.outputLen), dt(e.blockLen);
}
function It(e, t2 = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t2 && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function bn(e, t2) {
  _(e, void 0, "digestInto() output");
  const r2 = t2.outputLen;
  if (e.length < r2)
    throw new Error('"digestInto() output" expected to be of length >=' + r2);
}
function Ut(...e) {
  for (let t2 = 0; t2 < e.length; t2++)
    e[t2].fill(0);
}
function $t(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function G(e, t2) {
  return e << 32 - t2 | e >>> t2;
}
var Re = (
  /* @ts-ignore */
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
);
var yn = Array.from({ length: 256 }, (e, t2) => t2.toString(16).padStart(2, "0"));
function Ht(e) {
  if (_(e), Re)
    return e.toHex();
  let t2 = "";
  for (let r2 = 0; r2 < e.length; r2++)
    t2 += yn[e[r2]];
  return t2;
}
var Q$1 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function ue(e) {
  if (e >= Q$1._0 && e <= Q$1._9)
    return e - Q$1._0;
  if (e >= Q$1.A && e <= Q$1.F)
    return e - (Q$1.A - 10);
  if (e >= Q$1.a && e <= Q$1.f)
    return e - (Q$1.a - 10);
}
function Pt(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (Re)
    return Uint8Array.fromHex(e);
  const t2 = e.length, r2 = t2 / 2;
  if (t2 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t2);
  const n2 = new Uint8Array(r2);
  for (let i2 = 0, o = 0; i2 < r2; i2++, o += 2) {
    const s = ue(e.charCodeAt(o)), f = ue(e.charCodeAt(o + 1));
    if (s === void 0 || f === void 0) {
      const c = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + o);
    }
    n2[i2] = s * 16 + f;
  }
  return n2;
}
function W(...e) {
  let t2 = 0;
  for (let n2 = 0; n2 < e.length; n2++) {
    const i2 = e[n2];
    _(i2), t2 += i2.length;
  }
  const r2 = new Uint8Array(t2);
  for (let n2 = 0, i2 = 0; n2 < e.length; n2++) {
    const o = e[n2];
    r2.set(o, i2), i2 += o.length;
  }
  return r2;
}
function gn(e, t2 = {}) {
  const r2 = (i2, o) => e(o).update(i2).digest(), n2 = e(void 0);
  return r2.outputLen = n2.outputLen, r2.blockLen = n2.blockLen, r2.create = (i2) => e(i2), Object.assign(r2, t2), Object.freeze(r2);
}
function Kt(e = 32) {
  const t2 = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof (t2 == null ? void 0 : t2.getRandomValues) != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t2.getRandomValues(new Uint8Array(e));
}
var wn = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function pn(e, t2, r2) {
  return e & t2 ^ ~e & r2;
}
function mn(e, t2, r2) {
  return e & t2 ^ e & r2 ^ t2 & r2;
}
var En = class {
  constructor(t2, r2, n2, i2) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = t2, this.outputLen = r2, this.padOffset = n2, this.isLE = i2, this.buffer = new Uint8Array(t2), this.view = $t(this.buffer);
  }
  update(t2) {
    It(this), _(t2);
    const { view: r2, buffer: n2, blockLen: i2 } = this, o = t2.length;
    for (let s = 0; s < o; ) {
      const f = Math.min(i2 - this.pos, o - s);
      if (f === i2) {
        const c = $t(t2);
        for (; i2 <= o - s; s += i2)
          this.process(c, s);
        continue;
      }
      n2.set(t2.subarray(s, s + f), this.pos), this.pos += f, s += f, this.pos === i2 && (this.process(r2, 0), this.pos = 0);
    }
    return this.length += t2.length, this.roundClean(), this;
  }
  digestInto(t2) {
    It(this), bn(t2, this), this.finished = true;
    const { buffer: r2, view: n2, blockLen: i2, isLE: o } = this;
    let { pos: s } = this;
    r2[s++] = 128, Ut(this.buffer.subarray(s)), this.padOffset > i2 - s && (this.process(n2, 0), s = 0);
    for (let b = s; b < i2; b++)
      r2[b] = 0;
    n2.setBigUint64(i2 - 8, BigInt(this.length * 8), o), this.process(n2, 0);
    const f = $t(t2), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const a = c / 4, h = this.get();
    if (a > h.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let b = 0; b < a; b++)
      f.setUint32(4 * b, h[b], o);
  }
  digest() {
    const { buffer: t2, outputLen: r2 } = this;
    this.digestInto(t2);
    const n2 = t2.slice(0, r2);
    return this.destroy(), n2;
  }
  _cloneInto(t2) {
    t2 || (t2 = new this.constructor()), t2.set(...this.get());
    const { blockLen: r2, buffer: n2, length: i2, finished: o, destroyed: s, pos: f } = this;
    return t2.destroyed = s, t2.finished = o, t2.length = i2, t2.pos = f, i2 % r2 && t2.buffer.set(n2), t2;
  }
  clone() {
    return this._cloneInto();
  }
};
var et = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var xn = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var nt = new Uint32Array(64);
var vn = class extends En {
  constructor(t2) {
    super(64, t2, 8, false);
  }
  get() {
    const { A: t2, B: r2, C: n2, D: i2, E: o, F: s, G: f, H: c } = this;
    return [t2, r2, n2, i2, o, s, f, c];
  }
  // prettier-ignore
  set(t2, r2, n2, i2, o, s, f, c) {
    this.A = t2 | 0, this.B = r2 | 0, this.C = n2 | 0, this.D = i2 | 0, this.E = o | 0, this.F = s | 0, this.G = f | 0, this.H = c | 0;
  }
  process(t2, r2) {
    for (let b = 0; b < 16; b++, r2 += 4)
      nt[b] = t2.getUint32(r2, false);
    for (let b = 16; b < 64; b++) {
      const m = nt[b - 15], y = nt[b - 2], E = G(m, 7) ^ G(m, 18) ^ m >>> 3, O = G(y, 17) ^ G(y, 19) ^ y >>> 10;
      nt[b] = O + nt[b - 7] + E + nt[b - 16] | 0;
    }
    let { A: n2, B: i2, C: o, D: s, E: f, F: c, G: a, H: h } = this;
    for (let b = 0; b < 64; b++) {
      const m = G(f, 6) ^ G(f, 11) ^ G(f, 25), y = h + m + pn(f, c, a) + xn[b] + nt[b] | 0, O = (G(n2, 2) ^ G(n2, 13) ^ G(n2, 22)) + mn(n2, i2, o) | 0;
      h = a, a = c, c = f, f = s + y | 0, s = o, o = i2, i2 = n2, n2 = y + O | 0;
    }
    n2 = n2 + this.A | 0, i2 = i2 + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, f = f + this.E | 0, c = c + this.F | 0, a = a + this.G | 0, h = h + this.H | 0, this.set(n2, i2, o, s, f, c, a, h);
  }
  roundClean() {
    Ut(nt);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Ut(this.buffer);
  }
};
var Bn = class extends vn {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", et[0] | 0);
    __publicField(this, "B", et[1] | 0);
    __publicField(this, "C", et[2] | 0);
    __publicField(this, "D", et[3] | 0);
    __publicField(this, "E", et[4] | 0);
    __publicField(this, "F", et[5] | 0);
    __publicField(this, "G", et[6] | 0);
    __publicField(this, "H", et[7] | 0);
  }
};
var Et = gn(
  () => new Bn(),
  wn(1)
);
function Sn(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t2 = new Uint8Array(256);
  for (let a = 0; a < t2.length; a++)
    t2[a] = 255;
  for (let a = 0; a < e.length; a++) {
    const h = e.charAt(a), b = h.charCodeAt(0);
    if (t2[b] !== 255)
      throw new TypeError(h + " is ambiguous");
    t2[b] = a;
  }
  const r2 = e.length, n2 = e.charAt(0), i2 = Math.log(r2) / Math.log(256), o = Math.log(256) / Math.log(r2);
  function s(a) {
    if (a instanceof Uint8Array || (ArrayBuffer.isView(a) ? a = new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : Array.isArray(a) && (a = Uint8Array.from(a))), !(a instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (a.length === 0)
      return "";
    let h = 0, b = 0, m = 0;
    const y = a.length;
    for (; m !== y && a[m] === 0; )
      m++, h++;
    const E = (y - m) * o + 1 >>> 0, O = new Uint8Array(E);
    for (; m !== y; ) {
      let q = a[m], Z = 0;
      for (let L3 = E - 1; (q !== 0 || Z < b) && L3 !== -1; L3--, Z++)
        q += 256 * O[L3] >>> 0, O[L3] = q % r2 >>> 0, q = q / r2 >>> 0;
      if (q !== 0)
        throw new Error("Non-zero carry");
      b = Z, m++;
    }
    let A = E - b;
    for (; A !== E && O[A] === 0; )
      A++;
    let T = n2.repeat(h);
    for (; A < E; ++A)
      T += e.charAt(O[A]);
    return T;
  }
  function f(a) {
    if (typeof a != "string")
      throw new TypeError("Expected String");
    if (a.length === 0)
      return new Uint8Array();
    let h = 0, b = 0, m = 0;
    for (; a[h] === n2; )
      b++, h++;
    const y = (a.length - h) * i2 + 1 >>> 0, E = new Uint8Array(y);
    for (; h < a.length; ) {
      const q = a.charCodeAt(h);
      if (q > 255)
        return;
      let Z = t2[q];
      if (Z === 255)
        return;
      let L3 = 0;
      for (let j = y - 1; (Z !== 0 || L3 < m) && j !== -1; j--, L3++)
        Z += r2 * E[j] >>> 0, E[j] = Z % 256 >>> 0, Z = Z / 256 >>> 0;
      if (Z !== 0)
        throw new Error("Non-zero carry");
      m = L3, h++;
    }
    let O = y - m;
    for (; O !== y && E[O] === 0; )
      O++;
    const A = new Uint8Array(b + (y - O));
    let T = b;
    for (; O !== y; )
      A[T++] = E[O++];
    return A;
  }
  function c(a) {
    const h = f(a);
    if (h)
      return h;
    throw new Error("Non-base" + r2 + " character");
  }
  return {
    encode: s,
    decodeUnsafe: f,
    decode: c
  };
}
var An = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Vt = Sn(An);
function On(e) {
  function t2(o) {
    const s = e(o), f = o.length + 4, c = new Uint8Array(f);
    return c.set(o, 0), c.set(s.subarray(0, 4), o.length), Vt.encode(c);
  }
  function r2(o) {
    const s = o.slice(0, -4), f = o.slice(-4), c = e(s);
    if (!(f[0] ^ c[0] | f[1] ^ c[1] | f[2] ^ c[2] | f[3] ^ c[3]))
      return s;
  }
  function n2(o) {
    const s = Vt.decodeUnsafe(o);
    if (s !== void 0)
      return r2(s);
  }
  function i2(o) {
    const s = Vt.decode(o), f = r2(s);
    if (f === void 0)
      throw new Error("Invalid checksum");
    return f;
  }
  return {
    encode: t2,
    decode: i2,
    decodeUnsafe: n2
  };
}
function Rn(e) {
  return Et(Et(e));
}
var { encode: In, decode: Un, decodeUnsafe: Pn } = On(Rn);
var Ie = { encode: In, decode: Un, decodeUnsafe: Pn };
function Nn(e, t2) {
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: false
    };
  if (e.length !== 34)
    throw new Error("Invalid WIF length");
  if (e[33] !== 1)
    throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: true
  };
}
function Tn(e, t2, r2) {
  if (t2.length !== 32)
    throw new TypeError("Invalid privateKey length");
  const n2 = new Uint8Array(r2 ? 34 : 33);
  return new DataView(n2.buffer).setUint8(0, e), n2.set(t2, 1), r2 && (n2[33] = 1), n2;
}
function _n(e, t2) {
  return Nn(Ie.decode(e));
}
function kn(e) {
  return Ie.encode(Tn(e.version, e.privateKey, e.compressed));
}
function Ln(e, t2, r2) {
  return kn({
    version: r2.wif,
    privateKey: e,
    compressed: t2
  });
}
function Hn(e, t2) {
  const r2 = _n(e), n2 = r2.version;
  if (Array.isArray(t2)) {
    const s = t2.find((f) => f.wif === n2);
    if (!s) throw new Error("Unknown network version");
    return {
      privateKey: zt(r2.privateKey),
      compressed: r2.compressed,
      network: s
    };
  }
  const i2 = t2;
  if (n2 !== i2.wif)
    throw new Error("Invalid network version");
  return {
    privateKey: zt(r2.privateKey),
    compressed: r2.compressed,
    network: i2
  };
}
function Kn(e) {
  return e[0] === 3 ? true : e[0] === 4 && e.length === 65 ? (e[64] & 1) === 1 : false;
}
function qn(e) {
  const t2 = e.length === 32 ? e : e.subarray(1, 33);
  return hn(t2);
}
var Dt = 48;
function Zn(e) {
  let t2 = 0n;
  for (let r2 = 0; r2 < e.length; r2++)
    t2 = t2 << 8n | BigInt(e[r2]);
  return t2;
}
function Cn(e) {
  const t2 = new Uint8Array(32);
  for (let r2 = 31; r2 >= 0; r2--)
    t2[r2] = Number(e & 0xffn), e >>= 8n;
  return t2;
}
var _t, _e, _r, _n2, _i, _o, _s, _st_instances, f_fn, c_fn;
var _st = class _st {
  constructor(t2, r2, n2, i2, o) {
    __privateAdd(this, _st_instances);
    __privateAdd(this, _t);
    __privateAdd(this, _e);
    __privateAdd(this, _r);
    __privateAdd(this, _n2);
    __privateAdd(this, _i);
    __privateAdd(this, _o);
    __privateAdd(this, _s);
    if ((o == null ? void 0 : o.compressed) !== void 0 && typeof o.compressed != "boolean")
      throw new TypeError(
        `Expected boolean for compressed, got ${typeof o.compressed}`
      );
    __privateSet(this, _t, t2), __privateSet(this, _e, r2), __privateSet(this, _n2, (o == null ? void 0 : o.compressed) ?? true), __privateSet(this, _r, i2), n2 !== void 0 && __privateSet(this, _i, t2.pointCompress(n2, __privateGet(this, _n2)));
  }
  /** Raw private key bytes, or `undefined` for public-key-only signers. */
  get privateKey() {
    return __privateGet(this, _e);
  }
  /**
   * SEC1-encoded public key.  Lazily derived from the private key when
   * the signer was created via {@link fromPrivateKey} or {@link fromWIF}.
   *
   * @throws If neither a private nor public key is available (should never happen).
   */
  get publicKey() {
    if (__privateGet(this, _i) === void 0) {
      const t2 = __privateGet(this, _e);
      if (t2 === void 0)
        throw new Error("Missing both private and public key");
      const r2 = __privateGet(this, _t).pointFromScalar(t2, __privateGet(this, _n2));
      if (r2 === null)
        throw new Error("Failed to derive public key from private key");
      __privateSet(this, _i, r2);
    }
    return __privateGet(this, _i);
  }
  /** 32-byte BIP-340 x-only public key (lazily derived and cached). */
  get xOnlyPublicKey() {
    return __privateGet(this, _o) === void 0 && __privateSet(this, _o, qn(this.publicKey)), __privateGet(this, _o);
  }
  /** Network this signer is bound to. */
  get network() {
    return __privateGet(this, _r);
  }
  /** Whether the public key is in compressed SEC1 form. */
  get compressed() {
    return __privateGet(this, _n2);
  }
  /**
   * Bitmask of {@link SignerCapability} flags representing the operations
   * this signer can perform.  Lazily computed and cached.
   */
  get capabilities() {
    if (__privateGet(this, _s) === void 0) {
      let t2 = lt.EcdsaVerify | lt.PublicKeyTweak;
      __privateGet(this, _e) !== void 0 && (t2 |= lt.EcdsaSign | lt.PrivateKeyExport), __privateGet(this, _t).signSchnorr && __privateGet(this, _e) !== void 0 && (t2 |= lt.SchnorrSign), __privateGet(this, _t).verifySchnorr && (t2 |= lt.SchnorrVerify), __privateSet(this, _s, t2);
    }
    return __privateGet(this, _s);
  }
  /**
   * Creates a signer from a raw private key.
   *
   * @param backend - Cryptographic backend to use.
   * @param privateKey - 32-byte secp256k1 private key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws {TypeError} If the private key is not in the valid range `[1, n)`.
   */
  static fromPrivateKey(t2, r2, n2, i2) {
    if (!t2.isPrivate(r2))
      throw new TypeError("Private key not in range [1, n)");
    return new _st(t2, r2, void 0, n2, i2);
  }
  /**
   * Creates a public-key-only signer (cannot sign, export WIF, etc.).
   *
   * @param backend - Cryptographic backend to use.
   * @param publicKey - SEC1-encoded public key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws If the public key is not a valid curve point.
   */
  static fromPublicKey(t2, r2, n2, i2) {
    if (!t2.isPoint(r2))
      throw new Error("Point not on the curve");
    return new _st(t2, void 0, r2, n2, i2);
  }
  /**
   * Imports a signer from a WIF-encoded private key string.
   *
   * @param backend - Cryptographic backend to use.
   * @param wifString - Base58Check WIF string.
   * @param network - One or more candidate networks whose WIF version byte is matched.
   * @throws If no network matches the decoded version byte.
   */
  static fromWIF(t2, r2, n2) {
    const i2 = Hn(r2, n2);
    return _st.fromPrivateKey(t2, i2.privateKey, i2.network, {
      compressed: i2.compressed
    });
  }
  /**
   * Generates a new signer with a random private key.
   *
   * Uses FIPS 186-5 B.4.2 / RFC 9380 modular reduction:
   * 48 bytes of entropy are reduced via `(seed mod (n  1)) + 1`,
   * producing a key in `[1, n)` with negligible bias (< 2^128).
   *
   * @param backend - Cryptographic backend to use.
   * @param network - Target network.
   * @param options - Optional settings (rng, compressed).
   */
  static makeRandom(t2, r2, n2) {
    const o = ((n2 == null ? void 0 : n2.rng) ?? ((a) => crypto.getRandomValues(new Uint8Array(a))))(Dt);
    if (o.length !== Dt)
      throw new TypeError(
        `Expected ${Dt} bytes from rng, got ${o.length} bytes`
      );
    const f = Zn(o) % (Jt - 1n) + 1n, c = Cn(f);
    return _st.fromPrivateKey(
      t2,
      zt(c),
      r2,
      n2
    );
  }
  /**
   * Tests whether this signer has a specific capability.
   * @param cap - {@link SignerCapability} flag to test.
   */
  hasCapability(t2) {
    return (this.capabilities & t2) !== 0;
  }
  /**
   * Produces a compact ECDSA signature.
   *
   * When `lowR` is `true`, grinds the nonce until the R value's first
   * byte is `<= 0x7f`, producing a smaller DER encoding.
   *
   * @param hash - 32-byte message digest.
   * @param lowR - Enable low-R grinding.  Defaults to `false`.
   * @throws If this is a public-key-only signer.
   */
  sign(t2, r2) {
    if (__privateGet(this, _e) === void 0) throw new Error("Missing private key");
    if (!r2)
      return __privateGet(this, _t).sign(t2, __privateGet(this, _e));
    let n2 = __privateGet(this, _t).sign(t2, __privateGet(this, _e));
    const i2 = new Uint8Array(32), o = new DataView(i2.buffer, i2.byteOffset, i2.byteLength);
    let s = 0;
    for (; ; ) {
      const f = n2[0];
      if (f === void 0) throw new Error("Backend returned invalid signature");
      if (f <= 127) break;
      s++, o.setUint32(0, s, true), n2 = __privateGet(this, _t).sign(t2, __privateGet(this, _e), i2);
    }
    return n2;
  }
  /**
   * Produces a 64-byte BIP-340 Schnorr signature.
   *
   * @param hash - 32-byte message digest.
   * @throws If this is a public-key-only signer.
   * @throws If the backend does not support Schnorr signing.
   */
  signSchnorr(t2) {
    if (__privateGet(this, _e) === void 0) throw new Error("Missing private key");
    if (!__privateGet(this, _t).signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return __privateGet(this, _t).signSchnorr(t2, __privateGet(this, _e));
  }
  /**
   * Verifies a compact ECDSA signature against this signer's public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - Compact ECDSA signature.
   */
  verify(t2, r2) {
    return __privateGet(this, _t).verify(t2, this.publicKey, r2);
  }
  /**
   * Verifies a BIP-340 Schnorr signature against this signer's x-only public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - 64-byte Schnorr signature.
   * @throws If the backend does not support Schnorr verification.
   */
  verifySchnorr(t2, r2) {
    if (!__privateGet(this, _t).verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return __privateGet(this, _t).verifySchnorr(t2, this.xOnlyPublicKey, r2);
  }
  /**
   * Derives a new signer by applying a Taproot-style scalar tweak.
   *
   * When a private key is available the tweak is applied to the scalar
   * (negating first if the public key has odd Y).  Otherwise, only the
   * public key is tweaked via x-only point addition.
   *
   * @param t - 32-byte tweak scalar.
   * @throws If the tweaked key is invalid (e.g. lands on the point at infinity).
   */
  tweak(t2) {
    return Ae(t2), __privateGet(this, _e) !== void 0 ? __privateMethod(this, _st_instances, f_fn).call(this, t2) : __privateMethod(this, _st_instances, c_fn).call(this, t2);
  }
  /**
   * Exports the private key as a WIF string using this signer's network.
   *
   * @throws If this is a public-key-only signer.
   */
  toWIF() {
    if (__privateGet(this, _e) === void 0) throw new Error("Missing private key");
    return Ln(__privateGet(this, _e), __privateGet(this, _n2), __privateGet(this, _r));
  }
};
_t = new WeakMap();
_e = new WeakMap();
_r = new WeakMap();
_n2 = new WeakMap();
_i = new WeakMap();
_o = new WeakMap();
_s = new WeakMap();
_st_instances = new WeakSet();
f_fn = function(t2) {
  const r2 = this.publicKey, n2 = __privateGet(this, _e);
  if (n2 === void 0)
    throw new Error("Missing private key");
  const i2 = Kn(r2) ? __privateGet(this, _t).privateNegate(n2) : n2, o = __privateGet(this, _t).privateAdd(i2, t2);
  if (o === null) throw new Error("Invalid tweaked private key!");
  return _st.fromPrivateKey(__privateGet(this, _t), o, __privateGet(this, _r), {
    compressed: __privateGet(this, _n2)
  });
};
c_fn = function(t2) {
  const r2 = this.xOnlyPublicKey, n2 = __privateGet(this, _t).xOnlyPointAddTweak(r2, t2);
  if (n2 === null || n2.xOnlyPubkey === null)
    throw new Error("Cannot tweak public key!");
  const i2 = new Uint8Array([n2.parity === 0 ? 2 : 3]), o = nn(i2, n2.xOnlyPubkey);
  return _st.fromPublicKey(__privateGet(this, _t), ln(o), __privateGet(this, _r), {
    compressed: __privateGet(this, _n2)
  });
};
var st = _st;
var ee = BigInt(0);
var Ft = BigInt(1);
function Nt(e, t2 = "") {
  if (typeof e != "boolean") {
    const r2 = t2 && `"${t2}" `;
    throw new Error(r2 + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function Ue(e) {
  if (typeof e == "bigint") {
    if (!Rt(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    dt(e);
  return e;
}
function St(e) {
  const t2 = Ue(e).toString(16);
  return t2.length & 1 ? "0" + t2 : t2;
}
function Pe(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? ee : BigInt("0x" + e);
}
function xt(e) {
  return Pe(Ht(e));
}
function Ne(e) {
  return Pe(Ht($n(_(e)).reverse()));
}
function ne(e, t2) {
  dt(t2), e = Ue(e);
  const r2 = Pt(e.toString(16).padStart(t2 * 2, "0"));
  if (r2.length !== t2)
    throw new Error("number too large");
  return r2;
}
function Te(e, t2) {
  return ne(e, t2).reverse();
}
function $n(e) {
  return Uint8Array.from(e);
}
function Vn(e) {
  return Uint8Array.from(e, (t2, r2) => {
    const n2 = t2.charCodeAt(0);
    if (t2.length !== 1 || n2 > 127)
      throw new Error(`string contains non-ASCII character "${e[r2]}" with code ${n2} at position ${r2}`);
    return n2;
  });
}
var Rt = (e) => typeof e == "bigint" && ee <= e;
function Dn(e, t2, r2) {
  return Rt(e) && Rt(t2) && Rt(r2) && t2 <= e && e < r2;
}
function Mn(e, t2, r2, n2) {
  if (!Dn(t2, r2, n2))
    throw new Error("expected valid " + e + ": " + r2 + " <= n < " + n2 + ", got " + t2);
}
function Xn(e) {
  let t2;
  for (t2 = 0; e > ee; e >>= Ft, t2 += 1)
    ;
  return t2;
}
var re = (e) => (Ft << BigInt(e)) - Ft;
function Yn(e, t2, r2) {
  if (dt(e, "hashLen"), dt(t2, "qByteLen"), typeof r2 != "function")
    throw new Error("hmacFn must be a function");
  const n2 = (A) => new Uint8Array(A), i2 = Uint8Array.of(), o = Uint8Array.of(0), s = Uint8Array.of(1), f = 1e3;
  let c = n2(e), a = n2(e), h = 0;
  const b = () => {
    c.fill(1), a.fill(0), h = 0;
  }, m = (...A) => r2(a, W(c, ...A)), y = (A = i2) => {
    a = m(o, A), c = m(), A.length !== 0 && (a = m(s, A), c = m());
  }, E = () => {
    if (h++ >= f)
      throw new Error("drbg: tried max amount of iterations");
    let A = 0;
    const T = [];
    for (; A < t2; ) {
      c = m();
      const q = c.slice();
      T.push(q), A += c.length;
    }
    return W(...T);
  };
  return (A, T) => {
    b(), y(A);
    let q;
    for (; !(q = T(E())); )
      y();
    return b(), q;
  };
}
function ie(e, t2 = {}, r2 = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function n2(o, s, f) {
    const c = e[o];
    if (f && c === void 0)
      return;
    const a = typeof c;
    if (a !== s || c === null)
      throw new Error(`param "${o}" is invalid: expected ${s}, got ${a}`);
  }
  const i2 = (o, s) => Object.entries(o).forEach(([f, c]) => n2(f, c, s));
  i2(t2, false), i2(r2, true);
}
function le(e) {
  const t2 = /* @__PURE__ */ new WeakMap();
  return (r2, ...n2) => {
    const i2 = t2.get(r2);
    if (i2 !== void 0)
      return i2;
    const o = e(r2, ...n2);
    return t2.set(r2, o), o;
  };
}
var X = BigInt(0);
var D$1 = BigInt(1);
var ct = BigInt(2);
var _e2 = BigInt(3);
var ke = BigInt(4);
var Le = BigInt(5);
var jn = BigInt(7);
var He = BigInt(8);
var zn = BigInt(9);
var Ke = BigInt(16);
function Y(e, t2) {
  const r2 = e % t2;
  return r2 >= X ? r2 : t2 + r2;
}
function z(e, t2, r2) {
  let n2 = e;
  for (; t2-- > X; )
    n2 *= n2, n2 %= r2;
  return n2;
}
function he(e, t2) {
  if (e === X)
    throw new Error("invert: expected non-zero number");
  if (t2 <= X)
    throw new Error("invert: expected positive modulus, got " + t2);
  let r2 = Y(e, t2), n2 = t2, i2 = X, o = D$1;
  for (; r2 !== X; ) {
    const f = n2 / r2, c = n2 % r2, a = i2 - o * f;
    n2 = r2, r2 = c, i2 = o, o = a;
  }
  if (n2 !== D$1)
    throw new Error("invert: does not exist");
  return Y(i2, t2);
}
function oe(e, t2, r2) {
  if (!e.eql(e.sqr(t2), r2))
    throw new Error("Cannot find square root");
}
function qe(e, t2) {
  const r2 = (e.ORDER + D$1) / ke, n2 = e.pow(t2, r2);
  return oe(e, n2, t2), n2;
}
function Fn(e, t2) {
  const r2 = (e.ORDER - Le) / He, n2 = e.mul(t2, ct), i2 = e.pow(n2, r2), o = e.mul(t2, i2), s = e.mul(e.mul(o, ct), i2), f = e.mul(o, e.sub(s, e.ONE));
  return oe(e, f, t2), f;
}
function Gn(e) {
  const t2 = qt(e), r2 = Ze(e), n2 = r2(t2, t2.neg(t2.ONE)), i2 = r2(t2, n2), o = r2(t2, t2.neg(n2)), s = (e + jn) / Ke;
  return (f, c) => {
    let a = f.pow(c, s), h = f.mul(a, n2);
    const b = f.mul(a, i2), m = f.mul(a, o), y = f.eql(f.sqr(h), c), E = f.eql(f.sqr(b), c);
    a = f.cmov(a, h, y), h = f.cmov(m, b, E);
    const O = f.eql(f.sqr(h), c), A = f.cmov(a, h, O);
    return oe(f, A, c), A;
  };
}
function Ze(e) {
  if (e < _e2)
    throw new Error("sqrt is not defined for small field");
  let t2 = e - D$1, r2 = 0;
  for (; t2 % ct === X; )
    t2 /= ct, r2++;
  let n2 = ct;
  const i2 = qt(e);
  for (; be(i2, n2) === 1; )
    if (n2++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r2 === 1)
    return qe;
  let o = i2.pow(n2, t2);
  const s = (t2 + D$1) / ct;
  return function(c, a) {
    if (c.is0(a))
      return a;
    if (be(c, a) !== 1)
      throw new Error("Cannot find square root");
    let h = r2, b = c.mul(c.ONE, o), m = c.pow(a, t2), y = c.pow(a, s);
    for (; !c.eql(m, c.ONE); ) {
      if (c.is0(m))
        return c.ZERO;
      let E = 1, O = c.sqr(m);
      for (; !c.eql(O, c.ONE); )
        if (E++, O = c.sqr(O), E === h)
          throw new Error("Cannot find square root");
      const A = D$1 << BigInt(h - E - 1), T = c.pow(b, A);
      h = E, b = c.sqr(T), m = c.mul(m, b), y = c.mul(y, T);
    }
    return y;
  };
}
function Wn(e) {
  return e % ke === _e2 ? qe : e % He === Le ? Fn : e % Ke === zn ? Gn(e) : Ze(e);
}
var Qn = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Jn(e) {
  const t2 = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r2 = Qn.reduce((n2, i2) => (n2[i2] = "function", n2), t2);
  return ie(e, r2), e;
}
function tr(e, t2, r2) {
  if (r2 < X)
    throw new Error("invalid exponent, negatives unsupported");
  if (r2 === X)
    return e.ONE;
  if (r2 === D$1)
    return t2;
  let n2 = e.ONE, i2 = t2;
  for (; r2 > X; )
    r2 & D$1 && (n2 = e.mul(n2, i2)), i2 = e.sqr(i2), r2 >>= D$1;
  return n2;
}
function Ce(e, t2, r2 = false) {
  const n2 = new Array(t2.length).fill(r2 ? e.ZERO : void 0), i2 = t2.reduce((s, f, c) => e.is0(f) ? s : (n2[c] = s, e.mul(s, f)), e.ONE), o = e.inv(i2);
  return t2.reduceRight((s, f, c) => e.is0(f) ? s : (n2[c] = e.mul(s, n2[c]), e.mul(s, f)), o), n2;
}
function be(e, t2) {
  const r2 = (e.ORDER - D$1) / ct, n2 = e.pow(t2, r2), i2 = e.eql(n2, e.ONE), o = e.eql(n2, e.ZERO), s = e.eql(n2, e.neg(e.ONE));
  if (!i2 && !o && !s)
    throw new Error("invalid Legendre symbol result");
  return i2 ? 1 : o ? 0 : -1;
}
function er(e, t2) {
  t2 !== void 0 && dt(t2);
  const r2 = t2 !== void 0 ? t2 : e.toString(2).length, n2 = Math.ceil(r2 / 8);
  return { nBitLength: r2, nByteLength: n2 };
}
var nr = class {
  constructor(t2, r2 = {}) {
    __publicField(this, "ORDER");
    __publicField(this, "BITS");
    __publicField(this, "BYTES");
    __publicField(this, "isLE");
    __publicField(this, "ZERO", X);
    __publicField(this, "ONE", D$1);
    __publicField(this, "_lengths");
    __publicField(this, "_sqrt");
    // cached sqrt
    __publicField(this, "_mod");
    var _a5;
    if (t2 <= X)
      throw new Error("invalid field: expected ORDER > 0, got " + t2);
    let n2;
    this.isLE = false, r2 != null && typeof r2 == "object" && (typeof r2.BITS == "number" && (n2 = r2.BITS), typeof r2.sqrt == "function" && (this.sqrt = r2.sqrt), typeof r2.isLE == "boolean" && (this.isLE = r2.isLE), r2.allowedLengths && (this._lengths = (_a5 = r2.allowedLengths) == null ? void 0 : _a5.slice()), typeof r2.modFromBytes == "boolean" && (this._mod = r2.modFromBytes));
    const { nBitLength: i2, nByteLength: o } = er(t2, n2);
    if (o > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t2, this.BITS = i2, this.BYTES = o, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t2) {
    return Y(t2, this.ORDER);
  }
  isValid(t2) {
    if (typeof t2 != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t2);
    return X <= t2 && t2 < this.ORDER;
  }
  is0(t2) {
    return t2 === X;
  }
  // is valid and invertible
  isValidNot0(t2) {
    return !this.is0(t2) && this.isValid(t2);
  }
  isOdd(t2) {
    return (t2 & D$1) === D$1;
  }
  neg(t2) {
    return Y(-t2, this.ORDER);
  }
  eql(t2, r2) {
    return t2 === r2;
  }
  sqr(t2) {
    return Y(t2 * t2, this.ORDER);
  }
  add(t2, r2) {
    return Y(t2 + r2, this.ORDER);
  }
  sub(t2, r2) {
    return Y(t2 - r2, this.ORDER);
  }
  mul(t2, r2) {
    return Y(t2 * r2, this.ORDER);
  }
  pow(t2, r2) {
    return tr(this, t2, r2);
  }
  div(t2, r2) {
    return Y(t2 * he(r2, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t2) {
    return t2 * t2;
  }
  addN(t2, r2) {
    return t2 + r2;
  }
  subN(t2, r2) {
    return t2 - r2;
  }
  mulN(t2, r2) {
    return t2 * r2;
  }
  inv(t2) {
    return he(t2, this.ORDER);
  }
  sqrt(t2) {
    return this._sqrt || (this._sqrt = Wn(this.ORDER)), this._sqrt(this, t2);
  }
  toBytes(t2) {
    return this.isLE ? Te(t2, this.BYTES) : ne(t2, this.BYTES);
  }
  fromBytes(t2, r2 = false) {
    _(t2);
    const { _lengths: n2, BYTES: i2, isLE: o, ORDER: s, _mod: f } = this;
    if (n2) {
      if (!n2.includes(t2.length) || t2.length > i2)
        throw new Error("Field.fromBytes: expected " + n2 + " bytes, got " + t2.length);
      const a = new Uint8Array(i2);
      a.set(t2, o ? 0 : a.length - t2.length), t2 = a;
    }
    if (t2.length !== i2)
      throw new Error("Field.fromBytes: expected " + i2 + " bytes, got " + t2.length);
    let c = o ? Ne(t2) : xt(t2);
    if (f && (c = Y(c, s)), !r2 && !this.isValid(c))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return c;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t2) {
    return Ce(this, t2);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t2, r2, n2) {
    return n2 ? r2 : t2;
  }
};
function qt(e, t2 = {}) {
  return new nr(e, t2);
}
function $e(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t2 = e.toString(2).length;
  return Math.ceil(t2 / 8);
}
function Ve(e) {
  const t2 = $e(e);
  return t2 + Math.ceil(t2 / 2);
}
function De(e, t2, r2 = false) {
  _(e);
  const n2 = e.length, i2 = $e(t2), o = Ve(t2);
  if (n2 < 16 || n2 < o || n2 > 1024)
    throw new Error("expected " + o + "-1024 bytes of input, got " + n2);
  const s = r2 ? Ne(e) : xt(e), f = Y(s, t2 - D$1) + D$1;
  return r2 ? Te(f, i2) : ne(f, i2);
}
var yt = BigInt(0);
var at = BigInt(1);
function Tt(e, t2) {
  const r2 = t2.negate();
  return e ? r2 : t2;
}
function ye(e, t2) {
  const r2 = Ce(e.Fp, t2.map((n2) => n2.Z));
  return t2.map((n2, i2) => e.fromAffine(n2.toAffine(r2[i2])));
}
function Me(e, t2) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t2)
    throw new Error("invalid window size, expected [1.." + t2 + "], got W=" + e);
}
function Mt(e, t2) {
  Me(e, t2);
  const r2 = Math.ceil(t2 / e) + 1, n2 = 2 ** (e - 1), i2 = 2 ** e, o = re(e), s = BigInt(e);
  return { windows: r2, windowSize: n2, mask: o, maxNumber: i2, shiftBy: s };
}
function ge(e, t2, r2) {
  const { windowSize: n2, mask: i2, maxNumber: o, shiftBy: s } = r2;
  let f = Number(e & i2), c = e >> s;
  f > n2 && (f -= o, c += at);
  const a = t2 * n2, h = a + Math.abs(f) - 1, b = f === 0, m = f < 0, y = t2 % 2 !== 0;
  return { nextN: c, offset: h, isZero: b, isNeg: m, isNegF: y, offsetF: a };
}
var Xt = /* @__PURE__ */ new WeakMap();
var Xe = /* @__PURE__ */ new WeakMap();
function Yt(e) {
  return Xe.get(e) || 1;
}
function we(e) {
  if (e !== yt)
    throw new Error("invalid wNAF");
}
var rr = class {
  // Parametrized with a given Point class (not individual point)
  constructor(t2, r2) {
    __publicField(this, "BASE");
    __publicField(this, "ZERO");
    __publicField(this, "Fn");
    __publicField(this, "bits");
    this.BASE = t2.BASE, this.ZERO = t2.ZERO, this.Fn = t2.Fn, this.bits = r2;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t2, r2, n2 = this.ZERO) {
    let i2 = t2;
    for (; r2 > yt; )
      r2 & at && (n2 = n2.add(i2)), i2 = i2.double(), r2 >>= at;
    return n2;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t2, r2) {
    const { windows: n2, windowSize: i2 } = Mt(r2, this.bits), o = [];
    let s = t2, f = s;
    for (let c = 0; c < n2; c++) {
      f = s, o.push(f);
      for (let a = 1; a < i2; a++)
        f = f.add(s), o.push(f);
      s = f.double();
    }
    return o;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t2, r2, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let i2 = this.ZERO, o = this.BASE;
    const s = Mt(t2, this.bits);
    for (let f = 0; f < s.windows; f++) {
      const { nextN: c, offset: a, isZero: h, isNeg: b, isNegF: m, offsetF: y } = ge(n2, f, s);
      n2 = c, h ? o = o.add(Tt(m, r2[y])) : i2 = i2.add(Tt(b, r2[a]));
    }
    return we(n2), { p: i2, f: o };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t2, r2, n2, i2 = this.ZERO) {
    const o = Mt(t2, this.bits);
    for (let s = 0; s < o.windows && n2 !== yt; s++) {
      const { nextN: f, offset: c, isZero: a, isNeg: h } = ge(n2, s, o);
      if (n2 = f, !a) {
        const b = r2[c];
        i2 = i2.add(h ? b.negate() : b);
      }
    }
    return we(n2), i2;
  }
  getPrecomputes(t2, r2, n2) {
    let i2 = Xt.get(r2);
    return i2 || (i2 = this.precomputeWindow(r2, t2), t2 !== 1 && (typeof n2 == "function" && (i2 = n2(i2)), Xt.set(r2, i2))), i2;
  }
  cached(t2, r2, n2) {
    const i2 = Yt(t2);
    return this.wNAF(i2, this.getPrecomputes(i2, t2, n2), r2);
  }
  unsafe(t2, r2, n2, i2) {
    const o = Yt(t2);
    return o === 1 ? this._unsafeLadder(t2, r2, i2) : this.wNAFUnsafe(o, this.getPrecomputes(o, t2, n2), r2, i2);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t2, r2) {
    Me(r2, this.bits), Xe.set(t2, r2), Xt.delete(t2);
  }
  hasCache(t2) {
    return Yt(t2) !== 1;
  }
};
function ir(e, t2, r2, n2) {
  let i2 = t2, o = e.ZERO, s = e.ZERO;
  for (; r2 > yt || n2 > yt; )
    r2 & at && (o = o.add(i2)), n2 & at && (s = s.add(i2)), i2 = i2.double(), r2 >>= at, n2 >>= at;
  return { p1: o, p2: s };
}
function pe(e, t2, r2) {
  if (t2) {
    if (t2.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Jn(t2), t2;
  } else
    return qt(e, { isLE: r2 });
}
function or(e, t2, r2 = {}, n2) {
  if (n2 === void 0 && (n2 = e === "edwards"), !t2 || typeof t2 != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const a = t2[c];
    if (!(typeof a == "bigint" && a > yt))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const i2 = pe(t2.p, r2.Fp, n2), o = pe(t2.n, r2.Fn, n2), f = ["Gx", "Gy", "a", "b"];
  for (const c of f)
    if (!i2.isValid(t2[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t2 = Object.freeze(Object.assign({}, t2)), { CURVE: t2, Fp: i2, Fn: o };
}
function Ye(e, t2) {
  return function(n2) {
    const i2 = e(n2);
    return { secretKey: i2, publicKey: t2(i2) };
  };
}
var je = class {
  constructor(t2, r2) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    if (Oe(t2), _(r2, void 0, "key"), this.iHash = t2.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n2 = this.blockLen, i2 = new Uint8Array(n2);
    i2.set(r2.length > n2 ? t2.create().update(r2).digest() : r2);
    for (let o = 0; o < i2.length; o++)
      i2[o] ^= 54;
    this.iHash.update(i2), this.oHash = t2.create();
    for (let o = 0; o < i2.length; o++)
      i2[o] ^= 106;
    this.oHash.update(i2), Ut(i2);
  }
  update(t2) {
    return It(this), this.iHash.update(t2), this;
  }
  digestInto(t2) {
    It(this), _(t2, this.outputLen, "output"), this.finished = true, this.iHash.digestInto(t2), this.oHash.update(t2), this.oHash.digestInto(t2), this.destroy();
  }
  digest() {
    const t2 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t2), t2;
  }
  _cloneInto(t2) {
    t2 || (t2 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r2, iHash: n2, finished: i2, destroyed: o, blockLen: s, outputLen: f } = this;
    return t2 = t2, t2.finished = i2, t2.destroyed = o, t2.blockLen = s, t2.outputLen = f, t2.oHash = r2._cloneInto(t2.oHash), t2.iHash = n2._cloneInto(t2.iHash), t2;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var ze = (e, t2, r2) => new je(e, t2).update(r2).digest();
ze.create = (e, t2) => new je(e, t2);
var me = (e, t2) => (e + (e >= 0 ? t2 : -t2) / Fe) / t2;
function sr(e, t2, r2) {
  const [[n2, i2], [o, s]] = t2, f = me(s * e, r2), c = me(-i2 * e, r2);
  let a = e - f * n2 - c * o, h = -f * i2 - c * s;
  const b = a < J, m = h < J;
  b && (a = -a), m && (h = -h);
  const y = re(Math.ceil(Xn(r2) / 2)) + bt;
  if (a < J || a >= y || h < J || h >= y)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: b, k1: a, k2neg: m, k2: h };
}
function Gt(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function jt(e, t2) {
  const r2 = {};
  for (let n2 of Object.keys(t2))
    r2[n2] = e[n2] === void 0 ? t2[n2] : e[n2];
  return Nt(r2.lowS, "lowS"), Nt(r2.prehash, "prehash"), r2.format !== void 0 && Gt(r2.format), r2;
}
var fr = class extends Error {
  constructor(t2 = "") {
    super(t2);
  }
};
var rt = {
  // asn.1 DER encoding utils
  Err: fr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t2) => {
      const { Err: r2 } = rt;
      if (e < 0 || e > 256)
        throw new r2("tlv.encode: wrong tag");
      if (t2.length & 1)
        throw new r2("tlv.encode: unpadded data");
      const n2 = t2.length / 2, i2 = St(n2);
      if (i2.length / 2 & 128)
        throw new r2("tlv.encode: long form length too big");
      const o = n2 > 127 ? St(i2.length / 2 | 128) : "";
      return St(e) + o + i2 + t2;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t2) {
      const { Err: r2 } = rt;
      let n2 = 0;
      if (e < 0 || e > 256)
        throw new r2("tlv.encode: wrong tag");
      if (t2.length < 2 || t2[n2++] !== e)
        throw new r2("tlv.decode: wrong tlv");
      const i2 = t2[n2++], o = !!(i2 & 128);
      let s = 0;
      if (!o)
        s = i2;
      else {
        const c = i2 & 127;
        if (!c)
          throw new r2("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new r2("tlv.decode(long): byte length is too big");
        const a = t2.subarray(n2, n2 + c);
        if (a.length !== c)
          throw new r2("tlv.decode: length bytes not complete");
        if (a[0] === 0)
          throw new r2("tlv.decode(long): zero leftmost byte");
        for (const h of a)
          s = s << 8 | h;
        if (n2 += c, s < 128)
          throw new r2("tlv.decode(long): not minimal encoding");
      }
      const f = t2.subarray(n2, n2 + s);
      if (f.length !== s)
        throw new r2("tlv.decode: wrong value length");
      return { v: f, l: t2.subarray(n2 + s) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t2 } = rt;
      if (e < J)
        throw new t2("integer: negative integers are not allowed");
      let r2 = St(e);
      if (Number.parseInt(r2[0], 16) & 8 && (r2 = "00" + r2), r2.length & 1)
        throw new t2("unexpected DER parsing assertion: unpadded hex");
      return r2;
    },
    decode(e) {
      const { Err: t2 } = rt;
      if (e[0] & 128)
        throw new t2("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t2("invalid signature integer: unnecessary leading zero");
      return xt(e);
    }
  },
  toSig(e) {
    const { Err: t2, _int: r2, _tlv: n2 } = rt, i2 = _(e, void 0, "signature"), { v: o, l: s } = n2.decode(48, i2);
    if (s.length)
      throw new t2("invalid signature: left bytes after parsing");
    const { v: f, l: c } = n2.decode(2, o), { v: a, l: h } = n2.decode(2, c);
    if (h.length)
      throw new t2("invalid signature: left bytes after parsing");
    return { r: r2.decode(f), s: r2.decode(a) };
  },
  hexFromSig(e) {
    const { _tlv: t2, _int: r2 } = rt, n2 = t2.encode(2, r2.encode(e.r)), i2 = t2.encode(2, r2.encode(e.s)), o = n2 + i2;
    return t2.encode(48, o);
  }
};
var J = BigInt(0);
var bt = BigInt(1);
var Fe = BigInt(2);
var At = BigInt(3);
var cr = BigInt(4);
function ar(e, t2 = {}) {
  const r2 = or("weierstrass", e, t2), { Fp: n2, Fn: i2 } = r2;
  let o = r2.CURVE;
  const { h: s, n: f } = o;
  ie(t2, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: c } = t2;
  if (c && (!n2.is0(o.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const a = We(n2, i2);
  function h() {
    if (!n2.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function b(U, l, u) {
    const { x: d, y: g } = l.toAffine(), x = n2.toBytes(d);
    if (Nt(u, "isCompressed"), u) {
      h();
      const B = !n2.isOdd(g);
      return W(Ge(B), x);
    } else
      return W(Uint8Array.of(4), x, n2.toBytes(g));
  }
  function m(U) {
    _(U, void 0, "Point");
    const { publicKey: l, publicKeyUncompressed: u } = a, d = U.length, g = U[0], x = U.subarray(1);
    if (d === l && (g === 2 || g === 3)) {
      const B = n2.fromBytes(x);
      if (!n2.isValid(B))
        throw new Error("bad point: is not on curve, wrong x");
      const v = O(B);
      let p;
      try {
        p = n2.sqrt(v);
      } catch (C2) {
        const k = C2 instanceof Error ? ": " + C2.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + k);
      }
      h();
      const S2 = n2.isOdd(p);
      return (g & 1) === 1 !== S2 && (p = n2.neg(p)), { x: B, y: p };
    } else if (d === u && g === 4) {
      const B = n2.BYTES, v = n2.fromBytes(x.subarray(0, B)), p = n2.fromBytes(x.subarray(B, B * 2));
      if (!A(v, p))
        throw new Error("bad point: is not on curve");
      return { x: v, y: p };
    } else
      throw new Error(`bad point: got length ${d}, expected compressed=${l} or uncompressed=${u}`);
  }
  const y = t2.toBytes || b, E = t2.fromBytes || m;
  function O(U) {
    const l = n2.sqr(U), u = n2.mul(l, U);
    return n2.add(n2.add(u, n2.mul(U, o.a)), o.b);
  }
  function A(U, l) {
    const u = n2.sqr(l), d = O(U);
    return n2.eql(u, d);
  }
  if (!A(o.Gx, o.Gy))
    throw new Error("bad curve params: generator point");
  const T = n2.mul(n2.pow(o.a, At), cr), q = n2.mul(n2.sqr(o.b), BigInt(27));
  if (n2.is0(n2.add(T, q)))
    throw new Error("bad curve params: a or b");
  function Z(U, l, u = false) {
    if (!n2.isValid(l) || u && n2.is0(l))
      throw new Error(`bad point coordinate ${U}`);
    return l;
  }
  function L3(U) {
    if (!(U instanceof N2))
      throw new Error("Weierstrass Point expected");
  }
  function j(U) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return sr(U, c.basises, i2.ORDER);
  }
  const tt = le((U, l) => {
    const { X: u, Y: d, Z: g } = U;
    if (n2.eql(g, n2.ONE))
      return { x: u, y: d };
    const x = U.is0();
    l == null && (l = x ? n2.ONE : n2.inv(g));
    const B = n2.mul(u, l), v = n2.mul(d, l), p = n2.mul(g, l);
    if (x)
      return { x: n2.ZERO, y: n2.ZERO };
    if (!n2.eql(p, n2.ONE))
      throw new Error("invZ was invalid");
    return { x: B, y: v };
  }), Ct = le((U) => {
    if (U.is0()) {
      if (t2.allowInfinityPoint && !n2.is0(U.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: l, y: u } = U.toAffine();
    if (!n2.isValid(l) || !n2.isValid(u))
      throw new Error("bad point: x or y not field elements");
    if (!A(l, u))
      throw new Error("bad point: equation left != right");
    if (!U.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function gt(U, l, u, d, g) {
    return u = new N2(n2.mul(u.X, U), u.Y, u.Z), l = Tt(d, l), u = Tt(g, u), l.add(u);
  }
  const _N = class _N {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(l, u, d) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      this.X = Z("x", l), this.Y = Z("y", u, true), this.Z = Z("z", d), Object.freeze(this);
    }
    static CURVE() {
      return o;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(l) {
      const { x: u, y: d } = l || {};
      if (!l || !n2.isValid(u) || !n2.isValid(d))
        throw new Error("invalid affine point");
      if (l instanceof _N)
        throw new Error("projective point not allowed");
      return n2.is0(u) && n2.is0(d) ? _N.ZERO : new _N(u, d, n2.ONE);
    }
    static fromBytes(l) {
      const u = _N.fromAffine(E(_(l, void 0, "point")));
      return u.assertValidity(), u;
    }
    static fromHex(l) {
      return _N.fromBytes(Pt(l));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(l = 8, u = true) {
      return it2.createCache(this, l), u || this.multiply(At), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      Ct(this);
    }
    hasEvenY() {
      const { y: l } = this.toAffine();
      if (!n2.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n2.isOdd(l);
    }
    /** Compare one point to another. */
    equals(l) {
      L3(l);
      const { X: u, Y: d, Z: g } = this, { X: x, Y: B, Z: v } = l, p = n2.eql(n2.mul(u, v), n2.mul(x, g)), S2 = n2.eql(n2.mul(d, v), n2.mul(B, g));
      return p && S2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _N(this.X, n2.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: l, b: u } = o, d = n2.mul(u, At), { X: g, Y: x, Z: B } = this;
      let v = n2.ZERO, p = n2.ZERO, S2 = n2.ZERO, R = n2.mul(g, g), C2 = n2.mul(x, x), k = n2.mul(B, B), I2 = n2.mul(g, x);
      return I2 = n2.add(I2, I2), S2 = n2.mul(g, B), S2 = n2.add(S2, S2), v = n2.mul(l, S2), p = n2.mul(d, k), p = n2.add(v, p), v = n2.sub(C2, p), p = n2.add(C2, p), p = n2.mul(v, p), v = n2.mul(I2, v), S2 = n2.mul(d, S2), k = n2.mul(l, k), I2 = n2.sub(R, k), I2 = n2.mul(l, I2), I2 = n2.add(I2, S2), S2 = n2.add(R, R), R = n2.add(S2, R), R = n2.add(R, k), R = n2.mul(R, I2), p = n2.add(p, R), k = n2.mul(x, B), k = n2.add(k, k), R = n2.mul(k, I2), v = n2.sub(v, R), S2 = n2.mul(k, C2), S2 = n2.add(S2, S2), S2 = n2.add(S2, S2), new _N(v, p, S2);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(l) {
      L3(l);
      const { X: u, Y: d, Z: g } = this, { X: x, Y: B, Z: v } = l;
      let p = n2.ZERO, S2 = n2.ZERO, R = n2.ZERO;
      const C2 = o.a, k = n2.mul(o.b, At);
      let I2 = n2.mul(u, x), H = n2.mul(d, B), $ = n2.mul(g, v), F2 = n2.add(u, d), K2 = n2.add(x, B);
      F2 = n2.mul(F2, K2), K2 = n2.add(I2, H), F2 = n2.sub(F2, K2), K2 = n2.add(u, g);
      let V = n2.add(x, v);
      return K2 = n2.mul(K2, V), V = n2.add(I2, $), K2 = n2.sub(K2, V), V = n2.add(d, g), p = n2.add(B, v), V = n2.mul(V, p), p = n2.add(H, $), V = n2.sub(V, p), R = n2.mul(C2, K2), p = n2.mul(k, $), R = n2.add(p, R), p = n2.sub(H, R), R = n2.add(H, R), S2 = n2.mul(p, R), H = n2.add(I2, I2), H = n2.add(H, I2), $ = n2.mul(C2, $), K2 = n2.mul(k, K2), H = n2.add(H, $), $ = n2.sub(I2, $), $ = n2.mul(C2, $), K2 = n2.add(K2, $), I2 = n2.mul(H, K2), S2 = n2.add(S2, I2), I2 = n2.mul(V, K2), p = n2.mul(F2, p), p = n2.sub(p, I2), I2 = n2.mul(F2, H), R = n2.mul(V, R), R = n2.add(R, I2), new _N(p, S2, R);
    }
    subtract(l) {
      return this.add(l.negate());
    }
    is0() {
      return this.equals(_N.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(l) {
      const { endo: u } = t2;
      if (!i2.isValidNot0(l))
        throw new Error("invalid scalar: out of range");
      let d, g;
      const x = (B) => it2.cached(this, B, (v) => ye(_N, v));
      if (u) {
        const { k1neg: B, k1: v, k2neg: p, k2: S2 } = j(l), { p: R, f: C2 } = x(v), { p: k, f: I2 } = x(S2);
        g = C2.add(I2), d = gt(u.beta, R, k, B, p);
      } else {
        const { p: B, f: v } = x(l);
        d = B, g = v;
      }
      return ye(_N, [d, g])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(l) {
      const { endo: u } = t2, d = this;
      if (!i2.isValid(l))
        throw new Error("invalid scalar: out of range");
      if (l === J || d.is0())
        return _N.ZERO;
      if (l === bt)
        return d;
      if (it2.hasCache(this))
        return this.multiply(l);
      if (u) {
        const { k1neg: g, k1: x, k2neg: B, k2: v } = j(l), { p1: p, p2: S2 } = ir(_N, d, x, v);
        return gt(u.beta, p, S2, g, B);
      } else
        return it2.unsafe(d, l);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(l) {
      return tt(this, l);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: l } = t2;
      return s === bt ? true : l ? l(_N, this) : it2.unsafe(this, f).is0();
    }
    clearCofactor() {
      const { clearCofactor: l } = t2;
      return s === bt ? this : l ? l(_N, this) : this.multiplyUnsafe(s);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(s).is0();
    }
    toBytes(l = true) {
      return Nt(l, "isCompressed"), this.assertValidity(), y(_N, this, l);
    }
    toHex(l = true) {
      return Ht(this.toBytes(l));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_N, "BASE", new _N(o.Gx, o.Gy, n2.ONE));
  // zero / infinity / identity point
  __publicField(_N, "ZERO", new _N(n2.ZERO, n2.ONE, n2.ZERO));
  // 0, 1, 0
  // math field
  __publicField(_N, "Fp", n2);
  // scalar field
  __publicField(_N, "Fn", i2);
  let N2 = _N;
  const vt = i2.BITS, it2 = new rr(N2, t2.endo ? Math.ceil(vt / 2) : vt);
  return N2.BASE.precompute(8), N2;
}
function Ge(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function We(e, t2) {
  return {
    secretKey: t2.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * t2.BYTES
  };
}
function dr(e, t2 = {}) {
  const { Fn: r2 } = e, n2 = t2.randomBytes || Kt, i2 = Object.assign(We(e.Fp, r2), { seed: Ve(r2.ORDER) });
  function o(y) {
    try {
      const E = r2.fromBytes(y);
      return r2.isValidNot0(E);
    } catch {
      return false;
    }
  }
  function s(y, E) {
    const { publicKey: O, publicKeyUncompressed: A } = i2;
    try {
      const T = y.length;
      return E === true && T !== O || E === false && T !== A ? false : !!e.fromBytes(y);
    } catch {
      return false;
    }
  }
  function f(y = n2(i2.seed)) {
    return De(_(y, i2.seed, "seed"), r2.ORDER);
  }
  function c(y, E = true) {
    return e.BASE.multiply(r2.fromBytes(y)).toBytes(E);
  }
  function a(y) {
    const { secretKey: E, publicKey: O, publicKeyUncompressed: A } = i2;
    if (!te(y) || "_lengths" in r2 && r2._lengths || E === O)
      return;
    const T = _(y, void 0, "key").length;
    return T === O || T === A;
  }
  function h(y, E, O = true) {
    if (a(y) === true)
      throw new Error("first arg must be private key");
    if (a(E) === false)
      throw new Error("second arg must be public key");
    const A = r2.fromBytes(y);
    return e.fromBytes(E).multiply(A).toBytes(O);
  }
  const b = {
    isValidSecretKey: o,
    isValidPublicKey: s,
    randomSecretKey: f
  }, m = Ye(f, c);
  return Object.freeze({ getPublicKey: c, getSharedSecret: h, keygen: m, Point: e, utils: b, lengths: i2 });
}
function ur(e, t2, r2 = {}) {
  Oe(t2), ie(r2, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r2 = Object.assign({}, r2);
  const n2 = r2.randomBytes || Kt, i2 = r2.hmac || ((u, d) => ze(t2, u, d)), { Fp: o, Fn: s } = e, { ORDER: f, BITS: c } = s, { keygen: a, getPublicKey: h, getSharedSecret: b, utils: m, lengths: y } = dr(e, r2), E = {
    prehash: true,
    lowS: typeof r2.lowS == "boolean" ? r2.lowS : true,
    format: "compact",
    extraEntropy: false
  }, O = f * Fe < o.ORDER;
  function A(u) {
    const d = f >> bt;
    return u > d;
  }
  function T(u, d) {
    if (!s.isValidNot0(d))
      throw new Error(`invalid signature ${u}: out of range 1..Point.Fn.ORDER`);
    return d;
  }
  function q() {
    if (O)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function Z(u, d) {
    Gt(d);
    const g = y.signature, x = d === "compact" ? g : d === "recovered" ? g + 1 : void 0;
    return _(u, x);
  }
  class L3 {
    constructor(d, g, x) {
      __publicField(this, "r");
      __publicField(this, "s");
      __publicField(this, "recovery");
      if (this.r = T("r", d), this.s = T("s", g), x != null) {
        if (q(), ![0, 1, 2, 3].includes(x))
          throw new Error("invalid recovery id");
        this.recovery = x;
      }
      Object.freeze(this);
    }
    static fromBytes(d, g = E.format) {
      Z(d, g);
      let x;
      if (g === "der") {
        const { r: S2, s: R } = rt.toSig(_(d));
        return new L3(S2, R);
      }
      g === "recovered" && (x = d[0], g = "compact", d = d.subarray(1));
      const B = y.signature / 2, v = d.subarray(0, B), p = d.subarray(B, B * 2);
      return new L3(s.fromBytes(v), s.fromBytes(p), x);
    }
    static fromHex(d, g) {
      return this.fromBytes(Pt(d), g);
    }
    assertRecovery() {
      const { recovery: d } = this;
      if (d == null)
        throw new Error("invalid recovery id: must be present");
      return d;
    }
    addRecoveryBit(d) {
      return new L3(this.r, this.s, d);
    }
    recoverPublicKey(d) {
      const { r: g, s: x } = this, B = this.assertRecovery(), v = B === 2 || B === 3 ? g + f : g;
      if (!o.isValid(v))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const p = o.toBytes(v), S2 = e.fromBytes(W(Ge((B & 1) === 0), p)), R = s.inv(v), C2 = tt(_(d, void 0, "msgHash")), k = s.create(-C2 * R), I2 = s.create(x * R), H = e.BASE.multiplyUnsafe(k).add(S2.multiplyUnsafe(I2));
      if (H.is0())
        throw new Error("invalid recovery: point at infinify");
      return H.assertValidity(), H;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return A(this.s);
    }
    toBytes(d = E.format) {
      if (Gt(d), d === "der")
        return Pt(rt.hexFromSig(this));
      const { r: g, s: x } = this, B = s.toBytes(g), v = s.toBytes(x);
      return d === "recovered" ? (q(), W(Uint8Array.of(this.assertRecovery()), B, v)) : W(B, v);
    }
    toHex(d) {
      return Ht(this.toBytes(d));
    }
  }
  const j = r2.bits2int || function(d) {
    if (d.length > 8192)
      throw new Error("input is too large");
    const g = xt(d), x = d.length * 8 - c;
    return x > 0 ? g >> BigInt(x) : g;
  }, tt = r2.bits2int_modN || function(d) {
    return s.create(j(d));
  }, Ct = re(c);
  function gt(u) {
    return Mn("num < 2^" + c, u, J, Ct), s.toBytes(u);
  }
  function N2(u, d) {
    return _(u, void 0, "message"), d ? _(t2(u), void 0, "prehashed message") : u;
  }
  function vt(u, d, g) {
    const { lowS: x, prehash: B, extraEntropy: v } = jt(g, E);
    u = N2(u, B);
    const p = tt(u), S2 = s.fromBytes(d);
    if (!s.isValidNot0(S2))
      throw new Error("invalid private key");
    const R = [gt(S2), gt(p)];
    if (v != null && v !== false) {
      const H = v === true ? n2(y.secretKey) : v;
      R.push(_(H, void 0, "extraEntropy"));
    }
    const C2 = W(...R), k = p;
    function I2(H) {
      const $ = j(H);
      if (!s.isValidNot0($))
        return;
      const F2 = s.inv($), K2 = e.BASE.multiply($).toAffine(), V = s.create(K2.x);
      if (V === J)
        return;
      const Bt = s.create(F2 * s.create(k + V * S2));
      if (Bt === J)
        return;
      let ce = (K2.x === V ? 0 : 2) | Number(K2.y & bt), ae = Bt;
      return x && A(Bt) && (ae = s.neg(Bt), ce ^= 1), new L3(V, ae, O ? void 0 : ce);
    }
    return { seed: C2, k2sig: I2 };
  }
  function it2(u, d, g = {}) {
    const { seed: x, k2sig: B } = vt(u, d, g);
    return Yn(t2.outputLen, s.BYTES, i2)(x, B).toBytes(g.format);
  }
  function U(u, d, g, x = {}) {
    const { lowS: B, prehash: v, format: p } = jt(x, E);
    if (g = _(g, void 0, "publicKey"), d = N2(d, v), !te(u)) {
      const S2 = u instanceof L3 ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + S2);
    }
    Z(u, p);
    try {
      const S2 = L3.fromBytes(u, p), R = e.fromBytes(g);
      if (B && S2.hasHighS())
        return false;
      const { r: C2, s: k } = S2, I2 = tt(d), H = s.inv(k), $ = s.create(I2 * H), F2 = s.create(C2 * H), K2 = e.BASE.multiplyUnsafe($).add(R.multiplyUnsafe(F2));
      return K2.is0() ? false : s.create(K2.x) === C2;
    } catch {
      return false;
    }
  }
  function l(u, d, g = {}) {
    const { prehash: x } = jt(g, E);
    return d = N2(d, x), L3.fromBytes(u, "recovered").recoverPublicKey(d).toBytes();
  }
  return Object.freeze({
    keygen: a,
    getPublicKey: h,
    getSharedSecret: b,
    utils: m,
    lengths: y,
    Point: e,
    sign: it2,
    verify: U,
    recoverPublicKey: l,
    Signature: L3,
    hash: t2
  });
}
var Zt = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var lr = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var hr = BigInt(0);
var Wt = BigInt(2);
function br(e) {
  const t2 = Zt.p, r2 = BigInt(3), n2 = BigInt(6), i2 = BigInt(11), o = BigInt(22), s = BigInt(23), f = BigInt(44), c = BigInt(88), a = e * e * e % t2, h = a * a * e % t2, b = z(h, r2, t2) * h % t2, m = z(b, r2, t2) * h % t2, y = z(m, Wt, t2) * a % t2, E = z(y, i2, t2) * y % t2, O = z(E, o, t2) * E % t2, A = z(O, f, t2) * O % t2, T = z(A, c, t2) * A % t2, q = z(T, f, t2) * O % t2, Z = z(q, r2, t2) * h % t2, L3 = z(Z, s, t2) * E % t2, j = z(L3, n2, t2) * a % t2, tt = z(j, Wt, t2);
  if (!_t2.eql(_t2.sqr(tt), e))
    throw new Error("Cannot find square root");
  return tt;
}
var _t2 = qt(Zt.p, { sqrt: br });
var ut = ar(Zt, {
  Fp: _t2,
  endo: lr
});
var ft = ur(ut, Et);
var Ee = {};
function kt(e, ...t2) {
  let r2 = Ee[e];
  if (r2 === void 0) {
    const n2 = Et(Vn(e));
    r2 = W(n2, n2), Ee[e] = r2;
  }
  return Et(W(r2, ...t2));
}
var se = (e) => e.toBytes(true).slice(1);
var fe = (e) => e % Wt === hr;
function Qt(e) {
  const { Fn: t2, BASE: r2 } = ut, n2 = t2.fromBytes(e), i2 = r2.multiply(n2);
  return { scalar: fe(i2.y) ? n2 : t2.neg(n2), bytes: se(i2) };
}
function Qe(e) {
  const t2 = _t2;
  if (!t2.isValidNot0(e))
    throw new Error("invalid x: Fail if x  p");
  const r2 = t2.create(e * e), n2 = t2.create(r2 * e + BigInt(7));
  let i2 = t2.sqrt(n2);
  fe(i2) || (i2 = t2.neg(i2));
  const o = ut.fromAffine({ x: e, y: i2 });
  return o.assertValidity(), o;
}
var mt = xt;
function Je(...e) {
  return ut.Fn.create(mt(kt("BIP0340/challenge", ...e)));
}
function xe(e) {
  return Qt(e).bytes;
}
function yr(e, t2, r2 = Kt(32)) {
  const { Fn: n2 } = ut, i2 = _(e, void 0, "message"), { bytes: o, scalar: s } = Qt(t2), f = _(r2, 32, "auxRand"), c = n2.toBytes(s ^ mt(kt("BIP0340/aux", f))), a = kt("BIP0340/nonce", c, o, i2), { bytes: h, scalar: b } = Qt(a), m = Je(h, o, i2), y = new Uint8Array(64);
  if (y.set(h, 0), y.set(n2.toBytes(n2.create(b + m * s)), 32), !tn(y, i2, o))
    throw new Error("sign: Invalid signature produced");
  return y;
}
function tn(e, t2, r2) {
  const { Fp: n2, Fn: i2, BASE: o } = ut, s = _(e, 64, "signature"), f = _(t2, void 0, "message"), c = _(r2, 32, "publicKey");
  try {
    const a = Qe(mt(c)), h = mt(s.subarray(0, 32));
    if (!n2.isValidNot0(h))
      return false;
    const b = mt(s.subarray(32, 64));
    if (!i2.isValidNot0(b))
      return false;
    const m = Je(i2.toBytes(h), se(a), f), y = o.multiplyUnsafe(b).add(a.multiplyUnsafe(i2.neg(m))), { x: E, y: O } = y.toAffine();
    return !(y.is0() || !fe(O) || E !== h);
  } catch {
    return false;
  }
}
var pt = (() => {
  const r2 = (n2 = Kt(48)) => De(n2, Zt.n);
  return {
    keygen: Ye(r2, xe),
    getPublicKey: xe,
    sign: yr,
    verify: tn,
    Point: ut,
    utils: {
      randomSecretKey: r2,
      taggedHash: kt,
      lift_x: Qe,
      pointToBytes: se
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: false,
      signature: 64,
      seed: 48
    }
  };
})();
var ht = ft.Point;
var Ot = ht.Fn.ORDER;
function ve(e) {
  const t2 = e.toString(16).padStart(64, "0"), r2 = new Uint8Array(32);
  for (let n2 = 0; n2 < 32; n2++)
    r2[n2] = parseInt(t2.slice(n2 * 2, n2 * 2 + 2), 16);
  return r2;
}
function ot(e) {
  let t2 = 0n;
  for (let r2 = 0; r2 < e.length; r2++)
    t2 = t2 << 8n | BigInt(e[r2]);
  return t2;
}
var gr = class {
  /** @inheritDoc */
  isPrivate(t2) {
    return ft.utils.isValidSecretKey(t2);
  }
  /** @inheritDoc */
  isPoint(t2) {
    try {
      return ht.fromHex(wt(t2)), true;
    } catch {
      return false;
    }
  }
  /** @inheritDoc */
  isXOnlyPoint(t2) {
    if (t2.length !== 32) return false;
    try {
      return pt.utils.lift_x(ot(t2)), true;
    } catch {
      return false;
    }
  }
  /** @inheritDoc */
  pointFromScalar(t2, r2) {
    try {
      return ft.getPublicKey(t2, r2 ?? true);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  pointCompress(t2, r2) {
    return ht.fromHex(wt(t2)).toBytes(r2 ?? true);
  }
  /** @inheritDoc */
  pointAddScalar(t2, r2, n2) {
    try {
      const i2 = ht.fromHex(wt(t2));
      if (ot(r2) === 0n)
        return i2.toBytes(n2 ?? true);
      const s = ft.getPublicKey(r2, true), f = ht.fromHex(wt(s));
      return i2.add(f).toBytes(n2 ?? true);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t2, r2) {
    try {
      const n2 = pt.utils.lift_x(ot(t2));
      if (ot(r2) >= Ot) return null;
      const o = ft.getPublicKey(r2, true), s = ht.fromHex(wt(o)), f = n2.add(s), c = pt.utils.pointToBytes(f);
      return {
        parity: Number(f.y & 1n),
        xOnlyPubkey: c
      };
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  privateAdd(t2, r2) {
    const n2 = ot(t2), i2 = ot(r2), o = Y(n2 + i2, Ot);
    return o === 0n ? null : ve(o);
  }
  /** @inheritDoc */
  privateNegate(t2) {
    const r2 = ot(t2), n2 = Y(Ot - r2, Ot);
    return ve(n2);
  }
  /** @inheritDoc */
  sign(t2, r2, n2) {
    return ft.sign(t2, r2, {
      prehash: false,
      lowS: true,
      extraEntropy: n2 ?? false
    });
  }
  /** @inheritDoc */
  verify(t2, r2, n2) {
    return ft.verify(n2, t2, r2, {
      prehash: false,
      lowS: true
    });
  }
  /** @inheritDoc */
  signSchnorr(t2, r2, n2) {
    return pt.sign(t2, r2, n2);
  }
  /** @inheritDoc */
  verifySchnorr(t2, r2, n2) {
    return pt.verify(n2, t2, r2);
  }
};
function Nr() {
  return new gr();
}
var _t3;
var wr = class {
  /**
   * @param ecc - Object implementing the {@link TinySecp256k1Interface}.
   */
  constructor(t2) {
    __privateAdd(this, _t3);
    __privateSet(this, _t3, t2);
  }
  /** `true` when the underlying library supports Schnorr signing. */
  get hasSchnorrSign() {
    return typeof __privateGet(this, _t3).signSchnorr == "function";
  }
  /** `true` when the underlying library supports Schnorr verification. */
  get hasSchnorrVerify() {
    return typeof __privateGet(this, _t3).verifySchnorr == "function";
  }
  /** @inheritDoc */
  isPrivate(t2) {
    return __privateGet(this, _t3).isPrivate(t2);
  }
  /** @inheritDoc */
  isPoint(t2) {
    return __privateGet(this, _t3).isPoint(t2);
  }
  /** @inheritDoc */
  isXOnlyPoint(t2) {
    if (t2.length !== 32) return false;
    const r2 = new Uint8Array(33);
    return r2[0] = 2, r2.set(t2, 1), __privateGet(this, _t3).isPoint(r2);
  }
  /** @inheritDoc */
  pointFromScalar(t2, r2) {
    return __privateGet(this, _t3).pointFromScalar(t2, r2);
  }
  /** @inheritDoc */
  pointCompress(t2, r2) {
    return __privateGet(this, _t3).pointCompress(t2, r2);
  }
  /** @inheritDoc */
  pointAddScalar(t2, r2, n2) {
    return __privateGet(this, _t3).pointAddScalar(t2, r2, n2);
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t2, r2) {
    const n2 = __privateGet(this, _t3).xOnlyPointAddTweak(t2, r2);
    return n2 === null ? null : {
      parity: n2.parity,
      xOnlyPubkey: n2.xOnlyPubkey
    };
  }
  /** @inheritDoc */
  privateAdd(t2, r2) {
    return __privateGet(this, _t3).privateAdd(t2, r2);
  }
  /** @inheritDoc */
  privateNegate(t2) {
    return __privateGet(this, _t3).privateNegate(t2);
  }
  /** @inheritDoc */
  sign(t2, r2, n2) {
    return __privateGet(this, _t3).sign(t2, r2, n2);
  }
  /** @inheritDoc */
  verify(t2, r2, n2) {
    return __privateGet(this, _t3).verify(t2, r2, n2);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `signSchnorr`.
   */
  signSchnorr(t2, r2, n2) {
    if (!__privateGet(this, _t3).signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return __privateGet(this, _t3).signSchnorr(t2, r2, n2);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `verifySchnorr`.
   */
  verifySchnorr(t2, r2, n2) {
    if (!__privateGet(this, _t3).verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return __privateGet(this, _t3).verifySchnorr(t2, r2, n2);
  }
};
_t3 = new WeakMap();
function Tr(e) {
  return new wr(e);
}
function w(e) {
  return en(e);
}
function P$1(e, t2) {
  if (!e) throw new Error(`verifyCryptoBackend: ${t2}`);
}
function _r2(e) {
  P$1(
    e.isPoint(w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPoint should accept generator point"
  ), P$1(
    !e.isPoint(w("030000000000000000000000000000000000000000000000000000000000000005")),
    "isPoint should reject invalid point"
  ), P$1(
    e.isXOnlyPoint(
      w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "isXOnlyPoint should accept generator x-coordinate"
  ), P$1(
    !e.isXOnlyPoint(
      w("0000000000000000000000000000000000000000000000000000000000000005")
    ),
    "isXOnlyPoint should reject x-coordinate not on curve"
  ), P$1(
    !e.isXOnlyPoint(
      w("0000000000000000000000000000000000000000000000000000000000000000")
    ),
    "isXOnlyPoint should reject zero"
  ), P$1(
    !e.isXOnlyPoint(w("79be667ef9dcbbac55a06295ce870b07")),
    "isXOnlyPoint should reject wrong length"
  ), P$1(
    e.isPrivate(w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPrivate should accept valid scalar"
  ), P$1(
    e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")),
    "isPrivate should accept n-1"
  ), P$1(
    !e.isPrivate(w("0000000000000000000000000000000000000000000000000000000000000000")),
    "isPrivate should reject zero"
  ), P$1(
    !e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")),
    "isPrivate should reject n"
  ), P$1(
    !e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")),
    "isPrivate should reject n+1"
  );
  const t2 = e.privateAdd(
    w("0000000000000000000000000000000000000000000000000000000000000001"),
    w("0000000000000000000000000000000000000000000000000000000000000000")
  );
  P$1(
    t2 !== null && M(
      t2,
      w("0000000000000000000000000000000000000000000000000000000000000001")
    ),
    "privateAdd: 1 + 0 should equal 1"
  ), P$1(
    e.privateAdd(
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      w("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null,
    "privateAdd: (n-3) + 3 should return null (result is zero mod n)"
  );
  const r2 = e.privateAdd(
    w("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
    w("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
  );
  P$1(
    r2 !== null && M(
      r2,
      w("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    ),
    "privateAdd: known vector failed"
  ), P$1(
    M(
      e.privateNegate(
        w("0000000000000000000000000000000000000000000000000000000000000001")
      ),
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ),
    "privateNegate(1) should equal n-1"
  ), P$1(
    M(
      e.privateNegate(
        w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      ),
      w("0000000000000000000000000000000000000000000000000000000000000003")
    ),
    "privateNegate(n-3) should equal 3"
  ), P$1(
    M(
      e.privateNegate(
        w("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      ),
      w("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    ),
    "privateNegate known vector failed"
  ), P$1(
    M(
      e.pointCompress(
        w(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        true
      ),
      w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress uncompressed->compressed failed"
  ), P$1(
    M(
      e.pointCompress(
        w(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        false
      ),
      w(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress uncompressed->uncompressed failed"
  ), P$1(
    M(
      e.pointCompress(
        w(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        true
      ),
      w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress compressed->compressed failed"
  ), P$1(
    M(
      e.pointCompress(
        w(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        false
      ),
      w(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress compressed->uncompressed failed"
  );
  const n2 = e.pointFromScalar(
    w("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
  );
  P$1(
    n2 !== null && M(
      n2,
      w("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    ),
    "pointFromScalar known vector failed"
  ), P$1(
    e.xOnlyPointAddTweak(
      w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null,
    "xOnlyPointAddTweak should return null for infinity result"
  );
  let i2 = e.xOnlyPointAddTweak(
    w("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    w("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  P$1(
    i2 !== null && M(
      i2.xOnlyPubkey,
      w("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && i2.parity === 1,
    "xOnlyPointAddTweak parity=1 case failed"
  ), i2 = e.xOnlyPointAddTweak(
    w("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    w("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), P$1(
    i2 !== null && M(
      i2.xOnlyPubkey,
      w("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && i2.parity === 0,
    "xOnlyPointAddTweak parity=0 case failed"
  );
  const o = e.sign(
    w("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
    w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
  );
  if (P$1(
    M(
      o,
      w(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    ),
    "sign known vector failed"
  ), P$1(
    e.verify(
      w("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      w("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      o
    ),
    "verify known vector failed"
  ), e.signSchnorr) {
    const s = e.signSchnorr(
      w("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      w("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
      w("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
    );
    P$1(
      M(
        s,
        w(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      ),
      "signSchnorr known vector failed"
    );
  }
  e.verifySchnorr && P$1(
    e.verifySchnorr(
      w(
        "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"
      ),
      w(
        "dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"
      ),
      w(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    ),
    "verifySchnorr known vector failed"
  );
}
var browser$2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  ECPairSigner: st,
  EC_N: Jt,
  EC_P: mr,
  LegacyBackend: wr,
  NobleBackend: gr,
  SATOSHI_MAX: Be,
  SignerCapability: lt,
  assertBytes32: Ae,
  assertMessageHash: un,
  assertPrivateKey: cn,
  assertPublicKey: an,
  assertXOnlyPublicKey: dn,
  bytesEqual: M,
  compareBytes: pr,
  concatBytes: nn,
  createBytes20: Or,
  createBytes32: Ar,
  createLegacyBackend: Tr,
  createMessageHash: Ur,
  createNobleBackend: Nr,
  createPrivateKey: zt,
  createPublicKey: ln,
  createSatoshi: Pr,
  createSchnorrSignature: Ir,
  createSignature: Rr,
  createXOnlyPublicKey: hn,
  decodeWIF: Hn,
  encodeWIF: Ln,
  fromHexInternal: en,
  isBytes20: xr,
  isBytes32: Er,
  isMessageHash: Sr,
  isPrivateKey: vr,
  isPublicKey: rn,
  isSatoshi: fn,
  isSchnorrSignature: sn,
  isSignature: on,
  isXOnlyPublicKey: Br,
  isZeroBytes: Lt,
  toHex: wt,
  verifyCryptoBackend: _r2
}, Symbol.toStringTag, { value: "Module" }));
var _instance, _lib;
var _EccContext = class _EccContext {
  constructor(lib) {
    __privateAdd(this, _lib);
    __privateSet(this, _lib, lib);
  }
  /**
   * The underlying ECC library instance.
   */
  get lib() {
    return __privateGet(this, _lib);
  }
  /**
   * Initializes the ECC context with the provided library.
   * The library is verified before being set as active.
   *
   * @param lib - The CryptoBackend instance to initialize
   * @returns The initialized EccContext instance
   * @throws Error if the CryptoBackend fails verification
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   * import { createNobleBackend } from '@btc-vision/ecpair';
   *
   * const context = EccContext.init(createNobleBackend());
   * ```
   */
  static init(lib) {
    if (__privateGet(_EccContext, _instance) && __privateGet(__privateGet(_EccContext, _instance), _lib) === lib) {
      return __privateGet(_EccContext, _instance);
    }
    _r2(lib);
    __privateSet(_EccContext, _instance, new _EccContext(lib));
    return __privateGet(_EccContext, _instance);
  }
  /**
   * Gets the initialized ECC context.
   *
   * @returns The EccContext instance
   * @throws Error if the context has not been initialized
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * const context = EccContext.get();
   * const tweaked = context.lib.xOnlyPointAddTweak(key, tweak);
   * ```
   */
  static get() {
    if (!__privateGet(_EccContext, _instance)) {
      throw new Error("ECC library not initialized. Call EccContext.init() or initEccLib() first.");
    }
    return __privateGet(_EccContext, _instance);
  }
  /**
   * Clears the ECC context.
   * Useful for testing or when reinitializing with a different library.
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * EccContext.clear();
   * // Context is now uninitialized
   * ```
   */
  static clear() {
    __privateSet(_EccContext, _instance, void 0);
  }
  /**
   * Checks if the ECC context has been initialized.
   *
   * @returns True if initialized
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * if (!EccContext.isInitialized()) {
   *     EccContext.init(createNobleBackend());
   * }
   * ```
   */
  static isInitialized() {
    return __privateGet(_EccContext, _instance) !== void 0;
  }
};
_instance = new WeakMap();
_lib = new WeakMap();
__privateAdd(_EccContext, _instance);
var EccContext = _EccContext;
function initEccLib(eccLib2) {
  if (eccLib2 === void 0) {
    EccContext.clear();
    return;
  }
  EccContext.init(eccLib2);
}
function getEccLib() {
  return EccContext.get().lib;
}
var LEAF_VERSION_TAPSCRIPT = 192;
var MAX_TAPTREE_DEPTH = 128;
var isHashBranch = (ht2) => "left" in ht2 && "right" in ht2;
function rootHashFromPath(controlBlock, leafHash) {
  if (controlBlock.length < 33)
    throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 33.`);
  const m = (controlBlock.length - 33) / 32;
  let kj = leafHash;
  for (let j = 0; j < m; j++) {
    const ej = controlBlock.subarray(33 + 32 * j, 65 + 32 * j);
    if (compare$2(kj, ej) < 0) {
      kj = tapBranchHash(kj, ej);
    } else {
      kj = tapBranchHash(ej, kj);
    }
  }
  return kj;
}
function rootHashFromPathP2MR(controlBlock, leafHash) {
  if (controlBlock.length < 1)
    throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 1.`);
  const m = (controlBlock.length - 1) / 32;
  let kj = leafHash;
  for (let j = 0; j < m; j++) {
    const ej = controlBlock.subarray(1 + 32 * j, 33 + 32 * j);
    if (compare$2(kj, ej) < 0) {
      kj = tapBranchHash(kj, ej);
    } else {
      kj = tapBranchHash(ej, kj);
    }
  }
  return kj;
}
function toHashTree(scriptTree) {
  if (isTapleaf(scriptTree))
    return { hash: tapleafHash(scriptTree) };
  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
  hashes.sort((a, b) => compare$2(a.hash, b.hash));
  const left = hashes[0];
  const right = hashes[1];
  return {
    hash: tapBranchHash(left.hash, right.hash),
    left,
    right
  };
}
function findScriptPath(node, hash2) {
  if (isHashBranch(node)) {
    const leftPath = findScriptPath(node.left, hash2);
    if (leftPath !== void 0)
      return [...leftPath, node.right.hash];
    const rightPath = findScriptPath(node.right, hash2);
    if (rightPath !== void 0)
      return [...rightPath, node.left.hash];
  } else if (equals(node.hash, hash2)) {
    return [];
  }
  return void 0;
}
function tapleafHash(leaf) {
  const version2 = leaf.version || LEAF_VERSION_TAPSCRIPT;
  return taggedHash("TapLeaf", concat$1([new Uint8Array([version2]), serializeScript(leaf.output)]));
}
function tapTweakHash$1(pubKey, h) {
  return taggedHash("TapTweak", h ? concat$1([pubKey, h]) : pubKey);
}
function tweakKey(pubKey, h) {
  if (!(pubKey instanceof Uint8Array))
    return null;
  if (pubKey.length !== 32)
    return null;
  if (h && h.length !== 32)
    return null;
  const tweakHash = tapTweakHash$1(pubKey, h);
  const res = getEccLib().xOnlyPointAddTweak(pubKey, tweakHash);
  if (!res || res.xOnlyPubkey === null)
    return null;
  return {
    parity: res.parity,
    x: new Uint8Array(res.xOnlyPubkey)
  };
}
function tapBranchHash(a, b) {
  return taggedHash("TapBranch", concat$1([a, b]));
}
function serializeScript(s) {
  const varintLen = encodingLength$1(s.length);
  const buffer2 = alloc(varintLen);
  encode$k(s.length, buffer2);
  return concat$1([buffer2, s]);
}
var OPS$6 = opcodes;
var P2MR_WITNESS_VERSION = 2;
var ANNEX_PREFIX$1 = 80;
var _network4, _opts4, _inputAddress4, _inputHash3, _inputScriptTree, _inputOutput4, _inputWitness2, _inputRedeem2, _inputRedeemVersion, _address4, _hash3, _output4, _redeem2, _redeemVersion, _witness3, _addressComputed4, _hashComputed3, _outputComputed4, _redeemComputed2, _redeemVersionComputed, _witnessComputed3, _decodedAddress4, _decodedAddressComputed4, _witnessWithoutAnnex, _witnessWithoutAnnexComputed, _hashTree, _hashTreeComputed, _P2MR_instances, getDecodedAddress_fn4, getWitnessWithoutAnnex_fn, getHashTree_fn, computeAddress_fn4, computeHash_fn3, computeOutput_fn4, computeRedeem_fn2, computeRedeemVersion_fn, computeWitness_fn3, validate_fn4;
var _P2MR = class _P2MR {
  /**
   * Creates a new P2MR payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded address (bc1z...)
   * @param params.hash - Merkle root (32 bytes, = witness program)
   * @param params.scriptTree - Full script tree definition
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack
   * @param params.redeem - Redeem script for script-path spending
   * @param params.redeemVersion - Leaf version (defaults to LEAF_VERSION_TAPSCRIPT)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2MR_instances);
    __privateAdd(this, _network4);
    __privateAdd(this, _opts4);
    __privateAdd(this, _inputAddress4);
    __privateAdd(this, _inputHash3);
    __privateAdd(this, _inputScriptTree);
    __privateAdd(this, _inputOutput4);
    __privateAdd(this, _inputWitness2);
    __privateAdd(this, _inputRedeem2);
    __privateAdd(this, _inputRedeemVersion);
    __privateAdd(this, _address4);
    __privateAdd(this, _hash3);
    __privateAdd(this, _output4);
    __privateAdd(this, _redeem2);
    __privateAdd(this, _redeemVersion);
    __privateAdd(this, _witness3);
    __privateAdd(this, _addressComputed4, false);
    __privateAdd(this, _hashComputed3, false);
    __privateAdd(this, _outputComputed4, false);
    __privateAdd(this, _redeemComputed2, false);
    __privateAdd(this, _redeemVersionComputed, false);
    __privateAdd(this, _witnessComputed3, false);
    __privateAdd(this, _decodedAddress4);
    __privateAdd(this, _decodedAddressComputed4, false);
    __privateAdd(this, _witnessWithoutAnnex);
    __privateAdd(this, _witnessWithoutAnnexComputed, false);
    __privateAdd(this, _hashTree);
    __privateAdd(this, _hashTreeComputed, false);
    __privateSet(this, _network4, params.network ?? bitcoin$1);
    __privateSet(this, _opts4, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputAddress4, params.address);
    __privateSet(this, _inputHash3, params.hash);
    __privateSet(this, _inputScriptTree, params.scriptTree);
    __privateSet(this, _inputOutput4, params.output);
    __privateSet(this, _inputWitness2, params.witness);
    __privateSet(this, _inputRedeem2, params.redeem);
    __privateSet(this, _inputRedeemVersion, params.redeemVersion);
    if (__privateGet(this, _opts4).validate) {
      __privateMethod(this, _P2MR_instances, validate_fn4).call(this);
    }
  }
  /**
   * Payment type discriminant.
   *
   * @returns The P2MR payment type constant.
   */
  get name() {
    return PaymentType.P2MR;
  }
  /**
   * Network parameters used for address encoding.
   *
   * @returns The network configuration (mainnet, testnet, or regtest).
   */
  get network() {
    return __privateGet(this, _network4);
  }
  /**
   * Bech32m encoded address (bc1z... for mainnet).
   *
   * @returns The bech32m-encoded address, or `undefined` if insufficient data.
   */
  get address() {
    if (!__privateGet(this, _addressComputed4)) {
      __privateSet(this, _address4, __privateMethod(this, _P2MR_instances, computeAddress_fn4).call(this));
      __privateSet(this, _addressComputed4, true);
    }
    return __privateGet(this, _address4);
  }
  /**
   * Merkle root hash (32 bytes). This is the witness program and directly
   * appears in the output script.
   *
   * @returns The 32-byte merkle root, or `undefined` if insufficient data.
   */
  get hash() {
    if (!__privateGet(this, _hashComputed3)) {
      __privateSet(this, _hash3, __privateMethod(this, _P2MR_instances, computeHash_fn3).call(this));
      __privateSet(this, _hashComputed3, true);
    }
    return __privateGet(this, _hash3);
  }
  /**
   * The scriptPubKey: `OP_2 <32-byte merkle root>` (34 bytes total).
   *
   * @returns The output script, or `undefined` if insufficient data.
   */
  get output() {
    if (!__privateGet(this, _outputComputed4)) {
      __privateSet(this, _output4, __privateMethod(this, _P2MR_instances, computeOutput_fn4).call(this));
      __privateSet(this, _outputComputed4, true);
    }
    return __privateGet(this, _output4);
  }
  /**
   * Redeem script information for script-path spending.
   *
   * @returns The redeem script data, or `undefined` if not available.
   */
  get redeem() {
    if (!__privateGet(this, _redeemComputed2)) {
      __privateSet(this, _redeem2, __privateMethod(this, _P2MR_instances, computeRedeem_fn2).call(this));
      __privateSet(this, _redeemComputed2, true);
    }
    return __privateGet(this, _redeem2);
  }
  /**
   * Leaf version used for script-path hashing.
   *
   * @returns The leaf version byte (defaults to LEAF_VERSION_TAPSCRIPT = 0xc0).
   */
  get redeemVersion() {
    if (!__privateGet(this, _redeemVersionComputed)) {
      __privateSet(this, _redeemVersion, __privateMethod(this, _P2MR_instances, computeRedeemVersion_fn).call(this));
      __privateSet(this, _redeemVersionComputed, true);
    }
    return __privateGet(this, _redeemVersion) ?? LEAF_VERSION_TAPSCRIPT;
  }
  /**
   * Witness stack for script-path spending.
   * Format: `[script inputs..., script, control block]`
   *
   * @returns The witness stack array, or `undefined` if insufficient data.
   */
  get witness() {
    if (!__privateGet(this, _witnessComputed3)) {
      __privateSet(this, _witness3, __privateMethod(this, _P2MR_instances, computeWitness_fn3).call(this));
      __privateSet(this, _witnessComputed3, true);
    }
    return __privateGet(this, _witness3);
  }
  /**
   * Creates a P2MR payment from a script tree.
   *
   * @param scriptTree - The script tree
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromScriptTree(scriptTree, network) {
    return new _P2MR({ scriptTree, network });
  }
  /**
   * Creates a P2MR payment from a bech32m address.
   *
   * @param address - Bech32m encoded address (bc1z...)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromAddress(address, network) {
    return new _P2MR({ address, network });
  }
  /**
   * Creates a P2MR payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromOutput(output, network) {
    return new _P2MR({ output, network });
  }
  /**
   * Creates a P2MR payment from a merkle root hash.
   *
   * @param hash - The 32-byte merkle root
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromHash(hash2, network) {
    return new _P2MR({ hash: hash2, network });
  }
  /**
   * Converts to a plain P2MRPayment object for backwards compatibility.
   *
   * @returns A P2MRPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      scriptTree: __privateGet(this, _inputScriptTree),
      output: this.output,
      redeem: this.redeem,
      redeemVersion: this.redeemVersion,
      witness: this.witness
    };
  }
};
_network4 = new WeakMap();
_opts4 = new WeakMap();
_inputAddress4 = new WeakMap();
_inputHash3 = new WeakMap();
_inputScriptTree = new WeakMap();
_inputOutput4 = new WeakMap();
_inputWitness2 = new WeakMap();
_inputRedeem2 = new WeakMap();
_inputRedeemVersion = new WeakMap();
_address4 = new WeakMap();
_hash3 = new WeakMap();
_output4 = new WeakMap();
_redeem2 = new WeakMap();
_redeemVersion = new WeakMap();
_witness3 = new WeakMap();
_addressComputed4 = new WeakMap();
_hashComputed3 = new WeakMap();
_outputComputed4 = new WeakMap();
_redeemComputed2 = new WeakMap();
_redeemVersionComputed = new WeakMap();
_witnessComputed3 = new WeakMap();
_decodedAddress4 = new WeakMap();
_decodedAddressComputed4 = new WeakMap();
_witnessWithoutAnnex = new WeakMap();
_witnessWithoutAnnexComputed = new WeakMap();
_hashTree = new WeakMap();
_hashTreeComputed = new WeakMap();
_P2MR_instances = new WeakSet();
getDecodedAddress_fn4 = function() {
  if (!__privateGet(this, _decodedAddressComputed4)) {
    if (__privateGet(this, _inputAddress4)) {
      const decoded = fromBech32(__privateGet(this, _inputAddress4));
      if (decoded) {
        __privateSet(this, _decodedAddress4, {
          version: decoded.version,
          prefix: decoded.prefix,
          data: decoded.data
        });
      }
    }
    __privateSet(this, _decodedAddressComputed4, true);
  }
  return __privateGet(this, _decodedAddress4);
};
getWitnessWithoutAnnex_fn = function() {
  if (!__privateGet(this, _witnessWithoutAnnexComputed)) {
    if (__privateGet(this, _inputWitness2) && __privateGet(this, _inputWitness2).length > 0) {
      const lastWitness = __privateGet(this, _inputWitness2)[__privateGet(this, _inputWitness2).length - 1];
      if (__privateGet(this, _inputWitness2).length >= 2 && lastWitness && lastWitness[0] === ANNEX_PREFIX$1) {
        __privateSet(this, _witnessWithoutAnnex, __privateGet(this, _inputWitness2).slice(0, -1));
      } else {
        __privateSet(this, _witnessWithoutAnnex, __privateGet(this, _inputWitness2).slice());
      }
    }
    __privateSet(this, _witnessWithoutAnnexComputed, true);
  }
  return __privateGet(this, _witnessWithoutAnnex);
};
getHashTree_fn = function() {
  if (!__privateGet(this, _hashTreeComputed)) {
    if (__privateGet(this, _inputScriptTree)) {
      __privateSet(this, _hashTree, toHashTree(__privateGet(this, _inputScriptTree)));
    } else if (__privateGet(this, _inputHash3)) {
      __privateSet(this, _hashTree, { hash: __privateGet(this, _inputHash3) });
    }
    __privateSet(this, _hashTreeComputed, true);
  }
  return __privateGet(this, _hashTree);
};
computeAddress_fn4 = function() {
  if (__privateGet(this, _inputAddress4)) {
    return __privateGet(this, _inputAddress4);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  const words = distExports.bech32m.toWords(h);
  words.unshift(P2MR_WITNESS_VERSION);
  return distExports.bech32m.encode(__privateGet(this, _network4).bech32, words);
};
computeHash_fn3 = function() {
  var _a5;
  if (__privateGet(this, _inputHash3)) {
    return __privateGet(this, _inputHash3);
  }
  const hashTree = __privateMethod(this, _P2MR_instances, getHashTree_fn).call(this);
  if (hashTree) {
    return hashTree.hash;
  }
  if (__privateGet(this, _inputOutput4)) {
    return __privateGet(this, _inputOutput4).subarray(2);
  }
  if (__privateGet(this, _inputAddress4)) {
    return (_a5 = __privateMethod(this, _P2MR_instances, getDecodedAddress_fn4).call(this)) == null ? void 0 : _a5.data;
  }
  const w2 = __privateMethod(this, _P2MR_instances, getWitnessWithoutAnnex_fn).call(this);
  if (w2 && w2.length > 1) {
    const controlBlock = w2[w2.length - 1];
    const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;
    const script2 = w2[w2.length - 2];
    const leafHash = tapleafHash({
      output: script2,
      version: leafVersion
    });
    return rootHashFromPathP2MR(controlBlock, leafHash);
  }
  return void 0;
};
computeOutput_fn4 = function() {
  if (__privateGet(this, _inputOutput4)) {
    return __privateGet(this, _inputOutput4);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  return compile([OPS$6.OP_2, h]);
};
computeRedeem_fn2 = function() {
  if (__privateGet(this, _inputRedeem2)) {
    return __privateGet(this, _inputRedeem2);
  }
  const witness = __privateMethod(this, _P2MR_instances, getWitnessWithoutAnnex_fn).call(this);
  if (!witness || witness.length < 2) {
    return void 0;
  }
  const lastWitness = witness[witness.length - 1];
  return {
    output: witness[witness.length - 2],
    witness: witness.slice(0, -2),
    redeemVersion: lastWitness[0] & TAPLEAF_VERSION_MASK
  };
};
computeRedeemVersion_fn = function() {
  if (__privateGet(this, _inputRedeemVersion) !== void 0) {
    return __privateGet(this, _inputRedeemVersion);
  }
  if (__privateGet(this, _inputRedeem2) && __privateGet(this, _inputRedeem2).redeemVersion !== void 0 && __privateGet(this, _inputRedeem2).redeemVersion !== null) {
    return __privateGet(this, _inputRedeem2).redeemVersion;
  }
  return LEAF_VERSION_TAPSCRIPT;
};
computeWitness_fn3 = function() {
  var _a5;
  if (__privateGet(this, _inputWitness2)) {
    return __privateGet(this, _inputWitness2);
  }
  const hashTree = __privateMethod(this, _P2MR_instances, getHashTree_fn).call(this);
  if (hashTree && ((_a5 = __privateGet(this, _inputRedeem2)) == null ? void 0 : _a5.output)) {
    const leafHash = tapleafHash({
      output: __privateGet(this, _inputRedeem2).output,
      version: this.redeemVersion
    });
    const path = findScriptPath(hashTree, leafHash);
    if (!path)
      return void 0;
    const version2 = this.redeemVersion ?? 192;
    const controlBlock = concat$1([
      new Uint8Array([version2 | 1]),
      ...path
    ]);
    return [__privateGet(this, _inputRedeem2).output, controlBlock];
  }
  return void 0;
};
validate_fn4 = function() {
  var _a5;
  let knownHash = new Uint8Array(0);
  if (__privateGet(this, _inputAddress4)) {
    const addr = __privateMethod(this, _P2MR_instances, getDecodedAddress_fn4).call(this);
    if (!addr) {
      throw new TypeError("Invalid address");
    }
    if (__privateGet(this, _network4) && __privateGet(this, _network4).bech32 !== addr.prefix) {
      throw new TypeError("Invalid prefix or Network mismatch");
    }
    if (addr.version !== P2MR_WITNESS_VERSION) {
      throw new TypeError("Invalid address version");
    }
    if (addr.data.length !== 32) {
      throw new TypeError("Invalid address data");
    }
    knownHash = addr.data;
  }
  if (__privateGet(this, _inputOutput4)) {
    if (__privateGet(this, _inputOutput4).length !== 34 || __privateGet(this, _inputOutput4)[0] !== OPS$6.OP_2 || __privateGet(this, _inputOutput4)[1] !== 32) {
      throw new TypeError("Output is invalid");
    }
    if (knownHash.length > 0 && !equals(knownHash, __privateGet(this, _inputOutput4).subarray(2))) {
      throw new TypeError("Hash mismatch");
    } else {
      knownHash = __privateGet(this, _inputOutput4).subarray(2);
    }
  }
  if (__privateGet(this, _inputHash3)) {
    if (__privateGet(this, _inputHash3).length !== 32) {
      throw new TypeError("Invalid hash length");
    }
    if (knownHash.length > 0 && !equals(knownHash, __privateGet(this, _inputHash3))) {
      throw new TypeError("Hash mismatch");
    }
  }
  const hashTree = __privateMethod(this, _P2MR_instances, getHashTree_fn).call(this);
  if (__privateGet(this, _inputHash3) && hashTree) {
    if (!equals(__privateGet(this, _inputHash3), hashTree.hash)) {
      throw new TypeError("Hash mismatch");
    }
  }
  if (((_a5 = __privateGet(this, _inputRedeem2)) == null ? void 0 : _a5.output) && hashTree) {
    const leafHash = tapleafHash({
      output: __privateGet(this, _inputRedeem2).output,
      version: this.redeemVersion
    });
    if (!findScriptPath(hashTree, leafHash)) {
      throw new TypeError("Redeem script not in tree");
    }
  }
  const witness = __privateMethod(this, _P2MR_instances, getWitnessWithoutAnnex_fn).call(this);
  if (__privateGet(this, _inputRedeem2) && this.redeem) {
    if (__privateGet(this, _inputRedeem2).redeemVersion) {
      if (__privateGet(this, _inputRedeem2).redeemVersion !== this.redeem.redeemVersion) {
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      }
    }
    if (__privateGet(this, _inputRedeem2).output) {
      const decompiled = decompile(__privateGet(this, _inputRedeem2).output);
      if (!decompiled || decompiled.length === 0) {
        throw new TypeError("Redeem.output is invalid");
      }
      if (this.redeem.output && !equals(__privateGet(this, _inputRedeem2).output, this.redeem.output)) {
        throw new TypeError("Redeem.output and witness mismatch");
      }
    }
    if (__privateGet(this, _inputRedeem2).witness) {
      if (this.redeem.witness && !stacksEqual(__privateGet(this, _inputRedeem2).witness, this.redeem.witness)) {
        throw new TypeError("Redeem.witness and witness mismatch");
      }
    }
  }
  if (witness && witness.length > 0) {
    if (witness.length < 2) {
      throw new TypeError("P2MR requires at least 2 witness items (script + control block)");
    }
    const controlBlock = witness[witness.length - 1];
    if (controlBlock.length < 1) {
      throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 1.`);
    }
    if ((controlBlock.length - 1) % 32 !== 0) {
      throw new TypeError(`The control-block length of ${controlBlock.length} is incorrect!`);
    }
    const m = (controlBlock.length - 1) / 32;
    if (m > 128) {
      throw new TypeError(`The script path is too long. Got ${m}, expected max 128.`);
    }
    const controlBlockFirstByte = controlBlock[0];
    if ((controlBlockFirstByte & 1) !== 1) {
      throw new TypeError("P2MR control byte parity bit must be 1");
    }
    const leafVersion = controlBlockFirstByte & TAPLEAF_VERSION_MASK;
    const script2 = witness[witness.length - 2];
    const leafHash = tapleafHash({
      output: script2,
      version: leafVersion
    });
    const computedHash = rootHashFromPathP2MR(controlBlock, leafHash);
    if (knownHash.length > 0 && !equals(knownHash, computedHash)) {
      throw new TypeError("Merkle root mismatch for p2mr witness");
    }
  }
};
__publicField(_P2MR, "NAME", PaymentType.P2MR);
var P2MR = _P2MR;
function p2mr(a, opts) {
  if (!a.address && !a.output && !a.hash && !a.scriptTree && !(a.witness && a.witness.length > 1)) {
    throw new TypeError("Not enough data");
  }
  const instance = new P2MR({
    address: a.address,
    hash: a.hash,
    scriptTree: a.scriptTree,
    output: a.output,
    witness: a.witness,
    redeem: a.redeem,
    redeemVersion: a.redeemVersion,
    network: a.network
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
var OPS$5 = opcodes;
var TAPROOT_WITNESS_VERSION = 1;
var ANNEX_PREFIX = 80;
var _network5, _opts5, _inputAddress5, _inputPubkey2, _inputInternalPubkey, _inputHash4, _inputScriptTree2, _inputSignature2, _inputOutput5, _inputWitness3, _inputRedeem3, _inputRedeemVersion2, _address5, _pubkey2, _internalPubkey, _hash4, _signature2, _output5, _redeem3, _redeemVersion2, _witness4, _addressComputed5, _pubkeyComputed2, _internalPubkeyComputed, _hashComputed4, _signatureComputed2, _outputComputed5, _redeemComputed3, _redeemVersionComputed2, _witnessComputed4, _decodedAddress5, _decodedAddressComputed5, _witnessWithoutAnnex2, _witnessWithoutAnnexComputed2, _hashTree2, _hashTreeComputed2, _P2TR_instances, getDecodedAddress_fn5, getWitnessWithoutAnnex_fn2, getHashTree_fn2, computeAddress_fn5, computePubkey_fn2, computeInternalPubkey_fn, computeHash_fn4, computeSignature_fn2, computeOutput_fn5, computeRedeem_fn3, computeRedeemVersion_fn2, computeWitness_fn4, validate_fn5;
var _P2TR = class _P2TR {
  /**
   * Creates a new P2TR payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded address (bc1p...)
   * @param params.pubkey - x-only output pubkey (32 bytes)
   * @param params.internalPubkey - x-only internal pubkey (32 bytes)
   * @param params.hash - Merkle root (32 bytes, or empty for key-path only)
   * @param params.scriptTree - Full script tree definition
   * @param params.signature - Schnorr signature (for key-path spending)
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack
   * @param params.redeem - Redeem script for script-path spending
   * @param params.redeemVersion - Leaf version (defaults to LEAF_VERSION_TAPSCRIPT)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2TR_instances);
    // Private instance fields
    __privateAdd(this, _network5);
    __privateAdd(this, _opts5);
    // Input data (provided by user)
    __privateAdd(this, _inputAddress5);
    __privateAdd(this, _inputPubkey2);
    __privateAdd(this, _inputInternalPubkey);
    __privateAdd(this, _inputHash4);
    __privateAdd(this, _inputScriptTree2);
    __privateAdd(this, _inputSignature2);
    __privateAdd(this, _inputOutput5);
    __privateAdd(this, _inputWitness3);
    __privateAdd(this, _inputRedeem3);
    __privateAdd(this, _inputRedeemVersion2);
    // Cached computed values
    __privateAdd(this, _address5);
    __privateAdd(this, _pubkey2);
    __privateAdd(this, _internalPubkey);
    __privateAdd(this, _hash4);
    __privateAdd(this, _signature2);
    __privateAdd(this, _output5);
    __privateAdd(this, _redeem3);
    __privateAdd(this, _redeemVersion2);
    __privateAdd(this, _witness4);
    // Cache flags
    __privateAdd(this, _addressComputed5, false);
    __privateAdd(this, _pubkeyComputed2, false);
    __privateAdd(this, _internalPubkeyComputed, false);
    __privateAdd(this, _hashComputed4, false);
    __privateAdd(this, _signatureComputed2, false);
    __privateAdd(this, _outputComputed5, false);
    __privateAdd(this, _redeemComputed3, false);
    __privateAdd(this, _redeemVersionComputed2, false);
    __privateAdd(this, _witnessComputed4, false);
    // Decoded address cache
    __privateAdd(this, _decodedAddress5);
    __privateAdd(this, _decodedAddressComputed5, false);
    // Witness without annex
    __privateAdd(this, _witnessWithoutAnnex2);
    __privateAdd(this, _witnessWithoutAnnexComputed2, false);
    // Hash tree cache
    __privateAdd(this, _hashTree2);
    __privateAdd(this, _hashTreeComputed2, false);
    __privateSet(this, _network5, params.network ?? bitcoin$1);
    __privateSet(this, _opts5, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputAddress5, params.address);
    __privateSet(this, _inputPubkey2, params.pubkey);
    __privateSet(this, _inputInternalPubkey, params.internalPubkey);
    __privateSet(this, _inputHash4, params.hash);
    __privateSet(this, _inputScriptTree2, params.scriptTree);
    __privateSet(this, _inputSignature2, params.signature);
    __privateSet(this, _inputOutput5, params.output);
    __privateSet(this, _inputWitness3, params.witness);
    __privateSet(this, _inputRedeem3, params.redeem);
    __privateSet(this, _inputRedeemVersion2, params.redeemVersion);
    if (__privateGet(this, _opts5).validate) {
      __privateMethod(this, _P2TR_instances, validate_fn5).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return PaymentType.P2TR;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network5);
  }
  /**
   * Bech32m encoded address (bc1p... for mainnet).
   */
  get address() {
    if (!__privateGet(this, _addressComputed5)) {
      __privateSet(this, _address5, __privateMethod(this, _P2TR_instances, computeAddress_fn5).call(this));
      __privateSet(this, _addressComputed5, true);
    }
    return __privateGet(this, _address5);
  }
  /**
   * x-only output pubkey (32 bytes).
   * This is the tweaked pubkey that appears in the output.
   */
  get pubkey() {
    if (!__privateGet(this, _pubkeyComputed2)) {
      __privateSet(this, _pubkey2, __privateMethod(this, _P2TR_instances, computePubkey_fn2).call(this));
      __privateSet(this, _pubkeyComputed2, true);
    }
    return __privateGet(this, _pubkey2);
  }
  /**
   * x-only internal pubkey (32 bytes).
   * This is the untweaked pubkey before adding the merkle root tweak.
   */
  get internalPubkey() {
    if (!__privateGet(this, _internalPubkeyComputed)) {
      __privateSet(this, _internalPubkey, __privateMethod(this, _P2TR_instances, computeInternalPubkey_fn).call(this));
      __privateSet(this, _internalPubkeyComputed, true);
    }
    return __privateGet(this, _internalPubkey);
  }
  /**
   * Merkle root hash (32 bytes).
   * Present when a script tree is defined.
   */
  get hash() {
    if (!__privateGet(this, _hashComputed4)) {
      __privateSet(this, _hash4, __privateMethod(this, _P2TR_instances, computeHash_fn4).call(this));
      __privateSet(this, _hashComputed4, true);
    }
    return __privateGet(this, _hash4);
  }
  /**
   * Schnorr signature (for key-path spending).
   */
  get signature() {
    if (!__privateGet(this, _signatureComputed2)) {
      __privateSet(this, _signature2, __privateMethod(this, _P2TR_instances, computeSignature_fn2).call(this));
      __privateSet(this, _signatureComputed2, true);
    }
    return __privateGet(this, _signature2);
  }
  /**
   * The scriptPubKey: `OP_1 {32-byte x-only pubkey}`
   */
  get output() {
    if (!__privateGet(this, _outputComputed5)) {
      __privateSet(this, _output5, __privateMethod(this, _P2TR_instances, computeOutput_fn5).call(this));
      __privateSet(this, _outputComputed5, true);
    }
    return __privateGet(this, _output5);
  }
  /**
   * Redeem script information (for script-path spending).
   */
  get redeem() {
    if (!__privateGet(this, _redeemComputed3)) {
      __privateSet(this, _redeem3, __privateMethod(this, _P2TR_instances, computeRedeem_fn3).call(this));
      __privateSet(this, _redeemComputed3, true);
    }
    return __privateGet(this, _redeem3);
  }
  /**
   * Leaf version (defaults to LEAF_VERSION_TAPSCRIPT = 0xc0).
   */
  get redeemVersion() {
    if (!__privateGet(this, _redeemVersionComputed2)) {
      __privateSet(this, _redeemVersion2, __privateMethod(this, _P2TR_instances, computeRedeemVersion_fn2).call(this));
      __privateSet(this, _redeemVersionComputed2, true);
    }
    return __privateGet(this, _redeemVersion2) ?? LEAF_VERSION_TAPSCRIPT;
  }
  /**
   * Witness stack.
   * Key-path: `[signature]`
   * Script-path: `[script inputs..., script, control block]`
   */
  get witness() {
    if (!__privateGet(this, _witnessComputed4)) {
      __privateSet(this, _witness4, __privateMethod(this, _P2TR_instances, computeWitness_fn4).call(this));
      __privateSet(this, _witnessComputed4, true);
    }
    return __privateGet(this, _witness4);
  }
  // Static factory methods
  /**
   * Creates a P2TR payment from an internal pubkey (key-path only).
   *
   * @param internalPubkey - x-only internal pubkey (32 bytes)
   * @param scriptTree - Optional script tree
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   *
   * @example
   * ```typescript
   * // Key-path only
   * const p2tr = P2TR.fromInternalPubkey(internalPubkey);
   *
   * // With script tree
   * const withScripts = P2TR.fromInternalPubkey(internalPubkey, scriptTree);
   * ```
   */
  static fromInternalPubkey(internalPubkey, scriptTree, network) {
    return new _P2TR({ internalPubkey, scriptTree, network });
  }
  /**
   * Creates a P2TR payment from a bech32m address.
   *
   * @param address - Bech32m encoded address (bc1p...)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromAddress(address, network) {
    return new _P2TR({ address, network });
  }
  /**
   * Creates a P2TR payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromOutput(output, network) {
    return new _P2TR({ output, network });
  }
  /**
   * Creates a P2TR payment from a signature (for key-path spending).
   *
   * @param signature - Schnorr signature
   * @param internalPubkey - x-only internal pubkey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromSignature(signature2, internalPubkey, network) {
    return new _P2TR({ signature: signature2, internalPubkey, network });
  }
  // Private helper methods
  /**
   * Converts to a plain P2TRPayment object for backwards compatibility.
   *
   * @returns A P2TRPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      pubkey: this.pubkey,
      internalPubkey: this.internalPubkey,
      hash: this.hash,
      scriptTree: __privateGet(this, _inputScriptTree2),
      signature: this.signature,
      output: this.output,
      redeem: this.redeem,
      redeemVersion: this.redeemVersion,
      witness: this.witness
    };
  }
};
_network5 = new WeakMap();
_opts5 = new WeakMap();
_inputAddress5 = new WeakMap();
_inputPubkey2 = new WeakMap();
_inputInternalPubkey = new WeakMap();
_inputHash4 = new WeakMap();
_inputScriptTree2 = new WeakMap();
_inputSignature2 = new WeakMap();
_inputOutput5 = new WeakMap();
_inputWitness3 = new WeakMap();
_inputRedeem3 = new WeakMap();
_inputRedeemVersion2 = new WeakMap();
_address5 = new WeakMap();
_pubkey2 = new WeakMap();
_internalPubkey = new WeakMap();
_hash4 = new WeakMap();
_signature2 = new WeakMap();
_output5 = new WeakMap();
_redeem3 = new WeakMap();
_redeemVersion2 = new WeakMap();
_witness4 = new WeakMap();
_addressComputed5 = new WeakMap();
_pubkeyComputed2 = new WeakMap();
_internalPubkeyComputed = new WeakMap();
_hashComputed4 = new WeakMap();
_signatureComputed2 = new WeakMap();
_outputComputed5 = new WeakMap();
_redeemComputed3 = new WeakMap();
_redeemVersionComputed2 = new WeakMap();
_witnessComputed4 = new WeakMap();
_decodedAddress5 = new WeakMap();
_decodedAddressComputed5 = new WeakMap();
_witnessWithoutAnnex2 = new WeakMap();
_witnessWithoutAnnexComputed2 = new WeakMap();
_hashTree2 = new WeakMap();
_hashTreeComputed2 = new WeakMap();
_P2TR_instances = new WeakSet();
getDecodedAddress_fn5 = function() {
  if (!__privateGet(this, _decodedAddressComputed5)) {
    if (__privateGet(this, _inputAddress5)) {
      const decoded = fromBech32(__privateGet(this, _inputAddress5));
      if (decoded) {
        __privateSet(this, _decodedAddress5, {
          version: decoded.version,
          prefix: decoded.prefix,
          data: decoded.data
        });
      }
    }
    __privateSet(this, _decodedAddressComputed5, true);
  }
  return __privateGet(this, _decodedAddress5);
};
getWitnessWithoutAnnex_fn2 = function() {
  if (!__privateGet(this, _witnessWithoutAnnexComputed2)) {
    if (__privateGet(this, _inputWitness3) && __privateGet(this, _inputWitness3).length > 0) {
      const lastWitness = __privateGet(this, _inputWitness3)[__privateGet(this, _inputWitness3).length - 1];
      if (__privateGet(this, _inputWitness3).length >= 2 && lastWitness && lastWitness[0] === ANNEX_PREFIX) {
        __privateSet(this, _witnessWithoutAnnex2, __privateGet(this, _inputWitness3).slice(0, -1));
      } else {
        __privateSet(this, _witnessWithoutAnnex2, __privateGet(this, _inputWitness3).slice());
      }
    }
    __privateSet(this, _witnessWithoutAnnexComputed2, true);
  }
  return __privateGet(this, _witnessWithoutAnnex2);
};
// Private computation methods
getHashTree_fn2 = function() {
  if (!__privateGet(this, _hashTreeComputed2)) {
    if (__privateGet(this, _inputScriptTree2)) {
      __privateSet(this, _hashTree2, toHashTree(__privateGet(this, _inputScriptTree2)));
    } else if (__privateGet(this, _inputHash4)) {
      __privateSet(this, _hashTree2, { hash: __privateGet(this, _inputHash4) });
    }
    __privateSet(this, _hashTreeComputed2, true);
  }
  return __privateGet(this, _hashTree2);
};
computeAddress_fn5 = function() {
  if (__privateGet(this, _inputAddress5)) {
    return __privateGet(this, _inputAddress5);
  }
  const pk = this.pubkey;
  if (!pk)
    return void 0;
  const words = distExports.bech32m.toWords(pk);
  words.unshift(TAPROOT_WITNESS_VERSION);
  return distExports.bech32m.encode(__privateGet(this, _network5).bech32, words);
};
computePubkey_fn2 = function() {
  var _a5;
  if (__privateGet(this, _inputPubkey2)) {
    return __privateGet(this, _inputPubkey2);
  }
  if (__privateGet(this, _inputOutput5)) {
    return __privateGet(this, _inputOutput5).subarray(2);
  }
  if (__privateGet(this, _inputAddress5)) {
    return (_a5 = __privateMethod(this, _P2TR_instances, getDecodedAddress_fn5).call(this)) == null ? void 0 : _a5.data;
  }
  const internalPk = this.internalPubkey;
  if (internalPk) {
    const tweakedKey = tweakKey(internalPk, this.hash);
    if (tweakedKey) {
      return tweakedKey.x;
    }
  }
  return void 0;
};
computeInternalPubkey_fn = function() {
  if (__privateGet(this, _inputInternalPubkey)) {
    return __privateGet(this, _inputInternalPubkey);
  }
  const witness = __privateMethod(this, _P2TR_instances, getWitnessWithoutAnnex_fn2).call(this);
  if (witness && witness.length > 1) {
    const lastWitness = witness[witness.length - 1];
    if (lastWitness) {
      return lastWitness.subarray(1, 33);
    }
  }
  return void 0;
};
computeHash_fn4 = function() {
  const hashTree = __privateMethod(this, _P2TR_instances, getHashTree_fn2).call(this);
  if (hashTree) {
    return hashTree.hash;
  }
  const w2 = __privateMethod(this, _P2TR_instances, getWitnessWithoutAnnex_fn2).call(this);
  if (w2 && w2.length > 1) {
    const controlBlock = w2[w2.length - 1];
    const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;
    const script2 = w2[w2.length - 2];
    const leafHash = tapleafHash({
      output: script2,
      version: leafVersion
    });
    return rootHashFromPath(controlBlock, leafHash);
  }
  return void 0;
};
computeSignature_fn2 = function() {
  if (__privateGet(this, _inputSignature2)) {
    return __privateGet(this, _inputSignature2);
  }
  const witness = __privateMethod(this, _P2TR_instances, getWitnessWithoutAnnex_fn2).call(this);
  if (witness && witness.length === 1) {
    return witness[0];
  }
  return void 0;
};
computeOutput_fn5 = function() {
  if (__privateGet(this, _inputOutput5)) {
    return __privateGet(this, _inputOutput5);
  }
  const pk = this.pubkey;
  if (!pk)
    return void 0;
  return compile([OPS$5.OP_1, pk]);
};
computeRedeem_fn3 = function() {
  if (__privateGet(this, _inputRedeem3)) {
    return __privateGet(this, _inputRedeem3);
  }
  const witness = __privateMethod(this, _P2TR_instances, getWitnessWithoutAnnex_fn2).call(this);
  if (!witness || witness.length < 2) {
    return void 0;
  }
  const lastWitness = witness[witness.length - 1];
  return {
    output: witness[witness.length - 2],
    witness: witness.slice(0, -2),
    redeemVersion: lastWitness[0] & TAPLEAF_VERSION_MASK
  };
};
computeRedeemVersion_fn2 = function() {
  if (__privateGet(this, _inputRedeemVersion2) !== void 0) {
    return __privateGet(this, _inputRedeemVersion2);
  }
  if (__privateGet(this, _inputRedeem3) && __privateGet(this, _inputRedeem3).redeemVersion !== void 0 && __privateGet(this, _inputRedeem3).redeemVersion !== null) {
    return __privateGet(this, _inputRedeem3).redeemVersion;
  }
  return LEAF_VERSION_TAPSCRIPT;
};
// Validation
computeWitness_fn4 = function() {
  var _a5;
  if (__privateGet(this, _inputWitness3)) {
    return __privateGet(this, _inputWitness3);
  }
  const hashTree = __privateMethod(this, _P2TR_instances, getHashTree_fn2).call(this);
  if (hashTree && ((_a5 = __privateGet(this, _inputRedeem3)) == null ? void 0 : _a5.output) && __privateGet(this, _inputInternalPubkey)) {
    const leafHash = tapleafHash({
      output: __privateGet(this, _inputRedeem3).output,
      version: this.redeemVersion
    });
    const path = findScriptPath(hashTree, leafHash);
    if (!path)
      return void 0;
    const outputKey = tweakKey(__privateGet(this, _inputInternalPubkey), hashTree.hash);
    if (!outputKey)
      return void 0;
    const version2 = this.redeemVersion ?? 192;
    const controlBlock = concat$1([
      new Uint8Array([version2 | outputKey.parity]),
      __privateGet(this, _inputInternalPubkey),
      ...path
    ]);
    return [__privateGet(this, _inputRedeem3).output, controlBlock];
  }
  if (__privateGet(this, _inputSignature2)) {
    return [__privateGet(this, _inputSignature2)];
  }
  return void 0;
};
validate_fn5 = function() {
  var _a5;
  let pubkey = new Uint8Array(0);
  if (__privateGet(this, _inputAddress5)) {
    const addr = __privateMethod(this, _P2TR_instances, getDecodedAddress_fn5).call(this);
    if (!addr) {
      throw new TypeError("Invalid address");
    }
    if (__privateGet(this, _network5) && __privateGet(this, _network5).bech32 !== addr.prefix) {
      throw new TypeError("Invalid prefix or Network mismatch");
    }
    if (addr.version !== TAPROOT_WITNESS_VERSION) {
      throw new TypeError("Invalid address version");
    }
    if (addr.data.length !== 32) {
      throw new TypeError("Invalid address data");
    }
    pubkey = addr.data;
  }
  if (__privateGet(this, _inputPubkey2)) {
    if (pubkey.length > 0 && !equals(pubkey, __privateGet(this, _inputPubkey2))) {
      throw new TypeError("Pubkey mismatch");
    } else {
      pubkey = __privateGet(this, _inputPubkey2);
    }
  }
  if (__privateGet(this, _inputOutput5)) {
    if (__privateGet(this, _inputOutput5).length !== 34 || __privateGet(this, _inputOutput5)[0] !== OPS$5.OP_1 || __privateGet(this, _inputOutput5)[1] !== 32) {
      throw new TypeError("Output is invalid");
    }
    if (pubkey.length > 0 && !equals(pubkey, __privateGet(this, _inputOutput5).subarray(2))) {
      throw new TypeError("Pubkey mismatch");
    } else {
      pubkey = __privateGet(this, _inputOutput5).subarray(2);
    }
  }
  if (__privateGet(this, _inputInternalPubkey)) {
    const tweakedKey = tweakKey(__privateGet(this, _inputInternalPubkey), this.hash);
    if (!tweakedKey) {
      throw new TypeError("Invalid internal pubkey");
    }
    if (pubkey.length > 0 && !equals(pubkey, tweakedKey.x)) {
      throw new TypeError("Pubkey mismatch");
    } else {
      pubkey = tweakedKey.x;
    }
  }
  const hashTree = __privateMethod(this, _P2TR_instances, getHashTree_fn2).call(this);
  if (__privateGet(this, _inputHash4) && hashTree) {
    if (!equals(__privateGet(this, _inputHash4), hashTree.hash)) {
      throw new TypeError("Hash mismatch");
    }
  }
  if (((_a5 = __privateGet(this, _inputRedeem3)) == null ? void 0 : _a5.output) && hashTree) {
    const leafHash = tapleafHash({
      output: __privateGet(this, _inputRedeem3).output,
      version: this.redeemVersion
    });
    if (!findScriptPath(hashTree, leafHash)) {
      throw new TypeError("Redeem script not in tree");
    }
  }
  const witness = __privateMethod(this, _P2TR_instances, getWitnessWithoutAnnex_fn2).call(this);
  if (__privateGet(this, _inputRedeem3) && this.redeem) {
    if (__privateGet(this, _inputRedeem3).redeemVersion) {
      if (__privateGet(this, _inputRedeem3).redeemVersion !== this.redeem.redeemVersion) {
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      }
    }
    if (__privateGet(this, _inputRedeem3).output) {
      const decompiled = decompile(__privateGet(this, _inputRedeem3).output);
      if (!decompiled || decompiled.length === 0) {
        throw new TypeError("Redeem.output is invalid");
      }
      if (this.redeem.output && !equals(__privateGet(this, _inputRedeem3).output, this.redeem.output)) {
        throw new TypeError("Redeem.output and witness mismatch");
      }
    }
    if (__privateGet(this, _inputRedeem3).witness) {
      if (this.redeem.witness && !stacksEqual(__privateGet(this, _inputRedeem3).witness, this.redeem.witness)) {
        throw new TypeError("Redeem.witness and witness mismatch");
      }
    }
  }
  if (witness && witness.length > 0) {
    if (witness.length === 1) {
      const firstWitness = witness[0];
      if (__privateGet(this, _inputSignature2) && !equals(__privateGet(this, _inputSignature2), firstWitness)) {
        throw new TypeError("Signature mismatch");
      }
    } else {
      const controlBlock = witness[witness.length - 1];
      if (controlBlock.length < 33) {
        throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 33.`);
      }
      if ((controlBlock.length - 33) % 32 !== 0) {
        throw new TypeError(`The control-block length of ${controlBlock.length} is incorrect!`);
      }
      const m = (controlBlock.length - 33) / 32;
      if (m > 128) {
        throw new TypeError(`The script path is too long. Got ${m}, expected max 128.`);
      }
      const internalPk = controlBlock.subarray(1, 33);
      if (__privateGet(this, _inputInternalPubkey) && !equals(__privateGet(this, _inputInternalPubkey), internalPk)) {
        throw new TypeError("Internal pubkey mismatch");
      }
      if (!isXOnlyPublicKey(internalPk)) {
        throw new TypeError("Invalid internalPubkey for p2tr witness");
      }
      const controlBlockFirstByte = controlBlock[0];
      const leafVersion = controlBlockFirstByte & TAPLEAF_VERSION_MASK;
      const script2 = witness[witness.length - 2];
      const leafHash = tapleafHash({
        output: script2,
        version: leafVersion
      });
      const computedHash = rootHashFromPath(controlBlock, leafHash);
      const outputKey = tweakKey(internalPk, computedHash);
      if (!outputKey) {
        throw new TypeError("Invalid outputKey for p2tr witness");
      }
      if (pubkey.length > 0 && !equals(pubkey, outputKey.x)) {
        throw new TypeError("Pubkey mismatch for p2tr witness");
      }
      if (outputKey.parity !== (controlBlockFirstByte & 1)) {
        throw new Error("Incorrect parity");
      }
    }
  }
};
// Static public fields
__publicField(_P2TR, "NAME", PaymentType.P2TR);
var P2TR = _P2TR;
function p2tr(a, opts) {
  if (!a.address && !a.output && !a.pubkey && !a.internalPubkey && !(a.witness && a.witness.length > 1)) {
    throw new TypeError("Not enough data");
  }
  const instance = new P2TR({
    address: a.address,
    pubkey: a.pubkey,
    internalPubkey: a.internalPubkey,
    hash: a.hash,
    scriptTree: a.scriptTree,
    signature: a.signature,
    output: a.output,
    witness: a.witness,
    redeem: a.redeem,
    redeemVersion: a.redeemVersion,
    network: a.network
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
var OPS$4 = opcodes;
var EMPTY_BUFFER$1 = new Uint8Array(0);
var _network6, _opts6, _inputAddress6, _inputHash5, _inputPubkey3, _inputSignature3, _inputOutput6, _inputWitness4, _address6, _hash5, _pubkey3, _signature3, _output6, _input3, _witness5, _addressComputed6, _hashComputed5, _pubkeyComputed3, _signatureComputed3, _outputComputed6, _inputComputed3, _witnessComputed5, _decodedAddress6, _decodedAddressComputed6, _P2WPKH_instances, getDecodedAddress_fn6, computeAddress_fn6, computeHash_fn5, computePubkey_fn3, computeSignature_fn3, computeOutput_fn6, computeInput_fn3, computeWitness_fn5, validate_fn6;
var _P2WPKH = class _P2WPKH {
  /**
   * Creates a new P2WPKH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32 encoded address
   * @param params.hash - 20-byte witness program (pubkey hash)
   * @param params.pubkey - The public key (must be 33 bytes compressed)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack [signature, pubkey]
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2WPKH_instances);
    // Private instance fields
    __privateAdd(this, _network6);
    __privateAdd(this, _opts6);
    // Input data (provided by user)
    __privateAdd(this, _inputAddress6);
    __privateAdd(this, _inputHash5);
    __privateAdd(this, _inputPubkey3);
    __privateAdd(this, _inputSignature3);
    __privateAdd(this, _inputOutput6);
    __privateAdd(this, _inputWitness4);
    // Cached computed values
    __privateAdd(this, _address6);
    __privateAdd(this, _hash5);
    __privateAdd(this, _pubkey3);
    __privateAdd(this, _signature3);
    __privateAdd(this, _output6);
    __privateAdd(this, _input3);
    __privateAdd(this, _witness5);
    // Cache flags
    __privateAdd(this, _addressComputed6, false);
    __privateAdd(this, _hashComputed5, false);
    __privateAdd(this, _pubkeyComputed3, false);
    __privateAdd(this, _signatureComputed3, false);
    __privateAdd(this, _outputComputed6, false);
    __privateAdd(this, _inputComputed3, false);
    __privateAdd(this, _witnessComputed5, false);
    // Decoded address cache
    __privateAdd(this, _decodedAddress6);
    __privateAdd(this, _decodedAddressComputed6, false);
    __privateSet(this, _network6, params.network ?? bitcoin$1);
    __privateSet(this, _opts6, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputAddress6, params.address);
    __privateSet(this, _inputHash5, params.hash);
    __privateSet(this, _inputPubkey3, params.pubkey);
    __privateSet(this, _inputSignature3, params.signature);
    __privateSet(this, _inputOutput6, params.output);
    __privateSet(this, _inputWitness4, params.witness);
    if (__privateGet(this, _opts6).validate) {
      __privateMethod(this, _P2WPKH_instances, validate_fn6).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return PaymentType.P2WPKH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network6);
  }
  /**
   * Bech32 encoded address (bc1q... for mainnet).
   */
  get address() {
    if (!__privateGet(this, _addressComputed6)) {
      __privateSet(this, _address6, __privateMethod(this, _P2WPKH_instances, computeAddress_fn6).call(this));
      __privateSet(this, _addressComputed6, true);
    }
    return __privateGet(this, _address6);
  }
  /**
   * 20-byte witness program (RIPEMD160(SHA256(pubkey))).
   */
  get hash() {
    if (!__privateGet(this, _hashComputed5)) {
      __privateSet(this, _hash5, __privateMethod(this, _P2WPKH_instances, computeHash_fn5).call(this));
      __privateSet(this, _hashComputed5, true);
    }
    return __privateGet(this, _hash5);
  }
  /**
   * The public key (33 bytes compressed).
   */
  get pubkey() {
    if (!__privateGet(this, _pubkeyComputed3)) {
      __privateSet(this, _pubkey3, __privateMethod(this, _P2WPKH_instances, computePubkey_fn3).call(this));
      __privateSet(this, _pubkeyComputed3, true);
    }
    return __privateGet(this, _pubkey3);
  }
  /**
   * The DER-encoded signature.
   */
  get signature() {
    if (!__privateGet(this, _signatureComputed3)) {
      __privateSet(this, _signature3, __privateMethod(this, _P2WPKH_instances, computeSignature_fn3).call(this));
      __privateSet(this, _signatureComputed3, true);
    }
    return __privateGet(this, _signature3);
  }
  /**
   * The scriptPubKey: `OP_0 {20-byte hash}`
   */
  get output() {
    if (!__privateGet(this, _outputComputed6)) {
      __privateSet(this, _output6, __privateMethod(this, _P2WPKH_instances, computeOutput_fn6).call(this));
      __privateSet(this, _outputComputed6, true);
    }
    return __privateGet(this, _output6);
  }
  /**
   * The scriptSig (always empty for native SegWit).
   */
  get input() {
    if (!__privateGet(this, _inputComputed3)) {
      __privateSet(this, _input3, __privateMethod(this, _P2WPKH_instances, computeInput_fn3).call(this));
      __privateSet(this, _inputComputed3, true);
    }
    return __privateGet(this, _input3);
  }
  /**
   * Witness stack: `[signature, pubkey]`
   */
  get witness() {
    if (!__privateGet(this, _witnessComputed5)) {
      __privateSet(this, _witness5, __privateMethod(this, _P2WPKH_instances, computeWitness_fn5).call(this));
      __privateSet(this, _witnessComputed5, true);
    }
    return __privateGet(this, _witness5);
  }
  // Static factory methods
  /**
   * Creates a P2WPKH payment from a compressed public key.
   *
   * @param pubkey - The public key (must be 33 bytes compressed)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2WPKH.fromPubkey(pubkey);
   * const address = payment.address; // bc1q...
   * ```
   */
  static fromPubkey(pubkey, network) {
    return new _P2WPKH({ pubkey, network });
  }
  /**
   * Creates a P2WPKH payment from a bech32 address.
   *
   * @param address - Bech32 encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2WPKH.fromAddress('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
   * const hash = payment.hash;
   * ```
   */
  static fromAddress(address, network) {
    return new _P2WPKH({ address, network });
  }
  /**
   * Creates a P2WPKH payment from a 20-byte witness program.
   *
   * @param hash - 20-byte witness program (pubkey hash)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   */
  static fromHash(hash2, network) {
    return new _P2WPKH({ hash: hash2, network });
  }
  /**
   * Creates a P2WPKH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   */
  static fromOutput(output, network) {
    return new _P2WPKH({ output, network });
  }
  // Private helper methods
  /**
   * Converts to a plain P2WPKHPayment object for backwards compatibility.
   *
   * @returns A P2WPKHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
};
_network6 = new WeakMap();
_opts6 = new WeakMap();
_inputAddress6 = new WeakMap();
_inputHash5 = new WeakMap();
_inputPubkey3 = new WeakMap();
_inputSignature3 = new WeakMap();
_inputOutput6 = new WeakMap();
_inputWitness4 = new WeakMap();
_address6 = new WeakMap();
_hash5 = new WeakMap();
_pubkey3 = new WeakMap();
_signature3 = new WeakMap();
_output6 = new WeakMap();
_input3 = new WeakMap();
_witness5 = new WeakMap();
_addressComputed6 = new WeakMap();
_hashComputed5 = new WeakMap();
_pubkeyComputed3 = new WeakMap();
_signatureComputed3 = new WeakMap();
_outputComputed6 = new WeakMap();
_inputComputed3 = new WeakMap();
_witnessComputed5 = new WeakMap();
_decodedAddress6 = new WeakMap();
_decodedAddressComputed6 = new WeakMap();
_P2WPKH_instances = new WeakSet();
// Private computation methods
getDecodedAddress_fn6 = function() {
  if (!__privateGet(this, _decodedAddressComputed6)) {
    if (__privateGet(this, _inputAddress6)) {
      const result = distExports.bech32.decode(__privateGet(this, _inputAddress6));
      const version2 = result.words.shift();
      const data = distExports.bech32.fromWords(result.words);
      __privateSet(this, _decodedAddress6, {
        version: version2 ?? 0,
        prefix: result.prefix,
        data: new Uint8Array(data)
      });
    }
    __privateSet(this, _decodedAddressComputed6, true);
  }
  return __privateGet(this, _decodedAddress6);
};
computeAddress_fn6 = function() {
  if (__privateGet(this, _inputAddress6)) {
    return __privateGet(this, _inputAddress6);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  const words = distExports.bech32.toWords(h);
  words.unshift(0);
  return distExports.bech32.encode(__privateGet(this, _network6).bech32, words);
};
computeHash_fn5 = function() {
  var _a5;
  if (__privateGet(this, _inputHash5)) {
    return __privateGet(this, _inputHash5);
  }
  if (__privateGet(this, _inputOutput6)) {
    return __privateGet(this, _inputOutput6).subarray(2, 22);
  }
  if (__privateGet(this, _inputAddress6)) {
    return (_a5 = __privateMethod(this, _P2WPKH_instances, getDecodedAddress_fn6).call(this)) == null ? void 0 : _a5.data;
  }
  const pk = __privateGet(this, _inputPubkey3) ?? this.pubkey;
  if (pk) {
    return hash160(pk);
  }
  return void 0;
};
computePubkey_fn3 = function() {
  if (__privateGet(this, _inputPubkey3)) {
    return __privateGet(this, _inputPubkey3);
  }
  if (__privateGet(this, _inputWitness4) && __privateGet(this, _inputWitness4).length >= 2) {
    return __privateGet(this, _inputWitness4)[1];
  }
  return void 0;
};
computeSignature_fn3 = function() {
  if (__privateGet(this, _inputSignature3)) {
    return __privateGet(this, _inputSignature3);
  }
  if (__privateGet(this, _inputWitness4) && __privateGet(this, _inputWitness4).length >= 1) {
    return __privateGet(this, _inputWitness4)[0];
  }
  return void 0;
};
computeOutput_fn6 = function() {
  if (__privateGet(this, _inputOutput6)) {
    return __privateGet(this, _inputOutput6);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  return compile([OPS$4.OP_0, h]);
};
computeInput_fn3 = function() {
  if (this.witness) {
    return EMPTY_BUFFER$1;
  }
  return void 0;
};
// Validation
computeWitness_fn5 = function() {
  if (__privateGet(this, _inputWitness4)) {
    return __privateGet(this, _inputWitness4);
  }
  if (!__privateGet(this, _inputPubkey3) || !__privateGet(this, _inputSignature3)) {
    return void 0;
  }
  return [__privateGet(this, _inputSignature3), __privateGet(this, _inputPubkey3)];
};
validate_fn6 = function() {
  let hash2 = new Uint8Array(0);
  if (__privateGet(this, _inputAddress6)) {
    const addr = __privateMethod(this, _P2WPKH_instances, getDecodedAddress_fn6).call(this);
    if (!addr) {
      throw new TypeError("Invalid address");
    }
    if (__privateGet(this, _network6) && __privateGet(this, _network6).bech32 !== addr.prefix) {
      throw new TypeError("Invalid prefix or Network mismatch");
    }
    if (addr.version !== 0) {
      throw new TypeError("Invalid address version");
    }
    if (addr.data.length !== 20) {
      throw new TypeError("Invalid address data");
    }
    hash2 = addr.data;
  }
  if (__privateGet(this, _inputHash5)) {
    if (hash2.length > 0 && !equals(hash2, __privateGet(this, _inputHash5))) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = __privateGet(this, _inputHash5);
    }
  }
  if (__privateGet(this, _inputOutput6)) {
    if (__privateGet(this, _inputOutput6).length !== 22 || __privateGet(this, _inputOutput6)[0] !== OPS$4.OP_0 || __privateGet(this, _inputOutput6)[1] !== 20) {
      throw new TypeError("Output is invalid");
    }
    if (hash2.length > 0 && !equals(hash2, __privateGet(this, _inputOutput6).subarray(2))) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = __privateGet(this, _inputOutput6).subarray(2);
    }
  }
  if (__privateGet(this, _inputPubkey3)) {
    const pkh = hash160(__privateGet(this, _inputPubkey3));
    if (hash2.length > 0 && !equals(hash2, pkh)) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = pkh;
    }
    if (!isPoint(__privateGet(this, _inputPubkey3)) || __privateGet(this, _inputPubkey3).length !== 33) {
      throw new TypeError("Invalid pubkey for p2wpkh");
    }
  }
  if (__privateGet(this, _inputWitness4)) {
    if (__privateGet(this, _inputWitness4).length !== 2) {
      throw new TypeError("Witness is invalid");
    }
    const witnessSig = __privateGet(this, _inputWitness4)[0];
    const witnessPubkey = __privateGet(this, _inputWitness4)[1];
    if (!isCanonicalScriptSignature(witnessSig)) {
      throw new TypeError("Witness has invalid signature");
    }
    if (!isPoint(witnessPubkey) || witnessPubkey.length !== 33) {
      throw new TypeError("Witness has invalid pubkey");
    }
    if (__privateGet(this, _inputSignature3) && !equals(__privateGet(this, _inputSignature3), witnessSig)) {
      throw new TypeError("Signature mismatch");
    }
    if (__privateGet(this, _inputPubkey3) && !equals(__privateGet(this, _inputPubkey3), witnessPubkey)) {
      throw new TypeError("Pubkey mismatch");
    }
    const pkh = hash160(witnessPubkey);
    if (hash2.length > 0 && !equals(hash2, pkh)) {
      throw new TypeError("Hash mismatch");
    }
  }
};
// Static public fields
__publicField(_P2WPKH, "NAME", PaymentType.P2WPKH);
var P2WPKH = _P2WPKH;
function p2wpkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness) {
    throw new TypeError("Not enough data");
  }
  const instance = new P2WPKH({
    address: a.address,
    hash: a.hash,
    pubkey: a.pubkey,
    signature: a.signature,
    output: a.output,
    witness: a.witness,
    network: a.network
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
var OPS$3 = opcodes;
var EMPTY_BUFFER = new Uint8Array(0);
function chunkHasUncompressedPubkey(chunk) {
  if (chunk instanceof Uint8Array && chunk.length === 65 && chunk[0] === 4 && isPoint(chunk)) {
    return true;
  }
  return false;
}
var _network7, _opts7, _inputAddress7, _inputHash6, _inputOutput7, _inputRedeem4, _inputWitness5, _address7, _hash6, _output7, _input4, _redeem4, _witness6, _addressComputed7, _hashComputed6, _outputComputed7, _inputComputed4, _redeemComputed4, _witnessComputed6, _decodedAddress7, _decodedAddressComputed7, _redeemChunks, _redeemChunksComputed, _P2WSH_instances, getDecodedAddress_fn7, getRedeemChunks_fn, computeAddress_fn7, computeHash_fn6, computeOutput_fn7, computeInput_fn4, computeRedeem_fn4, computeWitness_fn6, validate_fn7;
var _P2WSH = class _P2WSH {
  /**
   * Creates a new P2WSH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32 encoded address
   * @param params.hash - 32-byte witness program (SHA256 of script)
   * @param params.output - The scriptPubKey
   * @param params.redeem - The redeem script information
   * @param params.witness - The witness stack
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2WSH_instances);
    // Private instance fields
    __privateAdd(this, _network7);
    __privateAdd(this, _opts7);
    // Input data (provided by user)
    __privateAdd(this, _inputAddress7);
    __privateAdd(this, _inputHash6);
    __privateAdd(this, _inputOutput7);
    __privateAdd(this, _inputRedeem4);
    __privateAdd(this, _inputWitness5);
    // Cached computed values
    __privateAdd(this, _address7);
    __privateAdd(this, _hash6);
    __privateAdd(this, _output7);
    __privateAdd(this, _input4);
    __privateAdd(this, _redeem4);
    __privateAdd(this, _witness6);
    // Cache flags
    __privateAdd(this, _addressComputed7, false);
    __privateAdd(this, _hashComputed6, false);
    __privateAdd(this, _outputComputed7, false);
    __privateAdd(this, _inputComputed4, false);
    __privateAdd(this, _redeemComputed4, false);
    __privateAdd(this, _witnessComputed6, false);
    // Decoded address cache
    __privateAdd(this, _decodedAddress7);
    __privateAdd(this, _decodedAddressComputed7, false);
    // Decoded redeem chunks cache
    __privateAdd(this, _redeemChunks);
    __privateAdd(this, _redeemChunksComputed, false);
    let network = params.network;
    if (!network) {
      network = params.redeem && params.redeem.network || bitcoin$1;
    }
    __privateSet(this, _network7, network);
    __privateSet(this, _opts7, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputAddress7, params.address);
    __privateSet(this, _inputHash6, params.hash);
    __privateSet(this, _inputOutput7, params.output);
    __privateSet(this, _inputRedeem4, params.redeem);
    __privateSet(this, _inputWitness5, params.witness);
    if (__privateGet(this, _opts7).validate) {
      __privateMethod(this, _P2WSH_instances, validate_fn7).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const r2 = this.redeem;
    if (r2 !== void 0 && r2.name !== void 0) {
      return `p2wsh-${r2.name}`;
    }
    return PaymentType.P2WSH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network7);
  }
  /**
   * Bech32 encoded address (bc1q... for mainnet).
   */
  get address() {
    if (!__privateGet(this, _addressComputed7)) {
      __privateSet(this, _address7, __privateMethod(this, _P2WSH_instances, computeAddress_fn7).call(this));
      __privateSet(this, _addressComputed7, true);
    }
    return __privateGet(this, _address7);
  }
  /**
   * 32-byte witness program (SHA256 of redeem script).
   */
  get hash() {
    if (!__privateGet(this, _hashComputed6)) {
      __privateSet(this, _hash6, __privateMethod(this, _P2WSH_instances, computeHash_fn6).call(this));
      __privateSet(this, _hashComputed6, true);
    }
    return __privateGet(this, _hash6);
  }
  /**
   * The scriptPubKey: `OP_0 {32-byte hash}`
   */
  get output() {
    if (!__privateGet(this, _outputComputed7)) {
      __privateSet(this, _output7, __privateMethod(this, _P2WSH_instances, computeOutput_fn7).call(this));
      __privateSet(this, _outputComputed7, true);
    }
    return __privateGet(this, _output7);
  }
  /**
   * The scriptSig (always empty for native SegWit).
   */
  get input() {
    if (!__privateGet(this, _inputComputed4)) {
      __privateSet(this, _input4, __privateMethod(this, _P2WSH_instances, computeInput_fn4).call(this));
      __privateSet(this, _inputComputed4, true);
    }
    return __privateGet(this, _input4);
  }
  /**
   * The redeem script information.
   */
  get redeem() {
    if (!__privateGet(this, _redeemComputed4)) {
      __privateSet(this, _redeem4, __privateMethod(this, _P2WSH_instances, computeRedeem_fn4).call(this));
      __privateSet(this, _redeemComputed4, true);
    }
    return __privateGet(this, _redeem4);
  }
  /**
   * Witness stack: `[{scriptSig...}, {redeemScript}]`
   */
  get witness() {
    if (!__privateGet(this, _witnessComputed6)) {
      __privateSet(this, _witness6, __privateMethod(this, _P2WSH_instances, computeWitness_fn6).call(this));
      __privateSet(this, _witnessComputed6, true);
    }
    return __privateGet(this, _witness6);
  }
  // Static factory methods
  /**
   * Creates a P2WSH payment from a redeem script.
   *
   * @param redeem - The redeem script information
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   *
   * @example
   * ```typescript
   * const p2wsh = P2WSH.fromRedeem({ output: redeemScript });
   * ```
   */
  static fromRedeem(redeem, network) {
    return new _P2WSH({ redeem, network });
  }
  /**
   * Creates a P2WSH payment from a bech32 address.
   *
   * @param address - Bech32 encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromAddress(address, network) {
    return new _P2WSH({ address, network });
  }
  /**
   * Creates a P2WSH payment from a 32-byte witness program.
   *
   * @param hash - 32-byte witness program (SHA256 of script)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromHash(hash2, network) {
    return new _P2WSH({ hash: hash2, network });
  }
  /**
   * Creates a P2WSH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromOutput(output, network) {
    return new _P2WSH({ output, network });
  }
  // Private helper methods
  /**
   * Converts to a plain P2WSHPayment object for backwards compatibility.
   *
   * @returns A P2WSHPayment object
   */
  toPayment() {
    const witness = this.witness;
    const redeem = this.redeem;
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      output: this.output,
      input: this.input,
      redeem,
      witness
    };
  }
};
_network7 = new WeakMap();
_opts7 = new WeakMap();
_inputAddress7 = new WeakMap();
_inputHash6 = new WeakMap();
_inputOutput7 = new WeakMap();
_inputRedeem4 = new WeakMap();
_inputWitness5 = new WeakMap();
_address7 = new WeakMap();
_hash6 = new WeakMap();
_output7 = new WeakMap();
_input4 = new WeakMap();
_redeem4 = new WeakMap();
_witness6 = new WeakMap();
_addressComputed7 = new WeakMap();
_hashComputed6 = new WeakMap();
_outputComputed7 = new WeakMap();
_inputComputed4 = new WeakMap();
_redeemComputed4 = new WeakMap();
_witnessComputed6 = new WeakMap();
_decodedAddress7 = new WeakMap();
_decodedAddressComputed7 = new WeakMap();
_redeemChunks = new WeakMap();
_redeemChunksComputed = new WeakMap();
_P2WSH_instances = new WeakSet();
getDecodedAddress_fn7 = function() {
  if (!__privateGet(this, _decodedAddressComputed7)) {
    if (__privateGet(this, _inputAddress7)) {
      const result = distExports.bech32.decode(__privateGet(this, _inputAddress7));
      const version2 = result.words.shift();
      const data = distExports.bech32.fromWords(result.words);
      __privateSet(this, _decodedAddress7, {
        version: version2 ?? 0,
        prefix: result.prefix,
        data: new Uint8Array(data)
      });
    }
    __privateSet(this, _decodedAddressComputed7, true);
  }
  return __privateGet(this, _decodedAddress7);
};
// Private computation methods
getRedeemChunks_fn = function() {
  var _a5;
  if (!__privateGet(this, _redeemChunksComputed)) {
    if ((_a5 = __privateGet(this, _inputRedeem4)) == null ? void 0 : _a5.input) {
      __privateSet(this, _redeemChunks, decompile(__privateGet(this, _inputRedeem4).input) ?? void 0);
    }
    __privateSet(this, _redeemChunksComputed, true);
  }
  return __privateGet(this, _redeemChunks);
};
computeAddress_fn7 = function() {
  if (__privateGet(this, _inputAddress7)) {
    return __privateGet(this, _inputAddress7);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  const words = distExports.bech32.toWords(h);
  words.unshift(0);
  return distExports.bech32.encode(__privateGet(this, _network7).bech32, words);
};
computeHash_fn6 = function() {
  var _a5;
  if (__privateGet(this, _inputHash6)) {
    return __privateGet(this, _inputHash6);
  }
  if (__privateGet(this, _inputOutput7)) {
    return __privateGet(this, _inputOutput7).subarray(2);
  }
  if (__privateGet(this, _inputAddress7)) {
    return (_a5 = __privateMethod(this, _P2WSH_instances, getDecodedAddress_fn7).call(this)) == null ? void 0 : _a5.data;
  }
  const r2 = this.redeem;
  if (r2 && r2.output) {
    return sha256$12(r2.output);
  }
  return void 0;
};
computeOutput_fn7 = function() {
  if (__privateGet(this, _inputOutput7)) {
    return __privateGet(this, _inputOutput7);
  }
  const h = this.hash;
  if (!h)
    return void 0;
  return compile([OPS$3.OP_0, h]);
};
computeInput_fn4 = function() {
  if (this.witness) {
    return EMPTY_BUFFER;
  }
  return void 0;
};
computeRedeem_fn4 = function() {
  if (__privateGet(this, _inputRedeem4)) {
    return __privateGet(this, _inputRedeem4);
  }
  if (__privateGet(this, _inputWitness5) && __privateGet(this, _inputWitness5).length > 0) {
    return {
      output: __privateGet(this, _inputWitness5)[__privateGet(this, _inputWitness5).length - 1],
      input: EMPTY_BUFFER,
      witness: __privateGet(this, _inputWitness5).slice(0, -1)
    };
  }
  return void 0;
};
// Validation
computeWitness_fn6 = function() {
  if (__privateGet(this, _inputWitness5)) {
    return __privateGet(this, _inputWitness5);
  }
  const r2 = __privateGet(this, _inputRedeem4);
  if (r2) {
    if (r2.input && r2.input.length > 0 && r2.output && r2.output.length > 0) {
      const chunks = __privateMethod(this, _P2WSH_instances, getRedeemChunks_fn).call(this);
      if (chunks) {
        const stack = toStack(chunks);
        __privateSet(this, _redeem4, Object.assign({ witness: stack }, r2, { input: EMPTY_BUFFER }));
        __privateSet(this, _redeemComputed4, true);
        return [].concat(stack, r2.output);
      }
    }
    if (!r2.output)
      return void 0;
    if (!r2.witness)
      return void 0;
    return [].concat(r2.witness, r2.output);
  }
  return void 0;
};
validate_fn7 = function() {
  let hash2 = new Uint8Array(0);
  if (__privateGet(this, _inputAddress7)) {
    const addr = __privateMethod(this, _P2WSH_instances, getDecodedAddress_fn7).call(this);
    if (!addr) {
      throw new TypeError("Invalid address");
    }
    if (addr.prefix !== __privateGet(this, _network7).bech32) {
      throw new TypeError("Invalid prefix or Network mismatch");
    }
    if (addr.version !== 0) {
      throw new TypeError("Invalid address version");
    }
    if (addr.data.length !== 32) {
      throw new TypeError("Invalid address data");
    }
    hash2 = addr.data;
  }
  if (__privateGet(this, _inputHash6)) {
    if (hash2.length > 0 && !equals(hash2, __privateGet(this, _inputHash6))) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = __privateGet(this, _inputHash6);
    }
  }
  if (__privateGet(this, _inputOutput7)) {
    if (__privateGet(this, _inputOutput7).length !== 34 || __privateGet(this, _inputOutput7)[0] !== OPS$3.OP_0 || __privateGet(this, _inputOutput7)[1] !== 32) {
      throw new TypeError("Output is invalid");
    }
    const hash22 = __privateGet(this, _inputOutput7).subarray(2);
    if (hash2.length > 0 && !equals(hash2, hash22)) {
      throw new TypeError("Hash mismatch");
    } else {
      hash2 = hash22;
    }
  }
  if (__privateGet(this, _inputRedeem4)) {
    if (__privateGet(this, _inputRedeem4).network && __privateGet(this, _inputRedeem4).network !== __privateGet(this, _network7)) {
      throw new TypeError("Network mismatch");
    }
    if (__privateGet(this, _inputRedeem4).input && __privateGet(this, _inputRedeem4).input.length > 0 && __privateGet(this, _inputRedeem4).witness && __privateGet(this, _inputRedeem4).witness.length > 0) {
      throw new TypeError("Ambiguous witness source");
    }
    if (__privateGet(this, _inputRedeem4).output) {
      const decompile$1 = decompile(__privateGet(this, _inputRedeem4).output);
      if (!decompile$1 || decompile$1.length < 1) {
        throw new TypeError("Redeem.output is invalid");
      }
      if (__privateGet(this, _inputRedeem4).output.byteLength > 3600) {
        throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");
      }
      if (countNonPushOnlyOPs(decompile$1) > 201) {
        throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
      }
      const hash22 = sha256$12(__privateGet(this, _inputRedeem4).output);
      if (hash2.length > 0 && !equals(hash2, hash22)) {
        throw new TypeError("Hash mismatch");
      } else {
        hash2 = hash22;
      }
    }
    const chunks = __privateMethod(this, _P2WSH_instances, getRedeemChunks_fn).call(this);
    if (__privateGet(this, _inputRedeem4).input && chunks && !isPushOnly(chunks)) {
      throw new TypeError("Non push-only scriptSig");
    }
    if (__privateGet(this, _inputWitness5) && __privateGet(this, _inputRedeem4).witness && !stacksEqual(__privateGet(this, _inputWitness5), __privateGet(this, _inputRedeem4).witness)) {
      throw new TypeError("Witness and redeem.witness mismatch");
    }
    if (__privateGet(this, _inputRedeem4).input && (chunks == null ? void 0 : chunks.some(chunkHasUncompressedPubkey)) || __privateGet(this, _inputRedeem4).output && (decompile(__privateGet(this, _inputRedeem4).output) || []).some(chunkHasUncompressedPubkey)) {
      throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
    }
  }
  if (__privateGet(this, _inputWitness5) && __privateGet(this, _inputWitness5).length > 0) {
    const wScript = __privateGet(this, _inputWitness5)[__privateGet(this, _inputWitness5).length - 1];
    if (__privateGet(this, _inputRedeem4) && __privateGet(this, _inputRedeem4).output && !equals(__privateGet(this, _inputRedeem4).output, wScript)) {
      throw new TypeError("Witness and redeem.output mismatch");
    }
    if (__privateGet(this, _inputWitness5).some(chunkHasUncompressedPubkey) || (decompile(wScript) || []).some(chunkHasUncompressedPubkey)) {
      throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
};
// Static public fields
__publicField(_P2WSH, "NAME", PaymentType.P2WSH);
var P2WSH = _P2WSH;
function p2wsh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness) {
    throw new TypeError("Not enough data");
  }
  const instance = new P2WSH({
    address: a.address,
    hash: a.hash,
    output: a.output,
    redeem: a.redeem,
    witness: a.witness,
    network: a.network
  }, opts);
  return instance.toPayment();
}
var FUTURE_SEGWIT_MAX_SIZE = 40;
var FUTURE_SEGWIT_MIN_SIZE = 2;
var FUTURE_SEGWIT_MAX_VERSION = 15;
var FUTURE_MAX_VERSION = 16;
var FUTURE_OPNET_VERSION = 16;
var FUTURE_SEGWIT_MIN_VERSION = 2;
var FUTURE_SEGWIT_VERSION_DIFF = 80;
var FUTURE_SEGWIT_VERSION_WARNING = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
var isUnknownSegwitVersion = (output) => {
  try {
    const data = output.subarray(2);
    if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) {
      throw new TypeError("Invalid program length for segwit address");
    }
    const firstByte = output[0];
    if (firstByte === void 0)
      throw new TypeError("Empty output");
    const version2 = firstByte - FUTURE_SEGWIT_VERSION_DIFF;
    if (version2 < FUTURE_SEGWIT_MIN_VERSION || version2 > FUTURE_SEGWIT_MAX_VERSION + 1) {
      throw new TypeError("Invalid version for segwit address");
    }
    if (version2 === 1)
      throw new TypeError("taproot");
    return true;
  } catch (e) {
  }
  return false;
};
function toFutureOPNetAddress(output, network) {
  if (!(output instanceof Uint8Array))
    throw new TypeError("output must be a Uint8Array");
  if (!network.bech32Opnet)
    throw new Error("Network does not support opnet");
  const opcode = output[0];
  let pushPos = 1, progLen;
  const byte1 = output[1];
  const byte2 = output[2];
  if (byte1 !== void 0 && byte1 < 76) {
    progLen = byte1;
    pushPos = 2;
  } else if (byte1 === 76 && byte2 !== void 0) {
    progLen = byte2;
    pushPos = 3;
  } else {
    throw new TypeError("Unsupported push opcode in script");
  }
  const program = output.subarray(pushPos, pushPos + progLen);
  if (program.length < FUTURE_SEGWIT_MIN_SIZE || program.length > FUTURE_SEGWIT_MAX_SIZE)
    throw new TypeError("Invalid program length for segwit address");
  const version2 = opcode === opcodes.OP_0 ? 0 : opcode !== void 0 && opcode >= opcodes.OP_1 && opcode <= opcodes.OP_16 ? opcode - (opcodes.OP_1 - 1) : -1;
  if (version2 < FUTURE_SEGWIT_MAX_VERSION || version2 > FUTURE_MAX_VERSION)
    throw new TypeError(`Invalid segwit version ${version2}`);
  const words = [version2, ...distExports.bech32m.toWords(program)];
  return distExports.bech32m.encode(network.bech32Opnet, words);
}
function _toFutureSegwitAddress(output, network) {
  const data = output.subarray(2);
  if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) {
    throw new TypeError("Invalid program length for segwit address");
  }
  const firstByte = output[0];
  if (firstByte === void 0)
    throw new TypeError("Empty output");
  const version2 = firstByte - FUTURE_SEGWIT_VERSION_DIFF;
  if (version2 < FUTURE_SEGWIT_MIN_VERSION || version2 > FUTURE_SEGWIT_MAX_VERSION) {
    throw new TypeError("Invalid version for segwit address");
  }
  if (output[1] !== data.length) {
    throw new TypeError(`Invalid script for segwit address ${output[1]} !== ${data.length}`);
  }
  return toBech32(data, version2, network.bech32, network.bech32Opnet);
}
function fromBase58Check(address) {
  const payload = new Uint8Array(decode$i(address));
  if (payload.length < 21)
    throw new TypeError(address + " is too short");
  if (payload.length > 21)
    throw new TypeError(address + " is too long");
  const version2 = payload[0];
  const hash2 = payload.subarray(1);
  return { version: version2, hash: hash2 };
}
function toBase58Check(hash2, version2) {
  if (!isBytes20(hash2))
    throw new TypeError("Expected 20 bytes hash");
  if (!isUInt8(version2))
    throw new TypeError("Expected UInt8 version");
  const payload = alloc(21);
  payload[0] = version2;
  payload.set(hash2, 1);
  return encode$j(payload);
}
function toBech32(data, version2, prefix, prefixOpnet) {
  const words = distExports.bech32.toWords(data);
  words.unshift(version2);
  if (version2 === FUTURE_OPNET_VERSION && prefixOpnet) {
    return distExports.bech32m.encode(prefixOpnet, words);
  }
  return version2 === 0 ? distExports.bech32.encode(prefix, words) : distExports.bech32m.encode(prefix, words);
}
function fromOutputScript(output, network) {
  network = network || bitcoin$1;
  const len = output.length;
  if (len === 25 && output[0] === 118 && output[1] === 169 && output[2] === 20 && output[23] === 136 && output[24] === 172) {
    return toBase58Check(output.subarray(3, 23), network.pubKeyHash);
  }
  if (len === 23 && output[0] === 169 && output[1] === 20 && output[22] === 135) {
    return toBase58Check(output.subarray(2, 22), network.scriptHash);
  }
  if (len === 22 && output[0] === 0 && output[1] === 20) {
    return toBech32(output.subarray(2, 22), 0, network.bech32);
  }
  if (len === 34 && output[0] === 0 && output[1] === 32) {
    return toBech32(output.subarray(2, 34), 0, network.bech32);
  }
  if (len === 34 && output[0] === 81 && output[1] === 32) {
    const words = distExports.bech32m.toWords(output.subarray(2, 34));
    words.unshift(1);
    return distExports.bech32m.encode(network.bech32, words);
  }
  if (len === 34 && output[0] === 82 && output[1] === 32) {
    const words = distExports.bech32m.toWords(output.subarray(2, 34));
    words.unshift(2);
    return distExports.bech32m.encode(network.bech32, words);
  }
  try {
    return toFutureOPNetAddress(output, network);
  } catch (e) {
  }
  try {
    return _toFutureSegwitAddress(output, network);
  } catch (e) {
  }
  throw new Error(toASM(output) + " has no matching Address");
}
function toOutputScript(address, networkOrOptions) {
  let network;
  let onFutureSegwitWarning;
  if (networkOrOptions && "bech32" in networkOrOptions) {
    network = networkOrOptions;
  } else if (networkOrOptions && typeof networkOrOptions === "object") {
    network = networkOrOptions.network || bitcoin$1;
    onFutureSegwitWarning = networkOrOptions.onFutureSegwitWarning;
  } else {
    network = bitcoin$1;
  }
  let decodeBase58;
  let decodeBech32;
  try {
    decodeBase58 = fromBase58Check(address);
  } catch (e) {
  }
  if (decodeBase58) {
    if (decodeBase58.version === network.pubKeyHash)
      return p2pkh({ hash: decodeBase58.hash }).output;
    if (decodeBase58.version === network.scriptHash)
      return p2sh({ hash: decodeBase58.hash }).output;
  } else {
    try {
      decodeBech32 = fromBech32(address);
    } catch (e) {
    }
    if (decodeBech32) {
      if (decodeBech32.prefix !== network.bech32 && network.bech32Opnet && decodeBech32.prefix !== network.bech32Opnet)
        throw new Error(address + " has an invalid prefix");
      if (decodeBech32.version === 0) {
        if (decodeBech32.data.length === 20)
          return p2wpkh({ hash: toBytes20(decodeBech32.data) }).output;
        if (decodeBech32.data.length === 32)
          return p2wsh({ hash: toBytes32(decodeBech32.data) }).output;
      } else if (decodeBech32.version === 1) {
        if (decodeBech32.data.length === 32)
          return p2tr({ pubkey: decodeBech32.data }).output;
      } else if (decodeBech32.version === 2 && decodeBech32.data.length === 32) {
        return p2mr({ hash: toBytes32(decodeBech32.data) }).output;
      } else if (decodeBech32.version === FUTURE_OPNET_VERSION) {
        if (!network.bech32Opnet)
          throw new Error(address + " has an invalid prefix");
        return p2op({
          program: decodeBech32.data,
          network
        }).output;
      } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
        if (decodeBech32.version !== FUTURE_OPNET_VERSION && onFutureSegwitWarning) {
          onFutureSegwitWarning(FUTURE_SEGWIT_VERSION_WARNING);
        }
        return compile([
          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
          decodeBech32.data
        ]);
      }
    }
  }
  throw new TypeError(address + " has no matching Script");
}
var OPS$2 = opcodes;
var _network8, _opts8, _inputPubkey4, _inputSignature4, _inputOutput8, _inputInput3, _pubkey4, _signature4, _output8, _input5, _witness7, _pubkeyComputed4, _signatureComputed4, _outputComputed8, _inputComputed5, _witnessComputed7, _P2PK_instances, computePubkey_fn4, computeSignature_fn4, computeOutput_fn8, computeInput_fn5, computeWitness_fn7, validate_fn8;
var _P2PK = class _P2PK {
  /**
   * Creates a new P2PK payment instance.
   *
   * @param params - Payment parameters
   * @param params.pubkey - The public key (33 or 65 bytes)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2PK_instances);
    // Private instance fields
    __privateAdd(this, _network8);
    __privateAdd(this, _opts8);
    // Input data (provided by user)
    __privateAdd(this, _inputPubkey4);
    __privateAdd(this, _inputSignature4);
    __privateAdd(this, _inputOutput8);
    __privateAdd(this, _inputInput3);
    // Cached computed values
    __privateAdd(this, _pubkey4);
    __privateAdd(this, _signature4);
    __privateAdd(this, _output8);
    __privateAdd(this, _input5);
    __privateAdd(this, _witness7);
    // Cache flags
    __privateAdd(this, _pubkeyComputed4, false);
    __privateAdd(this, _signatureComputed4, false);
    __privateAdd(this, _outputComputed8, false);
    __privateAdd(this, _inputComputed5, false);
    __privateAdd(this, _witnessComputed7, false);
    __privateSet(this, _network8, params.network ?? bitcoin$1);
    __privateSet(this, _opts8, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputPubkey4, params.pubkey);
    __privateSet(this, _inputSignature4, params.signature);
    __privateSet(this, _inputOutput8, params.output);
    __privateSet(this, _inputInput3, params.input);
    if (__privateGet(this, _opts8).validate) {
      __privateMethod(this, _P2PK_instances, validate_fn8).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return PaymentType.P2PK;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network8);
  }
  /**
   * The public key (33 or 65 bytes).
   * Computed lazily from output if not provided directly.
   */
  get pubkey() {
    if (!__privateGet(this, _pubkeyComputed4)) {
      __privateSet(this, _pubkey4, __privateMethod(this, _P2PK_instances, computePubkey_fn4).call(this));
      __privateSet(this, _pubkeyComputed4, true);
    }
    return __privateGet(this, _pubkey4);
  }
  /**
   * The DER-encoded signature.
   * Computed lazily from input if not provided directly.
   */
  get signature() {
    if (!__privateGet(this, _signatureComputed4)) {
      __privateSet(this, _signature4, __privateMethod(this, _P2PK_instances, computeSignature_fn4).call(this));
      __privateSet(this, _signatureComputed4, true);
    }
    return __privateGet(this, _signature4);
  }
  /**
   * The scriptPubKey: `{pubKey} OP_CHECKSIG`
   * Computed lazily from pubkey if not provided directly.
   */
  get output() {
    if (!__privateGet(this, _outputComputed8)) {
      __privateSet(this, _output8, __privateMethod(this, _P2PK_instances, computeOutput_fn8).call(this));
      __privateSet(this, _outputComputed8, true);
    }
    return __privateGet(this, _output8);
  }
  /**
   * The scriptSig: `{signature}`
   * Computed lazily from signature if not provided directly.
   */
  get input() {
    if (!__privateGet(this, _inputComputed5)) {
      __privateSet(this, _input5, __privateMethod(this, _P2PK_instances, computeInput_fn5).call(this));
      __privateSet(this, _inputComputed5, true);
    }
    return __privateGet(this, _input5);
  }
  /**
   * Witness stack (empty for P2PK as it's not a SegWit type).
   */
  get witness() {
    if (!__privateGet(this, _witnessComputed7)) {
      __privateSet(this, _witness7, __privateMethod(this, _P2PK_instances, computeWitness_fn7).call(this));
      __privateSet(this, _witnessComputed7, true);
    }
    return __privateGet(this, _witness7);
  }
  // Static factory methods
  /**
   * Creates a P2PK payment from a public key.
   *
   * @param pubkey - The public key (33 or 65 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromPubkey(pubkey);
   * const scriptPubKey = payment.output;
   * ```
   */
  static fromPubkey(pubkey, network) {
    return new _P2PK({ pubkey, network });
  }
  /**
   * Creates a P2PK payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromOutput(scriptPubKey);
   * const pubkey = payment.pubkey;
   * ```
   */
  static fromOutput(output, network) {
    return new _P2PK({ output, network });
  }
  /**
   * Creates a P2PK payment from a signature (for spending).
   *
   * @param signature - The DER-encoded signature
   * @param pubkey - The public key (optional, for validation)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromSignature(signature, pubkey);
   * const scriptSig = payment.input;
   * ```
   */
  static fromSignature(signature2, pubkey, network) {
    return new _P2PK({ signature: signature2, pubkey, network });
  }
  // Private computation methods
  /**
   * Converts to a plain P2PKPayment object for backwards compatibility.
   *
   * @returns A P2PKPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
};
_network8 = new WeakMap();
_opts8 = new WeakMap();
_inputPubkey4 = new WeakMap();
_inputSignature4 = new WeakMap();
_inputOutput8 = new WeakMap();
_inputInput3 = new WeakMap();
_pubkey4 = new WeakMap();
_signature4 = new WeakMap();
_output8 = new WeakMap();
_input5 = new WeakMap();
_witness7 = new WeakMap();
_pubkeyComputed4 = new WeakMap();
_signatureComputed4 = new WeakMap();
_outputComputed8 = new WeakMap();
_inputComputed5 = new WeakMap();
_witnessComputed7 = new WeakMap();
_P2PK_instances = new WeakSet();
computePubkey_fn4 = function() {
  if (__privateGet(this, _inputPubkey4)) {
    return __privateGet(this, _inputPubkey4);
  }
  if (__privateGet(this, _inputOutput8)) {
    return __privateGet(this, _inputOutput8).subarray(1, -1);
  }
  return void 0;
};
computeSignature_fn4 = function() {
  if (__privateGet(this, _inputSignature4)) {
    return __privateGet(this, _inputSignature4);
  }
  if (__privateGet(this, _inputInput3)) {
    const chunks = decompile(__privateGet(this, _inputInput3));
    if (chunks && chunks.length > 0) {
      return chunks[0];
    }
  }
  return void 0;
};
computeOutput_fn8 = function() {
  if (__privateGet(this, _inputOutput8)) {
    return __privateGet(this, _inputOutput8);
  }
  const pubkey = __privateGet(this, _inputPubkey4);
  if (pubkey) {
    return compile([pubkey, OPS$2.OP_CHECKSIG]);
  }
  return void 0;
};
computeInput_fn5 = function() {
  if (__privateGet(this, _inputInput3)) {
    return __privateGet(this, _inputInput3);
  }
  const signature2 = __privateGet(this, _inputSignature4);
  if (signature2) {
    return compile([signature2]);
  }
  return void 0;
};
// Validation
computeWitness_fn7 = function() {
  if (this.input) {
    return [];
  }
  return void 0;
};
validate_fn8 = function() {
  if (__privateGet(this, _inputOutput8)) {
    if (__privateGet(this, _inputOutput8)[__privateGet(this, _inputOutput8).length - 1] !== OPS$2.OP_CHECKSIG) {
      throw new TypeError("Output is invalid");
    }
    const extractedPubkey = this.pubkey;
    if (!isPoint(extractedPubkey)) {
      throw new TypeError("Output pubkey is invalid");
    }
    if (__privateGet(this, _inputPubkey4) && extractedPubkey && !equals(__privateGet(this, _inputPubkey4), extractedPubkey)) {
      throw new TypeError("Pubkey mismatch");
    }
  }
  if (__privateGet(this, _inputSignature4)) {
    const computedInput = this.input;
    if (__privateGet(this, _inputInput3) && computedInput && !equals(__privateGet(this, _inputInput3), computedInput)) {
      throw new TypeError("Signature mismatch");
    }
  }
  if (__privateGet(this, _inputInput3)) {
    const chunks = decompile(__privateGet(this, _inputInput3));
    if (!chunks || chunks.length !== 1) {
      throw new TypeError("Input is invalid");
    }
    const sig = this.signature;
    if (!sig || !isCanonicalScriptSignature(sig)) {
      throw new TypeError("Input has invalid signature");
    }
  }
};
// Static public fields
__publicField(_P2PK, "NAME", PaymentType.P2PK);
var P2PK = _P2PK;
function p2pk(a, opts) {
  if (!a.input && !a.output && !a.pubkey && !a.signature) {
    throw new TypeError("Not enough data");
  }
  const instance = new P2PK({
    pubkey: a.pubkey,
    signature: a.signature,
    output: a.output,
    input: a.input,
    network: a.network
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
var OPS$1 = opcodes;
var _network9, _opts9, _inputData, _inputOutput9, _data4, _output9, _dataComputed, _outputComputed9, _Embed_instances, computeData_fn, computeOutput_fn9, validate_fn9;
var _Embed = class _Embed {
  /**
   * Creates a new Embed payment instance.
   *
   * @param params - Payment parameters
   * @param params.data - Array of data chunks to embed
   * @param params.output - The scriptPubKey
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _Embed_instances);
    // Private instance fields
    __privateAdd(this, _network9);
    __privateAdd(this, _opts9);
    // Input data (provided by user)
    __privateAdd(this, _inputData);
    __privateAdd(this, _inputOutput9);
    // Cached computed values
    __privateAdd(this, _data4);
    __privateAdd(this, _output9);
    // Cache flags
    __privateAdd(this, _dataComputed, false);
    __privateAdd(this, _outputComputed9, false);
    __privateSet(this, _network9, params.network ?? bitcoin$1);
    __privateSet(this, _opts9, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputData, params.data);
    __privateSet(this, _inputOutput9, params.output);
    if (__privateGet(this, _opts9).validate) {
      __privateMethod(this, _Embed_instances, validate_fn9).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return PaymentType.Embed;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network9);
  }
  /**
   * The embedded data chunks.
   */
  get data() {
    if (!__privateGet(this, _dataComputed)) {
      __privateSet(this, _data4, __privateMethod(this, _Embed_instances, computeData_fn).call(this));
      __privateSet(this, _dataComputed, true);
    }
    return __privateGet(this, _data4) ?? [];
  }
  /**
   * The scriptPubKey: `OP_RETURN {data...}`
   */
  get output() {
    if (!__privateGet(this, _outputComputed9)) {
      __privateSet(this, _output9, __privateMethod(this, _Embed_instances, computeOutput_fn9).call(this));
      __privateSet(this, _outputComputed9, true);
    }
    return __privateGet(this, _output9);
  }
  // Static factory methods
  /**
   * Creates an Embed payment from data chunks.
   *
   * @param data - Array of data chunks to embed
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new Embed payment instance
   *
   * @example
   * ```typescript
   * const payment = Embed.fromData([
   *   new TextEncoder().encode('Hello'),
   *   new TextEncoder().encode('Bitcoin')
   * ]);
   * ```
   */
  static fromData(data, network) {
    return new _Embed({ data, network });
  }
  /**
   * Creates an Embed payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new Embed payment instance
   */
  static fromOutput(output, network) {
    return new _Embed({ output, network });
  }
  // Private computation methods
  /**
   * Converts to a plain EmbedPayment object for backwards compatibility.
   *
   * @returns An EmbedPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      data: this.data,
      output: this.output
    };
  }
};
_network9 = new WeakMap();
_opts9 = new WeakMap();
_inputData = new WeakMap();
_inputOutput9 = new WeakMap();
_data4 = new WeakMap();
_output9 = new WeakMap();
_dataComputed = new WeakMap();
_outputComputed9 = new WeakMap();
_Embed_instances = new WeakSet();
computeData_fn = function() {
  if (__privateGet(this, _inputData)) {
    return __privateGet(this, _inputData);
  }
  if (__privateGet(this, _inputOutput9)) {
    const script$1 = decompile(__privateGet(this, _inputOutput9));
    if (script$1 === null || script$1 === void 0) {
      return void 0;
    }
    return script$1.slice(1);
  }
  return void 0;
};
// Validation
computeOutput_fn9 = function() {
  if (__privateGet(this, _inputOutput9)) {
    return __privateGet(this, _inputOutput9);
  }
  if (!__privateGet(this, _inputData)) {
    return void 0;
  }
  return compile([OPS$1.OP_RETURN].concat(__privateGet(this, _inputData)));
};
validate_fn9 = function() {
  if (__privateGet(this, _inputOutput9)) {
    const chunks = decompile(__privateGet(this, _inputOutput9));
    if (!chunks) {
      throw new TypeError("Output is invalid");
    }
    if (chunks[0] !== OPS$1.OP_RETURN) {
      throw new TypeError("Output is invalid");
    }
    if (!chunks.slice(1).every((c) => c instanceof Uint8Array)) {
      throw new TypeError("Output is invalid");
    }
    if (__privateGet(this, _inputData) && !stacksEqual(__privateGet(this, _inputData), this.data)) {
      throw new TypeError("Data mismatch");
    }
  }
};
// Static public fields
__publicField(_Embed, "NAME", PaymentType.Embed);
var Embed = _Embed;
function p2data(a, opts) {
  if (!a.data && !a.output) {
    throw new TypeError("Not enough data");
  }
  const instance = new Embed({
    data: a.data,
    output: a.output,
    network: a.network
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
var OPS = opcodes;
var OP_INT_BASE = OPS.OP_RESERVED;
var _network10, _opts10, _inputM, _inputN, _inputPubkeys, _inputSignatures, _inputOutput10, _inputInput4, _m, _n3, _pubkeys, _signatures, _output10, _input6, _witness8, _mComputed, _nComputed, _pubkeysComputed, _signaturesComputed, _outputComputed10, _inputComputed6, _witnessComputed8, _decodedChunks, _decoded, _P2MS_instances, decode_fn, computeM_fn, computeN_fn, computePubkeys_fn, computeSignatures_fn, computeOutput_fn10, computeInput_fn6, computeWitness_fn8, isAcceptableSignature_fn, validate_fn10;
var _P2MS = class _P2MS {
  /**
   * Creates a new P2MS payment instance.
   *
   * @param params - Payment parameters
   * @param params.m - Required number of signatures
   * @param params.n - Total number of public keys (optional, derived from pubkeys)
   * @param params.pubkeys - Array of public keys
   * @param params.signatures - Array of signatures
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   * @param opts.allowIncomplete - Allow incomplete signatures (default: false)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(params, opts) {
    __privateAdd(this, _P2MS_instances);
    // Private instance fields
    __privateAdd(this, _network10);
    __privateAdd(this, _opts10);
    // Input data (provided by user)
    __privateAdd(this, _inputM);
    __privateAdd(this, _inputN);
    __privateAdd(this, _inputPubkeys);
    __privateAdd(this, _inputSignatures);
    __privateAdd(this, _inputOutput10);
    __privateAdd(this, _inputInput4);
    // Cached computed values
    __privateAdd(this, _m);
    __privateAdd(this, _n3);
    __privateAdd(this, _pubkeys);
    __privateAdd(this, _signatures);
    __privateAdd(this, _output10);
    __privateAdd(this, _input6);
    __privateAdd(this, _witness8);
    // Cache flags
    __privateAdd(this, _mComputed, false);
    __privateAdd(this, _nComputed, false);
    __privateAdd(this, _pubkeysComputed, false);
    __privateAdd(this, _signaturesComputed, false);
    __privateAdd(this, _outputComputed10, false);
    __privateAdd(this, _inputComputed6, false);
    __privateAdd(this, _witnessComputed8, false);
    // Decoded chunks cache
    __privateAdd(this, _decodedChunks);
    __privateAdd(this, _decoded, false);
    __privateSet(this, _network10, params.network ?? bitcoin$1);
    __privateSet(this, _opts10, {
      validate: (opts == null ? void 0 : opts.validate) ?? true,
      allowIncomplete: (opts == null ? void 0 : opts.allowIncomplete) ?? false
    });
    __privateSet(this, _inputM, params.m);
    __privateSet(this, _inputN, params.n);
    __privateSet(this, _inputPubkeys, params.pubkeys);
    __privateSet(this, _inputSignatures, params.signatures);
    __privateSet(this, _inputOutput10, params.output);
    __privateSet(this, _inputInput4, params.input);
    if (__privateGet(this, _opts10).validate) {
      __privateMethod(this, _P2MS_instances, validate_fn10).call(this);
    }
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const m = this.m;
    const n2 = this.n;
    if (m !== void 0 && n2 !== void 0) {
      return `p2ms(${m} of ${n2})`;
    }
    return PaymentType.P2MS;
  }
  /**
   * Network parameters.
   */
  get network() {
    return __privateGet(this, _network10);
  }
  /**
   * Required number of signatures (M in M-of-N).
   */
  get m() {
    if (!__privateGet(this, _mComputed)) {
      __privateSet(this, _m, __privateMethod(this, _P2MS_instances, computeM_fn).call(this));
      __privateSet(this, _mComputed, true);
    }
    return __privateGet(this, _m);
  }
  /**
   * Total number of public keys (N in M-of-N).
   */
  get n() {
    if (!__privateGet(this, _nComputed)) {
      __privateSet(this, _n3, __privateMethod(this, _P2MS_instances, computeN_fn).call(this));
      __privateSet(this, _nComputed, true);
    }
    return __privateGet(this, _n3);
  }
  /**
   * Array of public keys.
   */
  get pubkeys() {
    if (!__privateGet(this, _pubkeysComputed)) {
      __privateSet(this, _pubkeys, __privateMethod(this, _P2MS_instances, computePubkeys_fn).call(this));
      __privateSet(this, _pubkeysComputed, true);
    }
    return __privateGet(this, _pubkeys);
  }
  /**
   * Array of signatures.
   */
  get signatures() {
    if (!__privateGet(this, _signaturesComputed)) {
      __privateSet(this, _signatures, __privateMethod(this, _P2MS_instances, computeSignatures_fn).call(this));
      __privateSet(this, _signaturesComputed, true);
    }
    return __privateGet(this, _signatures);
  }
  /**
   * The scriptPubKey: `m {pubkeys} n OP_CHECKMULTISIG`
   */
  get output() {
    if (!__privateGet(this, _outputComputed10)) {
      __privateSet(this, _output10, __privateMethod(this, _P2MS_instances, computeOutput_fn10).call(this));
      __privateSet(this, _outputComputed10, true);
    }
    return __privateGet(this, _output10);
  }
  /**
   * The scriptSig: `OP_0 {signatures}`
   */
  get input() {
    if (!__privateGet(this, _inputComputed6)) {
      __privateSet(this, _input6, __privateMethod(this, _P2MS_instances, computeInput_fn6).call(this));
      __privateSet(this, _inputComputed6, true);
    }
    return __privateGet(this, _input6);
  }
  /**
   * Witness stack (empty for P2MS as it's not a SegWit type).
   */
  get witness() {
    if (!__privateGet(this, _witnessComputed8)) {
      __privateSet(this, _witness8, __privateMethod(this, _P2MS_instances, computeWitness_fn8).call(this));
      __privateSet(this, _witnessComputed8, true);
    }
    return __privateGet(this, _witness8);
  }
  // Static factory methods
  /**
   * Creates a P2MS payment from public keys.
   *
   * @param m - Required number of signatures
   * @param pubkeys - Array of public keys
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   *
   * @example
   * ```typescript
   * // Create a 2-of-3 multisig
   * const payment = P2MS.fromPubkeys(2, [pubkey1, pubkey2, pubkey3]);
   * ```
   */
  static fromPubkeys(m, pubkeys, network) {
    return new _P2MS({ m, pubkeys, network });
  }
  /**
   * Creates a P2MS payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   */
  static fromOutput(output, network) {
    return new _P2MS({ output, network });
  }
  /**
   * Creates a P2MS payment from signatures (for spending).
   *
   * @param signatures - Array of signatures
   * @param m - Required number of signatures (optional)
   * @param pubkeys - Array of public keys (optional, for validation)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   */
  static fromSignatures(signatures, m, pubkeys, network) {
    return new _P2MS({ signatures, m, pubkeys, network });
  }
  // Private helper methods
  /**
   * Converts to a plain P2MSPayment object for backwards compatibility.
   *
   * @returns A P2MSPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      m: this.m,
      n: this.n,
      pubkeys: this.pubkeys,
      signatures: this.signatures,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
};
_network10 = new WeakMap();
_opts10 = new WeakMap();
_inputM = new WeakMap();
_inputN = new WeakMap();
_inputPubkeys = new WeakMap();
_inputSignatures = new WeakMap();
_inputOutput10 = new WeakMap();
_inputInput4 = new WeakMap();
_m = new WeakMap();
_n3 = new WeakMap();
_pubkeys = new WeakMap();
_signatures = new WeakMap();
_output10 = new WeakMap();
_input6 = new WeakMap();
_witness8 = new WeakMap();
_mComputed = new WeakMap();
_nComputed = new WeakMap();
_pubkeysComputed = new WeakMap();
_signaturesComputed = new WeakMap();
_outputComputed10 = new WeakMap();
_inputComputed6 = new WeakMap();
_witnessComputed8 = new WeakMap();
_decodedChunks = new WeakMap();
_decoded = new WeakMap();
_P2MS_instances = new WeakSet();
// Private computation methods
decode_fn = function(output) {
  if (__privateGet(this, _decoded))
    return;
  __privateSet(this, _decoded, true);
  __privateSet(this, _decodedChunks, decompile(output) ?? []);
  __privateSet(this, _m, __privateGet(this, _decodedChunks)[0] - OP_INT_BASE);
  __privateSet(this, _n3, __privateGet(this, _decodedChunks)[__privateGet(this, _decodedChunks).length - 2] - OP_INT_BASE);
  __privateSet(this, _pubkeys, __privateGet(this, _decodedChunks).slice(1, -2));
  __privateSet(this, _mComputed, true);
  __privateSet(this, _nComputed, true);
  __privateSet(this, _pubkeysComputed, true);
};
computeM_fn = function() {
  if (__privateGet(this, _inputM) !== void 0) {
    return __privateGet(this, _inputM);
  }
  const output = __privateGet(this, _inputOutput10) ?? this.output;
  if (output) {
    __privateMethod(this, _P2MS_instances, decode_fn).call(this, output);
    return __privateGet(this, _m);
  }
  return void 0;
};
computeN_fn = function() {
  if (__privateGet(this, _inputN) !== void 0) {
    return __privateGet(this, _inputN);
  }
  if (__privateGet(this, _inputPubkeys)) {
    return __privateGet(this, _inputPubkeys).length;
  }
  if (__privateGet(this, _inputOutput10)) {
    __privateMethod(this, _P2MS_instances, decode_fn).call(this, __privateGet(this, _inputOutput10));
    return __privateGet(this, _n3);
  }
  return void 0;
};
computePubkeys_fn = function() {
  if (__privateGet(this, _inputPubkeys)) {
    return __privateGet(this, _inputPubkeys);
  }
  if (__privateGet(this, _inputOutput10)) {
    __privateMethod(this, _P2MS_instances, decode_fn).call(this, __privateGet(this, _inputOutput10));
    return __privateGet(this, _pubkeys);
  }
  return void 0;
};
computeSignatures_fn = function() {
  if (__privateGet(this, _inputSignatures)) {
    return __privateGet(this, _inputSignatures);
  }
  if (__privateGet(this, _inputInput4)) {
    const decompiled = decompile(__privateGet(this, _inputInput4));
    if (decompiled === null || decompiled === void 0) {
      return void 0;
    }
    return decompiled.slice(1);
  }
  return void 0;
};
computeOutput_fn10 = function() {
  if (__privateGet(this, _inputOutput10)) {
    return __privateGet(this, _inputOutput10);
  }
  const m = __privateGet(this, _inputM);
  const n2 = this.n;
  const pubkeys = __privateGet(this, _inputPubkeys);
  if (m === void 0 || n2 === void 0 || !pubkeys) {
    return void 0;
  }
  return compile([].concat(OP_INT_BASE + m, pubkeys, OP_INT_BASE + n2, OPS.OP_CHECKMULTISIG));
};
computeInput_fn6 = function() {
  if (__privateGet(this, _inputInput4)) {
    return __privateGet(this, _inputInput4);
  }
  if (!__privateGet(this, _inputSignatures)) {
    return void 0;
  }
  return compile([OPS.OP_0].concat(__privateGet(this, _inputSignatures)));
};
// Validation
computeWitness_fn8 = function() {
  if (this.input) {
    return [];
  }
  return void 0;
};
isAcceptableSignature_fn = function(x) {
  return isCanonicalScriptSignature(x) || __privateGet(this, _opts10).allowIncomplete && x === OPS.OP_0;
};
validate_fn10 = function() {
  if (__privateGet(this, _inputOutput10)) {
    __privateMethod(this, _P2MS_instances, decode_fn).call(this, __privateGet(this, _inputOutput10));
    const chunks = __privateGet(this, _decodedChunks);
    if (!chunks) {
      throw new TypeError("Output is invalid");
    }
    if (typeof chunks[0] !== "number") {
      throw new TypeError("Output is invalid");
    }
    if (typeof chunks[chunks.length - 2] !== "number") {
      throw new TypeError("Output is invalid");
    }
    if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG) {
      throw new TypeError("Output is invalid");
    }
    const m = __privateGet(this, _m);
    const n2 = __privateGet(this, _n3);
    const pubkeys = __privateGet(this, _pubkeys);
    if (m === void 0 || n2 === void 0 || !pubkeys) {
      throw new TypeError("Output is invalid");
    }
    if (m <= 0 || n2 > 16 || m > n2 || n2 !== chunks.length - 3) {
      throw new TypeError("Output is invalid");
    }
    if (!pubkeys.every((x) => isPoint(x))) {
      throw new TypeError("Output is invalid");
    }
    if (__privateGet(this, _inputM) !== void 0 && __privateGet(this, _inputM) !== m) {
      throw new TypeError("m mismatch");
    }
    if (__privateGet(this, _inputN) !== void 0 && __privateGet(this, _inputN) !== n2) {
      throw new TypeError("n mismatch");
    }
    if (__privateGet(this, _inputPubkeys) && !stacksEqual(__privateGet(this, _inputPubkeys), pubkeys)) {
      throw new TypeError("Pubkeys mismatch");
    }
  }
  if (__privateGet(this, _inputPubkeys)) {
    if (__privateGet(this, _inputN) !== void 0 && __privateGet(this, _inputN) !== __privateGet(this, _inputPubkeys).length) {
      throw new TypeError("Pubkey count mismatch");
    }
    __privateSet(this, _n3, __privateGet(this, _inputPubkeys).length);
    __privateSet(this, _nComputed, true);
    if (__privateGet(this, _m) !== void 0 && __privateGet(this, _n3) < __privateGet(this, _m)) {
      throw new TypeError("Pubkey count cannot be less than m");
    }
  }
  if (__privateGet(this, _inputSignatures)) {
    if (__privateGet(this, _m) !== void 0 && __privateGet(this, _inputSignatures).length < __privateGet(this, _m)) {
      throw new TypeError("Not enough signatures provided");
    }
    if (__privateGet(this, _m) !== void 0 && __privateGet(this, _inputSignatures).length > __privateGet(this, _m)) {
      throw new TypeError("Too many signatures provided");
    }
  }
  if (__privateGet(this, _inputInput4)) {
    if (__privateGet(this, _inputInput4)[0] !== OPS.OP_0) {
      throw new TypeError("Input is invalid");
    }
    const sigs = this.signatures;
    if (!sigs || sigs.length === 0 || !sigs.every((s) => __privateMethod(this, _P2MS_instances, isAcceptableSignature_fn).call(this, s))) {
      throw new TypeError("Input has invalid signature(s)");
    }
    if (__privateGet(this, _inputSignatures) && !stacksEqual(__privateGet(this, _inputSignatures), sigs)) {
      throw new TypeError("Signature mismatch");
    }
    if (__privateGet(this, _inputM) !== void 0 && __privateGet(this, _inputSignatures) && __privateGet(this, _inputM) !== __privateGet(this, _inputSignatures).length) {
      throw new TypeError("Signature count mismatch");
    }
  }
};
// Static public fields
__publicField(_P2MS, "NAME", PaymentType.P2MS);
var P2MS = _P2MS;
function p2ms(a, opts) {
  if (!a.input && !a.output && !(a.pubkeys && a.m !== void 0) && !a.signatures) {
    throw new TypeError("Not enough data");
  }
  const instance = new P2MS({
    m: a.m,
    n: a.n,
    pubkeys: a.pubkeys,
    signatures: a.signatures,
    output: a.output,
    input: a.input,
    network: a.network
  }, opts);
  return Object.assign(instance.toPayment(), a);
}
var payments = Object.freeze(Object.defineProperty({
  __proto__: null,
  Embed,
  LEAF_VERSION_TAPSCRIPT,
  MAX_TAPTREE_DEPTH,
  P2MR,
  P2MS,
  P2OP,
  P2PK,
  P2PKH,
  P2SH,
  P2TR,
  P2WPKH,
  P2WSH,
  PaymentType,
  findScriptPath,
  p2data,
  p2mr,
  p2ms,
  p2op,
  p2pk,
  p2pkh,
  p2sh,
  p2tr,
  p2wpkh,
  p2wsh,
  rootHashFromPath,
  rootHashFromPathP2MR,
  tapBranchHash,
  tapleafHash,
  toHashTree,
  tweakKey
}, Symbol.toStringTag, { value: "Module" }));
function varSliceSize(someScript) {
  const length = someScript.length;
  return encodingLength$1(length) + length;
}
function vectorSize(someVector) {
  const length = someVector.length;
  return encodingLength$1(length) + someVector.reduce((sum, witness) => {
    return sum + varSliceSize(witness);
  }, 0);
}
var EMPTY_BYTES = new Uint8Array(0);
var EMPTY_WITNESS = [];
var ZERO$1 = fromHex$1("0000000000000000000000000000000000000000000000000000000000000000");
var ONE$1 = toMessageHash(fromHex$1("0000000000000000000000000000000000000000000000000000000000000001"));
var BLANK_OUTPUT_VALUE = 0xffffffffffffffffn;
var _Transaction_instances, toBuffer_fn;
var _Transaction = class _Transaction {
  constructor() {
    __privateAdd(this, _Transaction_instances);
    __publicField(this, "version", 1);
    __publicField(this, "locktime", 0);
    __publicField(this, "ins", []);
    __publicField(this, "outs", []);
  }
  /**
   * Parse a transaction from a Uint8Array buffer.
   *
   * @param buffer - The raw transaction bytes
   * @param _NO_STRICT - If true, allow extra data after transaction
   * @returns Parsed Transaction instance
   */
  static fromBuffer(buffer2, _NO_STRICT) {
    const bufferReader = new BinaryReader$1(buffer2);
    const tx = new _Transaction();
    tx.version = bufferReader.readInt32LE();
    const marker = bufferReader.readUInt8();
    const flag = bufferReader.readUInt8();
    let hasWitnesses = false;
    if (marker === _Transaction.ADVANCED_TRANSACTION_MARKER && flag === _Transaction.ADVANCED_TRANSACTION_FLAG) {
      hasWitnesses = true;
    } else {
      bufferReader.offset -= 2;
    }
    const vinLen = bufferReader.readVarInt();
    for (let i2 = 0; i2 < vinLen; ++i2) {
      const hash2 = bufferReader.readBytes(32);
      const index = bufferReader.readUInt32LE();
      const script2 = bufferReader.readVarBytes();
      const sequence = bufferReader.readUInt32LE();
      tx.ins.push({
        hash: hash2,
        index,
        script: script2,
        sequence,
        witness: EMPTY_WITNESS
      });
    }
    const voutLen = bufferReader.readVarInt();
    for (let i2 = 0; i2 < voutLen; ++i2) {
      tx.outs.push({
        value: bufferReader.readUInt64LE(),
        script: bufferReader.readVarBytes()
      });
    }
    if (hasWitnesses) {
      for (let i2 = 0; i2 < vinLen; ++i2) {
        tx.ins[i2].witness = bufferReader.readVector();
      }
      if (!tx.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    tx.locktime = bufferReader.readUInt32LE();
    if (_NO_STRICT)
      return tx;
    if (bufferReader.offset !== buffer2.length)
      throw new Error("Transaction has unexpected data");
    return tx;
  }
  /**
   * Parse a transaction from a hex string.
   *
   * @param hex - The transaction as a hex string
   * @returns Parsed Transaction instance
   */
  static fromHex(hex) {
    return _Transaction.fromBuffer(fromHex$1(hex), false);
  }
  /**
   * Check if a hash is a coinbase hash (all zeros).
   *
   * @param hash - 32-byte hash to check
   * @returns true if hash is all zeros (coinbase)
   */
  static isCoinbaseHash(hash2) {
    if (hash2.length !== 32) {
      throw new TypeError("Expected 32-byte hash");
    }
    for (let i2 = 0; i2 < 32; ++i2) {
      if (hash2[i2] !== 0)
        return false;
    }
    return true;
  }
  isCoinbase() {
    const firstIn = this.ins[0];
    return this.ins.length === 1 && firstIn !== void 0 && _Transaction.isCoinbaseHash(firstIn.hash);
  }
  /**
   * Add an input to this transaction.
   *
   * @param hash - 32-byte hash of the previous transaction
   * @param index - Output index in the previous transaction
   * @param sequence - Sequence number (defaults to 0xffffffff)
   * @param scriptSig - Input script (defaults to empty)
   * @returns The index of the newly added input
   */
  addInput(hash2, index, sequence, scriptSig) {
    if (hash2.length !== 32) {
      throw new TypeError("Expected 32-byte hash");
    }
    if (!Number.isInteger(index) || index < 0 || index > 4294967295) {
      throw new TypeError("Expected unsigned 32-bit integer for index");
    }
    if (sequence !== void 0 && sequence !== null && (!Number.isInteger(sequence) || sequence < 0 || sequence > 4294967295)) {
      throw new TypeError("Expected unsigned 32-bit integer for sequence");
    }
    if (sequence === void 0 || sequence === null) {
      sequence = _Transaction.DEFAULT_SEQUENCE;
    }
    return this.ins.push({
      hash: hash2,
      index,
      script: scriptSig || EMPTY_BYTES,
      sequence,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  /**
   * Add an output to this transaction.
   *
   * @param scriptPubKey - Output script (locking script)
   * @param value - Output value in satoshis (bigint)
   * @returns The index of the newly added output
   */
  addOutput(scriptPubKey, value) {
    if (!(scriptPubKey instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array for scriptPubKey");
    }
    if (typeof value !== "bigint" || value < 0n || value > 0x7fffffffffffffffn) {
      throw new TypeError("Expected bigint satoshi value (0 to 2^63-1)");
    }
    return this.outs.push({
      script: scriptPubKey,
      value
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((x) => {
      return x.witness.length !== 0;
    });
  }
  weight() {
    const base2 = this.byteLength(false);
    const total = this.byteLength(true);
    return base2 * 3 + total;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(_ALLOW_WITNESS = true) {
    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
    return (hasWitnesses ? 10 : 8) + encodingLength$1(this.ins.length) + encodingLength$1(this.outs.length) + this.ins.reduce((sum, input) => {
      return sum + 40 + varSliceSize(input.script);
    }, 0) + this.outs.reduce((sum, output) => {
      return sum + 8 + varSliceSize(output.script);
    }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {
      return sum + vectorSize(input.witness);
    }, 0) : 0);
  }
  clone() {
    const newTx = new _Transaction();
    newTx.version = this.version;
    newTx.locktime = this.locktime;
    newTx.ins = this.ins.map((txIn) => {
      return {
        hash: txIn.hash,
        index: txIn.index,
        script: txIn.script,
        sequence: txIn.sequence,
        witness: txIn.witness
      };
    });
    newTx.outs = this.outs.map((txOut) => {
      return {
        script: txOut.script,
        value: txOut.value
      };
    });
    return newTx;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScript - The script of the output being spent
   * @param hashType - Signature hash type
   * @returns 32-byte hash for signing
   */
  hashForSignature(inIndex, prevOutScript, hashType) {
    var _a5;
    if (!Number.isInteger(inIndex) || inIndex < 0) {
      throw new TypeError("Expected non-negative integer for inIndex");
    }
    if (!(prevOutScript instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array for prevOutScript");
    }
    if (!Number.isInteger(hashType)) {
      throw new TypeError("Expected integer for hashType");
    }
    if (inIndex >= this.ins.length)
      return ONE$1;
    const decompiled = decompile(prevOutScript);
    if (!decompiled)
      throw new Error("Could not decompile prevOutScript");
    const ourScript = compile(decompiled.filter((x) => {
      return x !== opcodes.OP_CODESEPARATOR;
    }));
    const txTmp = this.clone();
    if ((hashType & 31) === _Transaction.SIGHASH_NONE) {
      txTmp.outs = [];
      txTmp.ins.forEach((input, i2) => {
        if (i2 === inIndex)
          return;
        input.sequence = 0;
      });
    } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE) {
      if (inIndex >= this.outs.length)
        return ONE$1;
      txTmp.outs.length = inIndex + 1;
      for (let i2 = 0; i2 < inIndex; i2++) {
        txTmp.outs[i2] = {
          script: EMPTY_BYTES,
          value: BLANK_OUTPUT_VALUE
        };
      }
      txTmp.ins.forEach((input, y) => {
        if (y === inIndex)
          return;
        input.sequence = 0;
      });
    }
    if (hashType & _Transaction.SIGHASH_ANYONECANPAY) {
      txTmp.ins = [txTmp.ins[inIndex]];
      txTmp.ins[0].script = ourScript;
    } else {
      txTmp.ins.forEach((input) => {
        input.script = EMPTY_BYTES;
      });
      txTmp.ins[inIndex].script = ourScript;
    }
    const buffer2 = alloc(txTmp.byteLength(false) + 4);
    const writer = new BinaryWriter$1(buffer2, txTmp.byteLength(false));
    writer.writeInt32LE(hashType);
    __privateMethod(_a5 = txTmp, _Transaction_instances, toBuffer_fn).call(_a5, buffer2, 0, false);
    return toMessageHash(hash256(buffer2));
  }
  /**
   * Hash transaction for signing a Taproot (witness v1) input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScripts - Scripts of all inputs being spent
   * @param values - Values of all inputs being spent (bigint satoshis)
   * @param hashType - Signature hash type
   * @param leafHash - Optional leaf hash for script path spending
   * @param annex - Optional annex data
   * @returns 32-byte hash for signing
   */
  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex, taprootCache) {
    if (!Number.isInteger(inIndex) || inIndex < 0 || inIndex > 4294967295) {
      throw new TypeError("Expected unsigned 32-bit integer for inIndex");
    }
    if (!Array.isArray(prevOutScripts) || !prevOutScripts.every((s) => s instanceof Uint8Array)) {
      throw new TypeError("Expected array of Uint8Array for prevOutScripts");
    }
    if (!Array.isArray(values) || !values.every((v) => typeof v === "bigint")) {
      throw new TypeError("Expected array of bigint for values");
    }
    if (!Number.isInteger(hashType) || hashType < 0 || hashType > 4294967295) {
      throw new TypeError("Expected unsigned 32-bit integer for hashType");
    }
    if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
      throw new Error("Must supply prevout script and value for all inputs");
    }
    const outputType = hashType === _Transaction.SIGHASH_DEFAULT ? _Transaction.SIGHASH_ALL : hashType & _Transaction.SIGHASH_OUTPUT_MASK;
    const inputType = hashType & _Transaction.SIGHASH_INPUT_MASK;
    const isAnyoneCanPay = inputType === _Transaction.SIGHASH_ANYONECANPAY;
    const isNone = outputType === _Transaction.SIGHASH_NONE;
    const isSingle = outputType === _Transaction.SIGHASH_SINGLE;
    let hashPrevouts = EMPTY_BYTES;
    let hashAmounts = EMPTY_BYTES;
    let hashScriptPubKeys = EMPTY_BYTES;
    let hashSequences = EMPTY_BYTES;
    let hashOutputs = EMPTY_BYTES;
    if (!isAnyoneCanPay) {
      if (taprootCache) {
        hashPrevouts = taprootCache.hashPrevouts;
        hashAmounts = taprootCache.hashAmounts;
        hashScriptPubKeys = taprootCache.hashScriptPubKeys;
        hashSequences = taprootCache.hashSequences;
      } else {
        let bufferWriter = new BinaryWriter$1(36 * this.ins.length);
        this.ins.forEach((txIn) => {
          bufferWriter.writeBytes(txIn.hash);
          bufferWriter.writeUInt32LE(txIn.index);
        });
        hashPrevouts = sha256$12(bufferWriter.finish());
        bufferWriter = new BinaryWriter$1(8 * this.ins.length);
        values.forEach((value) => bufferWriter.writeUInt64LE(value));
        hashAmounts = sha256$12(bufferWriter.finish());
        bufferWriter = new BinaryWriter$1(prevOutScripts.map(varSliceSize).reduce((a, b) => a + b));
        prevOutScripts.forEach((prevOutScript) => bufferWriter.writeVarBytes(prevOutScript));
        hashScriptPubKeys = sha256$12(bufferWriter.finish());
        bufferWriter = new BinaryWriter$1(4 * this.ins.length);
        this.ins.forEach((txIn) => bufferWriter.writeUInt32LE(txIn.sequence));
        hashSequences = sha256$12(bufferWriter.finish());
      }
    }
    if (!(isNone || isSingle)) {
      if (taprootCache) {
        hashOutputs = taprootCache.hashOutputs;
      } else {
        if (!this.outs.length)
          throw new Error("Add outputs to the transaction before signing.");
        const txOutsSize = this.outs.map((output) => 8 + varSliceSize(output.script)).reduce((a, b) => a + b);
        const bufferWriter = new BinaryWriter$1(txOutsSize);
        this.outs.forEach((out) => {
          bufferWriter.writeUInt64LE(out.value);
          bufferWriter.writeVarBytes(out.script);
        });
        hashOutputs = sha256$12(bufferWriter.finish());
      }
    } else if (isSingle && inIndex < this.outs.length) {
      const output = this.outs[inIndex];
      const bufferWriter = new BinaryWriter$1(8 + varSliceSize(output.script));
      bufferWriter.writeUInt64LE(output.value);
      bufferWriter.writeVarBytes(output.script);
      hashOutputs = sha256$12(bufferWriter.finish());
    }
    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
    const sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);
    const sigMsgWriter = new BinaryWriter$1(sigMsgSize);
    sigMsgWriter.writeUInt8(hashType);
    sigMsgWriter.writeInt32LE(this.version);
    sigMsgWriter.writeUInt32LE(this.locktime);
    sigMsgWriter.writeBytes(hashPrevouts);
    sigMsgWriter.writeBytes(hashAmounts);
    sigMsgWriter.writeBytes(hashScriptPubKeys);
    sigMsgWriter.writeBytes(hashSequences);
    if (!(isNone || isSingle)) {
      sigMsgWriter.writeBytes(hashOutputs);
    }
    sigMsgWriter.writeUInt8(spendType);
    if (isAnyoneCanPay) {
      const input = this.ins[inIndex];
      sigMsgWriter.writeBytes(input.hash);
      sigMsgWriter.writeUInt32LE(input.index);
      sigMsgWriter.writeUInt64LE(values[inIndex]);
      sigMsgWriter.writeVarBytes(prevOutScripts[inIndex]);
      sigMsgWriter.writeUInt32LE(input.sequence);
    } else {
      sigMsgWriter.writeUInt32LE(inIndex);
    }
    if (annex) {
      const bufferWriter = new BinaryWriter$1(varSliceSize(annex));
      bufferWriter.writeVarBytes(annex);
      sigMsgWriter.writeBytes(sha256$12(bufferWriter.finish()));
    }
    if (isSingle) {
      sigMsgWriter.writeBytes(hashOutputs);
    }
    if (leafHash) {
      sigMsgWriter.writeBytes(leafHash);
      sigMsgWriter.writeUInt8(0);
      sigMsgWriter.writeUInt32LE(4294967295);
    }
    const prefix = new Uint8Array([0]);
    const sigMsg = sigMsgWriter.finish();
    const combined = new Uint8Array(1 + sigMsg.length);
    combined.set(prefix);
    combined.set(sigMsg, 1);
    return toMessageHash(taggedHash("TapSighash", combined));
  }
  /**
   * Pre-compute intermediate hashes for Taproot signing.
   * Call this once before signing multiple inputs to avoid O(n^2) performance.
   *
   * @param prevOutScripts - Array of previous output scripts for all inputs
   * @param values - Array of previous output values for all inputs
   * @returns Cache object to pass to hashForWitnessV1
   */
  getTaprootHashCache(prevOutScripts, values) {
    let bufferWriter = new BinaryWriter$1(36 * this.ins.length);
    for (const txIn of this.ins) {
      bufferWriter.writeBytes(txIn.hash);
      bufferWriter.writeUInt32LE(txIn.index);
    }
    const hashPrevouts = sha256$12(bufferWriter.finish());
    bufferWriter = new BinaryWriter$1(8 * values.length);
    for (const value of values) {
      bufferWriter.writeUInt64LE(value);
    }
    const hashAmounts = sha256$12(bufferWriter.finish());
    let scriptPubKeysSize = 0;
    for (const script2 of prevOutScripts) {
      scriptPubKeysSize += varSliceSize(script2);
    }
    bufferWriter = new BinaryWriter$1(scriptPubKeysSize);
    for (const script2 of prevOutScripts) {
      bufferWriter.writeVarBytes(script2);
    }
    const hashScriptPubKeys = sha256$12(bufferWriter.finish());
    bufferWriter = new BinaryWriter$1(4 * this.ins.length);
    for (const txIn of this.ins) {
      bufferWriter.writeUInt32LE(txIn.sequence);
    }
    const hashSequences = sha256$12(bufferWriter.finish());
    let txOutsSize = 0;
    for (const out of this.outs) {
      txOutsSize += 8 + varSliceSize(out.script);
    }
    bufferWriter = new BinaryWriter$1(txOutsSize);
    for (const out of this.outs) {
      bufferWriter.writeUInt64LE(out.value);
      bufferWriter.writeVarBytes(out.script);
    }
    const hashOutputs = this.outs.length ? sha256$12(bufferWriter.finish()) : ZERO$1;
    return { hashPrevouts, hashAmounts, hashScriptPubKeys, hashSequences, hashOutputs };
  }
  /**
   * Hash transaction for signing a SegWit v0 (P2WPKH/P2WSH) input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScript - The script of the output being spent
   * @param value - Value of the output being spent (bigint satoshis)
   * @param hashType - Signature hash type
   * @returns 32-byte hash for signing
   */
  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
    if (!Number.isInteger(inIndex) || inIndex < 0 || inIndex > 4294967295) {
      throw new TypeError("Expected unsigned 32-bit integer for inIndex");
    }
    if (!(prevOutScript instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array for prevOutScript");
    }
    if (typeof value !== "bigint") {
      throw new TypeError("Expected bigint for value");
    }
    if (!Number.isInteger(hashType) || hashType < 0 || hashType > 4294967295) {
      throw new TypeError("Expected unsigned 32-bit integer for hashType");
    }
    let tbuffer;
    let bufferWriter;
    let hashOutputs = ZERO$1;
    let hashPrevouts = ZERO$1;
    let hashSequence = ZERO$1;
    if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
      tbuffer = alloc(36 * this.ins.length);
      bufferWriter = new BinaryWriter$1(tbuffer, 0);
      this.ins.forEach((txIn) => {
        bufferWriter.writeBytes(txIn.hash);
        bufferWriter.writeUInt32LE(txIn.index);
      });
      hashPrevouts = hash256(tbuffer);
    }
    if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY) && (hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
      tbuffer = alloc(4 * this.ins.length);
      bufferWriter = new BinaryWriter$1(tbuffer, 0);
      this.ins.forEach((txIn) => {
        bufferWriter.writeUInt32LE(txIn.sequence);
      });
      hashSequence = hash256(tbuffer);
    }
    if ((hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
      const txOutsSize = this.outs.reduce((sum, output) => {
        return sum + 8 + varSliceSize(output.script);
      }, 0);
      tbuffer = alloc(txOutsSize);
      bufferWriter = new BinaryWriter$1(tbuffer, 0);
      this.outs.forEach((out) => {
        bufferWriter.writeUInt64LE(out.value);
        bufferWriter.writeVarBytes(out.script);
      });
      hashOutputs = hash256(tbuffer);
    } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
      const output = this.outs[inIndex];
      tbuffer = alloc(8 + varSliceSize(output.script));
      bufferWriter = new BinaryWriter$1(tbuffer, 0);
      bufferWriter.writeUInt64LE(output.value);
      bufferWriter.writeVarBytes(output.script);
      hashOutputs = hash256(tbuffer);
    }
    tbuffer = alloc(156 + varSliceSize(prevOutScript));
    bufferWriter = new BinaryWriter$1(tbuffer, 0);
    const input = this.ins[inIndex];
    bufferWriter.writeInt32LE(this.version);
    bufferWriter.writeBytes(hashPrevouts);
    bufferWriter.writeBytes(hashSequence);
    bufferWriter.writeBytes(input.hash);
    bufferWriter.writeUInt32LE(input.index);
    bufferWriter.writeVarBytes(prevOutScript);
    bufferWriter.writeUInt64LE(value);
    bufferWriter.writeUInt32LE(input.sequence);
    bufferWriter.writeBytes(hashOutputs);
    bufferWriter.writeUInt32LE(this.locktime);
    bufferWriter.writeUInt32LE(hashType);
    return toMessageHash(hash256(tbuffer));
  }
  /**
   * Get the transaction hash.
   *
   * @param forWitness - If true, include witness data (wtxid)
   * @returns 32-byte transaction hash
   */
  getHash(forWitness) {
    if (forWitness && this.isCoinbase())
      return new Uint8Array(32);
    return hash256(__privateMethod(this, _Transaction_instances, toBuffer_fn).call(this, void 0, void 0, forWitness));
  }
  /**
   * Get the transaction ID (txid) as a hex string.
   *
   * @returns Transaction ID in reversed hex format
   */
  getId() {
    return toHex$1(reverse(this.getHash(false)));
  }
  /**
   * Serialize the transaction to a Uint8Array buffer.
   *
   * @param buffer - Optional pre-allocated buffer
   * @param initialOffset - Optional starting offset in buffer
   * @returns Serialized transaction bytes
   */
  toBuffer(buffer2, initialOffset) {
    return __privateMethod(this, _Transaction_instances, toBuffer_fn).call(this, buffer2, initialOffset, true);
  }
  /**
   * Serialize the transaction to a hex string.
   *
   * @returns Transaction as hex string
   */
  toHex() {
    return toHex$1(this.toBuffer(void 0, void 0));
  }
  /**
   * Set the input script for a specific input.
   *
   * @param index - Input index
   * @param scriptSig - The script to set
   */
  setInputScript(index, scriptSig) {
    if (!Number.isInteger(index) || index < 0) {
      throw new TypeError("Expected non-negative integer for index");
    }
    if (!(scriptSig instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array for scriptSig");
    }
    this.ins[index].script = scriptSig;
  }
  /**
   * Set the witness data for a specific input.
   *
   * @param index - Input index
   * @param witness - Array of witness elements
   */
  setWitness(index, witness) {
    if (!Number.isInteger(index) || index < 0) {
      throw new TypeError("Expected non-negative integer for index");
    }
    if (!Array.isArray(witness) || !witness.every((w2) => w2 instanceof Uint8Array)) {
      throw new TypeError("Expected array of Uint8Array for witness");
    }
    this.ins[index].witness = witness;
  }
};
_Transaction_instances = new WeakSet();
/**
 * Internal method to serialize the transaction.
 *
 * @param buffer - Optional pre-allocated buffer
 * @param initialOffset - Optional starting offset
 * @param _ALLOW_WITNESS - Whether to include witness data
 * @returns Serialized transaction bytes
 */
toBuffer_fn = function(buffer2, initialOffset, _ALLOW_WITNESS = false) {
  if (!buffer2)
    buffer2 = alloc(this.byteLength(_ALLOW_WITNESS));
  const bufferWriter = new BinaryWriter$1(buffer2, initialOffset || 0);
  bufferWriter.writeInt32LE(this.version);
  const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
  if (hasWitnesses) {
    bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_MARKER);
    bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_FLAG);
  }
  bufferWriter.writeVarInt(this.ins.length);
  this.ins.forEach((txIn) => {
    bufferWriter.writeBytes(txIn.hash);
    bufferWriter.writeUInt32LE(txIn.index);
    bufferWriter.writeVarBytes(txIn.script);
    bufferWriter.writeUInt32LE(txIn.sequence);
  });
  bufferWriter.writeVarInt(this.outs.length);
  this.outs.forEach((txOut) => {
    bufferWriter.writeUInt64LE(txOut.value);
    bufferWriter.writeVarBytes(txOut.script);
  });
  if (hasWitnesses) {
    this.ins.forEach((input) => {
      bufferWriter.writeVector(input.witness);
    });
  }
  bufferWriter.writeUInt32LE(this.locktime);
  if (initialOffset !== void 0)
    return buffer2.subarray(initialOffset, bufferWriter.offset);
  return buffer2;
};
__publicField(_Transaction, "DEFAULT_SEQUENCE", 4294967295);
__publicField(_Transaction, "SIGHASH_DEFAULT", 0);
__publicField(_Transaction, "SIGHASH_ALL", 1);
__publicField(_Transaction, "SIGHASH_NONE", 2);
__publicField(_Transaction, "SIGHASH_SINGLE", 3);
__publicField(_Transaction, "SIGHASH_ANYONECANPAY", 128);
__publicField(_Transaction, "SIGHASH_OUTPUT_MASK", 3);
__publicField(_Transaction, "SIGHASH_INPUT_MASK", 128);
__publicField(_Transaction, "ADVANCED_TRANSACTION_MARKER", 0);
__publicField(_Transaction, "ADVANCED_TRANSACTION_FLAG", 1);
__publicField(_Transaction, "TRUC_VERSION", 3);
__publicField(_Transaction, "TRUC_MAX_VSIZE", 1e4);
__publicField(_Transaction, "TRUC_CHILD_MAX_VSIZE", 1e3);
var Transaction = _Transaction;
var GlobalTypes;
(function(GlobalTypes2) {
  GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
  GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
})(GlobalTypes || (GlobalTypes = {}));
var InputTypes;
(function(InputTypes2) {
  InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
  InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
  InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
  InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
  InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
  InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
  InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
  InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
  InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
  InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
  InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
  InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
  InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
  InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
  InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
  InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
})(InputTypes || (InputTypes = {}));
var OutputTypes;
(function(OutputTypes2) {
  OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
  OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
  OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
  OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
  OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
  OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
})(OutputTypes || (OutputTypes = {}));
var HEX_STRINGS = "0123456789abcdefABCDEF";
var HEX_CODES = HEX_STRINGS.split("").map((c) => c.codePointAt(0));
var HEX_CODEPOINTS = Array(256).fill(true).map((_2, i2) => {
  const s = String.fromCodePoint(i2);
  const index = HEX_STRINGS.indexOf(s);
  return index < 0 ? void 0 : index < 16 ? index : index - 6;
});
var ENCODER = new TextEncoder();
var DECODER = new TextDecoder();
function toUtf8(bytes) {
  return DECODER.decode(bytes);
}
function fromUtf8(s) {
  return ENCODER.encode(s);
}
function concat(arrays) {
  const totalLength = arrays.reduce((a, b) => a + b.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }
  return result;
}
function toHex(bytes) {
  const b = bytes || new Uint8Array();
  return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);
}
function _toHexIterPerf(bytes) {
  let s = "";
  for (let i2 = 0; i2 < bytes.length; ++i2) {
    s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i2] >> 4]]];
    s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i2] & 15]]];
  }
  return s;
}
function _toHexLengthPerf(bytes) {
  const hexBytes = new Uint8Array(bytes.length * 2);
  for (let i2 = 0; i2 < bytes.length; ++i2) {
    hexBytes[i2 * 2] = HEX_CODES[bytes[i2] >> 4];
    hexBytes[i2 * 2 + 1] = HEX_CODES[bytes[i2] & 15];
  }
  return DECODER.decode(hexBytes);
}
function fromHex(hexString) {
  const hexBytes = ENCODER.encode(hexString || "");
  const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));
  let i2;
  for (i2 = 0; i2 < resultBytes.length; i2++) {
    const a = HEX_CODEPOINTS[hexBytes[i2 * 2]];
    const b = HEX_CODEPOINTS[hexBytes[i2 * 2 + 1]];
    if (a === void 0 || b === void 0) {
      break;
    }
    resultBytes[i2] = a << 4 | b;
  }
  return i2 === resultBytes.length ? resultBytes : resultBytes.slice(0, i2);
}
function toBase64(bytes) {
  return btoa(String.fromCharCode(...bytes));
}
function fromBase64(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i2 = 0; i2 < binaryString.length; i2++) {
    bytes[i2] = binaryString.charCodeAt(i2);
  }
  return bytes;
}
function compare$1(v1, v2) {
  const minLength = Math.min(v1.length, v2.length);
  for (let i2 = 0; i2 < minLength; ++i2) {
    if (v1[i2] !== v2[i2]) {
      return v1[i2] < v2[i2] ? -1 : 1;
    }
  }
  return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
}
function writeUInt8(buffer2, offset, value) {
  if (offset + 1 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value > 255) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${255}. Received ${value}`);
  }
  buffer2[offset] = value;
  return offset + 1;
}
function writeUInt16(buffer2, offset, value, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value > 65535) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${65535}. Received ${value}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = value & 255;
    buffer2[offset + 1] = value >> 8 & 255;
  } else {
    buffer2[offset] = value >> 8 & 255;
    buffer2[offset + 1] = value & 255;
  }
  return offset + 2;
}
function writeUInt32(buffer2, offset, value, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value > 4294967295) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${value}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = value & 255;
    buffer2[offset + 1] = value >> 8 & 255;
    buffer2[offset + 2] = value >> 16 & 255;
    buffer2[offset + 3] = value >> 24 & 255;
  } else {
    buffer2[offset] = value >> 24 & 255;
    buffer2[offset + 1] = value >> 16 & 255;
    buffer2[offset + 2] = value >> 8 & 255;
    buffer2[offset + 3] = value & 255;
  }
  return offset + 4;
}
function writeUInt64(buffer2, offset, value, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (value > 0xffffffffffffffffn) {
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);
  }
  if (littleEndian === "LE") {
    buffer2[offset] = Number(value & 0xffn);
    buffer2[offset + 1] = Number(value >> 8n & 0xffn);
    buffer2[offset + 2] = Number(value >> 16n & 0xffn);
    buffer2[offset + 3] = Number(value >> 24n & 0xffn);
    buffer2[offset + 4] = Number(value >> 32n & 0xffn);
    buffer2[offset + 5] = Number(value >> 40n & 0xffn);
    buffer2[offset + 6] = Number(value >> 48n & 0xffn);
    buffer2[offset + 7] = Number(value >> 56n & 0xffn);
  } else {
    buffer2[offset] = Number(value >> 56n & 0xffn);
    buffer2[offset + 1] = Number(value >> 48n & 0xffn);
    buffer2[offset + 2] = Number(value >> 40n & 0xffn);
    buffer2[offset + 3] = Number(value >> 32n & 0xffn);
    buffer2[offset + 4] = Number(value >> 24n & 0xffn);
    buffer2[offset + 5] = Number(value >> 16n & 0xffn);
    buffer2[offset + 6] = Number(value >> 8n & 0xffn);
    buffer2[offset + 7] = Number(value & 0xffn);
  }
  return offset + 8;
}
function readUInt8(buffer2, offset) {
  if (offset + 1 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  return buffer2[offset];
}
function readUInt16(buffer2, offset, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num = 0;
    num = (num << 8) + buffer2[offset + 1];
    num = (num << 8) + buffer2[offset];
    return num;
  } else {
    let num = 0;
    num = (num << 8) + buffer2[offset];
    num = (num << 8) + buffer2[offset + 1];
    return num;
  }
}
function readUInt32(buffer2, offset, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num = 0;
    num = (num << 8) + buffer2[offset + 3] >>> 0;
    num = (num << 8) + buffer2[offset + 2] >>> 0;
    num = (num << 8) + buffer2[offset + 1] >>> 0;
    num = (num << 8) + buffer2[offset] >>> 0;
    return num;
  } else {
    let num = 0;
    num = (num << 8) + buffer2[offset] >>> 0;
    num = (num << 8) + buffer2[offset + 1] >>> 0;
    num = (num << 8) + buffer2[offset + 2] >>> 0;
    num = (num << 8) + buffer2[offset + 3] >>> 0;
    return num;
  }
}
function readUInt64(buffer2, offset, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    let num = 0n;
    num = (num << 8n) + BigInt(buffer2[offset + 7]);
    num = (num << 8n) + BigInt(buffer2[offset + 6]);
    num = (num << 8n) + BigInt(buffer2[offset + 5]);
    num = (num << 8n) + BigInt(buffer2[offset + 4]);
    num = (num << 8n) + BigInt(buffer2[offset + 3]);
    num = (num << 8n) + BigInt(buffer2[offset + 2]);
    num = (num << 8n) + BigInt(buffer2[offset + 1]);
    num = (num << 8n) + BigInt(buffer2[offset]);
    return num;
  } else {
    let num = 0n;
    num = (num << 8n) + BigInt(buffer2[offset]);
    num = (num << 8n) + BigInt(buffer2[offset + 1]);
    num = (num << 8n) + BigInt(buffer2[offset + 2]);
    num = (num << 8n) + BigInt(buffer2[offset + 3]);
    num = (num << 8n) + BigInt(buffer2[offset + 4]);
    num = (num << 8n) + BigInt(buffer2[offset + 5]);
    num = (num << 8n) + BigInt(buffer2[offset + 6]);
    num = (num << 8n) + BigInt(buffer2[offset + 7]);
    return num;
  }
}
function writeInt8(buffer2, offset, value) {
  if (offset + 1 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value > 127 || value < -128) {
    throw new Error(`The value of "value" is out of range. It must be >= ${-128} and <= ${127}. Received ${value}`);
  }
  buffer2[offset] = value;
  return offset + 1;
}
function writeInt16(buffer2, offset, value, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value > 32767 || value < -32768) {
    throw new Error(`The value of "value" is out of range. It must be >= ${-32768} and <= ${32767}. Received ${value}`);
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    buffer2[offset] = value & 255;
    buffer2[offset + 1] = value >> 8 & 255;
  } else {
    buffer2[offset] = value >> 8 & 255;
    buffer2[offset + 1] = value & 255;
  }
  return offset + 2;
}
function writeInt32(buffer2, offset, value, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value > 2147483647 || value < -2147483648) {
    throw new Error(`The value of "value" is out of range. It must be >= ${-2147483648} and <= ${2147483647}. Received ${value}`);
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    buffer2[offset] = value & 255;
    buffer2[offset + 1] = value >> 8 & 255;
    buffer2[offset + 2] = value >> 16 & 255;
    buffer2[offset + 3] = value >> 24 & 255;
  } else {
    buffer2[offset] = value >> 24 & 255;
    buffer2[offset + 1] = value >> 16 & 255;
    buffer2[offset + 2] = value >> 8 & 255;
    buffer2[offset + 3] = value & 255;
  }
  return offset + 4;
}
function writeInt64(buffer2, offset, value, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  if (value > 0x7fffffffffffffffn || value < -0x8000000000000000n) {
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${value}`);
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    buffer2[offset] = Number(value & 0xffn);
    buffer2[offset + 1] = Number(value >> 8n & 0xffn);
    buffer2[offset + 2] = Number(value >> 16n & 0xffn);
    buffer2[offset + 3] = Number(value >> 24n & 0xffn);
    buffer2[offset + 4] = Number(value >> 32n & 0xffn);
    buffer2[offset + 5] = Number(value >> 40n & 0xffn);
    buffer2[offset + 6] = Number(value >> 48n & 0xffn);
    buffer2[offset + 7] = Number(value >> 56n & 0xffn);
  } else {
    buffer2[offset] = Number(value >> 56n & 0xffn);
    buffer2[offset + 1] = Number(value >> 48n & 0xffn);
    buffer2[offset + 2] = Number(value >> 40n & 0xffn);
    buffer2[offset + 3] = Number(value >> 32n & 0xffn);
    buffer2[offset + 4] = Number(value >> 24n & 0xffn);
    buffer2[offset + 5] = Number(value >> 16n & 0xffn);
    buffer2[offset + 6] = Number(value >> 8n & 0xffn);
    buffer2[offset + 7] = Number(value & 0xffn);
  }
  return offset + 8;
}
function readInt8(buffer2, offset) {
  if (offset + 1 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  const val = buffer2[offset];
  if (val <= 127) {
    return val;
  } else {
    return val - 256;
  }
}
function readInt16(buffer2, offset, littleEndian) {
  if (offset + 2 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    const val = buffer2[offset] + (buffer2[offset + 1] << 8);
    return buffer2[offset + 1] <= 127 ? val : val - 65536;
  } else {
    const val = (buffer2[offset] << 8) + buffer2[offset + 1];
    return buffer2[offset] <= 127 ? val : val - 65536;
  }
}
function readInt32(buffer2, offset, littleEndian) {
  if (offset + 4 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  if (littleEndian === "LE") {
    const val = buffer2[offset] + (buffer2[offset + 1] << 8) + (buffer2[offset + 2] << 16) + (buffer2[offset + 3] << 24 >>> 0);
    return buffer2[offset + 3] <= 127 ? val : val - 4294967296;
  } else {
    const val = (buffer2[offset] << 24 >>> 0) + (buffer2[offset + 1] << 16) + (buffer2[offset + 2] << 8) + buffer2[offset + 3];
    return buffer2[offset] <= 127 ? val : val - 4294967296;
  }
}
function readInt64(buffer2, offset, littleEndian) {
  if (offset + 8 > buffer2.length) {
    throw new Error("Offset is outside the bounds of Uint8Array");
  }
  littleEndian = littleEndian.toUpperCase();
  let num = 0n;
  if (littleEndian === "LE") {
    num = (num << 8n) + BigInt(buffer2[offset + 7]);
    num = (num << 8n) + BigInt(buffer2[offset + 6]);
    num = (num << 8n) + BigInt(buffer2[offset + 5]);
    num = (num << 8n) + BigInt(buffer2[offset + 4]);
    num = (num << 8n) + BigInt(buffer2[offset + 3]);
    num = (num << 8n) + BigInt(buffer2[offset + 2]);
    num = (num << 8n) + BigInt(buffer2[offset + 1]);
    num = (num << 8n) + BigInt(buffer2[offset]);
    return buffer2[offset + 7] <= 127 ? num : num - 0x10000000000000000n;
  } else {
    let num2 = 0n;
    num2 = (num2 << 8n) + BigInt(buffer2[offset]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 1]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 2]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 3]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 4]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 5]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 6]);
    num2 = (num2 << 8n) + BigInt(buffer2[offset + 7]);
    return buffer2[offset] <= 127 ? num2 : num2 - 0x10000000000000000n;
  }
}
var browser$1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  compare: compare$1,
  concat,
  fromBase64,
  fromHex,
  fromUtf8,
  readInt16,
  readInt32,
  readInt64,
  readInt8,
  readUInt16,
  readUInt32,
  readUInt64,
  readUInt8,
  toBase64,
  toHex,
  toUtf8,
  writeInt16,
  writeInt32,
  writeInt64,
  writeInt8,
  writeUInt16,
  writeUInt32,
  writeUInt64,
  writeUInt8
}, Symbol.toStringTag, { value: "Module" }));
var range$4 = (n2) => [...Array(n2).keys()];
function decode$d(keyVal) {
  if (keyVal.key[0] !== GlobalTypes.GLOBAL_XPUB) {
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.value.length / 4 % 1 !== 0) {
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  }
  const extendedPubkey = keyVal.key.slice(1);
  const data = {
    masterFingerprint: keyVal.value.slice(0, 4),
    extendedPubkey,
    path: "m"
  };
  for (const i2 of range$4(keyVal.value.length / 4 - 1)) {
    const val = readUInt32(keyVal.value, i2 * 4 + 4, "LE");
    const isHard = !!(val & 2147483648);
    const idx = val & 2147483647;
    data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
  }
  return data;
}
function encode$e(data) {
  const head = new Uint8Array([GlobalTypes.GLOBAL_XPUB]);
  const key = concat([head, data.extendedPubkey]);
  const splitPath = data.path.split("/");
  const value = new Uint8Array(splitPath.length * 4);
  value.set(data.masterFingerprint, 0);
  let offset = 4;
  splitPath.slice(1).forEach((level2) => {
    const isHard = level2.slice(-1) === "'";
    let num = 2147483647 & parseInt(isHard ? level2.slice(0, -1) : level2, 10);
    if (isHard) num += 2147483648;
    writeUInt32(value, offset, num, "LE");
    offset += 4;
  });
  return {
    key,
    value
  };
}
var expected$c = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function check$c(data) {
  const epk = data.extendedPubkey;
  const mfp = data.masterFingerprint;
  const p = data.path;
  return epk instanceof Uint8Array && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && mfp instanceof Uint8Array && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
}
function canAddToArray$3(array, item, dupeSet) {
  const dupeString = toHex(item.extendedPubkey);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter((v) => compare$1(v.extendedPubkey, item.extendedPubkey)).length === 0;
}
var globalXpub = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: canAddToArray$3,
  check: check$c,
  decode: decode$d,
  encode: encode$e,
  expected: expected$c
}, Symbol.toStringTag, { value: "Module" }));
function encode$d(data) {
  return {
    key: new Uint8Array([GlobalTypes.UNSIGNED_TX]),
    value: data.toBuffer()
  };
}
var unsignedTx = Object.freeze(Object.defineProperty({
  __proto__: null,
  encode: encode$d
}, Symbol.toStringTag, { value: "Module" }));
function decode$c(keyVal) {
  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTSIG) {
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + toHex(keyVal.key)
    );
  }
  return keyVal.value;
}
function encode$c(data) {
  const key = new Uint8Array([InputTypes.FINAL_SCRIPTSIG]);
  return {
    key,
    value: data
  };
}
var expected$b = "Uint8Array";
function check$b(data) {
  return data instanceof Uint8Array;
}
function canAdd$8(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptSig === void 0;
}
var finalScriptSig = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: canAdd$8,
  check: check$b,
  decode: decode$c,
  encode: encode$c,
  expected: expected$b
}, Symbol.toStringTag, { value: "Module" }));
function decode$b(keyVal) {
  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTWITNESS) {
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + toHex(keyVal.key)
    );
  }
  return keyVal.value;
}
function encode$b(data) {
  const key = new Uint8Array([InputTypes.FINAL_SCRIPTWITNESS]);
  return {
    key,
    value: data
  };
}
var expected$a = "Uint8Array";
function check$a(data) {
  return data instanceof Uint8Array;
}
function canAdd$7(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptWitness === void 0;
}
var finalScriptWitness = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: canAdd$7,
  check: check$a,
  decode: decode$b,
  encode: encode$b,
  expected: expected$a
}, Symbol.toStringTag, { value: "Module" }));
function decode$a(keyVal) {
  if (keyVal.key[0] !== InputTypes.NON_WITNESS_UTXO) {
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + toHex(keyVal.key)
    );
  }
  return keyVal.value;
}
function encode$a(data) {
  return {
    key: new Uint8Array([InputTypes.NON_WITNESS_UTXO]),
    value: data
  };
}
var expected$9 = "Uint8Array";
function check$9(data) {
  return data instanceof Uint8Array;
}
function canAdd$6(currentData, newData) {
  return !!currentData && !!newData && currentData.nonWitnessUtxo === void 0;
}
var nonWitnessUtxo = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: canAdd$6,
  check: check$9,
  decode: decode$a,
  encode: encode$a,
  expected: expected$9
}, Symbol.toStringTag, { value: "Module" }));
function decode$9(keyVal) {
  if (keyVal.key[0] !== InputTypes.PARTIAL_SIG) {
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + toHex(keyVal.key)
    );
  }
  if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + toHex(keyVal.key)
    );
  }
  const pubkey = keyVal.key.slice(1);
  return {
    pubkey,
    signature: keyVal.value
  };
}
function encode$9(pSig) {
  const head = new Uint8Array([InputTypes.PARTIAL_SIG]);
  return {
    key: concat([head, pSig.pubkey]),
    value: pSig.signature
  };
}
var expected$8 = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function check$8(data) {
  return data.pubkey instanceof Uint8Array && data.signature instanceof Uint8Array && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
}
function isDerSigWithSighash(buf) {
  if (!(buf instanceof Uint8Array) || buf.length < 9) return false;
  if (buf[0] !== 48) return false;
  if (buf.length !== buf[1] + 3) return false;
  if (buf[2] !== 2) return false;
  const rLen = buf[3];
  if (rLen > 33 || rLen < 1) return false;
  if (buf[3 + rLen + 1] !== 2) return false;
  const sLen = buf[3 + rLen + 2];
  if (sLen > 33 || sLen < 1) return false;
  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
  return true;
}
function canAddToArray$2(array, item, dupeSet) {
  const dupeString = toHex(item.pubkey);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter((v) => compare$1(v.pubkey, item.pubkey) === 0).length === 0;
}
var partialSig = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: canAddToArray$2,
  check: check$8,
  decode: decode$9,
  encode: encode$9,
  expected: expected$8
}, Symbol.toStringTag, { value: "Module" }));
function decode$8(keyVal) {
  if (keyVal.key[0] !== InputTypes.POR_COMMITMENT) {
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + toHex(keyVal.key)
    );
  }
  return toUtf8(keyVal.value);
}
function encode$8(data) {
  const key = new Uint8Array([InputTypes.POR_COMMITMENT]);
  return {
    key,
    value: fromUtf8(data)
  };
}
var expected$7 = "string";
function check$7(data) {
  return typeof data === "string";
}
function canAdd$5(currentData, newData) {
  return !!currentData && !!newData && currentData.porCommitment === void 0;
}
var porCommitment = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: canAdd$5,
  check: check$7,
  decode: decode$8,
  encode: encode$8,
  expected: expected$7
}, Symbol.toStringTag, { value: "Module" }));
function decode$7(keyVal) {
  if (keyVal.key[0] !== InputTypes.SIGHASH_TYPE) {
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + toHex(keyVal.key)
    );
  }
  return Number(readUInt32(keyVal.value, 0, "LE"));
}
function encode$7(data) {
  const key = Uint8Array.from([InputTypes.SIGHASH_TYPE]);
  const value = new Uint8Array(4);
  writeUInt32(value, 0, data, "LE");
  return {
    key,
    value
  };
}
var expected$6 = "number";
function check$6(data) {
  return typeof data === "number";
}
function canAdd$4(currentData, newData) {
  return !!currentData && !!newData && currentData.sighashType === void 0;
}
var sighashType = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: canAdd$4,
  check: check$6,
  decode: decode$7,
  encode: encode$7,
  expected: expected$6
}, Symbol.toStringTag, { value: "Module" }));
function decode$6(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + toHex(keyVal.key)
    );
  }
  if (!check$5(keyVal.value)) {
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  }
  return keyVal.value;
}
function encode$6(value) {
  const key = Uint8Array.from([InputTypes.TAP_KEY_SIG]);
  return { key, value };
}
var expected$5 = "Uint8Array";
function check$5(data) {
  return data instanceof Uint8Array && (data.length === 64 || data.length === 65);
}
function canAdd$3(currentData, newData) {
  return !!currentData && !!newData && currentData.tapKeySig === void 0;
}
var tapKeySig = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: canAdd$3,
  check: check$5,
  decode: decode$6,
  encode: encode$6,
  expected: expected$5
}, Symbol.toStringTag, { value: "Module" }));
function decode$5(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_LEAF_SCRIPT) {
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + toHex(keyVal.key)
    );
  }
  if ((keyVal.key.length - 2) % 32 !== 0) {
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + toHex(keyVal.key)
    );
  }
  const leafVersion = keyVal.value[keyVal.value.length - 1];
  if ((keyVal.key[1] & 254) !== leafVersion) {
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + toHex(keyVal.key)
    );
  }
  const script2 = keyVal.value.slice(0, -1);
  const controlBlock = keyVal.key.slice(1);
  return { controlBlock, script: script2, leafVersion };
}
function encode$5(tScript) {
  const head = Uint8Array.from([InputTypes.TAP_LEAF_SCRIPT]);
  const verBuf = Uint8Array.from([tScript.leafVersion]);
  return {
    key: concat([head, tScript.controlBlock]),
    value: concat([tScript.script, verBuf])
  };
}
var expected$4 = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function check$4(data) {
  return data.controlBlock instanceof Uint8Array && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 254) === data.leafVersion && data.script instanceof Uint8Array;
}
function canAddToArray$1(array, item, dupeSet) {
  const dupeString = toHex(item.controlBlock);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter((v) => compare$1(v.controlBlock, item.controlBlock) === 0).length === 0;
}
var tapLeafScript = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: canAddToArray$1,
  check: check$4,
  decode: decode$5,
  encode: encode$5,
  expected: expected$4
}, Symbol.toStringTag, { value: "Module" }));
function decode$4(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + toHex(keyVal.key)
    );
  }
  if (!check$3(keyVal.value)) {
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  }
  return keyVal.value;
}
function encode$4(value) {
  const key = Uint8Array.from([InputTypes.TAP_MERKLE_ROOT]);
  return { key, value };
}
var expected$3 = "Uint8Array";
function check$3(data) {
  return data instanceof Uint8Array && data.length === 32;
}
function canAdd$2(currentData, newData) {
  return !!currentData && !!newData && currentData.tapMerkleRoot === void 0;
}
var tapMerkleRoot = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: canAdd$2,
  check: check$3,
  decode: decode$4,
  encode: encode$4,
  expected: expected$3
}, Symbol.toStringTag, { value: "Module" }));
function decode$3(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_SCRIPT_SIG) {
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.key.length !== 65) {
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + toHex(keyVal.key)
    );
  }
  const pubkey = keyVal.key.slice(1, 33);
  const leafHash = keyVal.key.slice(33);
  return {
    pubkey,
    leafHash,
    signature: keyVal.value
  };
}
function encode$3(tSig) {
  const head = Uint8Array.from([InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: concat([head, tSig.pubkey, tSig.leafHash]),
    value: tSig.signature
  };
}
var expected$2 = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function check$2(data) {
  return data.pubkey instanceof Uint8Array && data.leafHash instanceof Uint8Array && data.signature instanceof Uint8Array && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
}
function canAddToArray(array, item, dupeSet) {
  const dupeString = toHex(item.pubkey) + toHex(item.leafHash);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(
    (v) => compare$1(v.pubkey, item.pubkey) === 0 && compare$1(v.leafHash, item.leafHash) === 0
  ).length === 0;
}
var tapScriptSig = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray,
  check: check$2,
  decode: decode$3,
  encode: encode$3,
  expected: expected$2
}, Symbol.toStringTag, { value: "Module" }));
function decode$2(keyVal) {
  if (keyVal.key[0] !== InputTypes.WITNESS_UTXO) {
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + toHex(keyVal.key)
    );
  }
  const value = readInt64(keyVal.value, 0, "LE");
  let _offset4 = 8;
  const { numberValue: scriptLen, bytes } = decode$j(
    keyVal.value,
    _offset4
  );
  _offset4 += bytes;
  const script2 = keyVal.value.slice(_offset4);
  if (script2.length !== scriptLen) {
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  }
  return {
    script: script2,
    value
  };
}
function encode$2(data) {
  const { script: script2, value } = data;
  const varuintlen = encodingLength$1(script2.length);
  const result = new Uint8Array(8 + varuintlen + script2.length);
  writeInt64(result, 0, BigInt(value), "LE");
  encode$k(script2.length, result, 8);
  result.set(script2, 8 + varuintlen);
  return {
    key: Uint8Array.from([InputTypes.WITNESS_UTXO]),
    value: result
  };
}
var expected$1 = "{ script: Uint8Array; value: bigint; }";
function check$1(data) {
  return data.script instanceof Uint8Array && typeof data.value === "bigint";
}
function canAdd$1(currentData, newData) {
  return !!currentData && !!newData && currentData.witnessUtxo === void 0;
}
var witnessUtxo = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: canAdd$1,
  check: check$1,
  decode: decode$2,
  encode: encode$2,
  expected: expected$1
}, Symbol.toStringTag, { value: "Module" }));
function decode$1(keyVal) {
  if (keyVal.key[0] !== OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + toHex(keyVal.key)
    );
  }
  let _offset4 = 0;
  const data = [];
  while (_offset4 < keyVal.value.length) {
    const depth = keyVal.value[_offset4++];
    const leafVersion = keyVal.value[_offset4++];
    const { numberValue: scriptLen, bytes } = decode$j(
      keyVal.value,
      _offset4
    );
    _offset4 += bytes;
    data.push({
      depth,
      leafVersion,
      script: keyVal.value.slice(_offset4, _offset4 + scriptLen)
    });
    _offset4 += scriptLen;
  }
  return { leaves: data };
}
function encode$1(tree) {
  const key = Uint8Array.from([OutputTypes.TAP_TREE]);
  const bufs = [].concat(
    ...tree.leaves.map((tapLeaf) => [
      Uint8Array.of(tapLeaf.depth, tapLeaf.leafVersion),
      encode$k(BigInt(tapLeaf.script.length)).buffer,
      tapLeaf.script
    ])
  );
  return {
    key,
    value: concat(bufs)
  };
}
var expected = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function check(data) {
  return Array.isArray(data.leaves) && data.leaves.every(
    (tapLeaf) => tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 254) === tapLeaf.leafVersion && tapLeaf.script instanceof Uint8Array
  );
}
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapTree === void 0;
}
var tapTree = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd,
  check,
  decode: decode$1,
  encode: encode$1,
  expected
}, Symbol.toStringTag, { value: "Module" }));
var range$3 = (n2) => [...Array(n2).keys()];
var isValidDERKey = (pubkey) => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
function makeConverter$4(TYPE_BYTE, isValidPubkey = isValidDERKey) {
  function decode2(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + toHex(keyVal.key)
      );
    }
    const pubkey = keyVal.key.slice(1);
    if (!isValidPubkey(pubkey)) {
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + toHex(keyVal.key)
      );
    }
    if (keyVal.value.length / 4 % 1 !== 0) {
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    }
    const data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      pubkey,
      path: "m"
    };
    for (const i2 of range$3(keyVal.value.length / 4 - 1)) {
      const val = readUInt32(keyVal.value, i2 * 4 + 4, "LE");
      const isHard = !!(val & 2147483648);
      const idx = val & 2147483647;
      data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
    }
    return data;
  }
  function encode2(data) {
    const head = Uint8Array.from([TYPE_BYTE]);
    const key = concat([head, data.pubkey]);
    const splitPath = data.path.split("/");
    const value = new Uint8Array(splitPath.length * 4);
    value.set(data.masterFingerprint, 0);
    let offset = 4;
    splitPath.slice(1).forEach((level2) => {
      const isHard = level2.slice(-1) === "'";
      let num = 2147483647 & parseInt(isHard ? level2.slice(0, -1) : level2, 10);
      if (isHard) num += 2147483648;
      writeUInt32(value, offset, num, "LE");
      offset += 4;
    });
    return {
      key,
      value
    };
  }
  const expected2 = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function check2(data) {
    return data.pubkey instanceof Uint8Array && data.masterFingerprint instanceof Uint8Array && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
  }
  function canAddToArray2(array, item, dupeSet) {
    const dupeString = toHex(item.pubkey);
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter((v) => compare$1(v.pubkey, item.pubkey) === 0).length === 0;
  }
  return {
    decode: decode2,
    encode: encode2,
    check: check2,
    expected: expected2,
    canAddToArray: canAddToArray2
  };
}
function makeChecker(pubkeyTypes) {
  return checkPubkey;
  function checkPubkey(keyVal) {
    let pubkey;
    if (pubkeyTypes.includes(keyVal.key[0])) {
      pubkey = keyVal.key.slice(1);
      if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
        throw new Error(
          "Format Error: invalid pubkey in key 0x" + toHex(keyVal.key)
        );
      }
    }
    return pubkey;
  }
}
function makeConverter$3(TYPE_BYTE) {
  function decode2(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + toHex(keyVal.key)
      );
    }
    return keyVal.value;
  }
  function encode2(data) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return {
      key,
      value: data
    };
  }
  const expected2 = "Uint8Array";
  function check2(data) {
    return data instanceof Uint8Array;
  }
  function canAdd2(currentData, newData) {
    return !!currentData && !!newData && currentData.redeemScript === void 0;
  }
  return {
    decode: decode2,
    encode: encode2,
    check: check2,
    expected: expected2,
    canAdd: canAdd2
  };
}
var isValidBIP340Key = (pubkey) => pubkey.length === 32;
function makeConverter$2(TYPE_BYTE) {
  const parent = makeConverter$4(TYPE_BYTE, isValidBIP340Key);
  function decode2(keyVal) {
    const { numberValue: nHashes, bytes: nHashesLen } = decode$j(
      keyVal.value
    );
    const base2 = parent.decode({
      key: keyVal.key,
      value: keyVal.value.slice(nHashesLen + Number(nHashes) * 32)
    });
    const leafHashes = new Array(Number(nHashes));
    for (let i2 = 0, _offset4 = nHashesLen; i2 < nHashes; i2++, _offset4 += 32) {
      leafHashes[i2] = keyVal.value.slice(_offset4, _offset4 + 32);
    }
    return { ...base2, leafHashes };
  }
  function encode2(data) {
    const base2 = parent.encode(data);
    const nHashesLen = encodingLength$1(data.leafHashes.length);
    const nHashesBuf = new Uint8Array(nHashesLen);
    encode$k(data.leafHashes.length, nHashesBuf);
    const value = concat([nHashesBuf, ...data.leafHashes, base2.value]);
    return { ...base2, value };
  }
  const expected2 = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function check2(data) {
    return Array.isArray(data.leafHashes) && data.leafHashes.every(
      (leafHash) => leafHash instanceof Uint8Array && leafHash.length === 32
    ) && parent.check(data);
  }
  return {
    decode: decode2,
    encode: encode2,
    check: check2,
    expected: expected2,
    canAddToArray: parent.canAddToArray
  };
}
function makeConverter$1(TYPE_BYTE) {
  function decode2(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + toHex(keyVal.key)
      );
    }
    if (keyVal.value.length !== 32) {
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    }
    return keyVal.value;
  }
  function encode2(value) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return { key, value };
  }
  const expected2 = "Uint8Array";
  function check2(data) {
    return data instanceof Uint8Array && data.length === 32;
  }
  function canAdd2(currentData, newData) {
    return !!currentData && !!newData && currentData.tapInternalKey === void 0;
  }
  return {
    decode: decode2,
    encode: encode2,
    check: check2,
    expected: expected2,
    canAdd: canAdd2
  };
}
function makeConverter(TYPE_BYTE) {
  function decode2(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + toHex(keyVal.key)
      );
    }
    return keyVal.value;
  }
  function encode2(data) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return {
      key,
      value: data
    };
  }
  const expected2 = "Uint8Array";
  function check2(data) {
    return data instanceof Uint8Array;
  }
  function canAdd2(currentData, newData) {
    return !!currentData && !!newData && currentData.witnessScript === void 0;
  }
  return {
    decode: decode2,
    encode: encode2,
    check: check2,
    expected: expected2,
    canAdd: canAdd2
  };
}
var globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: makeChecker([])
};
var inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: makeConverter$4(InputTypes.BIP32_DERIVATION),
  redeemScript: makeConverter$3(InputTypes.REDEEM_SCRIPT),
  witnessScript: makeConverter(InputTypes.WITNESS_SCRIPT),
  checkPubkey: makeChecker([
    InputTypes.PARTIAL_SIG,
    InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: makeConverter$2(
    InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: makeConverter$1(InputTypes.TAP_INTERNAL_KEY),
  tapMerkleRoot
};
var outputs = {
  bip32Derivation: makeConverter$4(OutputTypes.BIP32_DERIVATION),
  redeemScript: makeConverter$3(OutputTypes.REDEEM_SCRIPT),
  witnessScript: makeConverter(OutputTypes.WITNESS_SCRIPT),
  checkPubkey: makeChecker([OutputTypes.BIP32_DERIVATION]),
  tapBip32Derivation: makeConverter$2(
    OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: makeConverter$1(OutputTypes.TAP_INTERNAL_KEY)
};
var converter = Object.freeze(Object.defineProperty({
  __proto__: null,
  globals,
  inputs,
  outputs
}, Symbol.toStringTag, { value: "Module" }));
var range$2 = (n2) => [...Array(n2).keys()];
function keyValsToBuffer(keyVals) {
  const buffers = keyVals.map(keyValToBuffer);
  buffers.push(Uint8Array.from([0]));
  return concat(buffers);
}
function keyValToBuffer(keyVal) {
  const keyLen = keyVal.key.length;
  const valLen = keyVal.value.length;
  const keyVarIntLen = encodingLength$1(keyLen);
  const valVarIntLen = encodingLength$1(valLen);
  const buffer2 = new Uint8Array(keyVarIntLen + keyLen + valVarIntLen + valLen);
  encode$k(keyLen, buffer2, 0);
  buffer2.set(keyVal.key, keyVarIntLen);
  encode$k(valLen, buffer2, keyVarIntLen + keyLen);
  buffer2.set(keyVal.value, keyVarIntLen + keyLen + valVarIntLen);
  return buffer2;
}
function psbtFromBuffer(buffer2, txGetter) {
  let offset = 0;
  function varSlice() {
    const { numberValue: keyLen, bytes } = decode$j(buffer2, offset);
    offset += bytes;
    const key = buffer2.slice(offset, offset + Number(keyLen));
    offset += Number(keyLen);
    return key;
  }
  function readUInt32BE() {
    const num = readUInt32(buffer2, offset, "BE");
    offset += 4;
    return num;
  }
  function readUInt8$1() {
    const num = readUInt8(buffer2, offset);
    offset += 1;
    return num;
  }
  function getKeyValue() {
    const key = varSlice();
    const value = varSlice();
    return {
      key,
      value
    };
  }
  function checkEndOfKeyValPairs() {
    if (offset >= buffer2.length) {
      throw new Error("Format Error: Unexpected End of PSBT");
    }
    const isEnd = readUInt8(buffer2, offset) === 0;
    if (isEnd) {
      offset++;
    }
    return isEnd;
  }
  if (readUInt32BE() !== 1886610036) {
    throw new Error("Format Error: Invalid Magic Number");
  }
  if (readUInt8$1() !== 255) {
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  }
  const globalMapKeyVals = [];
  const globalKeyIndex = {};
  while (!checkEndOfKeyValPairs()) {
    const keyVal = getKeyValue();
    const hexKey = toHex(keyVal.key);
    if (globalKeyIndex[hexKey]) {
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + hexKey
      );
    }
    globalKeyIndex[hexKey] = 1;
    globalMapKeyVals.push(keyVal);
  }
  const unsignedTxMaps = globalMapKeyVals.filter(
    (keyVal) => keyVal.key[0] === GlobalTypes.UNSIGNED_TX
  );
  if (unsignedTxMaps.length !== 1) {
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  }
  const unsignedTx2 = txGetter(unsignedTxMaps[0].value);
  const { inputCount, outputCount } = unsignedTx2.getInputOutputCounts();
  const inputKeyVals = [];
  const outputKeyVals = [];
  for (const index of range$2(inputCount)) {
    const inputKeyIndex = {};
    const input = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = toHex(keyVal.key);
      if (inputKeyIndex[hexKey]) {
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
        );
      }
      inputKeyIndex[hexKey] = 1;
      input.push(keyVal);
    }
    inputKeyVals.push(input);
  }
  for (const index of range$2(outputCount)) {
    const outputKeyIndex = {};
    const output = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = toHex(keyVal.key);
      if (outputKeyIndex[hexKey]) {
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
        );
      }
      outputKeyIndex[hexKey] = 1;
      output.push(keyVal);
    }
    outputKeyVals.push(output);
  }
  return psbtFromKeyVals(unsignedTx2, {
    globalMapKeyVals,
    inputKeyVals,
    outputKeyVals
  });
}
function checkKeyBuffer(type2, keyBuf, keyNum) {
  if (compare$1(keyBuf, Uint8Array.from([keyNum]))) {
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${type2} key: ${toHex(keyBuf)}`
    );
  }
}
function psbtFromKeyVals(unsignedTx2, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
  const globalMap = {
    unsignedTx: unsignedTx2
  };
  let txCount = 0;
  for (const keyVal of globalMapKeyVals) {
    switch (keyVal.key[0]) {
      case GlobalTypes.UNSIGNED_TX:
        checkKeyBuffer("global", keyVal.key, GlobalTypes.UNSIGNED_TX);
        if (txCount > 0) {
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        }
        txCount++;
        break;
      case GlobalTypes.GLOBAL_XPUB:
        if (globalMap.globalXpub === void 0) {
          globalMap.globalXpub = [];
        }
        globalMap.globalXpub.push(globals.globalXpub.decode(keyVal));
        break;
      default:
        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
        globalMap.unknownKeyVals.push(keyVal);
    }
  }
  const inputCount = inputKeyVals.length;
  const outputCount = outputKeyVals.length;
  const inputs$1 = [];
  const outputs$1 = [];
  for (const index of range$2(inputCount)) {
    const input = {};
    for (const keyVal of inputKeyVals[index]) {
      inputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case InputTypes.NON_WITNESS_UTXO:
          checkKeyBuffer("input", keyVal.key, InputTypes.NON_WITNESS_UTXO);
          if (input.nonWitnessUtxo !== void 0) {
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          }
          input.nonWitnessUtxo = inputs.nonWitnessUtxo.decode(keyVal);
          break;
        case InputTypes.WITNESS_UTXO:
          checkKeyBuffer("input", keyVal.key, InputTypes.WITNESS_UTXO);
          if (input.witnessUtxo !== void 0) {
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          }
          input.witnessUtxo = inputs.witnessUtxo.decode(keyVal);
          break;
        case InputTypes.PARTIAL_SIG:
          if (input.partialSig === void 0) {
            input.partialSig = [];
          }
          input.partialSig.push(inputs.partialSig.decode(keyVal));
          break;
        case InputTypes.SIGHASH_TYPE:
          checkKeyBuffer("input", keyVal.key, InputTypes.SIGHASH_TYPE);
          if (input.sighashType !== void 0) {
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          }
          input.sighashType = inputs.sighashType.decode(keyVal);
          break;
        case InputTypes.REDEEM_SCRIPT:
          checkKeyBuffer("input", keyVal.key, InputTypes.REDEEM_SCRIPT);
          if (input.redeemScript !== void 0) {
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          }
          input.redeemScript = inputs.redeemScript.decode(keyVal);
          break;
        case InputTypes.WITNESS_SCRIPT:
          checkKeyBuffer("input", keyVal.key, InputTypes.WITNESS_SCRIPT);
          if (input.witnessScript !== void 0) {
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          }
          input.witnessScript = inputs.witnessScript.decode(keyVal);
          break;
        case InputTypes.BIP32_DERIVATION:
          if (input.bip32Derivation === void 0) {
            input.bip32Derivation = [];
          }
          input.bip32Derivation.push(
            inputs.bip32Derivation.decode(keyVal)
          );
          break;
        case InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer("input", keyVal.key, InputTypes.FINAL_SCRIPTSIG);
          input.finalScriptSig = inputs.finalScriptSig.decode(keyVal);
          break;
        case InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer("input", keyVal.key, InputTypes.FINAL_SCRIPTWITNESS);
          input.finalScriptWitness = inputs.finalScriptWitness.decode(
            keyVal
          );
          break;
        case InputTypes.POR_COMMITMENT:
          checkKeyBuffer("input", keyVal.key, InputTypes.POR_COMMITMENT);
          input.porCommitment = inputs.porCommitment.decode(keyVal);
          break;
        case InputTypes.TAP_KEY_SIG:
          checkKeyBuffer("input", keyVal.key, InputTypes.TAP_KEY_SIG);
          input.tapKeySig = inputs.tapKeySig.decode(keyVal);
          break;
        case InputTypes.TAP_SCRIPT_SIG:
          if (input.tapScriptSig === void 0) {
            input.tapScriptSig = [];
          }
          input.tapScriptSig.push(inputs.tapScriptSig.decode(keyVal));
          break;
        case InputTypes.TAP_LEAF_SCRIPT:
          if (input.tapLeafScript === void 0) {
            input.tapLeafScript = [];
          }
          input.tapLeafScript.push(inputs.tapLeafScript.decode(keyVal));
          break;
        case InputTypes.TAP_BIP32_DERIVATION:
          if (input.tapBip32Derivation === void 0) {
            input.tapBip32Derivation = [];
          }
          input.tapBip32Derivation.push(
            inputs.tapBip32Derivation.decode(keyVal)
          );
          break;
        case InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer("input", keyVal.key, InputTypes.TAP_INTERNAL_KEY);
          input.tapInternalKey = inputs.tapInternalKey.decode(keyVal);
          break;
        case InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer("input", keyVal.key, InputTypes.TAP_MERKLE_ROOT);
          input.tapMerkleRoot = inputs.tapMerkleRoot.decode(keyVal);
          break;
        default:
          if (!input.unknownKeyVals) input.unknownKeyVals = [];
          input.unknownKeyVals.push(keyVal);
      }
    }
    inputs$1.push(input);
  }
  for (const index of range$2(outputCount)) {
    const output = {};
    for (const keyVal of outputKeyVals[index]) {
      outputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case OutputTypes.REDEEM_SCRIPT:
          checkKeyBuffer("output", keyVal.key, OutputTypes.REDEEM_SCRIPT);
          if (output.redeemScript !== void 0) {
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          }
          output.redeemScript = outputs.redeemScript.decode(keyVal);
          break;
        case OutputTypes.WITNESS_SCRIPT:
          checkKeyBuffer("output", keyVal.key, OutputTypes.WITNESS_SCRIPT);
          if (output.witnessScript !== void 0) {
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          }
          output.witnessScript = outputs.witnessScript.decode(keyVal);
          break;
        case OutputTypes.BIP32_DERIVATION:
          if (output.bip32Derivation === void 0) {
            output.bip32Derivation = [];
          }
          output.bip32Derivation.push(
            outputs.bip32Derivation.decode(keyVal)
          );
          break;
        case OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer("output", keyVal.key, OutputTypes.TAP_INTERNAL_KEY);
          output.tapInternalKey = outputs.tapInternalKey.decode(keyVal);
          break;
        case OutputTypes.TAP_TREE:
          checkKeyBuffer("output", keyVal.key, OutputTypes.TAP_TREE);
          output.tapTree = outputs.tapTree.decode(keyVal);
          break;
        case OutputTypes.TAP_BIP32_DERIVATION:
          if (output.tapBip32Derivation === void 0) {
            output.tapBip32Derivation = [];
          }
          output.tapBip32Derivation.push(
            outputs.tapBip32Derivation.decode(keyVal)
          );
          break;
        default:
          if (!output.unknownKeyVals) output.unknownKeyVals = [];
          output.unknownKeyVals.push(keyVal);
      }
    }
    outputs$1.push(output);
  }
  return { globalMap, inputs: inputs$1, outputs: outputs$1 };
}
function psbtToBuffer({ globalMap, inputs: inputs2, outputs: outputs2 }) {
  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
    globalMap,
    inputs: inputs2,
    outputs: outputs2
  });
  const globalBuffer = keyValsToBuffer(globalKeyVals);
  const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Uint8Array.from([0])] : keyVals.map(keyValsToBuffer);
  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
  const header = new Uint8Array(5);
  header.set([112, 115, 98, 116, 255], 0);
  return concat(
    [header, globalBuffer].concat(inputBuffers, outputBuffers)
  );
}
var sortKeyVals = (a, b) => {
  return compare$1(a.key, b.key);
};
function keyValsFromMap(keyValMap, converterFactory) {
  const keyHexSet = /* @__PURE__ */ new Set();
  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
    if (key === "unknownKeyVals") return result;
    const converter2 = converterFactory[key];
    if (converter2 === void 0) return result;
    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
      converter2.encode
    );
    const keyHexes = encodedKeyVals.map((kv) => toHex(kv.key));
    keyHexes.forEach((hex) => {
      if (keyHexSet.has(hex))
        throw new Error("Serialize Error: Duplicate key: " + hex);
      keyHexSet.add(hex);
    });
    return result.concat(encodedKeyVals);
  }, []);
  const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
    return !keyHexSet.has(toHex(keyVal.key));
  }) : [];
  return keyVals.concat(otherKeyVals).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap, inputs: inputs$1, outputs: outputs$1 }) {
  return {
    globalKeyVals: keyValsFromMap(globalMap, globals),
    inputKeyVals: inputs$1.map((i2) => keyValsFromMap(i2, inputs)),
    outputKeyVals: outputs$1.map((o) => keyValsFromMap(o, outputs))
  };
}
function combine(psbts) {
  const self2 = psbts[0];
  const selfKeyVals = psbtToKeyVals(self2);
  const others = psbts.slice(1);
  if (others.length === 0) throw new Error("Combine: Nothing to combine");
  const selfTx = getTx(self2);
  if (selfTx === void 0) {
    throw new Error("Combine: Self missing transaction");
  }
  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
  for (const other of others) {
    const otherTx = getTx(other);
    if (otherTx === void 0 || compare$1(otherTx.toBuffer(), selfTx.toBuffer()) !== 0) {
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    }
    const otherKeyVals = psbtToKeyVals(other);
    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
    otherGlobalSet.forEach(
      keyPusher(
        selfGlobalSet,
        selfKeyVals.globalKeyVals,
        otherKeyVals.globalKeyVals
      )
    );
    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
    otherInputSets.forEach(
      (inputSet, idx) => inputSet.forEach(
        keyPusher(
          selfInputSets[idx],
          selfKeyVals.inputKeyVals[idx],
          otherKeyVals.inputKeyVals[idx]
        )
      )
    );
    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
    otherOutputSets.forEach(
      (outputSet, idx) => outputSet.forEach(
        keyPusher(
          selfOutputSets[idx],
          selfKeyVals.outputKeyVals[idx],
          otherKeyVals.outputKeyVals[idx]
        )
      )
    );
  }
  return psbtFromKeyVals(selfTx, {
    globalMapKeyVals: selfKeyVals.globalKeyVals,
    inputKeyVals: selfKeyVals.inputKeyVals,
    outputKeyVals: selfKeyVals.outputKeyVals
  });
}
function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
  return (key) => {
    if (selfSet.has(key)) return;
    const newKv = otherKeyVals.filter((kv) => toHex(kv.key) === key)[0];
    selfKeyVals.push(newKv);
    selfSet.add(key);
  };
}
function getTx(psbt) {
  return psbt.globalMap.unsignedTx;
}
function getKeySet(keyVals) {
  const set = /* @__PURE__ */ new Set();
  keyVals.forEach((keyVal) => {
    const hex = toHex(keyVal.key);
    if (set.has(hex))
      throw new Error("Combine: KeyValue Map keys should be unique");
    set.add(hex);
  });
  return set;
}
function checkForInput(inputs2, inputIndex) {
  const input = inputs2[inputIndex];
  if (input === void 0) throw new Error(`No input #${inputIndex}`);
  return input;
}
function checkForOutput(outputs2, outputIndex) {
  const output = outputs2[outputIndex];
  if (output === void 0) throw new Error(`No output #${outputIndex}`);
  return output;
}
function checkHasKey(checkKeyVal, keyVals, enumLength) {
  if (checkKeyVal.key[0] < enumLength) {
    throw new Error(
      `Use the method for your specific key instead of addUnknownKeyVal*`
    );
  }
  if (keyVals && keyVals.filter((kv) => compare$1(kv.key, checkKeyVal.key) === 0).length !== 0) {
    throw new Error(`Duplicate Key: ${toHex(checkKeyVal.key)}`);
  }
}
function getEnumLength(myenum) {
  let count = 0;
  Object.keys(myenum).forEach((val) => {
    if (Number(isNaN(Number(val)))) {
      count++;
    }
  });
  return count;
}
function inputCheckUncleanFinalized(inputIndex, input) {
  let result = false;
  if (input.nonWitnessUtxo || input.witnessUtxo) {
    const needScriptSig = !!input.redeemScript;
    const needWitnessScript = !!input.witnessScript;
    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
    result = scriptSigOK && witnessScriptOK && hasOneFinal;
  }
  if (result === false) {
    throw new Error(
      `Input #${inputIndex} has too much or too little data to clean`
    );
  }
}
function throwForUpdateMaker(typeName, name, expected2, data) {
  throw new Error(
    `Data for ${typeName} key ${name} is incorrect: Expected ${expected2} and got ${JSON.stringify(data)}`
  );
}
function updateMaker(typeName) {
  return (updateData, mainData) => {
    for (const name of Object.keys(updateData)) {
      const data = updateData[name];
      const { canAdd: canAdd2, canAddToArray: canAddToArray2, check: check2, expected: expected2 } = (
        // @ts-ignore
        converter[typeName + "s"][name] || {}
      );
      const isArray2 = !!canAddToArray2;
      if (check2) {
        if (isArray2) {
          if (!Array.isArray(data) || // @ts-ignore
          mainData[name] && !Array.isArray(mainData[name])) {
            throw new Error(`Key type ${name} must be an array`);
          }
          if (!data.every(check2)) {
            throwForUpdateMaker(typeName, name, expected2, data);
          }
          const arr = mainData[name] || [];
          const dupeCheckSet = /* @__PURE__ */ new Set();
          if (!data.every((v) => canAddToArray2(arr, v, dupeCheckSet))) {
            throw new Error("Can not add duplicate data to array");
          }
          mainData[name] = arr.concat(data);
        } else {
          if (!check2(data)) {
            throwForUpdateMaker(typeName, name, expected2, data);
          }
          if (!canAdd2(mainData, data)) {
            throw new Error(`Can not add duplicate data to ${typeName}`);
          }
          mainData[name] = data;
        }
      }
    }
  };
}
var updateGlobal = updateMaker("global");
var updateInput = updateMaker("input");
var updateOutput = updateMaker("output");
function addInputAttributes(inputs2, data) {
  const index = inputs2.length - 1;
  const input = checkForInput(inputs2, index);
  updateInput(data, input);
}
function addOutputAttributes(outputs2, data) {
  const index = outputs2.length - 1;
  const output = checkForOutput(outputs2, index);
  updateOutput(data, output);
}
var Psbt$1 = class Psbt {
  constructor(tx) {
    this.inputs = [];
    this.outputs = [];
    this.globalMap = {
      unsignedTx: tx
    };
  }
  static fromBase64(data, txFromBuffer2) {
    const buffer2 = fromBase64(data);
    return this.fromBuffer(buffer2, txFromBuffer2);
  }
  static fromHex(data, txFromBuffer2) {
    const buffer2 = fromHex(data);
    return this.fromBuffer(buffer2, txFromBuffer2);
  }
  static fromBuffer(buffer2, txFromBuffer2) {
    const results = psbtFromBuffer(buffer2, txFromBuffer2);
    const psbt = new this(results.globalMap.unsignedTx);
    Object.assign(psbt, results);
    return psbt;
  }
  toBase64() {
    const buffer2 = this.toBuffer();
    return toBase64(buffer2);
  }
  toHex() {
    const buffer2 = this.toBuffer();
    return toHex(buffer2);
  }
  toBuffer() {
    return psbtToBuffer(this);
  }
  updateGlobal(updateData) {
    updateGlobal(updateData, this.globalMap);
    return this;
  }
  updateInput(inputIndex, updateData) {
    const input = checkForInput(this.inputs, inputIndex);
    updateInput(updateData, input);
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const output = checkForOutput(this.outputs, outputIndex);
    updateOutput(updateData, output);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    checkHasKey(
      keyVal,
      this.globalMap.unknownKeyVals,
      getEnumLength(GlobalTypes)
    );
    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
    this.globalMap.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    const input = checkForInput(this.inputs, inputIndex);
    checkHasKey(keyVal, input.unknownKeyVals, getEnumLength(InputTypes));
    if (!input.unknownKeyVals) input.unknownKeyVals = [];
    input.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    const output = checkForOutput(this.outputs, outputIndex);
    checkHasKey(keyVal, output.unknownKeyVals, getEnumLength(OutputTypes));
    if (!output.unknownKeyVals) output.unknownKeyVals = [];
    output.unknownKeyVals.push(keyVal);
    return this;
  }
  addInput(inputData) {
    this.globalMap.unsignedTx.addInput(inputData);
    this.inputs.push({
      unknownKeyVals: []
    });
    const addKeyVals = inputData.unknownKeyVals || [];
    const inputIndex = this.inputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error("unknownKeyVals must be an Array");
    }
    addKeyVals.forEach(
      (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
    );
    addInputAttributes(this.inputs, inputData);
    return this;
  }
  addOutput(outputData) {
    this.globalMap.unsignedTx.addOutput(outputData);
    this.outputs.push({
      unknownKeyVals: []
    });
    const addKeyVals = outputData.unknownKeyVals || [];
    const outputIndex = this.outputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error("unknownKeyVals must be an Array");
    }
    addKeyVals.forEach(
      (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
    );
    addOutputAttributes(this.outputs, outputData);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    const input = checkForInput(this.inputs, inputIndex);
    inputCheckUncleanFinalized(inputIndex, input);
    for (const key of Object.keys(input)) {
      if (![
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(key)) {
        delete input[key];
      }
    }
    return this;
  }
  combine(...those) {
    const result = combine([this].concat(those));
    Object.assign(this, result);
    return this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
function isPaymentFactory(payment) {
  return (script2) => {
    try {
      payment({ output: script2 });
      return true;
    } catch {
      return false;
    }
  };
}
var isP2MS = isPaymentFactory(p2ms);
var isP2PK = isPaymentFactory(p2pk);
var isP2PKH = isPaymentFactory(p2pkh);
var isP2WPKH = isPaymentFactory(p2wpkh);
var isP2WSHScript = isPaymentFactory(p2wsh);
var isP2SHScript = isPaymentFactory(p2sh);
var isP2TR = isPaymentFactory(p2tr);
var isP2MR = isPaymentFactory(p2mr);
var isP2A = (script2) => {
  return script2.length === 4 && script2[0] === 81 && // OP_1
  script2[1] === 2 && // push 2 bytes
  script2[2] === 78 && script2[3] === 115;
};
function witnessStackToScriptWitness$1(witness) {
  const chunks = [];
  function writeSlice(slice) {
    chunks.push(slice);
  }
  function writeVarInt(i2) {
    const varintLen = encodingLength$1(i2);
    const buf = alloc(varintLen);
    encode$k(i2, buf, 0);
    chunks.push(buf);
  }
  function writeVarSlice(slice) {
    writeVarInt(slice.length);
    writeSlice(slice);
  }
  function writeVector(vector) {
    writeVarInt(vector.length);
    vector.forEach(writeVarSlice);
  }
  writeVector(witness);
  return concat$1(chunks);
}
function pubkeyPositionInScript(pubkey, script$1) {
  const decompiled = decompile(script$1);
  if (decompiled === null)
    throw new Error("Unknown script error");
  const pubkeyHash = hash160(pubkey);
  const pubkeyXOnly = toXOnly(pubkey);
  const uncompressed = decompressPublicKey(pubkey);
  const pubkeyHybridHash = (uncompressed == null ? void 0 : uncompressed.hybrid) ? hash160(uncompressed.hybrid) : void 0;
  const pubkeyUncompressedHash = (uncompressed == null ? void 0 : uncompressed.uncompressed) ? hash160(uncompressed.uncompressed) : void 0;
  return decompiled.findIndex((element) => {
    if (typeof element === "number")
      return false;
    if (pubkeysMatch(element, pubkey))
      return true;
    if (pubkeysMatch(element, pubkeyXOnly))
      return true;
    if (equals(element, pubkeyHash)) {
      return true;
    }
    if (uncompressed) {
      if (pubkeysMatch(element, uncompressed.uncompressed))
        return true;
      if (pubkeysMatch(element, uncompressed.hybrid))
        return true;
      if (pubkeyHybridHash && equals(element, pubkeyHybridHash) || pubkeyUncompressedHash && equals(element, pubkeyUncompressedHash)) {
        return true;
      }
    }
    return false;
  });
}
function pubkeyInScript$1(pubkey, script2) {
  return pubkeyPositionInScript(pubkey, script2) !== -1;
}
function checkInputForSig(input, action) {
  const pSigs = extractPartialSigs(input);
  return pSigs.some((pSig) => signatureBlocksAction(pSig, signature.decode, action));
}
function signatureBlocksAction(signature2, signatureDecodeFn, action) {
  const { hashType } = signatureDecodeFn(signature2);
  const whitelist = [];
  const isAnyoneCanPay = hashType & Transaction.SIGHASH_ANYONECANPAY;
  if (isAnyoneCanPay)
    whitelist.push("addInput");
  const hashMod = hashType & 31;
  switch (hashMod) {
    case Transaction.SIGHASH_ALL:
      break;
    case Transaction.SIGHASH_SINGLE:
    case Transaction.SIGHASH_NONE:
      whitelist.push("addOutput");
      whitelist.push("setInputSequence");
      break;
  }
  return whitelist.indexOf(action) === -1;
}
function extractPartialSigs(input) {
  const { partialSig: partialSig2 } = input;
  let pSigs;
  if (!partialSig2 || partialSig2.length === 0) {
    if (!input.finalScriptSig && !input.finalScriptWitness)
      return [];
    pSigs = getPsigsFromInputFinalScripts(input);
  } else {
    pSigs = partialSig2;
  }
  return pSigs.map((p) => new Uint8Array(p.signature));
}
function getPsigsFromInputFinalScripts(input) {
  const scriptItems = !input.finalScriptSig ? [] : decompile(new Uint8Array(input.finalScriptSig)) || [];
  const witnessItems = !input.finalScriptWitness ? [] : decompile(new Uint8Array(input.finalScriptWitness)) || [];
  return scriptItems.concat(witnessItems).filter((item) => {
    return item instanceof Uint8Array && isCanonicalScriptSignature(item);
  }).map((sig) => ({ signature: sig }));
}
function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
  const tapLeaf = findTapLeafToFinalize(input, inputIndex, tapLeafHashToFinalize);
  try {
    const sigs = sortSignatures(input, tapLeaf);
    const witness = sigs.concat(new Uint8Array(tapLeaf.script)).concat(new Uint8Array(tapLeaf.controlBlock));
    return { finalScriptWitness: witnessStackToScriptWitness$1(witness) };
  } catch (err2) {
    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err2}`, { cause: err2 });
  }
}
function serializeTaprootSignature(sig, sighashType2) {
  const sighashTypeByte = sighashType2 ? new Uint8Array([sighashType2]) : new Uint8Array(0);
  return concat$1([sig, sighashTypeByte]);
}
function isTaprootInput$1(input) {
  return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (isP2TR(new Uint8Array(input.witnessUtxo.script)) || isP2MR(new Uint8Array(input.witnessUtxo.script))));
}
function isP2MRInput(input) {
  return !!(input.witnessUtxo && isP2MR(new Uint8Array(input.witnessUtxo.script)));
}
function isTaprootOutput(output, script2) {
  return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script2);
}
function checkTaprootInputFields(inputData, newInputData, action) {
  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
  checkIfTapLeafInTree(inputData, newInputData, action);
}
function checkTaprootOutputFields(outputData, newOutputData, action) {
  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
  checkTaprootScriptPubkey(outputData, newOutputData);
}
function checkTaprootScriptPubkey(outputData, newOutputData) {
  if (!newOutputData.tapTree && !newOutputData.tapInternalKey)
    return;
  const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
  const tapTree2 = newOutputData.tapTree || outputData.tapTree;
  if (tapInternalKey) {
    const scriptPubkey = outputData.script;
    const script2 = getTaprootScripPubkey(tapInternalKey, tapTree2);
    if (scriptPubkey && !equals(scriptPubkey, script2))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(tapInternalKey, tapTree2) {
  const scriptTree = tapTree2 && tapTreeFromList(tapTree2.leaves);
  const { output } = p2tr({
    internalPubkey: new Uint8Array(tapInternalKey),
    scriptTree
  });
  if (!output)
    throw new Error("Failed to generate taproot script pubkey");
  return output;
}
function tapTreeFromList(leaves = []) {
  const firstLeaf = leaves[0];
  if (leaves.length === 1 && firstLeaf && firstLeaf.depth === 0)
    return {
      output: new Uint8Array(firstLeaf.script),
      version: firstLeaf.leafVersion
    };
  return insertLeavesInTree(leaves);
}
function checkTaprootInputForSigs(input, action) {
  const sigs = extractTaprootSigs(input);
  return sigs.some((sig) => signatureBlocksAction(sig, decodeSchnorrSignature, action));
}
function decodeSchnorrSignature(signature2) {
  return {
    signature: signature2.subarray(0, 64),
    hashType: signature2.subarray(64)[0] || Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(input) {
  const sigs = [];
  if (input.tapKeySig)
    sigs.push(new Uint8Array(input.tapKeySig));
  if (input.tapScriptSig)
    sigs.push(...input.tapScriptSig.map((s) => new Uint8Array(s.signature)));
  if (!sigs.length) {
    const finalTapKeySig = getTapKeySigFromWitness(input.finalScriptWitness ? new Uint8Array(input.finalScriptWitness) : void 0);
    if (finalTapKeySig)
      sigs.push(finalTapKeySig);
  }
  return sigs;
}
function getTapKeySigFromWitness(finalScriptWitness2) {
  if (!finalScriptWitness2)
    return;
  const witness = finalScriptWitness2.subarray(2);
  if (witness.length === 64 || witness.length === 65)
    return witness;
  return void 0;
}
function insertLeavesInTree(leaves) {
  let tree;
  for (const leaf of leaves) {
    tree = insertLeafInTree(leaf, tree);
    if (!tree)
      throw new Error(`No room left to insert tapleaf in tree`);
  }
  return tree;
}
function insertLeafInTree(leaf, tree, depth = 0) {
  if (depth > MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (leaf.depth === depth) {
    if (!tree)
      return {
        output: new Uint8Array(leaf.script),
        version: leaf.leafVersion
      };
    return;
  }
  if (isTapleaf(tree))
    return;
  const leftSide = insertLeafInTree(leaf, tree && tree[0], depth + 1);
  if (leftSide)
    return [leftSide, tree && tree[1]];
  const rightSide = insertLeafInTree(leaf, tree && tree[1], depth + 1);
  if (rightSide)
    return [tree && tree[0], rightSide];
  return void 0;
}
function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
  const isBadTaprootUpdate = isTaprootInput$1(inputData) && hasNonTaprootFields(newInputData);
  const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput$1(newInputData);
  const hasMixedFields = inputData === newInputData && isTaprootInput$1(newInputData) && hasNonTaprootFields(newInputData);
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
    throw new Error(`Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`);
}
function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
  const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
  const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
  const hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
    throw new Error(`Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`);
}
function checkIfTapLeafInTree(inputData, newInputData, action) {
  const p2mrInput = isP2MRInput(inputData) || isP2MRInput(newInputData);
  if (newInputData.tapMerkleRoot) {
    const merkleRoot = new Uint8Array(newInputData.tapMerkleRoot);
    const newLeafsInTree = (newInputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, merkleRoot, p2mrInput));
    const oldLeafsInTree = (inputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, merkleRoot, p2mrInput));
    if (!newLeafsInTree || !oldLeafsInTree)
      throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);
  } else if (inputData.tapMerkleRoot) {
    const merkleRoot = new Uint8Array(inputData.tapMerkleRoot);
    const newLeafsInTree = (newInputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, merkleRoot, p2mrInput));
    if (!newLeafsInTree)
      throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);
  }
}
function isTapLeafInTree(tapLeaf, merkleRoot, p2mr2 = false) {
  if (!merkleRoot)
    return true;
  const leafHash = tapleafHash({
    output: new Uint8Array(tapLeaf.script),
    version: tapLeaf.leafVersion
  });
  const controlBlock = new Uint8Array(tapLeaf.controlBlock);
  if (p2mr2) {
    return equals(rootHashFromPathP2MR(controlBlock, leafHash), merkleRoot);
  }
  const isValidP2TRLength = controlBlock.length >= 33 && (controlBlock.length - 33) % 32 === 0;
  const isValidP2MRLength = controlBlock.length >= 1 && (controlBlock.length - 1) % 32 === 0;
  if (isValidP2TRLength) {
    const rootHash = rootHashFromPath(controlBlock, leafHash);
    if (equals(rootHash, merkleRoot))
      return true;
  }
  if (isValidP2MRLength) {
    const rootHash = rootHashFromPathP2MR(controlBlock, leafHash);
    if (equals(rootHash, merkleRoot))
      return true;
  }
  return false;
}
function sortSignatures(input, tapLeaf) {
  const tapLeafScript2 = new Uint8Array(tapLeaf.script);
  const leafHash = tapleafHash({
    output: tapLeafScript2,
    version: tapLeaf.leafVersion
  });
  return (input.tapScriptSig || []).filter((tss) => equals(new Uint8Array(tss.leafHash), leafHash)).map((tss) => addPubkeyPositionInScript(tapLeafScript2, tss)).sort((t1, t2) => t2.positionInScript - t1.positionInScript).map((t2) => new Uint8Array(t2.signature));
}
function addPubkeyPositionInScript(script2, tss) {
  return Object.assign({
    positionInScript: pubkeyPositionInScript(new Uint8Array(tss.pubkey), script2)
  }, tss);
}
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
  const { tapScriptSig: tapScriptSig2 } = input;
  if (!tapScriptSig2 || !tapScriptSig2.length)
    throw new Error(`Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`);
  const tapLeaf = (input.tapLeafScript || []).sort((a, b) => a.controlBlock.length - b.controlBlock.length).find((leaf) => canFinalizeLeaf(leaf, tapScriptSig2, leafHashToFinalize));
  if (!tapLeaf)
    throw new Error(`Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`);
  return tapLeaf;
}
function canFinalizeLeaf(leaf, tapScriptSig2, hash2) {
  const leafHash = tapleafHash({
    output: new Uint8Array(leaf.script),
    version: leaf.leafVersion
  });
  const whiteListedHash = !hash2 || equals(hash2, leafHash);
  return whiteListedHash && tapScriptSig2.find((tss) => equals(new Uint8Array(tss.leafHash), leafHash)) !== void 0;
}
function hasNonTaprootFields(io) {
  return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);
}
function check32Bit(num) {
  if (typeof num !== "number" || num !== Math.floor(num) || num > 4294967295 || num < 0) {
    throw new Error("Invalid 32 bit integer");
  }
}
function checkCache(cache) {
  if (cache.unsafeSignNonSegwit) {
    throw new Error("Not BIP174 compliant, can not export");
  }
}
function isFinalized(input) {
  return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function checkTxEmpty(tx) {
  const isEmpty = tx.ins.every((input) => input.script && input.script.length === 0 && input.witness && input.witness.length === 0);
  if (!isEmpty) {
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
  }
}
function checkTxInputCache(cache, input) {
  const reversed = reverse(new Uint8Array(input.hash));
  const key = `${toHex$1(reversed)}:${input.index}`;
  if (cache.txInCache[key])
    throw new Error("Duplicate input detected.");
  cache.txInCache[key] = 1;
}
function checkTxForDupeIns(tx, cache) {
  tx.ins.forEach((input) => {
    checkTxInputCache(cache, input);
  });
}
function checkInputsForPartialSig(inputs2, action, hasSignaturesCache) {
  if (hasSignaturesCache === false) {
    return;
  }
  inputs2.forEach((input) => {
    const throws = isTaprootInput$1(input) ? checkTaprootInputForSigs(input, action) : checkInputForSig(input, action);
    if (throws)
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(input) {
  if (!input.sighashType || !input.partialSig)
    return;
  const { partialSig: partialSig2, sighashType: sighashType2 } = input;
  partialSig2.forEach((pSig) => {
    const { hashType } = signature.decode(pSig.signature);
    if (sighashType2 !== hashType) {
      throw new Error("Signature sighash does not match input sighash type");
    }
  });
}
function checkScriptForPubkey(pubkey, script2, action) {
  if (!pubkeyInScript$1(pubkey, script2)) {
    throw new Error(`Can not ${action} for this input with the key ${toHex$1(pubkey)}`);
  }
}
function scriptCheckerFactory(payment, paymentScriptName) {
  return (inputIndex, scriptPubKey, redeemScript, ioType) => {
    const redeemScriptOutput = payment({
      redeem: { output: redeemScript }
    }).output;
    if (!equals(scriptPubKey, redeemScriptOutput)) {
      throw new Error(`${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`);
    }
  };
}
var checkRedeemScript = scriptCheckerFactory(p2sh, "Redeem script");
var checkWitnessScript = scriptCheckerFactory(p2wsh, "Witness script");
function scriptWitnessToWitnessStack(buffer2) {
  let offset = 0;
  function readSlice(n2) {
    offset += n2;
    return buffer2.subarray(offset - n2, offset);
  }
  function readVarInt() {
    const vi = decode$j(buffer2, offset);
    offset += vi.bytes;
    return vi.numberValue || 0;
  }
  function readVarSlice() {
    return readSlice(readVarInt());
  }
  function readVector() {
    const count = readVarInt();
    const vector = [];
    for (let i2 = 0; i2 < count; i2++)
      vector.push(readVarSlice());
    return vector;
  }
  return readVector();
}
function sighashTypeToString(sighashType2) {
  let text = sighashType2 & Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  const sigMod = sighashType2 & 31;
  switch (sigMod) {
    case Transaction.SIGHASH_ALL:
      text += "SIGHASH_ALL";
      break;
    case Transaction.SIGHASH_SINGLE:
      text += "SIGHASH_SINGLE";
      break;
    case Transaction.SIGHASH_NONE:
      text += "SIGHASH_NONE";
      break;
  }
  return text;
}
function compressPubkey(pubkey) {
  if (pubkey.length === 65) {
    const parity = pubkey[64] & 1;
    const newKey = new Uint8Array(pubkey.subarray(0, 33));
    newKey[0] = 2 | parity;
    return newKey;
  }
  return new Uint8Array(pubkey);
}
function isPubkeyLike(buf) {
  return buf.length === 33 && isCanonicalPubKey(buf);
}
function isSigLike(buf) {
  return isCanonicalScriptSignature(buf);
}
function classifyScript(script2) {
  if (isP2WPKH(script2))
    return "witnesspubkeyhash";
  if (isP2PKH(script2))
    return "pubkeyhash";
  if (isP2MS(script2))
    return "multisig";
  if (isP2PK(script2))
    return "pubkey";
  return "nonstandard";
}
function range$1(n2) {
  return [...Array(n2).keys()];
}
function checkInvalidP2WSH(script2) {
  if (isP2WPKH(script2) || isP2SHScript(script2)) {
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
  }
}
function getMeaningfulScript(script2, index, ioType, redeemScript, witnessScript) {
  const isP2SH = isP2SHScript(script2);
  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);
  const isP2WSH = isP2WSHScript(script2);
  if (isP2SH && redeemScript === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  let meaningfulScript;
  if (isP2SHP2WSH) {
    if (!witnessScript)
      throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    if (!redeemScript)
      throw new Error("P2SH-P2WSH requires redeemScript");
    meaningfulScript = witnessScript;
    checkRedeemScript(index, script2, redeemScript, ioType);
    checkWitnessScript(index, redeemScript, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2WSH) {
    if (!witnessScript)
      throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    meaningfulScript = witnessScript;
    checkWitnessScript(index, script2, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2SH) {
    if (!redeemScript)
      throw new Error("P2SH requires redeemScript");
    meaningfulScript = redeemScript;
    checkRedeemScript(index, script2, redeemScript, ioType);
  } else {
    meaningfulScript = script2;
  }
  return {
    meaningfulScript,
    type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
  };
}
var PsbtCache = class {
  constructor(tx) {
    __publicField(this, "nonWitnessUtxoTxCache");
    __publicField(this, "nonWitnessUtxoBufCache");
    __publicField(this, "txInCache");
    __publicField(this, "tx");
    __publicField(this, "unsafeSignNonSegwit");
    __publicField(this, "hasSignatures");
    __publicField(this, "fee");
    __publicField(this, "feeRate");
    __publicField(this, "extractedTx");
    __publicField(this, "prevOuts");
    __publicField(this, "signingScripts");
    __publicField(this, "values");
    __publicField(this, "taprootHashCache");
    this.nonWitnessUtxoTxCache = [];
    this.nonWitnessUtxoBufCache = [];
    this.txInCache = {};
    this.tx = tx;
    this.unsafeSignNonSegwit = false;
    this.hasSignatures = false;
  }
  /**
   * Invalidates cached computed values.
   * @param scope - 'full' clears everything (for input changes), 'outputs' clears fee/extract/taproot caches
   */
  invalidate(scope) {
    this.fee = void 0;
    this.feeRate = void 0;
    this.extractedTx = void 0;
    this.taprootHashCache = void 0;
    if (scope === "full") {
      this.prevOuts = void 0;
      this.signingScripts = void 0;
      this.values = void 0;
    }
  }
  addNonWitnessTxCache(input, inputIndex, txFromBuffer2) {
    if (!input.nonWitnessUtxo)
      throw new Error("nonWitnessUtxo is required");
    if (input === null || input === Object.prototype) {
      throw new Error("Invalid input object");
    }
    const nonWitnessUtxoBuf = input.nonWitnessUtxo;
    this.nonWitnessUtxoBufCache[inputIndex] = nonWitnessUtxoBuf;
    this.nonWitnessUtxoTxCache[inputIndex] = txFromBuffer2(nonWitnessUtxoBuf);
  }
  getNonWitnessUtxoTx(input, inputIndex, txFromBuffer2) {
    const cached = this.nonWitnessUtxoTxCache[inputIndex];
    if (!cached) {
      this.addNonWitnessTxCache(input, inputIndex, txFromBuffer2);
    }
    return this.nonWitnessUtxoTxCache[inputIndex];
  }
  getScriptFromUtxo(inputIndex, input, txFromBuffer2) {
    const { script: script2 } = this.getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer2);
    return script2;
  }
  getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer2) {
    if (input.witnessUtxo !== void 0) {
      return {
        script: input.witnessUtxo.script,
        value: input.witnessUtxo.value
      };
    } else if (input.nonWitnessUtxo !== void 0) {
      const nonWitnessUtxoTx = this.getNonWitnessUtxoTx(input, inputIndex, txFromBuffer2);
      const txIn = this.tx.ins[inputIndex];
      const o = nonWitnessUtxoTx.outs[txIn.index];
      return { script: o.script, value: o.value };
    } else {
      throw new Error("Can't find pubkey in input without Utxo data");
    }
  }
  computeFee(inputs2, disableOutputChecks = false, txFromBuffer2) {
    if (!inputs2.every(isFinalized))
      throw new Error("PSBT must be finalized to calculate fee");
    if (this.fee !== void 0)
      return this.fee;
    let tx;
    let mustFinalize = true;
    if (this.extractedTx) {
      tx = this.extractedTx;
      mustFinalize = false;
    } else {
      tx = this.tx.clone();
    }
    const { fee } = this.finalizeAndComputeAmounts(inputs2, tx, mustFinalize, disableOutputChecks, txFromBuffer2);
    return fee;
  }
  computeFeeRate(inputs2, disableOutputChecks = false, txFromBuffer2) {
    if (!inputs2.every(isFinalized))
      throw new Error("PSBT must be finalized to calculate fee rate");
    if (this.feeRate !== void 0)
      return this.feeRate;
    let tx;
    let mustFinalize = true;
    if (this.extractedTx) {
      tx = this.extractedTx;
      mustFinalize = false;
    } else {
      tx = this.tx.clone();
    }
    const { feeRate } = this.finalizeAndComputeAmounts(inputs2, tx, mustFinalize, disableOutputChecks, txFromBuffer2);
    return feeRate;
  }
  checkFees(opts) {
    const feeRate = this.feeRate;
    if (!this.extractedTx)
      throw new Error("Transaction not extracted");
    if (feeRate === void 0)
      throw new Error("Fee rate not computed");
    const vsize = this.extractedTx.virtualSize();
    const satoshis = feeRate * vsize;
    if (feeRate >= opts.maximumFeeRate) {
      throw new Error(`Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in fees, which is ${feeRate} satoshi per byte for a transaction with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`);
    }
  }
  pubkeyInInput(pubkey, input, inputIndex, txFromBuffer2) {
    const script2 = this.getScriptFromUtxo(inputIndex, input, txFromBuffer2);
    const { meaningfulScript } = getMeaningfulScript(script2, inputIndex, "input", input.redeemScript, input.witnessScript);
    return pubkeyInScript$1(pubkey, meaningfulScript);
  }
  pubkeyInOutput(pubkey, output, outputIndex) {
    const script2 = this.tx.outs[outputIndex].script;
    const { meaningfulScript } = getMeaningfulScript(script2, outputIndex, "output", output.redeemScript, output.witnessScript);
    return pubkeyInScript$1(pubkey, meaningfulScript);
  }
  redeemFromFinalScriptSig(finalScript) {
    if (!finalScript)
      return;
    const decomp = decompile(finalScript);
    if (!decomp)
      return;
    const lastItem = decomp[decomp.length - 1];
    if (!(lastItem instanceof Uint8Array) || isPubkeyLike(lastItem) || isSigLike(lastItem))
      return;
    const sDecomp = decompile(lastItem);
    if (!sDecomp)
      return;
    return lastItem;
  }
  redeemFromFinalWitnessScript(finalScript) {
    if (!finalScript)
      return;
    const decomp = scriptWitnessToWitnessStack(finalScript);
    const lastItem = decomp[decomp.length - 1];
    if (!lastItem)
      return;
    if (isPubkeyLike(lastItem))
      return;
    const sDecomp = decompile(lastItem);
    if (!sDecomp)
      return;
    return lastItem;
  }
  /**
   * Finalize transaction inputs and compute fee amounts.
   * Returns computed values instead of mutating cache parameters directly.
   */
  finalizeAndComputeAmounts(inputs2, tx, mustFinalize, disableOutputChecks, txFromBuffer2) {
    let inputAmount = 0n;
    inputs2.forEach((input, idx) => {
      const txIn = tx.ins[idx];
      if (mustFinalize && input.finalScriptSig)
        txIn.script = input.finalScriptSig;
      if (mustFinalize && input.finalScriptWitness) {
        txIn.witness = scriptWitnessToWitnessStack(input.finalScriptWitness);
      }
      if (input.witnessUtxo) {
        inputAmount += input.witnessUtxo.value;
      } else if (input.nonWitnessUtxo) {
        if (!txFromBuffer2)
          throw new Error("txFromBuffer is required for nonWitnessUtxo inputs");
        const nwTx = this.getNonWitnessUtxoTx(input, idx, txFromBuffer2);
        const vout = txIn.index;
        const out = nwTx.outs[vout];
        inputAmount += out.value;
      }
    });
    const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0n);
    const feeValue = inputAmount - outputAmount;
    if (!disableOutputChecks) {
      if (feeValue < 0n) {
        throw new Error(`Outputs are spending more than Inputs ${inputAmount} < ${outputAmount}`);
      }
    }
    const bytes = tx.virtualSize();
    const fee = Number(feeValue);
    const feeRate = Math.floor(fee / bytes);
    this.fee = fee;
    this.extractedTx = tx;
    this.feeRate = feeRate;
    return { fee, feeRate };
  }
  getScriptFromInput(inputIndex, input, txFromBuffer2) {
    const res = {
      script: null,
      isSegwit: false,
      isP2SH: false,
      isP2WSH: false
    };
    res.isP2SH = !!input.redeemScript;
    res.isP2WSH = !!input.witnessScript;
    if (input.witnessScript) {
      res.script = input.witnessScript;
    } else if (input.redeemScript) {
      res.script = input.redeemScript;
    } else {
      if (input.nonWitnessUtxo) {
        const nonWitnessUtxoTx = this.getNonWitnessUtxoTx(input, inputIndex, txFromBuffer2);
        const prevoutIndex = this.tx.ins[inputIndex].index;
        res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
      } else if (input.witnessUtxo) {
        res.script = input.witnessUtxo.script;
      }
    }
    if (input.witnessScript || res.script && isP2WPKH(res.script)) {
      res.isSegwit = true;
    } else {
      if (res.script && isUnknownSegwitVersion(res.script)) {
        res.isSegwit = true;
      }
    }
    return res;
  }
  getPrevoutTaprootKey(inputIndex, input, txFromBuffer2) {
    const { script: script2 } = this.getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer2);
    return isP2TR(script2) ? script2.subarray(2, 34) : null;
  }
};
var _cache, _txFromBuffer;
var PsbtSigner = class {
  constructor(cache, txFromBuffer2) {
    __privateAdd(this, _cache);
    __privateAdd(this, _txFromBuffer);
    __privateSet(this, _cache, cache);
    __privateSet(this, _txFromBuffer, txFromBuffer2);
  }
  getHashAndSighashType(inputs2, inputIndex, pubkey, sighashTypes) {
    const input = checkForInput(inputs2, inputIndex);
    const { hash: hash2, sighashType: sighashType2, script: script2 } = this.getHashForSig(inputIndex, input, false, sighashTypes);
    checkScriptForPubkey(pubkey, script2, "sign");
    return { hash: hash2, sighashType: sighashType2 };
  }
  getHashForSig(inputIndex, input, forValidate, sighashTypes) {
    const unsignedTx2 = __privateGet(this, _cache).tx;
    const sighashType2 = input.sighashType || Transaction.SIGHASH_ALL;
    checkSighashTypeAllowed(sighashType2, sighashTypes);
    let hash2;
    let prevout;
    if (input.nonWitnessUtxo) {
      const nonWitnessUtxoTx = __privateGet(this, _cache).getNonWitnessUtxoTx(input, inputIndex, __privateGet(this, _txFromBuffer));
      const txIn = unsignedTx2.ins[inputIndex];
      const prevoutHash = txIn.hash;
      const utxoHash = nonWitnessUtxoTx.getHash();
      if (!equals(prevoutHash, utxoHash)) {
        throw new Error(`Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`);
      }
      const prevoutIndex = txIn.index;
      prevout = nonWitnessUtxoTx.outs[prevoutIndex];
    } else if (input.witnessUtxo) {
      prevout = {
        script: input.witnessUtxo.script,
        value: input.witnessUtxo.value
      };
    } else {
      throw new Error("Need a Utxo input item for signing");
    }
    const { meaningfulScript, type: type2 } = getMeaningfulScript(prevout.script, inputIndex, "input", input.redeemScript, input.witnessScript);
    const script2 = meaningfulScript;
    if (["p2sh-p2wsh", "p2wsh"].includes(type2)) {
      hash2 = unsignedTx2.hashForWitnessV0(inputIndex, script2, prevout.value, sighashType2);
    } else if (isP2WPKH(meaningfulScript)) {
      const p2pkhPayment = p2pkh({
        hash: meaningfulScript.subarray(2)
      });
      if (!p2pkhPayment.output)
        throw new Error("Unable to create signing script");
      hash2 = unsignedTx2.hashForWitnessV0(inputIndex, p2pkhPayment.output, prevout.value, sighashType2);
    } else {
      if (input.nonWitnessUtxo === void 0 && !__privateGet(this, _cache).unsafeSignNonSegwit)
        throw new Error(`Input #${inputIndex} has witnessUtxo but non-segwit script: ` + toHex$1(meaningfulScript));
      if (!forValidate && __privateGet(this, _cache).unsafeSignNonSegwit)
        console.warn("Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************");
      hash2 = unsignedTx2.hashForSignature(inputIndex, script2, sighashType2);
    }
    return { script: script2, sighashType: sighashType2, hash: hash2 };
  }
  getTaprootHashesForSig(inputIndex, input, inputs2, pubkey, tapLeafHashToSign, allowedSighashTypes) {
    const unsignedTx2 = __privateGet(this, _cache).tx;
    const sighashType2 = input.sighashType || Transaction.SIGHASH_DEFAULT;
    checkSighashTypeAllowed(sighashType2, allowedSighashTypes);
    if (!__privateGet(this, _cache).prevOuts) {
      const prevOuts = inputs2.map((i2, index) => __privateGet(this, _cache).getScriptAndAmountFromUtxo(index, i2, __privateGet(this, _txFromBuffer)));
      __privateGet(this, _cache).prevOuts = prevOuts;
      __privateGet(this, _cache).signingScripts = prevOuts.map((o) => o.script);
      __privateGet(this, _cache).values = prevOuts.map((o) => o.value);
    }
    const signingScripts = __privateGet(this, _cache).signingScripts;
    const values = __privateGet(this, _cache).values;
    if (!__privateGet(this, _cache).taprootHashCache) {
      __privateGet(this, _cache).taprootHashCache = unsignedTx2.getTaprootHashCache(signingScripts, values);
    }
    const taprootCache = __privateGet(this, _cache).taprootHashCache;
    const hashes = [];
    if (input.tapInternalKey && !tapLeafHashToSign) {
      const outputKey = __privateGet(this, _cache).getPrevoutTaprootKey(inputIndex, input, __privateGet(this, _txFromBuffer)) || new Uint8Array(0);
      if (equals(toXOnly(pubkey), outputKey)) {
        const tapKeyHash = unsignedTx2.hashForWitnessV1(inputIndex, signingScripts, values, sighashType2, void 0, void 0, taprootCache);
        hashes.push({ pubkey, hash: tapKeyHash });
      }
    }
    const tapLeafHashes = (input.tapLeafScript || []).filter((tapLeaf) => pubkeyInScript$1(pubkey, tapLeaf.script)).map((tapLeaf) => {
      const hash2 = tapleafHash({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      return Object.assign({ hash: hash2 }, tapLeaf);
    }).filter((tapLeaf) => !tapLeafHashToSign || equals(tapLeafHashToSign, tapLeaf.hash)).map((tapLeaf) => {
      const tapScriptHash = unsignedTx2.hashForWitnessV1(inputIndex, signingScripts, values, sighashType2, tapLeaf.hash, void 0, taprootCache);
      return {
        pubkey,
        hash: tapScriptHash,
        leafHash: tapLeaf.hash
      };
    });
    return hashes.concat(tapLeafHashes);
  }
  getAllTaprootHashesForSig(inputIndex, input, inputs2) {
    const allPublicKeys = [];
    if (input.tapInternalKey) {
      const key = __privateGet(this, _cache).getPrevoutTaprootKey(inputIndex, input, __privateGet(this, _txFromBuffer));
      if (key) {
        allPublicKeys.push(key);
      }
    }
    if (input.tapScriptSig) {
      const tapScriptPubkeys = input.tapScriptSig.map((tss) => tss.pubkey);
      allPublicKeys.push(...tapScriptPubkeys);
    }
    const allHashes = allPublicKeys.map((pubicKey) => this.getTaprootHashesForSig(inputIndex, input, inputs2, pubicKey));
    return allHashes.flat();
  }
  trimTaprootSig(signature2) {
    return signature2.length === 64 ? signature2 : signature2.subarray(0, 64);
  }
  getSignersFromHD(inputIndex, inputs2, hdKeyPair) {
    const input = checkForInput(inputs2, inputIndex);
    if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
      throw new Error("Need bip32Derivation to sign with HD");
    }
    const myDerivations = input.bip32Derivation.map((bipDv) => {
      if (equals(bipDv.masterFingerprint, hdKeyPair.fingerprint)) {
        return bipDv;
      } else {
        return;
      }
    }).filter((v) => !!v);
    if (myDerivations.length === 0) {
      throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");
    }
    return myDerivations.map((bipDv) => {
      const node = hdKeyPair.derivePath(bipDv.path);
      if (!equals(bipDv.pubkey, node.publicKey)) {
        throw new Error("pubkey did not match bip32Derivation");
      }
      return node;
    });
  }
  bip32DerivationIsMine(root) {
    return (d) => {
      const fingerprint = root.fingerprint instanceof Uint8Array ? root.fingerprint : new Uint8Array(root.fingerprint);
      if (!equals(d.masterFingerprint, fingerprint))
        return false;
      const derivedPubkey = root.derivePath(d.path).publicKey;
      const pubkey = derivedPubkey instanceof Uint8Array ? derivedPubkey : new Uint8Array(derivedPubkey);
      if (!equals(pubkey, d.pubkey))
        return false;
      return true;
    };
  }
};
_cache = new WeakMap();
_txFromBuffer = new WeakMap();
function checkSighashTypeAllowed(sighashType2, sighashTypes) {
  if (sighashTypes && !sighashTypes.includes(sighashType2)) {
    const str = sighashTypeToString(sighashType2);
    throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${str}`);
  }
}
var _cache2, _txFromBuffer2;
var PsbtFinalizer = class {
  constructor(cache, txFromBuffer2) {
    __privateAdd(this, _cache2);
    __privateAdd(this, _txFromBuffer2);
    __privateSet(this, _cache2, cache);
    __privateSet(this, _txFromBuffer2, txFromBuffer2);
  }
  getFinalScripts(inputIndex, input, script2, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
    const scriptType = classifyScript(script2);
    if (!canFinalize(input, script2, scriptType) && canRunChecks) {
      throw new Error(`Can not finalize input #${inputIndex}`);
    }
    if (!input.partialSig)
      throw new Error("Input missing partial signatures");
    return prepareFinalScripts(script2, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH, solution);
  }
  getScriptFromInput(inputIndex, input) {
    return __privateGet(this, _cache2).getScriptFromInput(inputIndex, input, __privateGet(this, _txFromBuffer2));
  }
};
_cache2 = new WeakMap();
_txFromBuffer2 = new WeakMap();
function getFinalScripts$1(inputIndex, input, script2, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
  const scriptType = classifyScript(script2);
  if (!canFinalize(input, script2, scriptType) && canRunChecks) {
    throw new Error(`Can not finalize input #${inputIndex}`);
  }
  if (!input.partialSig)
    throw new Error("Input missing partial signatures");
  return prepareFinalScripts(script2, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH, solution);
}
function prepareFinalScripts(script2, scriptType, partialSig2, isSegwit, isP2SH, isP2WSH, solution) {
  let finalScriptSig2;
  let finalScriptWitness2;
  const payment = getPayment(script2, scriptType, partialSig2);
  const p2wsh$1 = !isP2WSH ? null : p2wsh({ redeem: payment });
  const p2sh$1 = !isP2SH ? null : p2sh({ redeem: p2wsh$1 || payment });
  if (isSegwit) {
    if (p2wsh$1 && p2wsh$1.witness) {
      finalScriptWitness2 = witnessStackToScriptWitness$1(p2wsh$1.witness);
    } else if (payment && payment.witness) {
      finalScriptWitness2 = witnessStackToScriptWitness$1(payment.witness);
    } else {
      finalScriptWitness2 = witnessStackToScriptWitness$1(solution ?? [new Uint8Array([0])]);
    }
    if (p2sh$1) {
      finalScriptSig2 = p2sh$1 == null ? void 0 : p2sh$1.input;
    }
  } else {
    if (p2sh$1) {
      finalScriptSig2 = p2sh$1 == null ? void 0 : p2sh$1.input;
    } else {
      if (!payment) {
        finalScriptSig2 = Array.isArray(solution) && solution[0] ? solution[0] : new Uint8Array([1]);
      } else {
        finalScriptSig2 = payment.input;
      }
    }
  }
  return { finalScriptSig: finalScriptSig2, finalScriptWitness: finalScriptWitness2 };
}
function canFinalize(input, script2, scriptType) {
  switch (scriptType) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, input.partialSig);
    case "multisig": {
      const p2ms$1 = p2ms({
        output: script2
      });
      if (p2ms$1.m === void 0)
        throw new Error("Cannot determine m for multisig");
      return hasSigs(p2ms$1.m, input.partialSig, p2ms$1.pubkeys);
    }
    case "nonstandard":
      return true;
    default:
      return false;
  }
}
function hasSigs(neededSigs, partialSig2, pubkeys) {
  if (!partialSig2)
    return false;
  let sigs;
  if (pubkeys) {
    sigs = pubkeys.map((pkey) => {
      const pubkey = compressPubkey(pkey);
      return partialSig2.find((pSig) => equals(pSig.pubkey, pubkey));
    }).filter((v) => !!v);
  } else {
    sigs = partialSig2;
  }
  if (sigs.length > neededSigs)
    throw new Error("Too many signatures");
  return sigs.length === neededSigs;
}
function getPayment(script2, scriptType, partialSig2) {
  const scriptBranded = script2;
  switch (scriptType) {
    case "multisig": {
      const sigs = getSortedSigs(script2, partialSig2);
      return p2ms({
        output: scriptBranded,
        signatures: sigs
      });
    }
    case "pubkey": {
      const sig0 = partialSig2[0];
      return p2pk({
        output: scriptBranded,
        signature: sig0.signature
      });
    }
    case "pubkeyhash": {
      const sig0 = partialSig2[0];
      return p2pkh({
        output: scriptBranded,
        pubkey: sig0.pubkey,
        signature: sig0.signature
      });
    }
    case "witnesspubkeyhash": {
      const sig0 = partialSig2[0];
      return p2wpkh({
        output: scriptBranded,
        pubkey: sig0.pubkey,
        signature: sig0.signature
      });
    }
    default:
      throw new Error(`Unknown script type: ${scriptType}`);
  }
}
function getSortedSigs(script2, partialSig2) {
  const p2ms$1 = p2ms({ output: script2 });
  if (!p2ms$1.pubkeys)
    throw new Error("Cannot extract pubkeys from multisig script");
  const result = [];
  for (const pk of p2ms$1.pubkeys) {
    const matched = partialSig2.filter((ps) => {
      return equals(ps.pubkey, pk);
    })[0];
    if (matched) {
      result.push(new Uint8Array(matched.signature));
    }
  }
  return result;
}
var EMPTY_TX_V2 = new Uint8Array([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
var PsbtTransaction = class {
  constructor(buffer2 = EMPTY_TX_V2) {
    __publicField(this, "tx");
    this.tx = Transaction.fromBuffer(buffer2);
    checkTxEmpty(this.tx);
    Object.defineProperty(this, "tx", {
      enumerable: false,
      writable: true
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(input) {
    if (input.hash === void 0 || input.index === void 0 || !(input.hash instanceof Uint8Array) && typeof input.hash !== "string" || typeof input.index !== "number") {
      throw new Error("Error adding input.");
    }
    const hash2 = typeof input.hash === "string" ? reverse(fromHex$1(input.hash)) : input.hash;
    this.tx.addInput(hash2, input.index, input.sequence);
  }
  addOutput(output) {
    if (output.script === void 0 || output.value === void 0 || !(output.script instanceof Uint8Array) || typeof output.value !== "bigint") {
      throw new Error("Error adding output.");
    }
    this.tx.addOutput(output.script, output.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
};
var transactionFromBuffer = (buffer2) => new PsbtTransaction(buffer2);
var DEFAULT_OPTS = {
  network: bitcoin$1,
  maximumFeeRate: 5e3
};
function txFromBuffer(buf) {
  return Transaction.fromBuffer(buf);
}
function getFinalScripts(inputIndex, input, script2, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
  return getFinalScripts$1(inputIndex, input, script2, isSegwit, isP2SH, isP2WSH, canRunChecks, solution);
}
var _cache3, _signer, _finalizer, _opts11, _Psbt_instances, lazySigner_get, lazyFinalizer_get, finalizeInput_fn, finalizeTaprootInput_fn, validateSignaturesOfInput_fn, validateSignaturesOfTaprootInput_fn, signInput_fn, signTaprootInput_fn, signInputAsync_fn, signTaprootInputAsync_fn;
var _Psbt = class _Psbt {
  constructor(opts = {}, data = new Psbt$1(new PsbtTransaction())) {
    __privateAdd(this, _Psbt_instances);
    __publicField(this, "data");
    __privateAdd(this, _cache3);
    __privateAdd(this, _signer);
    __privateAdd(this, _finalizer);
    __privateAdd(this, _opts11);
    this.data = data;
    __privateSet(this, _opts11, Object.assign({}, DEFAULT_OPTS, opts));
    const tx = this.data.globalMap.unsignedTx.tx;
    __privateSet(this, _cache3, new PsbtCache(tx));
    if (opts.version === 3) {
      this.setVersionTRUC();
    } else if (this.data.inputs.length === 0)
      this.setVersion(2);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return __privateGet(this, _cache3).tx.version;
  }
  set version(version2) {
    this.setVersion(version2);
  }
  get locktime() {
    return __privateGet(this, _cache3).tx.locktime;
  }
  set locktime(locktime) {
    this.setLocktime(locktime);
  }
  get txInputs() {
    return __privateGet(this, _cache3).tx.ins.map((input) => ({
      hash: clone$1(input.hash),
      index: input.index,
      sequence: input.sequence
    }));
  }
  get txOutputs() {
    return __privateGet(this, _cache3).tx.outs.map((output) => {
      let address;
      try {
        address = fromOutputScript(output.script, __privateGet(this, _opts11).network);
      } catch (_2) {
      }
      return {
        script: clone$1(output.script),
        value: output.value,
        address
      };
    });
  }
  static fromBase64(data, opts = {}) {
    const buffer2 = fromBase64$1(data);
    return this.fromBuffer(buffer2, opts);
  }
  static fromHex(data, opts = {}) {
    const buffer2 = fromHex$1(data);
    return this.fromBuffer(buffer2, opts);
  }
  static fromBuffer(buffer2, opts = {}) {
    const psbtBase = Psbt$1.fromBuffer(buffer2, transactionFromBuffer);
    const psbt = new _Psbt(opts, psbtBase);
    checkTxForDupeIns(__privateGet(psbt, _cache3).tx, __privateGet(psbt, _cache3));
    __privateGet(psbt, _cache3).hasSignatures = psbt.data.inputs.some((input) => {
      var _a5, _b2;
      return ((_a5 = input.partialSig) == null ? void 0 : _a5.length) || input.tapKeySig || ((_b2 = input.tapScriptSig) == null ? void 0 : _b2.length) || input.finalScriptSig || input.finalScriptWitness;
    });
    return psbt;
  }
  combine(...those) {
    this.data.combine(...those.map((o) => o.data));
    return this;
  }
  clone() {
    const clonedOpts = structuredClone(__privateGet(this, _opts11));
    return _Psbt.fromBuffer(new Uint8Array(this.data.toBuffer()), clonedOpts);
  }
  get maximumFeeRate() {
    return __privateGet(this, _opts11).maximumFeeRate;
  }
  setMaximumFeeRate(satoshiPerByte) {
    check32Bit(satoshiPerByte);
    __privateGet(this, _opts11).maximumFeeRate = satoshiPerByte;
  }
  setVersion(version2) {
    check32Bit(version2);
    checkInputsForPartialSig(this.data.inputs, "setVersion", __privateGet(this, _cache3).hasSignatures);
    __privateGet(this, _cache3).tx.version = version2;
    __privateGet(this, _cache3).invalidate("outputs");
    return this;
  }
  setVersionTRUC() {
    return this.setVersion(Transaction.TRUC_VERSION);
  }
  setLocktime(locktime) {
    check32Bit(locktime);
    checkInputsForPartialSig(this.data.inputs, "setLocktime", __privateGet(this, _cache3).hasSignatures);
    __privateGet(this, _cache3).tx.locktime = locktime;
    __privateGet(this, _cache3).invalidate("outputs");
    return this;
  }
  setInputSequence(inputIndex, sequence) {
    check32Bit(sequence);
    checkInputsForPartialSig(this.data.inputs, "setInputSequence", __privateGet(this, _cache3).hasSignatures);
    if (__privateGet(this, _cache3).tx.ins.length <= inputIndex) {
      throw new Error("Input index too high");
    }
    __privateGet(this, _cache3).tx.ins[inputIndex].sequence = sequence;
    __privateGet(this, _cache3).invalidate("outputs");
    return this;
  }
  addInputs(inputDatas, checkPartialSigs = true) {
    inputDatas.forEach((inputData) => this.addInput(inputData, checkPartialSigs));
    return this;
  }
  addInput(inputData, checkPartialSigs = true) {
    if (!inputData || inputData.hash === void 0 || inputData.index === void 0) {
      throw new Error(`Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`);
    }
    checkTaprootInputFields(inputData, inputData, "addInput");
    if (checkPartialSigs) {
      checkInputsForPartialSig(this.data.inputs, "addInput", __privateGet(this, _cache3).hasSignatures);
    }
    if (inputData.witnessScript)
      checkInvalidP2WSH(inputData.witnessScript);
    const normalizedInputData = inputData.witnessUtxo ? {
      ...inputData,
      witnessUtxo: {
        script: inputData.witnessUtxo.script,
        value: typeof inputData.witnessUtxo.value === "bigint" ? inputData.witnessUtxo.value : BigInt(inputData.witnessUtxo.value)
      }
    } : inputData;
    this.data.addInput(normalizedInputData);
    const txIn = __privateGet(this, _cache3).tx.ins[__privateGet(this, _cache3).tx.ins.length - 1];
    checkTxInputCache(__privateGet(this, _cache3), txIn);
    const inputIndex = this.data.inputs.length - 1;
    const input = this.data.inputs[inputIndex];
    if (input.nonWitnessUtxo) {
      __privateGet(this, _cache3).addNonWitnessTxCache(input, inputIndex, txFromBuffer);
    }
    __privateGet(this, _cache3).invalidate("full");
    return this;
  }
  addOutputs(outputDatas, checkPartialSigs = true) {
    outputDatas.forEach((outputData) => this.addOutput(outputData, checkPartialSigs));
    return this;
  }
  addOutput(outputData, checkPartialSigs = true) {
    const hasAddress = "address" in outputData;
    const hasScript = "script" in outputData;
    if (!outputData || outputData.value === void 0 || !hasAddress && !hasScript) {
      throw new Error(`Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`);
    }
    if (checkPartialSigs) {
      checkInputsForPartialSig(this.data.inputs, "addOutput", __privateGet(this, _cache3).hasSignatures);
    }
    if (hasAddress) {
      const { address } = outputData;
      const { network } = __privateGet(this, _opts11);
      const script2 = toOutputScript(address, network);
      outputData = Object.assign({}, outputData, { script: script2 });
    }
    checkTaprootOutputFields(outputData, outputData, "addOutput");
    this.data.addOutput(outputData);
    __privateGet(this, _cache3).invalidate("outputs");
    return this;
  }
  extractTransaction(disableFeeCheck, disableOutputChecks) {
    if (disableOutputChecks) {
      this.data.inputs = this.data.inputs.filter((i2) => !i2.partialSig);
    }
    if (!this.data.inputs.every(isFinalized))
      throw new Error("Not finalized");
    if (!disableFeeCheck) {
      __privateGet(this, _cache3).computeFeeRate(this.data.inputs, disableOutputChecks, txFromBuffer);
      __privateGet(this, _cache3).checkFees(__privateGet(this, _opts11));
    }
    if (__privateGet(this, _cache3).extractedTx)
      return __privateGet(this, _cache3).extractedTx;
    const tx = __privateGet(this, _cache3).tx.clone();
    __privateGet(this, _cache3).finalizeAndComputeAmounts(this.data.inputs, tx, true, disableOutputChecks, txFromBuffer);
    return tx;
  }
  getFeeRate(disableOutputChecks = false) {
    return __privateGet(this, _cache3).computeFeeRate(this.data.inputs, disableOutputChecks, txFromBuffer);
  }
  getFee(disableOutputChecks = false) {
    return __privateGet(this, _cache3).computeFee(this.data.inputs, disableOutputChecks, txFromBuffer);
  }
  finalizeAllInputs() {
    checkForInput(this.data.inputs, 0);
    range$1(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
    return this;
  }
  finalizeInput(inputIndex, finalScriptsFunc, canRunChecks) {
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return __privateMethod(this, _Psbt_instances, finalizeTaprootInput_fn).call(this, inputIndex, input, void 0, finalScriptsFunc);
    }
    return __privateMethod(this, _Psbt_instances, finalizeInput_fn).call(this, inputIndex, input, finalScriptsFunc, canRunChecks ?? true);
  }
  finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = tapScriptFinalizer) {
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input))
      return __privateMethod(this, _Psbt_instances, finalizeTaprootInput_fn).call(this, inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc);
    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
  }
  getInputType(inputIndex) {
    const input = checkForInput(this.data.inputs, inputIndex);
    const script2 = __privateGet(this, _cache3).getScriptFromUtxo(inputIndex, input, txFromBuffer);
    const result = getMeaningfulScript(script2, inputIndex, "input", input.redeemScript || __privateGet(this, _cache3).redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript || __privateGet(this, _cache3).redeemFromFinalWitnessScript(input.finalScriptWitness));
    const type2 = result.type === "raw" ? "" : result.type + "-";
    const mainType = classifyScript(result.meaningfulScript);
    return type2 + mainType;
  }
  inputHasPubkey(inputIndex, pubkey) {
    const input = checkForInput(this.data.inputs, inputIndex);
    return __privateGet(this, _cache3).pubkeyInInput(pubkey, input, inputIndex, txFromBuffer);
  }
  inputHasHDKey(inputIndex, root) {
    const input = checkForInput(this.data.inputs, inputIndex);
    const derivationIsMine = __privateGet(this, _Psbt_instances, lazySigner_get).bip32DerivationIsMine(root);
    return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
  }
  outputHasPubkey(outputIndex, pubkey) {
    const output = checkForOutput(this.data.outputs, outputIndex);
    return __privateGet(this, _cache3).pubkeyInOutput(pubkey, output, outputIndex);
  }
  outputHasHDKey(outputIndex, root) {
    const output = checkForOutput(this.data.outputs, outputIndex);
    const derivationIsMine = __privateGet(this, _Psbt_instances, lazySigner_get).bip32DerivationIsMine(root);
    return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
  }
  validateSignaturesOfAllInputs(validator) {
    checkForInput(this.data.inputs, 0);
    const results = range$1(this.data.inputs.length).map((idx) => this.validateSignaturesOfInput(idx, validator));
    return results.every((res) => res);
  }
  validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    if (isTaprootInput$1(input))
      return __privateMethod(this, _Psbt_instances, validateSignaturesOfTaprootInput_fn).call(this, inputIndex, validator, pubkey);
    return __privateMethod(this, _Psbt_instances, validateSignaturesOfInput_fn).call(this, inputIndex, validator, pubkey);
  }
  signAllInputsHD(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const results = [];
    for (const i2 of range$1(this.data.inputs.length)) {
      try {
        this.signInputHD(i2, hdKeyPair, sighashTypes);
        results.push(true);
      } catch (err2) {
        results.push(false);
      }
    }
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
    return this;
  }
  async signAllInputsHDAsync(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const results = [];
    const promises = [];
    for (const i2 of range$1(this.data.inputs.length)) {
      promises.push(this.signInputHDAsync(i2, hdKeyPair, sighashTypes).then(() => {
        results.push(true);
      }, () => {
        results.push(false);
      }));
    }
    await Promise.all(promises);
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
  }
  signInputHD(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const signers = __privateGet(this, _Psbt_instances, lazySigner_get).getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
    return this;
  }
  async signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const signers = __privateGet(this, _Psbt_instances, lazySigner_get).getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    const promises = signers.map((signer) => this.signInputAsync(inputIndex, signer, sighashTypes));
    await Promise.all(promises);
  }
  signAllInputs(keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const results = [];
    for (const i2 of range$1(this.data.inputs.length)) {
      try {
        this.signInput(i2, keyPair, sighashTypes);
        results.push(true);
      } catch (err2) {
        results.push(false);
      }
    }
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
    return this;
  }
  async signAllInputsAsync(keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const results = [];
    const promises = [];
    for (const [i2] of this.data.inputs.entries()) {
      promises.push(this.signInputAsync(i2, keyPair, sighashTypes).then(() => {
        results.push(true);
      }, () => {
        results.push(false);
      }));
    }
    await Promise.all(promises);
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
  }
  signInput(inputIndex, keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey) {
      throw new Error("Need Signer to sign input");
    }
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return __privateMethod(this, _Psbt_instances, signTaprootInput_fn).call(this, inputIndex, input, keyPair, void 0, sighashTypes);
    }
    return __privateMethod(this, _Psbt_instances, signInput_fn).call(this, inputIndex, keyPair, sighashTypes);
  }
  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
    if (!keyPair || !keyPair.publicKey) {
      throw new Error("Need Signer to sign input");
    }
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return __privateMethod(this, _Psbt_instances, signTaprootInput_fn).call(this, inputIndex, input, keyPair, tapLeafHashToSign, sighashTypes);
    }
    throw new Error(`Input #${inputIndex} is not of type Taproot.`);
  }
  async signInputAsync(inputIndex, keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input))
      return __privateMethod(this, _Psbt_instances, signTaprootInputAsync_fn).call(this, inputIndex, input, keyPair, void 0, sighashTypes);
    return __privateMethod(this, _Psbt_instances, signInputAsync_fn).call(this, inputIndex, keyPair, sighashTypes);
  }
  async signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input))
      return __privateMethod(this, _Psbt_instances, signTaprootInputAsync_fn).call(this, inputIndex, input, keyPair, tapLeafHash, sighashTypes);
    throw new Error(`Input #${inputIndex} is not of type Taproot.`);
  }
  toBuffer() {
    checkCache(__privateGet(this, _cache3));
    return new Uint8Array(this.data.toBuffer());
  }
  toHex() {
    checkCache(__privateGet(this, _cache3));
    return this.data.toHex();
  }
  toBase64() {
    checkCache(__privateGet(this, _cache3));
    return this.data.toBase64();
  }
  updateGlobal(updateData) {
    this.data.updateGlobal(updateData);
    return this;
  }
  updateInput(inputIndex, updateData) {
    if (updateData.witnessScript)
      checkInvalidP2WSH(updateData.witnessScript);
    checkTaprootInputFields(this.data.inputs[inputIndex], updateData, "updateInput");
    const normalizedUpdate = updateData.witnessUtxo ? {
      ...updateData,
      witnessUtxo: {
        script: updateData.witnessUtxo.script,
        value: typeof updateData.witnessUtxo.value === "bigint" ? updateData.witnessUtxo.value : BigInt(updateData.witnessUtxo.value)
      }
    } : updateData;
    this.data.updateInput(inputIndex, normalizedUpdate);
    if (updateData.nonWitnessUtxo) {
      __privateGet(this, _cache3).addNonWitnessTxCache(this.data.inputs[inputIndex], inputIndex, txFromBuffer);
    }
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const outputData = this.data.outputs[outputIndex];
    checkTaprootOutputFields(outputData, updateData, "updateOutput");
    this.data.updateOutput(outputIndex, updateData);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    this.data.addUnknownKeyValToGlobal(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    this.data.addUnknownKeyValToInput(inputIndex, keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
    if (!("signSchnorr" in keyPair) || typeof keyPair.signSchnorr !== "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
    const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
    const hashesForSig = __privateGet(this, _Psbt_instances, lazySigner_get).getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, tapLeafHashToSign, allowedSighashTypes);
    if (!hashesForSig || !hashesForSig.length)
      throw new Error(`Can not sign for input #${inputIndex} with the key ${toHex$1(pubkey)}`);
    return hashesForSig;
  }
};
_cache3 = new WeakMap();
_signer = new WeakMap();
_finalizer = new WeakMap();
_opts11 = new WeakMap();
_Psbt_instances = new WeakSet();
lazySigner_get = function() {
  if (!__privateGet(this, _signer)) {
    __privateSet(this, _signer, new PsbtSigner(__privateGet(this, _cache3), txFromBuffer));
  }
  return __privateGet(this, _signer);
};
lazyFinalizer_get = function() {
  if (!__privateGet(this, _finalizer)) {
    __privateSet(this, _finalizer, new PsbtFinalizer(__privateGet(this, _cache3), txFromBuffer));
  }
  return __privateGet(this, _finalizer);
};
finalizeInput_fn = function(inputIndex, input, finalScriptsFunc = getFinalScripts, canRunChecks = true) {
  const { script: script2, isP2SH, isP2WSH, isSegwit } = __privateGet(this, _Psbt_instances, lazyFinalizer_get).getScriptFromInput(inputIndex, input);
  if (!script2)
    throw new Error(`No script found for input #${inputIndex}`);
  checkPartialSigSighashes(input);
  const { finalScriptSig: finalScriptSig2, finalScriptWitness: finalScriptWitness2 } = finalScriptsFunc(inputIndex, input, script2, isSegwit, isP2SH, isP2WSH, canRunChecks);
  if (finalScriptSig2)
    this.data.updateInput(inputIndex, { finalScriptSig: finalScriptSig2 });
  if (finalScriptWitness2)
    this.data.updateInput(inputIndex, { finalScriptWitness: finalScriptWitness2 });
  if (!finalScriptSig2 && !finalScriptWitness2)
    throw new Error(`Unknown error finalizing input #${inputIndex}`);
  this.data.clearFinalizedInput(inputIndex);
  return this;
};
finalizeTaprootInput_fn = function(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = tapScriptFinalizer) {
  if (!input.witnessUtxo)
    throw new Error(`Cannot finalize input #${inputIndex}. Missing witness utxo.`);
  if (input.tapKeySig && !isP2MRInput(input)) {
    const payment = p2tr({
      output: input.witnessUtxo.script,
      signature: input.tapKeySig
    });
    if (!payment.witness)
      throw new Error("Cannot finalize taproot key spend");
    const finalScriptWitness2 = witnessStackToScriptWitness$1(payment.witness);
    this.data.updateInput(inputIndex, { finalScriptWitness: finalScriptWitness2 });
  } else {
    const { finalScriptWitness: finalScriptWitness2 } = finalScriptsFunc(inputIndex, input, tapLeafHashToFinalize);
    this.data.updateInput(inputIndex, { finalScriptWitness: finalScriptWitness2 });
  }
  this.data.clearFinalizedInput(inputIndex);
  return this;
};
validateSignaturesOfInput_fn = function(inputIndex, validator, pubkey) {
  const input = this.data.inputs[inputIndex];
  const partialSig2 = input == null ? void 0 : input.partialSig;
  if (!input || !partialSig2 || partialSig2.length < 1)
    throw new Error("No signatures to validate");
  if (typeof validator !== "function")
    throw new Error("Need validator function to validate signatures");
  const mySigs = pubkey ? partialSig2.filter((sig) => equals(sig.pubkey, pubkey)) : partialSig2;
  if (mySigs.length < 1)
    throw new Error("No signatures for this pubkey");
  const results = [];
  let hashCache;
  let scriptCache;
  let sighashCache;
  for (const pSig of mySigs) {
    const pSigSignature = pSig.signature;
    const pSigPubkey = pSig.pubkey;
    const sig = signature.decode(pSigSignature);
    const { hash: hash2, script: script$1 } = sighashCache !== sig.hashType || !hashCache || !scriptCache ? __privateGet(this, _Psbt_instances, lazySigner_get).getHashForSig(inputIndex, Object.assign({}, input, {
      sighashType: sig.hashType
    }), true) : { hash: hashCache, script: scriptCache };
    sighashCache = sig.hashType;
    hashCache = hash2;
    scriptCache = script$1;
    checkScriptForPubkey(pSigPubkey, script$1, "verify");
    results.push(validator(pSigPubkey, hash2, sig.signature));
  }
  return results.every((res) => res);
};
validateSignaturesOfTaprootInput_fn = function(inputIndex, validator, pubkey) {
  const input = this.data.inputs[inputIndex];
  const tapKeySig2 = input == null ? void 0 : input.tapKeySig;
  const tapScriptSig2 = input == null ? void 0 : input.tapScriptSig;
  if (!input && !tapKeySig2 && !(tapScriptSig2 && !tapScriptSig2.length))
    throw new Error("No signatures to validate");
  if (typeof validator !== "function")
    throw new Error("Need validator function to validate signatures");
  const xPubkey = pubkey ? toXOnly(pubkey) : void 0;
  const allHashses = xPubkey ? __privateGet(this, _Psbt_instances, lazySigner_get).getTaprootHashesForSig(inputIndex, input, this.data.inputs, xPubkey) : __privateGet(this, _Psbt_instances, lazySigner_get).getAllTaprootHashesForSig(inputIndex, input, this.data.inputs);
  if (!allHashses.length)
    throw new Error("No signatures for this pubkey");
  const tapKeyHash = allHashses.find((h) => !h.leafHash);
  let validationResultCount = 0;
  if (tapKeySig2 && tapKeyHash) {
    const isValidTapkeySig = validator(tapKeyHash.pubkey, tapKeyHash.hash, __privateGet(this, _Psbt_instances, lazySigner_get).trimTaprootSig(tapKeySig2));
    if (!isValidTapkeySig)
      return false;
    validationResultCount++;
  }
  if (tapScriptSig2) {
    for (const tapSig of tapScriptSig2) {
      const tapSigPubkey = tapSig.pubkey;
      const tapSigHash = allHashses.find((h) => equals(tapSigPubkey, h.pubkey));
      if (tapSigHash) {
        const isValidTapScriptSig = validator(tapSigPubkey, tapSigHash.hash, __privateGet(this, _Psbt_instances, lazySigner_get).trimTaprootSig(tapSig.signature));
        if (!isValidTapScriptSig)
          return false;
        validationResultCount++;
      }
    }
  }
  return validationResultCount > 0;
};
signInput_fn = function(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
  const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
  const { hash: hash2, sighashType: sighashType2 } = __privateGet(this, _Psbt_instances, lazySigner_get).getHashAndSighashType(this.data.inputs, inputIndex, pubkey, sighashTypes);
  const sig = keyPair.sign(hash2);
  const partialSig2 = [
    {
      pubkey,
      signature: signature.encode(sig instanceof Uint8Array ? sig : new Uint8Array(sig), sighashType2)
    }
  ];
  this.data.updateInput(inputIndex, { partialSig: partialSig2 });
  __privateGet(this, _cache3).hasSignatures = true;
  return this;
};
signTaprootInput_fn = function(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [Transaction.SIGHASH_DEFAULT]) {
  const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
  if (!("signSchnorr" in keyPair) || typeof keyPair.signSchnorr !== "function")
    throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
  const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes);
  const signSchnorr = keyPair.signSchnorr.bind(keyPair);
  const tapKeySig2 = hashesForSig.filter((h) => !h.leafHash).map((h) => serializeTaprootSignature(signSchnorr(h.hash), input.sighashType))[0];
  const tapScriptSig2 = hashesForSig.filter((h) => !!h.leafHash).map((h) => ({
    pubkey: toXOnly(pubkey),
    signature: serializeTaprootSignature(signSchnorr(h.hash), input.sighashType),
    leafHash: h.leafHash
  }));
  if (tapKeySig2) {
    this.data.updateInput(inputIndex, { tapKeySig: tapKeySig2 });
    __privateGet(this, _cache3).hasSignatures = true;
  }
  if (tapScriptSig2.length) {
    this.data.updateInput(inputIndex, { tapScriptSig: tapScriptSig2 });
    __privateGet(this, _cache3).hasSignatures = true;
  }
  return this;
};
signInputAsync_fn = async function(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
  const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
  const { hash: hash2, sighashType: sighashType2 } = __privateGet(this, _Psbt_instances, lazySigner_get).getHashAndSighashType(this.data.inputs, inputIndex, pubkey, sighashTypes);
  const signature$1 = await keyPair.sign(hash2);
  const sig = signature$1 instanceof Uint8Array ? signature$1 : new Uint8Array(signature$1);
  const partialSig2 = [
    {
      pubkey,
      signature: signature.encode(sig, sighashType2)
    }
  ];
  this.data.updateInput(inputIndex, { partialSig: partialSig2 });
  __privateGet(this, _cache3).hasSignatures = true;
};
signTaprootInputAsync_fn = async function(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [Transaction.SIGHASH_DEFAULT]) {
  const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
  if (!("signSchnorr" in keyPair) || typeof keyPair.signSchnorr !== "function")
    throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
  const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
  const signSchnorr = keyPair.signSchnorr.bind(keyPair);
  const tapKeyHash = hashesForSig.find((h) => !h.leafHash);
  if (tapKeyHash) {
    const sig = await signSchnorr(tapKeyHash.hash);
    const tapKeySig2 = serializeTaprootSignature(sig, input.sighashType);
    this.data.updateInput(inputIndex, { tapKeySig: tapKeySig2 });
    __privateGet(this, _cache3).hasSignatures = true;
  }
  const tapScriptHashes = hashesForSig.filter((h) => !!h.leafHash);
  if (tapScriptHashes.length) {
    const tapScriptSigs = await Promise.all(tapScriptHashes.map(async (tsh) => {
      const signature2 = await signSchnorr(tsh.hash);
      return {
        pubkey: toXOnly(pubkey),
        signature: serializeTaprootSignature(signature2, input.sighashType),
        leafHash: tsh.leafHash
      };
    }));
    this.data.updateInput(inputIndex, { tapScriptSig: tapScriptSigs });
    __privateGet(this, _cache3).hasSignatures = true;
  }
};
var Psbt2 = _Psbt;
var SignatureType$1 = {
  /** ECDSA signature (secp256k1) */
  ECDSA: 0,
  /** Schnorr signature (BIP340) */
  Schnorr: 1
};
function isBatchResult(response) {
  return response.type === "batchResult";
}
function isWorkerReady(response) {
  return response.type === "ready";
}
var WorkerState = {
  /** Worker is initializing */
  Initializing: 0,
  /** Worker is ready and idle */
  Idle: 1,
  /** Worker is processing a task */
  Busy: 2,
  /** Worker is shutting down */
  ShuttingDown: 3,
  /** Worker has terminated */
  Terminated: 4
};
var ECC_BUNDLE = '"use strict";var nobleBundle=(()=>{var rt=Object.defineProperty;var _e=Object.getOwnPropertyDescriptor;var Ce=Object.getOwnPropertyNames;var ke=Object.prototype.hasOwnProperty;var Ve=(e,t,n)=>t in e?rt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Ct=(e,t)=>{for(var n in t)rt(e,n,{get:t[n],enumerable:!0})},Te=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of Ce(t))!ke.call(e,r)&&r!==n&&rt(e,r,{get:()=>t[r],enumerable:!(s=_e(t,r))||s.enumerable});return e};var Ge=e=>Te(rt({},"__esModule",{value:!0}),e);var l=(e,t,n)=>Ve(e,typeof t!="symbol"?t+"":t,n);var yn={};Ct(yn,{hmac:()=>lt,secp:()=>Lt,sha256:()=>ht});var Lt={};Ct(Lt,{Point:()=>U,Signature:()=>R,etc:()=>sn,getPublicKey:()=>Pt,getSharedSecret:()=>en,hash:()=>je,hashes:()=>K,keygen:()=>nn,recoverPublicKey:()=>Qe,recoverPublicKeyAsync:()=>tn,schnorr:()=>un,sign:()=>We,signAsync:()=>ze,utils:()=>rn,verify:()=>qe,verifyAsync:()=>Je});var Nt={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:D,n:v,Gx:Fe,Gy:De,b:Zt}=Nt,w=32,Z=64,et={publicKey:w+1,publicKeyUncompressed:Z+1,signature:Z,seed:w+w/2},Ke=(...e)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...e)},b=(e="")=>{let t=new Error(e);throw Ke(t,b),t},Oe=e=>typeof e=="bigint",Ne=e=>typeof e=="string",Ze=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",A=(e,t,n="")=>{let s=Ze(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;b(c+"expected Uint8Array"+i+", got "+u)}return e},k=e=>new Uint8Array(e),jt=(e,t)=>e.toString(16).padStart(t,"0"),wt=e=>Array.from(A(e)).map(t=>jt(t,2)).join(""),V={_0:48,_9:57,A:65,F:70,a:97,f:102},kt=e=>{if(e>=V._0&&e<=V._9)return e-V._0;if(e>=V.A&&e<=V.F)return e-(V.A-10);if(e>=V.a&&e<=V.f)return e-(V.a-10)},mt=e=>{let t="hex invalid";if(!Ne(e))return b(t);let n=e.length,s=n/2;if(n%2)return b(t);let r=k(s);for(let o=0,c=0;o<s;o++,c+=2){let i=kt(e.charCodeAt(c)),u=kt(e.charCodeAt(c+1));if(i===void 0||u===void 0)return b(t);r[o]=i*16+u}return r},Rt=()=>globalThis?.crypto,Vt=()=>Rt()?.subtle??b("crypto.subtle must be defined, consider polyfill"),L=(...e)=>{let t=k(e.reduce((s,r)=>s+A(r).length,0)),n=0;return e.forEach(s=>{t.set(s,n),n+=s.length}),t},nt=(e=w)=>Rt().getRandomValues(k(e)),Y=BigInt,j=(e,t,n,s="bad number: out of range")=>Oe(e)&&t<=e&&e<n?e:b(s),a=(e,t=D)=>{let n=e%t;return n>=0n?n:t+n},E=e=>a(e,v),st=(e,t)=>{(e===0n||t<=0n)&&b("no inverse n="+e+" mod="+t);let n=a(e,t),s=t,r=0n,o=1n,c=1n,i=0n;for(;n!==0n;){let u=s/n,d=s%n,f=r-c*u,h=o-i*u;s=n,n=d,r=c,o=i,c=f,i=h}return s===1n?a(r,t):b("no inverse")},it=e=>{let t=K[e];return typeof t!="function"&&b("hashes."+e+" not set"),t},je=e=>it("sha256")(e),xt=e=>e instanceof U?e:b("Point expected"),Xt=e=>a(a(e*e)*e+Zt),Tt=e=>j(e,0n,D),tt=e=>j(e,1n,D),bt=e=>j(e,1n,v),M=e=>(e&1n)===0n,ft=e=>Uint8Array.of(e),Yt=e=>ft(M(e)?2:3),Mt=e=>{let t=Xt(tt(e)),n=1n;for(let s=t,r=(D+1n)/4n;r>0n;r>>=1n)r&1n&&(n=n*s%D),s=s*s%D;return a(n*n)===t?n:b("sqrt invalid")},C=class C{constructor(t,n,s){l(this,"X");l(this,"Y");l(this,"Z");this.X=Tt(t),this.Y=tt(n),this.Z=Tt(s),Object.freeze(this)}static CURVE(){return Nt}static fromAffine(t){let{x:n,y:s}=t;return n===0n&&s===0n?N:new C(n,s,1n)}static fromBytes(t){A(t);let{publicKey:n,publicKeyUncompressed:s}=et,r,o=t.length,c=t[0],i=t.subarray(1),u=P(i,0,w);if(o===n&&(c===2||c===3)){let d=Mt(u),f=M(d);M(Y(c))!==f&&(d=a(-d)),r=new C(u,d,1n)}return o===s&&c===4&&(r=new C(u,P(i,w,Z),1n)),r?r.assertValidity():b("bad point: not on curve")}static fromHex(t){return C.fromBytes(mt(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=a(n*i),d=a(o*r),f=a(s*i),h=a(c*r);return u===d&&f===h}is0(){return this.equals(N)}negate(){return new C(this.X,a(-this.Y),this.Z)}double(){return this.add(this)}add(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=0n,d=Zt,f=0n,h=0n,x=0n,y=a(d*3n),p=a(n*o),g=a(s*c),H=a(r*i),I=a(n+s),m=a(o+c);I=a(I*m),m=a(p+g),I=a(I-m),m=a(n+r);let S=a(o+i);return m=a(m*S),S=a(p+H),m=a(m-S),S=a(s+r),f=a(c+i),S=a(S*f),f=a(g+H),S=a(S-f),x=a(u*m),f=a(y*H),x=a(f+x),f=a(g-x),x=a(g+x),h=a(f*x),g=a(p+p),g=a(g+p),H=a(u*H),m=a(y*m),g=a(g+H),H=a(p-H),H=a(u*H),m=a(m+H),p=a(g*m),h=a(h+p),p=a(S*m),f=a(I*f),f=a(f-p),p=a(I*g),x=a(S*x),x=a(x+p),new C(f,h,x)}subtract(t){return this.add(xt(t).negate())}multiply(t,n=!0){if(!n&&t===0n)return N;if(bt(t),t===1n)return this;if(this.equals(T))return ln(t).p;let s=N,r=T;for(let o=this;t>0n;o=o.double(),t>>=1n)t&1n?s=s.add(o):n&&(r=r.add(o));return s}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){let{X:t,Y:n,Z:s}=this;if(this.equals(N))return{x:0n,y:0n};if(s===1n)return{x:t,y:n};let r=st(s,D);return a(s*r)!==1n&&b("inverse invalid"),{x:a(t*r),y:a(n*r)}}assertValidity(){let{x:t,y:n}=this.toAffine();return tt(t),tt(n),a(n*n)===Xt(t)?this:b("bad point: not on curve")}toBytes(t=!0){let{x:n,y:s}=this.assertValidity().toAffine(),r=B(n);return t?L(Yt(s),r):L(ft(4),r,B(s))}toHex(t){return wt(this.toBytes(t))}};l(C,"BASE"),l(C,"ZERO");var U=C,T=new U(Fe,De,1n),N=new U(0n,1n,0n);U.BASE=T;U.ZERO=N;var At=(e,t,n)=>T.multiply(t,!1).add(e.multiply(n,!1)).assertValidity(),G=e=>Y("0x"+(wt(e)||"0")),P=(e,t,n)=>G(e.subarray(t,n)),Re=2n**256n,B=e=>mt(jt(j(e,0n,Re),Z)),W=e=>{let t=G(A(e,w,"secret key"));return j(t,1n,v,"invalid secret key: outside of range")},Ht=e=>e>v>>1n,Pt=(e,t=!0)=>T.multiply(W(e)).toBytes(t),Xe=e=>{try{return!!W(e)}catch{return!1}},Ye=(e,t)=>{let{publicKey:n,publicKeyUncompressed:s}=et;try{let r=e.length;return t===!0&&r!==n||t===!1&&r!==s?!1:!!U.fromBytes(e)}catch{return!1}},$t=e=>{[0,1,2,3].includes(e)||b("recovery id must be valid and present")},Me=e=>{e!=null&&!Gt.includes(e)&&b(`Signature format must be one of: ${Gt.join(", ")}`),e===qt&&b(\'Signature format "der" is not supported: switch to noble-curves\')},Wt=(e,t=$)=>{Me(t);let n=et.signature,s=n+1,r=`Signature format "${t}" expects Uint8Array with length `;t===$&&e.length!==n&&b(r+n),t===ot&&e.length!==s&&b(r+s)},R=class e{constructor(t,n,s){l(this,"r");l(this,"s");l(this,"recovery");this.r=bt(t),this.s=bt(n),s!=null&&(this.recovery=s),Object.freeze(this)}static fromBytes(t,n=$){Wt(t,n);let s;n===ot&&(s=t[0],t=t.subarray(1));let r=P(t,0,w),o=P(t,w,Z);return new e(r,o,s)}addRecoveryBit(t){return new e(this.r,this.s,t)}hasHighS(){return Ht(this.s)}toBytes(t=$){let{r:n,s,recovery:r}=this,o=L(B(n),B(s));return t===ot?($t(r),L(Uint8Array.of(r),o)):o}},zt=e=>{let t=e.length*8-256;t>1024&&b("msg invalid");let n=G(e);return t>0?n>>Y(t):n},St=e=>E(zt(A(e))),$="compact",ot="recovered",qt="der",Gt=[$,ot,qt],Ft={lowS:!0,prehash:!0,format:$,extraEntropy:!1},Dt="SHA-256",K={hmacSha256Async:async(e,t)=>{let n=Vt(),s="HMAC",r=await n.importKey("raw",e,{name:s,hash:{name:Dt}},!1,["sign"]);return k(await n.sign(s,r,t))},hmacSha256:void 0,sha256Async:async e=>k(await Vt().digest(Dt,e)),sha256:void 0},z=(e,t,n)=>(A(e,void 0,"message"),t.prehash?n?K.sha256Async(e):it("sha256")(e):e),Jt=k(0),Qt=ft(0),te=ft(1),ee=1e3,ne="drbg: tried max amount of iterations",Pe=(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>it("hmacSha256")(s,L(n,...f)),i=(f=Jt)=>{s=c(Qt,f),n=c(),f.length!==0&&(s=c(te,f),n=c())},u=()=>(r++>=ee&&b(ne),n=c(),n);o(),i(e);let d;for(;!(d=t(u()));)i();return o(),d},$e=async(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>K.hmacSha256Async(s,L(n,...f)),i=async(f=Jt)=>{s=await c(Qt,f),n=await c(),f.length!==0&&(s=await c(te,f),n=await c())},u=async()=>(r++>=ee&&b(ne),n=await c(),n);o(),await i(e);let d;for(;!(d=t(await u()));)await i();return o(),d},se=(e,t,n,s)=>{let{lowS:r,extraEntropy:o}=n,c=B,i=St(e),u=c(i),d=W(t),f=[c(d),u];if(o!=null&&o!==!1){let p=o===!0?nt(w):o;f.push(A(p,void 0,"extraEntropy"))}let h=L(...f),x=i;return s(h,p=>{let g=zt(p);if(!(1n<=g&&g<v))return;let H=st(g,v),I=T.multiply(g).toAffine(),m=E(I.x);if(m===0n)return;let S=E(H*E(x+m*d));if(S===0n)return;let vt=(I.x===m?0:2)|Number(I.y&1n),_t=S;return r&&Ht(S)&&(_t=E(-S),vt^=1),new R(m,_t,vt).toBytes(n.format)})},re=(e,t,n,s={})=>{let{lowS:r,format:o}=s;e instanceof R&&b("Signature must be in Uint8Array, use .toBytes()"),Wt(e,o),A(n,void 0,"publicKey");try{let{r:c,s:i}=R.fromBytes(e,o),u=St(t),d=U.fromBytes(n);if(r&&Ht(i))return!1;let f=st(i,v),h=E(u*f),x=E(c*f),y=At(d,h,x).toAffine();return E(y.x)===c}catch{return!1}},q=e=>{let t={};return Object.keys(Ft).forEach(n=>{t[n]=e[n]??Ft[n]}),t},We=(e,t,n={})=>(n=q(n),e=z(e,n,!1),se(e,t,n,Pe)),ze=async(e,t,n={})=>(n=q(n),e=await z(e,n,!0),se(e,t,n,$e)),qe=(e,t,n,s={})=>(s=q(s),t=z(t,s,!1),re(e,t,n,s)),Je=async(e,t,n,s={})=>(s=q(s),t=await z(t,s,!0),re(e,t,n,s)),oe=(e,t)=>{let n=R.fromBytes(e,"recovered"),{r:s,s:r,recovery:o}=n;$t(o);let c=St(A(t,w)),i=o===2||o===3?s+v:s;tt(i);let u=Yt(Y(o)),d=L(u,B(i)),f=U.fromBytes(d),h=st(i,v),x=E(-c*h),y=E(r*h);return At(f,x,y).toBytes()},Qe=(e,t,n={})=>(t=z(t,q(n),!1),oe(e,t)),tn=async(e,t,n={})=>(t=await z(t,q(n),!0),oe(e,t)),en=(e,t,n=!0)=>U.fromBytes(t).multiply(W(e)).toBytes(n),ce=(e=nt(et.seed))=>{A(e),(e.length<et.seed||e.length>1024)&&b("expected 40-1024b");let t=a(G(e),v-1n);return B(t+1n)},ie=e=>t=>{let n=ce(t);return{secretKey:n,publicKey:e(n)}},nn=ie(Pt),sn={hexToBytes:mt,bytesToHex:wt,concatBytes:L,bytesToNumberBE:G,numberToBytesBE:B,mod:a,invert:st,randomBytes:nt,secretKeyToScalar:W,abytes:A},rn={isValidSecretKey:Xe,isValidPublicKey:Ye,randomSecretKey:ce},fe=e=>Uint8Array.from("BIP0340/"+e,t=>t.charCodeAt(0)),ae="aux",ue="nonce",he="challenge",yt=(e,...t)=>{let n=it("sha256"),s=n(fe(e));return n(L(s,s,...t))},pt=async(e,...t)=>{let n=K.sha256Async,s=await n(fe(e));return await n(L(s,s,...t))},Bt=e=>{let t=W(e),n=T.multiply(t),{x:s,y:r}=n.assertValidity().toAffine(),o=M(r)?t:E(-t),c=B(s);return{d:o,px:c}},Et=e=>E(G(e)),de=(...e)=>Et(yt(he,...e)),le=async(...e)=>Et(await pt(he,...e)),xe=e=>Bt(e).px,on=ie(xe),be=(e,t,n)=>{let{px:s,d:r}=Bt(t);return{m:A(e),px:s,d:r,a:A(n,w)}},ye=e=>{let t=Et(e);t===0n&&b("sign failed: k is zero");let{px:n,d:s}=Bt(B(t));return{rx:n,k:s}},pe=(e,t,n,s)=>L(t,B(E(e+n*s))),ge="invalid signature produced",cn=(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=yt(ae,c),u=B(o^G(i)),d=yt(ue,u,r,s),{rx:f,k:h}=ye(d),x=de(f,r,s),y=pe(h,f,x,o);return me(y,s,r)||b(ge),y},fn=async(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=await pt(ae,c),u=B(o^G(i)),d=await pt(ue,u,r,s),{rx:f,k:h}=ye(d),x=await le(f,r,s),y=pe(h,f,x,o);return await Ae(y,s,r)||b(ge),y},an=(e,t)=>e instanceof Promise?e.then(t):t(e),we=(e,t,n,s)=>{let r=A(e,Z,"signature"),o=A(t,void 0,"message"),c=A(n,w,"publicKey");try{let i=G(c),u=Mt(i),d=M(u)?u:a(-u),f=new U(i,d,1n).assertValidity(),h=B(f.toAffine().x),x=P(r,0,w);j(x,1n,D);let y=P(r,w,Z);j(y,1n,v);let p=L(B(x),h,o);return an(s(p),g=>{let{x:H,y:I}=At(f,y,E(-g)).toAffine();return!(!M(I)||H!==x)})}catch{return!1}},me=(e,t,n)=>we(e,t,n,de),Ae=async(e,t,n)=>we(e,t,n,le),un={keygen:on,getPublicKey:xe,sign:cn,verify:me,signAsync:fn,verifyAsync:Ae},ct=8,hn=256,He=Math.ceil(hn/ct)+1,gt=2**(ct-1),dn=()=>{let e=[],t=T,n=t;for(let s=0;s<He;s++){n=t,e.push(n);for(let r=1;r<gt;r++)n=n.add(t),e.push(n);t=n.double()}return e},Kt,Ot=(e,t)=>{let n=t.negate();return e?n:t},ln=e=>{let t=Kt||(Kt=dn()),n=N,s=T,r=2**ct,o=r,c=Y(r-1),i=Y(ct);for(let u=0;u<He;u++){let d=Number(e&c);e>>=i,d>gt&&(d-=o,e+=1n);let f=u*gt,h=f,x=f+Math.abs(d)-1,y=u%2!==0,p=d<0;d===0?s=s.add(Ot(y,t[h])):n=n.add(Ot(p,t[x]))}return e!==0n&&b("invalid wnaf"),{p:n,f:s}};function xn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Se(e,t=""){if(!Number.isSafeInteger(e)||e<0){let n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function J(e,t,n=""){let s=xn(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;throw new Error(c+"expected Uint8Array"+i+", got "+u)}return e}function Be(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Se(e.outputLen),Se(e.blockLen)}function Q(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Ee(e,t){J(e,void 0,"digestInto() output");let n=t.outputLen;if(e.length<n)throw new Error(\'"digestInto() output" expected to be of length >=\'+n)}function X(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function at(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function _(e,t){return e<<32-t|e>>>t}function Le(e,t={}){let n=(r,o)=>e(o).update(r).digest(),s=e(void 0);return n.outputLen=s.outputLen,n.blockLen=s.blockLen,n.create=r=>e(r),Object.assign(n,t),Object.freeze(n)}var Ue=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function Ie(e,t,n){return e&t^~e&n}function ve(e,t,n){return e&t^e&n^t&n}var ut=class{constructor(t,n,s,r){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=t,this.outputLen=n,this.padOffset=s,this.isLE=r,this.buffer=new Uint8Array(t),this.view=at(this.buffer)}update(t){Q(this),J(t);let{view:n,buffer:s,blockLen:r}=this,o=t.length;for(let c=0;c<o;){let i=Math.min(r-this.pos,o-c);if(i===r){let u=at(t);for(;r<=o-c;c+=r)this.process(u,c);continue}s.set(t.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Q(this),Ee(t,this),this.finished=!0;let{buffer:n,view:s,blockLen:r,isLE:o}=this,{pos:c}=this;n[c++]=128,X(this.buffer.subarray(c)),this.padOffset>r-c&&(this.process(s,0),c=0);for(let h=c;h<r;h++)n[h]=0;s.setBigUint64(r-8,BigInt(this.length*8),o),this.process(s,0);let i=at(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let d=u/4,f=this.get();if(d>f.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<d;h++)i.setUint32(4*h,f[h],o)}digest(){let{buffer:t,outputLen:n}=this;this.digestInto(t);let s=t.slice(0,n);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:n,buffer:s,length:r,finished:o,destroyed:c,pos:i}=this;return t.destroyed=c,t.finished=o,t.length=r,t.pos=i,r%n&&t.buffer.set(s),t}clone(){return this._cloneInto()}},F=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var bn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),O=new Uint32Array(64),Ut=class extends ut{constructor(t){super(64,t,8,!1)}get(){let{A:t,B:n,C:s,D:r,E:o,F:c,G:i,H:u}=this;return[t,n,s,r,o,c,i,u]}set(t,n,s,r,o,c,i,u){this.A=t|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=c|0,this.G=i|0,this.H=u|0}process(t,n){for(let h=0;h<16;h++,n+=4)O[h]=t.getUint32(n,!1);for(let h=16;h<64;h++){let x=O[h-15],y=O[h-2],p=_(x,7)^_(x,18)^x>>>3,g=_(y,17)^_(y,19)^y>>>10;O[h]=g+O[h-7]+p+O[h-16]|0}let{A:s,B:r,C:o,D:c,E:i,F:u,G:d,H:f}=this;for(let h=0;h<64;h++){let x=_(i,6)^_(i,11)^_(i,25),y=f+x+Ie(i,u,d)+bn[h]+O[h]|0,g=(_(s,2)^_(s,13)^_(s,22))+ve(s,r,o)|0;f=d,d=u,u=i,i=c+y|0,c=o,o=r,r=s,s=y+g|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,c=c+this.D|0,i=i+this.E|0,u=u+this.F|0,d=d+this.G|0,f=f+this.H|0,this.set(s,r,o,c,i,u,d,f)}roundClean(){X(O)}destroy(){this.set(0,0,0,0,0,0,0,0),X(this.buffer)}},It=class extends Ut{constructor(){super(32);l(this,"A",F[0]|0);l(this,"B",F[1]|0);l(this,"C",F[2]|0);l(this,"D",F[3]|0);l(this,"E",F[4]|0);l(this,"F",F[5]|0);l(this,"G",F[6]|0);l(this,"H",F[7]|0)}};var ht=Le(()=>new It,Ue(1));var dt=class{constructor(t,n){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if(Be(t),J(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let s=this.blockLen,r=new Uint8Array(s);r.set(n.length>s?t.create().update(n).digest():n);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=t.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),X(r)}update(t){return Q(this),this.iHash.update(t),this}digestInto(t){Q(this),J(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:n,iHash:s,finished:r,destroyed:o,blockLen:c,outputLen:i}=this;return t=t,t.finished=r,t.destroyed=o,t.blockLen=c,t.outputLen=i,t.oHash=n._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},lt=(e,t,n)=>new dt(e,t).update(n).digest();lt.create=(e,t)=>new dt(e,t);K.sha256=ht;K.hmacSha256=(e,...t)=>{let n=new Uint8Array(t.reduce((r,o)=>r+o.length,0)),s=0;for(let r of t)n.set(r,s),s+=r.length;return lt(ht,e,n)};return Ge(yn);})();\n/*! Bundled license information:\n\n@noble/secp256k1/index.js:\n  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)\n\n@noble/hashes/utils.js:\n  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n*/\n';
function generateWorkerCode() {
  return `
'use strict';

/**
 * Zero out a Uint8Array to clear sensitive data.
 * @param {Uint8Array} arr - Array to zero
 */
function secureZero(arr) {
    if (arr && arr.fill) {
        arr.fill(0);
        // Double-write to prevent optimization
        for (let i = 0; i < arr.length; i++) {
            arr[i] = 0;
        }
    }
}

/**
 * Bundled @noble/secp256k1 + hashes library (embedded at compile time).
 */
const eccBundle = ${JSON.stringify(ECC_BUNDLE)};

/**
 * Initialize the ECC library from the bundle.
 * The bundle exports nobleBundle with { secp, sha256, hmac }.
 */
const eccModule = (function() {
    // Execute the IIFE and return the nobleBundle object
    const fn = new Function(eccBundle + '; return nobleBundle;');
    return fn();
})();

/**
 * ECC library wrapper with the interface we need.
 * Uses eccModule.secp which has hashes pre-configured.
 */
const eccLib = {
    sign: (hash, privateKey) => {
        // noble's sign returns Signature object, we need compact 64-byte format
        const sig = eccModule.secp.sign(hash, privateKey, { lowS: true });
        return sig.toCompactRawBytes();
    },
    signSchnorr: (hash, privateKey) => {
        return eccModule.secp.schnorr.sign(hash, privateKey);
    }
};

/**
 * Whether initialization is complete.
 */
let initialized = false;

/**
 * Pending messages received before init completes.
 */
const pendingMessages = [];

/**
 * Handle incoming messages from main thread.
 */
self.onmessage = async function(event) {
    const msg = event.data;

    // Queue messages until initialized (except init)
    if (!initialized && msg.type !== 'init') {
        pendingMessages.push(msg);
        return;
    }

    await handleMessage(msg);
};

/**
 * Process a message.
 */
async function handleMessage(msg) {
    switch (msg.type) {
        case 'init':
            handleInit(msg);
            break;
        case 'sign':
            handleSign(msg);
            break;
        case 'signBatch':
            handleSignBatch(msg);
            break;
        case 'shutdown':
            handleShutdown();
            break;
        default:
            self.postMessage({
                type: 'error',
                taskId: msg.taskId || 'unknown',
                error: 'Unknown message type: ' + msg.type,
                inputIndex: msg.inputIndex || -1
            });
    }
}

/**
 * Initialize the worker.
 * ECC library is already bundled, so this just marks as ready.
 */
function handleInit(msg) {
    initialized = true;

    // Signal ready
    self.postMessage({ type: 'ready' });

    // Process pending messages
    while (pendingMessages.length > 0) {
        handleMessage(pendingMessages.shift());
    }
}

/**
 * Handle a signing request.
 *
 * SECURITY: Private key is zeroed immediately after use.
 *
 * @param {Object} msg - Signing task message
 */
function handleSign(msg) {
    const {
        taskId,
        hash,
        privateKey,
        publicKey,
        signatureType,
        lowR,
        inputIndex,
        sighashType,
        leafHash
    } = msg;

    // Validate inputs
    if (!hash || hash.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: 'Invalid hash: must be 32 bytes',
            inputIndex: inputIndex
        });
        return;
    }

    if (!privateKey || privateKey.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: 'Invalid private key: must be 32 bytes',
            inputIndex: inputIndex
        });
        return;
    }

    let signature;

    try {
        if (signatureType === 1) {
            // Schnorr signature (BIP340)
            if (typeof eccLib.signSchnorr !== 'function') {
                throw new Error('ECC library does not support Schnorr signatures');
            }
            signature = eccLib.signSchnorr(hash, privateKey);
        } else {
            // ECDSA signature
            if (typeof eccLib.sign !== 'function') {
                throw new Error('ECC library does not support ECDSA signatures');
            }
            signature = eccLib.sign(hash, privateKey, { lowR: lowR || false });
        }

        if (!signature) {
            throw new Error('Signing returned null or undefined');
        }

    } catch (error) {
        // ALWAYS zero the key, even on error
        secureZero(privateKey);

        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: error.message || 'Signing failed',
            inputIndex: inputIndex
        });
        return;
    }

    // CRITICAL: Zero the private key immediately after signing
    secureZero(privateKey);

    // Send result back
    const result = {
        type: 'result',
        taskId: taskId,
        signature: signature,
        inputIndex: inputIndex,
        publicKey: publicKey,
        signatureType: signatureType
    };

    if (leafHash) {
        result.leafHash = leafHash;
    }

    self.postMessage(result);
}

/**
 * Handle a batch signing request.
 * Signs multiple tasks and returns all results in a single message.
 *
 * SECURITY: Private key is zeroed immediately after all signatures.
 *
 * @param {Object} msg - Batch signing message with tasks array
 */
function handleSignBatch(msg) {
    const { batchId, tasks, privateKey } = msg;
    const results = [];
    const errors = [];

    // Validate private key once
    if (!privateKey || privateKey.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'batchResult',
            batchId: batchId,
            results: [],
            errors: [{ inputIndex: -1, error: 'Invalid private key: must be 32 bytes' }]
        });
        return;
    }

    // Process all tasks
    for (const task of tasks) {
        const { taskId, hash, publicKey, signatureType, lowR, inputIndex, sighashType, leafHash } = task;

        // Validate hash
        if (!hash || hash.length !== 32) {
            errors.push({ taskId, inputIndex, error: 'Invalid hash: must be 32 bytes' });
            continue;
        }

        try {
            let signature;
            if (signatureType === 1) {
                // Schnorr signature (BIP340)
                signature = eccLib.signSchnorr(hash, privateKey);
            } else {
                // ECDSA signature
                signature = eccLib.sign(hash, privateKey, { lowR: lowR || false });
            }

            if (!signature) {
                throw new Error('Signing returned null or undefined');
            }

            const result = {
                taskId: taskId,
                signature: signature,
                inputIndex: inputIndex,
                publicKey: publicKey,
                signatureType: signatureType
            };

            if (leafHash) {
                result.leafHash = leafHash;
            }

            results.push(result);
        } catch (error) {
            errors.push({ taskId, inputIndex, error: error.message || 'Signing failed' });
        }
    }

    // CRITICAL: Zero the private key after processing all tasks
    secureZero(privateKey);

    // Send batch result back
    self.postMessage({
        type: 'batchResult',
        batchId: batchId,
        results: results,
        errors: errors
    });
}

/**
 * Handle shutdown request.
 */
function handleShutdown() {
    initialized = false;
    pendingMessages.length = 0;

    self.postMessage({ type: 'shutdown-ack' });

    // Close the worker
    self.close();
}
`;
}
function createWorkerBlobUrl() {
  const code2 = generateWorkerCode();
  const blob = new Blob([code2], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function revokeWorkerBlobUrl(url) {
  URL.revokeObjectURL(url);
}
var DEFAULT_CONFIG = {
  workerCount: typeof navigator !== "undefined" ? navigator.hardwareConcurrency || 4 : 4,
  taskTimeoutMs: 3e4,
  maxKeyHoldTimeMs: 5e3,
  verifySignatures: true,
  preserveWorkers: false
};
var _instance2, _config, _workers, _pendingBatches, _workerBlobUrl, _preserveWorkers, _nextWorkerId, _nextTaskId, _initialized, _shuttingDown, _WorkerSigningPool_instances, createWorker_fn, signBatchOnWorker_fn, getIdleWorker_fn, handleWorkerMessage_fn, terminateWorker_fn, terminateIdleWorkers_fn;
var _WorkerSigningPool = class _WorkerSigningPool {
  /**
   * Creates a new WorkerSigningPool.
   *
   * @param config - Pool configuration
   */
  constructor(config2 = {}) {
    __privateAdd(this, _WorkerSigningPool_instances);
    /**
     * Pool configuration.
     */
    __privateAdd(this, _config);
    /**
     * Worker pool.
     */
    __privateAdd(this, _workers, []);
    /**
     * Pending batches awaiting completion.
     */
    __privateAdd(this, _pendingBatches, /* @__PURE__ */ new Map());
    /**
     * Worker blob URL (shared across all workers).
     */
    __privateAdd(this, _workerBlobUrl, null);
    /**
     * Whether workers are preserved between batches.
     */
    __privateAdd(this, _preserveWorkers, false);
    /**
     * Next worker ID counter.
     */
    __privateAdd(this, _nextWorkerId, 0);
    /**
     * Next task ID counter.
     */
    __privateAdd(this, _nextTaskId, 0);
    /**
     * Whether the pool is initialized.
     */
    __privateAdd(this, _initialized, false);
    /**
     * Whether the pool is shutting down.
     */
    __privateAdd(this, _shuttingDown, false);
    __privateSet(this, _config, { ...DEFAULT_CONFIG, ...config2 });
    __privateSet(this, _preserveWorkers, __privateGet(this, _config).preserveWorkers);
  }
  /**
   * Number of workers in the pool.
   */
  get workerCount() {
    return __privateGet(this, _workers).length;
  }
  /**
   * Number of idle workers available.
   */
  get idleWorkerCount() {
    return __privateGet(this, _workers).filter((w2) => w2.state === WorkerState.Idle).length;
  }
  /**
   * Number of busy workers.
   */
  get busyWorkerCount() {
    return __privateGet(this, _workers).filter((w2) => w2.state === WorkerState.Busy).length;
  }
  /**
   * Whether workers are being preserved between batches.
   */
  get isPreservingWorkers() {
    return __privateGet(this, _preserveWorkers);
  }
  /**
   * Gets the singleton pool instance.
   *
   * @param config - Optional configuration (only used on first call)
   * @returns The singleton pool instance
   *
   * @example
   * ```typescript
   * const pool = WorkerSigningPool.getInstance({ workerCount: 8 });
   * ```
   */
  static getInstance(config2) {
    if (!__privateGet(_WorkerSigningPool, _instance2)) {
      __privateSet(_WorkerSigningPool, _instance2, new _WorkerSigningPool(config2));
    }
    return __privateGet(_WorkerSigningPool, _instance2);
  }
  /**
   * Resets the singleton instance (for testing).
   */
  static resetInstance() {
    if (__privateGet(_WorkerSigningPool, _instance2)) {
      __privateGet(_WorkerSigningPool, _instance2).shutdown().catch(() => {
      });
      __privateSet(_WorkerSigningPool, _instance2, null);
    }
  }
  /**
   * Enables worker preservation between signing batches.
   *
   * When enabled, workers remain alive after completing a batch,
   * ready for the next signing operation. This is faster but
   * keeps workers in memory.
   *
   * Call shutdown() when done to terminate all workers.
   *
   * @example
   * ```typescript
   * const pool = WorkerSigningPool.getInstance();
   * pool.preserveWorkers(); // Enable at app startup
   *
   * // ... do many signing operations ...
   *
   * await pool.shutdown(); // Cleanup at app shutdown
   * ```
   */
  preserveWorkers() {
    __privateSet(this, _preserveWorkers, true);
  }
  /**
   * Disables worker preservation.
   *
   * Workers will be terminated after each signing batch.
   * More secure (no persistent workers) but slower for multiple batches.
   */
  releaseWorkers() {
    __privateSet(this, _preserveWorkers, false);
  }
  /**
   * Initializes the worker pool.
   *
   * Creates workers and waits for them to be ready.
   * Called automatically on first signBatch() if not called manually.
   *
   * @returns Promise that resolves when all workers are ready
   */
  async initialize() {
    if (__privateGet(this, _initialized)) {
      return;
    }
    if (__privateGet(this, _shuttingDown)) {
      throw new Error("Cannot initialize pool while shutting down");
    }
    __privateSet(this, _workerBlobUrl, createWorkerBlobUrl());
    const workerPromises = [];
    for (let i2 = 0; i2 < __privateGet(this, _config).workerCount; i2++) {
      workerPromises.push(__privateMethod(this, _WorkerSigningPool_instances, createWorker_fn).call(this));
    }
    await Promise.all(workerPromises);
    __privateSet(this, _initialized, true);
  }
  /**
   * Signs a batch of tasks in parallel.
   *
   * SECURITY: Private keys are obtained via keyPair.getPrivateKey() and
   * cloned to workers. Keys are zeroed in workers immediately after signing.
   *
   * Tasks are distributed across workers and processed in batches for efficiency.
   *
   * @param tasks - Signing tasks (hashes, input indices, etc.)
   * @param keyPair - Key pair with getPrivateKey() method
   * @returns Promise resolving to signing results
   *
   * @example
   * ```typescript
   * const tasks: SigningTask[] = [
   *     { taskId: '1', inputIndex: 0, hash: hash0, signatureType: SignatureType.ECDSA, sighashType: 0x01 },
   *     { taskId: '2', inputIndex: 1, hash: hash1, signatureType: SignatureType.Schnorr, sighashType: 0x00 },
   * ];
   *
   * const result = await pool.signBatch(tasks, keyPair);
   *
   * if (result.success) {
   *     for (const [inputIndex, sig] of result.signatures) {
   *         console.log(`Input ${inputIndex}: ${sig.signature}`);
   *     }
   * }
   * ```
   */
  async signBatch(tasks, keyPair) {
    const startTime = performance.now();
    if (!__privateGet(this, _initialized)) {
      await this.initialize();
    }
    if (tasks.length === 0) {
      return {
        success: true,
        signatures: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map(),
        durationMs: performance.now() - startTime
      };
    }
    const workerCount = Math.min(__privateGet(this, _workers).length, tasks.length);
    const taskBatches = Array.from({ length: workerCount }, () => []);
    for (let i2 = 0; i2 < tasks.length; i2++) {
      taskBatches[i2 % workerCount].push(tasks[i2]);
    }
    const privateKey = keyPair.getPrivateKey();
    try {
      const batchResults = await Promise.allSettled(taskBatches.map((batch, index) => __privateMethod(this, _WorkerSigningPool_instances, signBatchOnWorker_fn).call(this, batch, privateKey, keyPair.publicKey, index)));
      const signatures = /* @__PURE__ */ new Map();
      const errors = /* @__PURE__ */ new Map();
      for (let i2 = 0; i2 < batchResults.length; i2++) {
        const result = batchResults[i2];
        if (result.status === "fulfilled") {
          const batchResult = result.value;
          for (const sig of batchResult.results) {
            signatures.set(sig.inputIndex, {
              type: "result",
              taskId: sig.taskId,
              signature: sig.signature,
              inputIndex: sig.inputIndex,
              publicKey: sig.publicKey,
              signatureType: sig.signatureType,
              leafHash: sig.leafHash
            });
          }
          for (const err2 of batchResult.errors) {
            errors.set(err2.inputIndex, err2.error);
          }
        } else {
          const reason = result.reason;
          const errorMsg = (reason == null ? void 0 : reason.message) ?? "Batch signing failed";
          const failedBatch = taskBatches[i2];
          for (const task of failedBatch) {
            errors.set(task.inputIndex, errorMsg);
          }
        }
      }
      if (!__privateGet(this, _preserveWorkers)) {
        await __privateMethod(this, _WorkerSigningPool_instances, terminateIdleWorkers_fn).call(this);
      }
      return {
        success: errors.size === 0,
        signatures,
        errors,
        durationMs: performance.now() - startTime
      };
    } finally {
      privateKey.fill(0);
    }
  }
  /**
   * Disposes of the pool by shutting down all workers.
   *
   * Enables `await using pool = ...` syntax for automatic cleanup.
   */
  async [Symbol.asyncDispose]() {
    await this.shutdown();
  }
  /**
   * Shuts down the pool and terminates all workers.
   *
   * Call this when the application is done with signing operations.
   *
   * @returns Promise that resolves when all workers are terminated
   */
  async shutdown() {
    if (__privateGet(this, _shuttingDown)) {
      return;
    }
    __privateSet(this, _shuttingDown, true);
    const terminatePromises = __privateGet(this, _workers).map((worker) => __privateMethod(this, _WorkerSigningPool_instances, terminateWorker_fn).call(this, worker));
    await Promise.all(terminatePromises);
    __privateGet(this, _workers).length = 0;
    __privateGet(this, _pendingBatches).clear();
    if (__privateGet(this, _workerBlobUrl)) {
      revokeWorkerBlobUrl(__privateGet(this, _workerBlobUrl));
      __privateSet(this, _workerBlobUrl, null);
    }
    __privateSet(this, _initialized, false);
    __privateSet(this, _shuttingDown, false);
  }
  [Symbol.dispose]() {
    void this.shutdown();
  }
};
_instance2 = new WeakMap();
_config = new WeakMap();
_workers = new WeakMap();
_pendingBatches = new WeakMap();
_workerBlobUrl = new WeakMap();
_preserveWorkers = new WeakMap();
_nextWorkerId = new WeakMap();
_nextTaskId = new WeakMap();
_initialized = new WeakMap();
_shuttingDown = new WeakMap();
_WorkerSigningPool_instances = new WeakSet();
createWorker_fn = async function() {
  if (!__privateGet(this, _workerBlobUrl)) {
    throw new Error("Worker blob URL not created");
  }
  const workerId = __privateWrapper(this, _nextWorkerId)._++;
  const worker = new Worker(__privateGet(this, _workerBlobUrl), {
    name: `signing-worker-${workerId}`
  });
  const pooledWorker = {
    id: workerId,
    state: WorkerState.Initializing,
    worker,
    currentTaskId: null,
    taskStartTime: null
  };
  __privateGet(this, _workers).push(pooledWorker);
  await new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error(`Worker ${workerId} initialization timeout`));
    }, 1e4);
    const messageHandler = (event) => {
      if (isWorkerReady(event.data)) {
        clearTimeout(timeout);
        worker.removeEventListener("message", messageHandler);
        pooledWorker.state = WorkerState.Idle;
        resolve();
      }
    };
    worker.addEventListener("message", messageHandler);
    worker.addEventListener("error", (error) => {
      clearTimeout(timeout);
      reject(new Error(`Worker ${workerId} error: ${error.message}`));
    });
    worker.postMessage({
      type: "init"
    });
  });
  worker.addEventListener("message", (event) => {
    __privateMethod(this, _WorkerSigningPool_instances, handleWorkerMessage_fn).call(this, pooledWorker, event.data);
  });
};
signBatchOnWorker_fn = async function(tasks, privateKey, publicKey, workerIndex) {
  if (tasks.length === 0) {
    return { type: "batchResult", batchId: "", results: [], errors: [] };
  }
  const worker = __privateGet(this, _workers)[workerIndex] ?? await __privateMethod(this, _WorkerSigningPool_instances, getIdleWorker_fn).call(this);
  const batchId = `batch-${__privateWrapper(this, _nextTaskId)._++}`;
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      __privateGet(this, _pendingBatches).delete(batchId);
      worker.state = WorkerState.Idle;
      worker.currentTaskId = null;
      worker.taskStartTime = null;
      __privateMethod(this, _WorkerSigningPool_instances, terminateWorker_fn).call(this, worker).catch(() => {
      });
      __privateMethod(this, _WorkerSigningPool_instances, createWorker_fn).call(this).catch(() => {
      });
      reject(new Error(`Batch signing timeout for ${tasks.length} tasks`));
    }, __privateGet(this, _config).maxKeyHoldTimeMs);
    const pendingBatch = {
      batchId,
      resolve,
      reject,
      timeoutId
    };
    __privateGet(this, _pendingBatches).set(batchId, pendingBatch);
    worker.state = WorkerState.Busy;
    worker.currentTaskId = batchId;
    worker.taskStartTime = Date.now();
    const batchTasks = tasks.map((task) => ({
      taskId: task.taskId,
      hash: task.hash,
      publicKey,
      signatureType: task.signatureType,
      lowR: task.lowR,
      inputIndex: task.inputIndex,
      sighashType: task.sighashType,
      leafHash: task.leafHash
    }));
    const message = {
      type: "signBatch",
      batchId,
      tasks: batchTasks,
      privateKey
      // Cloned to worker, zeroed there after all signatures
    };
    worker.worker.postMessage(message);
  });
};
getIdleWorker_fn = async function() {
  let worker = __privateGet(this, _workers).find((w2) => w2.state === WorkerState.Idle);
  if (worker) {
    return worker;
  }
  if (__privateGet(this, _workers).length < __privateGet(this, _config).workerCount) {
    await __privateMethod(this, _WorkerSigningPool_instances, createWorker_fn).call(this);
    worker = __privateGet(this, _workers).find((w2) => w2.state === WorkerState.Idle);
    if (worker) {
      return worker;
    }
  }
  return new Promise((resolve) => {
    const checkInterval = setInterval(() => {
      const idleWorker = __privateGet(this, _workers).find((w2) => w2.state === WorkerState.Idle);
      if (idleWorker) {
        clearInterval(checkInterval);
        resolve(idleWorker);
      }
    }, 10);
  });
};
/**
 * Handles a message from a worker.
 */
handleWorkerMessage_fn = function(worker, response) {
  if (isBatchResult(response)) {
    const pending = __privateGet(this, _pendingBatches).get(response.batchId);
    if (pending) {
      clearTimeout(pending.timeoutId);
      __privateGet(this, _pendingBatches).delete(response.batchId);
      worker.state = WorkerState.Idle;
      worker.currentTaskId = null;
      worker.taskStartTime = null;
      pending.resolve(response);
    }
  }
};
terminateWorker_fn = async function(worker) {
  if (worker.state === WorkerState.Terminated) {
    return;
  }
  worker.state = WorkerState.ShuttingDown;
  worker.worker.postMessage({ type: "shutdown" });
  await new Promise((resolve) => {
    const timeout = setTimeout(() => {
      worker.worker.terminate();
      worker.state = WorkerState.Terminated;
      resolve();
    }, 1e3);
    const handler = (event) => {
      if (event.data.type === "shutdown-ack") {
        clearTimeout(timeout);
        worker.worker.removeEventListener("message", handler);
        worker.worker.terminate();
        worker.state = WorkerState.Terminated;
        resolve();
      }
    };
    worker.worker.addEventListener("message", handler);
  });
  const index = __privateGet(this, _workers).indexOf(worker);
  if (index >= 0) {
    __privateGet(this, _workers).splice(index, 1);
  }
};
terminateIdleWorkers_fn = async function() {
  const idleWorkers = __privateGet(this, _workers).filter((w2) => w2.state === WorkerState.Idle);
  await Promise.all(idleWorkers.map((w2) => __privateMethod(this, _WorkerSigningPool_instances, terminateWorker_fn).call(this, w2)));
};
/**
 * Singleton instance.
 */
__privateAdd(_WorkerSigningPool, _instance2, null);
var WorkerSigningPool = _WorkerSigningPool;
function prepareSigningTasks(psbt, keyPair, options = {}) {
  const tasks = [];
  const inputs2 = psbt.data.inputs;
  const pubkey = keyPair.publicKey;
  for (let i2 = 0; i2 < inputs2.length; i2++) {
    const input = inputs2[i2];
    if (!psbt.inputHasPubkey(i2, pubkey)) {
      continue;
    }
    if (isTaprootInput$1(input)) {
      const taprootTasks = prepareTaprootTasks(psbt, i2, input, keyPair, options);
      tasks.push(...taprootTasks);
    } else {
      const legacyTask = prepareLegacyTask(psbt, i2, input, keyPair, options);
      if (legacyTask) {
        tasks.push(legacyTask);
      }
    }
  }
  return tasks;
}
function prepareTaprootTasks(psbt, inputIndex, input, keyPair, options) {
  const tasks = [];
  try {
    const hashesForSig = psbt.checkTaprootHashesForSig(inputIndex, input, keyPair, options.tapLeafHash, options.sighashTypes);
    for (const { hash: hash2, leafHash } of hashesForSig) {
      tasks.push({
        taskId: `taproot-${inputIndex}-${leafHash ? "script" : "key"}`,
        inputIndex,
        hash: hash2,
        signatureType: SignatureType$1.Schnorr,
        sighashType: input.sighashType ?? Transaction.SIGHASH_DEFAULT,
        leafHash
      });
    }
  } catch {
  }
  return tasks;
}
function prepareLegacyTask(_psbt, _inputIndex, input, _keyPair2, options) {
  try {
    const sighashType2 = input.sighashType ?? Transaction.SIGHASH_ALL;
    const allowedTypes = options.sighashTypes ?? [Transaction.SIGHASH_ALL];
    if (!allowedTypes.includes(sighashType2)) {
      return null;
    }
    return null;
  } catch {
    return null;
  }
}
function applySignaturesToPsbt(psbt, result, keyPair) {
  const pubkey = keyPair.publicKey;
  for (const [inputIndex, sigResult] of result.signatures) {
    const input = psbt.data.inputs[inputIndex];
    if (sigResult.signatureType === SignatureType$1.Schnorr) {
      if (sigResult.leafHash) {
        const tapScriptSig2 = [
          {
            pubkey: toXOnly(pubkey),
            signature: serializeTaprootSignature(sigResult.signature, input.sighashType),
            leafHash: sigResult.leafHash
          }
        ];
        psbt.data.updateInput(inputIndex, { tapScriptSig: tapScriptSig2 });
      } else {
        const tapKeySig2 = serializeTaprootSignature(sigResult.signature, input.sighashType);
        psbt.data.updateInput(inputIndex, { tapKeySig: tapKeySig2 });
      }
    } else {
      const encodedSig = signature.encode(sigResult.signature, input.sighashType ?? Transaction.SIGHASH_ALL);
      const partialSig2 = [
        {
          pubkey: Uint8Array.from(pubkey),
          signature: encodedSig
        }
      ];
      psbt.data.updateInput(inputIndex, { partialSig: partialSig2 });
    }
  }
}
var bitcoin = {
  payments,
  script,
  crypto: crypto$2
};
var S = Symbol;
if (typeof S.dispose !== "symbol") {
  S.dispose = Symbol.for("Symbol.dispose");
}
if (typeof S.asyncDispose !== "symbol") {
  S.asyncDispose = Symbol.for("Symbol.asyncDispose");
}
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist2) => {
  return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
};
var put_short = (s, w2) => {
  s.pending_buf[s.pending++] = w2 & 255;
  s.pending_buf[s.pending++] = w2 >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code2, len) => {
  let res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base2 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n2, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n2 = s.heap[h];
    bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits;
    if (n2 > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n2 >= base2) {
      xbits = extra[n2 - base2];
    }
    f = tree[n2 * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n2 = s.bl_count[bits];
    while (n2 !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n2--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code2 = 0;
  let bits;
  let n2;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code2 = code2 + bl_count[bits - 1] << 1;
    next_code[bits] = code2;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    let len = tree[n2 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n2;
  let bits;
  let length;
  let code2;
  let dist2;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length;
    for (n2 = 0; n2 < 1 << extra_lbits[code2]; n2++) {
      _length_code[length++] = code2;
    }
  }
  _length_code[length - 1] = code2;
  dist2 = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist2;
    for (n2 = 0; n2 < 1 << extra_dbits[code2]; n2++) {
      _dist_code[dist2++] = code2;
    }
  }
  dist2 >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist2 << 7;
    for (n2 = 0; n2 < 1 << extra_dbits[code2] - 7; n2++) {
      _dist_code[256 + dist2++] = code2;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    static_dtree[n2 * 2 + 1] = 5;
    static_dtree[n2 * 2] = bi_reverse(n2, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n2;
  for (n2 = 0; n2 < L_CODES$1; n2++) {
    s.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    s.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$1; n2++) {
    s.bl_tree[n2 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n2, m, depth) => {
  const _n22 = n2 * 2;
  const _m2 = m * 2;
  return tree[_n22] < tree[_m2] || tree[_n22] === tree[_m2] && depth[n2] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist2;
  let lc;
  let sx = 0;
  let code2;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist2 = s.pending_buf[s.sym_buf + sx++] & 255;
      dist2 += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist2 === 0) {
        send_code(s, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s, lc, extra);
        }
        dist2--;
        code2 = d_code(dist2);
        send_code(s, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist2 -= base_dist[code2];
          send_bits(s, dist2, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n2, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n2;
      s.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap(s, tree, n2);
  }
  node = elems;
  do {
    n2 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n2;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n2 * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n2;
  for (n2 = 0; n2 <= 31; n2++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n2 = 32; n2 < LITERALS$1; n2++) {
    if (s.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist2, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist2;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist2 >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist2 === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist2--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist2) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len !== 0) {
    n2 = len > 2e3 ? 2e3 : len;
    len -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c = n2;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n2] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t2 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n2, m;
  let p;
  let wsize = s.w_size;
  n2 = s.hash_size;
  p = n2;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n2);
  n2 = wsize;
  p = n2;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n2);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n2, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n2;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level2, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level2 === Z_DEFAULT_COMPRESSION$1) {
    level2 = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level2 < 0 || level2 > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level2;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level2) => {
  return deflateInit2(strm, level2, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n2 = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n2);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l = chunks.length; i2 < l; i2++) {
    len += chunks[i2].length;
  }
  const result = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l = chunks.length; i2 < l; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i2++] = c;
    } else if (c < 2048) {
      buf[i2++] = 192 | c >>> 6;
      buf[i2++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i2++] = 224 | c >>> 12;
      buf[i2++] = 128 | c >>> 6 & 63;
      buf[i2++] = 128 | c & 63;
    } else {
      buf[i2++] = 240 | c >>> 18;
      buf[i2++] = 128 | c >>> 12 & 63;
      buf[i2++] = 128 | c >>> 6 & 63;
      buf[i2++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += String.fromCharCode(buf[i2]);
  }
  return result;
};
var buf2string = (buf, max2) => {
  const len = max2 || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max2));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c = buf[i2++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c = c << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max2) => {
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  let pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist2;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist2 = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist2 += hold & (1 << op) - 1;
                  if (dist2 > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist2 > op) {
                    op = dist2 - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist2;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist2;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist2;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min2 = 0, max2 = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base2 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base2 = extra = work;
    match = 20;
  } else if (type2 === LENS$1) {
    base2 = lbase;
    extra = lext;
    match = 257;
  } else {
    base2 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base2[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min2 = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src2, end, copy) => {
  let dist2;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src2.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist2 = state.wsize - state.wnext;
    if (dist2 > copy) {
      dist2 = copy;
    }
    state.window.set(src2.subarray(end - copy, end - copy + dist2), state.wnext);
    copy -= dist2;
    if (copy) {
      state.window.set(src2.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist2;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist2;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};
function gzipSync(data, options = {}) {
  return Buffer.from(pako.gzip(data, { level: options.level || 6 }));
}
function gunzipSync(data) {
  return Buffer.from(pako.ungzip(data));
}
var zlib = {
  gzipSync,
  gunzipSync
};
var _Compressor = class _Compressor {
  /**
   * Compresses the data using gzip.
   * @param {Uint8Array} data The data to compress.
   * @returns {Uint8Array} The compressed data.
   */
  static compress(data) {
    return new Uint8Array(zlib.gzipSync(data, _Compressor.zlibOptions));
  }
  /**
   * Decompresses the data using gunzip.
   * @param {Uint8Array} data The data to decompress.
   * @returns {Uint8Array} The decompressed data.
   */
  static decompress(data) {
    return new Uint8Array(zlib.gunzipSync(data, _Compressor.zlibOptions));
  }
};
__publicField(_Compressor, "zlibOptions", {
  level: 9,
  maxOutputLength: 1024 * 1024 * 16
  // 16mb, limit it to 16mb.
});
var Compressor = _Compressor;
var backend = Nr();
var eccLib = backend;
initEccLib(eccLib);
var cjs = {};
var bip32$1 = {};
var crypto$1 = {};
var hasRequiredCrypto2;
function requireCrypto2() {
  if (hasRequiredCrypto2) return crypto$1;
  hasRequiredCrypto2 = 1;
  Object.defineProperty(crypto$1, "__esModule", { value: true });
  crypto$1.hash160 = hash1602;
  crypto$1.hash256 = hash2562;
  crypto$1.hmacSHA512 = hmacSHA512;
  const hmac_js_1 = require$$0;
  const legacy_js_1 = require$$1;
  const sha2_js_1 = require$$2;
  function hash1602(buffer2) {
    return (0, legacy_js_1.ripemd160)((0, sha2_js_1.sha256)(buffer2));
  }
  function hash2562(buffer2) {
    return (0, sha2_js_1.sha256)(buffer2);
  }
  function hmacSHA512(key, data) {
    return (0, hmac_js_1.hmac)(sha2_js_1.sha512, key, data);
  }
  return crypto$1;
}
var testecc = {};
var require$$2$1 = getAugmentedNamespace(browser$1);
var hasRequiredTestecc;
function requireTestecc() {
  if (hasRequiredTestecc) return testecc;
  hasRequiredTestecc = 1;
  var __createBinding = testecc && testecc.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = testecc && testecc.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = testecc && testecc.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar2 = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar2[ar2.length] = k;
        return ar2;
      };
      return ownKeys(o);
    };
    return function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k = ownKeys(mod3), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod3, k[i2]);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
  })();
  Object.defineProperty(testecc, "__esModule", { value: true });
  testecc.testEcc = testEcc;
  const tools = __importStar(require$$2$1);
  const h = (hex) => tools.fromHex(hex);
  function testEcc(ecc) {
    assert(ecc.isPoint(h("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));
    assert(!ecc.isPoint(h("030000000000000000000000000000000000000000000000000000000000000005")));
    assert(ecc.isPrivate(h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));
    assert(ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));
    assert(!ecc.isPrivate(h("0000000000000000000000000000000000000000000000000000000000000000")));
    assert(!ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")));
    assert(!ecc.isPrivate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")));
    assert(tools.compare(ecc.pointFromScalar(h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), h("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0);
    if (ecc.xOnlyPointAddTweak) {
      assert(ecc.xOnlyPointAddTweak(h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
      let xOnlyRes = ecc.xOnlyPointAddTweak(h("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), h("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
      assert(tools.compare(xOnlyRes.xOnlyPubkey, h("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && xOnlyRes.parity === 1);
      xOnlyRes = ecc.xOnlyPointAddTweak(h("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), h("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
    }
    assert(tools.compare(ecc.pointAddScalar(h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h("0000000000000000000000000000000000000000000000000000000000000003")), h("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0);
    assert(tools.compare(ecc.privateAdd(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), h("0000000000000000000000000000000000000000000000000000000000000002")), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0);
    if (ecc.privateNegate) {
      assert(tools.compare(ecc.privateNegate(h("0000000000000000000000000000000000000000000000000000000000000001")), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0);
      assert(tools.compare(ecc.privateNegate(h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), h("0000000000000000000000000000000000000000000000000000000000000003")) === 0);
      assert(tools.compare(ecc.privateNegate(h("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), h("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0);
    }
    assert(tools.compare(ecc.sign(h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), h("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0);
    assert(ecc.verify(h("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")));
    if (ecc.signSchnorr) {
      assert(tools.compare(ecc.signSchnorr(h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), h("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), h("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0);
    }
    if (ecc.verifySchnorr) {
      assert(ecc.verifySchnorr(h("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), h("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
    }
  }
  function assert(bool) {
    if (!bool)
      throw new Error("ecc library invalid");
  }
  return testecc;
}
var require$$4$2 = getAugmentedNamespace(build$1);
var types$1 = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$1, "__esModule", { value: true });
  types$1.validateBip32Path = validateBip32Path;
  types$1.validateBytes32 = validateBytes32;
  types$1.validateBytes33 = validateBytes33;
  const BIP32_PATH_REGEX = /^(m\/)?(\d+'?\/)*\d+'?$/;
  function validateBip32Path(path) {
    if (typeof path !== "string" || !BIP32_PATH_REGEX.test(path)) {
      throw new TypeError("Expected BIP32 derivation path");
    }
  }
  function validateBytes32(buf) {
    if (!(buf instanceof Uint8Array) || buf.length !== 32) {
      throw new TypeError("Expected Uint8Array of length 32");
    }
  }
  function validateBytes33(buf) {
    if (!(buf instanceof Uint8Array) || buf.length !== 33) {
      throw new TypeError("Expected Uint8Array of length 33");
    }
  }
  return types$1;
}
function decodeRaw(buffer2, version2) {
  if (version2 !== void 0 && buffer2[0] !== version2) {
    throw new Error("Invalid network version");
  }
  if (buffer2.length === 33) {
    return {
      version: buffer2[0],
      privateKey: buffer2.slice(1, 33),
      compressed: false
    };
  }
  if (buffer2.length !== 34) {
    throw new Error("Invalid WIF length");
  }
  if (buffer2[33] !== 1) {
    throw new Error("Invalid compression flag");
  }
  return {
    version: buffer2[0],
    privateKey: buffer2.slice(1, 33),
    compressed: true
  };
}
function encodeRaw(version2, privateKey, compressed) {
  if (privateKey.length !== 32) {
    throw new TypeError("Invalid privateKey length");
  }
  const result = new Uint8Array(compressed ? 34 : 33);
  const view = new DataView(result.buffer);
  view.setUint8(0, version2);
  result.set(privateKey, 1);
  if (compressed) {
    result[33] = 1;
  }
  return result;
}
function decode(str, version2) {
  return decodeRaw(bs58check.decode(str), version2);
}
function encode(wif) {
  return bs58check.encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));
}
var build = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode,
  decodeRaw,
  encode,
  encodeRaw
}, Symbol.toStringTag, { value: "Module" }));
var require$$4$1 = getAugmentedNamespace(build);
var networks = {};
var hasRequiredNetworks;
function requireNetworks() {
  if (hasRequiredNetworks) return networks;
  hasRequiredNetworks = 1;
  Object.defineProperty(networks, "__esModule", { value: true });
  networks.REGTEST = networks.TESTNET = networks.BITCOIN = void 0;
  networks.BITCOIN = {
    messagePrefix: "Bitcoin Signed Message:\n",
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  };
  networks.TESTNET = {
    messagePrefix: "Bitcoin Signed Message:\n",
    bech32: "tb",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  };
  networks.REGTEST = {
    messagePrefix: "Bitcoin Signed Message:\n",
    bech32: "bcrt",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  };
  return networks;
}
var require$$7$1 = getAugmentedNamespace(browser$2);
var hasRequiredBip32;
function requireBip32() {
  if (hasRequiredBip32) return bip32$1;
  hasRequiredBip32 = 1;
  var __createBinding = bip32$1 && bip32$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = bip32$1 && bip32$1.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = bip32$1 && bip32$1.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar2 = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar2[ar2.length] = k;
        return ar2;
      };
      return ownKeys(o);
    };
    return function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k = ownKeys(mod3), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod3, k[i2]);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
  })();
  Object.defineProperty(bip32$1, "__esModule", { value: true });
  bip32$1.BIP32Factory = BIP32Factory;
  const crypto3 = __importStar(requireCrypto2());
  const testecc_js_1 = requireTestecc();
  const bs58check2 = __importStar(require$$4$2);
  const types_js_1 = requireTypes$1();
  const wif = __importStar(require$$4$1);
  const tools = __importStar(require$$2$1);
  const networks_js_1 = requireNetworks();
  const ecpair_1 = require$$7$1;
  const BITCOIN_SEED = tools.fromUtf8("Bitcoin seed");
  const testedLibs = /* @__PURE__ */ new WeakSet();
  function BIP32Factory(ecc) {
    var _ID;
    const lib = ecc;
    if (!testedLibs.has(lib)) {
      (0, testecc_js_1.testEcc)(lib);
      testedLibs.add(lib);
    }
    const HIGHEST_BIT = 2147483648;
    function toXOnly2(pubKey) {
      return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
    }
    class Bip32Signer {
      constructor(__D, __Q, network) {
        __publicField(this, "__D");
        __publicField(this, "__Q");
        __publicField(this, "network");
        __publicField(this, "lowR", false);
        this.__D = __D;
        this.__Q = __Q;
        this.network = network;
      }
      get publicKey() {
        if (this.__Q === void 0)
          this.__Q = lib.pointFromScalar(this.__D, true);
        return this.__Q;
      }
      get xOnlyPublicKey() {
        return toXOnly2(this.publicKey);
      }
      get privateKey() {
        return this.__D;
      }
      get compressed() {
        return true;
      }
      get capabilities() {
        let caps = ecpair_1.SignerCapability.EcdsaVerify | ecpair_1.SignerCapability.PublicKeyTweak;
        if (this.__D !== void 0) {
          caps |= ecpair_1.SignerCapability.EcdsaSign | ecpair_1.SignerCapability.PrivateKeyExport;
        }
        if (lib.signSchnorr && this.__D !== void 0) {
          caps |= ecpair_1.SignerCapability.SchnorrSign;
        }
        if (lib.verifySchnorr) {
          caps |= ecpair_1.SignerCapability.SchnorrVerify;
        }
        return caps;
      }
      hasCapability(cap) {
        return (this.capabilities & cap) !== 0;
      }
      sign(hash2, lowR) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (lowR === void 0)
          lowR = this.lowR;
        if (!lowR) {
          return lib.sign(hash2, this.privateKey);
        } else {
          let sig = lib.sign(hash2, this.privateKey);
          const extraData = new Uint8Array(32);
          let counter = 0;
          while (sig[0] > 127) {
            counter++;
            tools.writeUInt32(extraData, 0, counter, "LE");
            sig = lib.sign(hash2, this.privateKey, extraData);
          }
          return sig;
        }
      }
      signSchnorr(hash2) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (!lib.signSchnorr)
          throw new Error("signSchnorr not supported by ecc library");
        return lib.signSchnorr(hash2, this.privateKey);
      }
      verify(hash2, signature2) {
        return lib.verify(hash2, this.publicKey, signature2);
      }
      verifySchnorr(hash2, signature2) {
        if (!lib.verifySchnorr)
          throw new Error("verifySchnorr not supported by ecc library");
        return lib.verifySchnorr(hash2, this.publicKey.subarray(1, 33), signature2);
      }
      tweak(t2) {
        if (this.privateKey)
          return this.tweakFromPrivateKey(t2);
        return this.tweakFromPublicKey(t2);
      }
      toWIF() {
        if (!this.privateKey)
          throw new TypeError("Missing private key");
        return wif.encode({
          version: this.network.wif,
          privateKey: this.privateKey,
          compressed: true
        });
      }
      tweakFromPublicKey(t2) {
        const xOnlyPubKey = toXOnly2(this.publicKey);
        const xOnlyPointAddTweak = lib.xOnlyPointAddTweak;
        if (!xOnlyPointAddTweak)
          throw new Error("xOnlyPointAddTweak not supported by ecc library");
        const tweakedPublicKey = xOnlyPointAddTweak(xOnlyPubKey, t2);
        if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
          throw new Error("Cannot tweak public key!");
        const parityByte = Uint8Array.from([
          tweakedPublicKey.parity === 0 ? 2 : 3
        ]);
        const tweakedPublicKeyCompresed = tools.concat([
          parityByte,
          tweakedPublicKey.xOnlyPubkey
        ]);
        return new Bip32Signer(void 0, tweakedPublicKeyCompresed, this.network);
      }
      tweakFromPrivateKey(t2) {
        const hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
        const privateKey = (() => {
          if (!hasOddY)
            return this.privateKey;
          else if (!lib.privateNegate)
            throw new Error("privateNegate not supported by ecc library");
          else
            return lib.privateNegate(this.privateKey);
        })();
        const tweakedPrivateKey = lib.privateAdd(privateKey, t2);
        if (!tweakedPrivateKey)
          throw new Error("Invalid tweaked private key!");
        return new Bip32Signer(tweakedPrivateKey, void 0, this.network);
      }
    }
    const _BIP32 = class _BIP32 extends Bip32Signer {
      constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0) {
        super(__D, __Q, network);
        __publicField(this, "chainCode");
        __publicField(this, "__DEPTH");
        __publicField(this, "__INDEX");
        __publicField(this, "__PARENT_FINGERPRINT");
        __privateAdd(this, _ID);
        this.chainCode = chainCode;
        this.__DEPTH = __DEPTH;
        this.__INDEX = __INDEX;
        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
      }
      get capabilities() {
        return super.capabilities | ecpair_1.SignerCapability.HdDerivation;
      }
      get depth() {
        return this.__DEPTH;
      }
      get index() {
        return this.__INDEX;
      }
      get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
      }
      get identifier() {
        if (__privateGet(this, _ID) === void 0)
          __privateSet(this, _ID, crypto3.hash160(this.publicKey));
        return __privateGet(this, _ID);
      }
      get fingerprint() {
        return this.identifier.subarray(0, 4);
      }
      // Private === not neutered
      // Public === neutered
      isNeutered() {
        return this.__D === void 0;
      }
      neutered() {
        return new _BIP32(void 0, this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
      toBase58() {
        const network = this.network;
        const version2 = !this.isNeutered() ? network.bip32.private : network.bip32.public;
        const buffer2 = new Uint8Array(78);
        tools.writeUInt32(buffer2, 0, version2, "BE");
        tools.writeUInt8(buffer2, 4, this.depth);
        tools.writeUInt32(buffer2, 5, this.parentFingerprint, "BE");
        tools.writeUInt32(buffer2, 9, this.index, "BE");
        buffer2.set(this.chainCode, 13);
        if (!this.isNeutered()) {
          tools.writeUInt8(buffer2, 45, 0);
          buffer2.set(this.privateKey, 46);
        } else {
          buffer2.set(this.publicKey, 45);
        }
        return bs58check2.encode(buffer2);
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
      derive(index) {
        if (index !== index >>> 0)
          throw new TypeError("Expected UInt32, got " + index);
        const isHardened = index >= HIGHEST_BIT;
        const data = new Uint8Array(37);
        if (isHardened) {
          if (this.isNeutered())
            throw new TypeError("Missing private key for hardened child key");
          data[0] = 0;
          data.set(this.privateKey, 1);
          tools.writeUInt32(data, 33, index, "BE");
        } else {
          data.set(this.publicKey, 0);
          tools.writeUInt32(data, 33, index, "BE");
        }
        const I2 = crypto3.hmacSHA512(this.chainCode, data);
        const IL = I2.slice(0, 32);
        const IR = I2.slice(32);
        if (!lib.isPrivate(IL))
          return this.derive(index + 1);
        const parentFp = tools.readUInt32(this.fingerprint, 0, "BE");
        const nextDepth = this.depth + 1;
        if (!this.isNeutered()) {
          const ki = lib.privateAdd(this.privateKey, IL);
          if (ki == null)
            return this.derive(index + 1);
          return new _BIP32(ki, void 0, IR, this.network, nextDepth, index, parentFp);
        } else {
          const Ki = lib.pointAddScalar(this.publicKey, IL, true);
          if (Ki === null)
            return this.derive(index + 1);
          return new _BIP32(void 0, Ki, IR, this.network, nextDepth, index, parentFp);
        }
      }
      deriveHardened(index) {
        if (!Number.isInteger(index) || index < 0 || index > 2147483647)
          throw new TypeError("Expected UInt31, got " + index);
        return this.derive(index + HIGHEST_BIT);
      }
      derivePath(path) {
        (0, types_js_1.validateBip32Path)(path);
        let splitPath = path.split("/");
        if (splitPath[0] === "m") {
          if (this.parentFingerprint)
            throw new TypeError("Expected master, got child");
          splitPath = splitPath.slice(1);
        }
        return splitPath.reduce((prevHd, indexStr) => {
          let index;
          if (indexStr.slice(-1) === `'`) {
            index = parseInt(indexStr.slice(0, -1), 10);
            return prevHd.deriveHardened(index);
          } else {
            index = parseInt(indexStr, 10);
            return prevHd.derive(index);
          }
        }, this);
      }
    };
    _ID = new WeakMap();
    let BIP32 = _BIP32;
    function fromBase58(inString, network) {
      const buffer2 = bs58check2.decode(inString);
      if (buffer2.length !== 78)
        throw new TypeError("Invalid buffer length");
      network = network || networks_js_1.BITCOIN;
      const version2 = tools.readUInt32(buffer2, 0, "BE");
      if (version2 !== network.bip32.private && version2 !== network.bip32.public)
        throw new TypeError("Invalid network version");
      const depth = buffer2[4];
      const parentFingerprint = tools.readUInt32(buffer2, 5, "BE");
      if (depth === 0) {
        if (parentFingerprint !== 0)
          throw new TypeError("Invalid parent fingerprint");
      }
      const index = tools.readUInt32(buffer2, 9, "BE");
      if (depth === 0 && index !== 0)
        throw new TypeError("Invalid index");
      const chainCode = buffer2.slice(13, 45);
      let hd;
      if (version2 === network.bip32.private) {
        if (buffer2[45] !== 0)
          throw new TypeError("Invalid private key");
        const k = buffer2.slice(46, 78);
        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
      } else {
        const X2 = buffer2.slice(45, 78);
        hd = fromPublicKeyLocal(X2, chainCode, network, depth, index, parentFingerprint);
      }
      return hd;
    }
    function fromPrivateKey(privateKey, chainCode, network) {
      return fromPrivateKeyLocal(privateKey, chainCode, network);
    }
    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
      (0, types_js_1.validateBytes32)(privateKey);
      (0, types_js_1.validateBytes32)(chainCode);
      network = network || networks_js_1.BITCOIN;
      if (!lib.isPrivate(privateKey))
        throw new TypeError("Private key not in range [1, n)");
      return new BIP32(privateKey, void 0, chainCode, network, depth, index, parentFingerprint);
    }
    function fromPublicKey(publicKey, chainCode, network) {
      return fromPublicKeyLocal(publicKey, chainCode, network);
    }
    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
      (0, types_js_1.validateBytes33)(publicKey);
      (0, types_js_1.validateBytes32)(chainCode);
      network = network || networks_js_1.BITCOIN;
      if (!lib.isPoint(publicKey))
        throw new TypeError("Point is not on the curve");
      return new BIP32(void 0, publicKey, chainCode, network, depth, index, parentFingerprint);
    }
    function fromSeed(seed, network) {
      if (!(seed instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (seed.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
      if (seed.length > 64)
        throw new TypeError("Seed should be at most 512 bits");
      network = network || networks_js_1.BITCOIN;
      const I2 = crypto3.hmacSHA512(BITCOIN_SEED, seed);
      const IL = I2.slice(0, 32);
      const IR = I2.slice(32);
      return fromPrivateKey(IL, IR, network);
    }
    function fromPrecomputed(privateKey, publicKey, chainCode, depth, index, parentFingerprint, network) {
      return new BIP32(privateKey, publicKey, chainCode, network || networks_js_1.BITCOIN, depth, index, parentFingerprint);
    }
    return {
      fromSeed,
      fromBase58,
      fromPublicKey,
      fromPrivateKey,
      fromPrecomputed
    };
  }
  return bip32$1;
}
var quantum = {};
var mldsa = {};
var randomBytes2 = randomBytes;
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a.length; i2++)
    diff |= a[i2] ^ b[i2];
  return diff === 0;
}
function copyBytes2(bytes) {
  return Uint8Array.from(bytes);
}
function validateOpts(opts) {
  if (typeof opts !== "object" || opts === null || isBytes(opts))
    throw new Error("expected opts to be an object");
}
function validateVerOpts(opts) {
  validateOpts(opts);
  if (opts.context !== void 0)
    abytes(opts.context, void 0, "opts.context");
}
function validateSigOpts2(opts) {
  validateVerOpts(opts);
  if (opts.extraEntropy !== false && opts.extraEntropy !== void 0)
    abytes(opts.extraEntropy, void 0, "opts.extraEntropy");
}
function splitCoder(label, ...lengths2) {
  const getLength = (c) => typeof c === "number" ? c : c.bytesLen;
  const bytesLen = lengths2.reduce((sum, a) => sum + getLength(a), 0);
  return {
    bytesLen,
    encode: (bufs) => {
      const res = new Uint8Array(bytesLen);
      for (let i2 = 0, pos = 0; i2 < lengths2.length; i2++) {
        const c = lengths2[i2];
        const l = getLength(c);
        const b = typeof c === "number" ? bufs[i2] : c.encode(bufs[i2]);
        abytes(b, l, label);
        res.set(b, pos);
        if (typeof c !== "number")
          b.fill(0);
        pos += l;
      }
      return res;
    },
    decode: (buf) => {
      abytes(buf, bytesLen, label);
      const res = [];
      for (const c of lengths2) {
        const l = getLength(c);
        const b = buf.subarray(0, l);
        res.push(typeof c === "number" ? b : c.decode(b));
        buf = buf.subarray(l);
      }
      return res;
    }
  };
}
function vecCoder(c, vecLen) {
  const bytesLen = vecLen * c.bytesLen;
  return {
    bytesLen,
    encode: (u) => {
      if (u.length !== vecLen)
        throw new Error(`vecCoder.encode: wrong length=${u.length}. Expected: ${vecLen}`);
      const res = new Uint8Array(bytesLen);
      for (let i2 = 0, pos = 0; i2 < u.length; i2++) {
        const b = c.encode(u[i2]);
        res.set(b, pos);
        b.fill(0);
        pos += b.length;
      }
      return res;
    },
    decode: (a) => {
      abytes(a, bytesLen);
      const r2 = [];
      for (let i2 = 0; i2 < a.length; i2 += c.bytesLen)
        r2.push(c.decode(a.subarray(i2, i2 + c.bytesLen)));
      return r2;
    }
  };
}
function cleanBytes(...list) {
  for (const t2 of list) {
    if (Array.isArray(t2))
      for (const b of t2)
        b.fill(0);
    else
      t2.fill(0);
  }
}
function getMask(bits) {
  return (1 << bits) - 1;
}
var EMPTY = Uint8Array.of();
function getMessage(msg, ctx = EMPTY) {
  abytes(msg);
  abytes(ctx);
  if (ctx.length > 255)
    throw new Error("context should be less than 255 bytes");
  return concatBytes(new Uint8Array([0, ctx.length]), ctx, msg);
}
var oidNistP = Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2]);
function checkHash(hash2, requiredStrength = 0) {
  if (!hash2.oid || !equalBytes(hash2.oid.subarray(0, 10), oidNistP))
    throw new Error("hash.oid is invalid: expected NIST hash");
  const collisionResistance = hash2.outputLen * 8 / 2;
  if (requiredStrength > collisionResistance) {
    throw new Error("Pre-hash security strength too low: " + collisionResistance + ", required: " + requiredStrength);
  }
}
function getMessagePrehash(hash2, msg, ctx = EMPTY) {
  abytes(msg);
  abytes(ctx);
  if (ctx.length > 255)
    throw new Error("context should be less than 255 bytes");
  const hashed = hash2(msg);
  return concatBytes(new Uint8Array([1, ctx.length]), ctx, hash2.oid, hashed);
}
var utils2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  EMPTY,
  abytes,
  checkHash,
  cleanBytes,
  concatBytes,
  copyBytes: copyBytes2,
  equalBytes,
  getMask,
  getMessage,
  getMessagePrehash,
  randomBytes: randomBytes2,
  splitCoder,
  validateOpts,
  validateSigOpts: validateSigOpts2,
  validateVerOpts,
  vecCoder
}, Symbol.toStringTag, { value: "Module" }));
var require$$0$2 = getAugmentedNamespace(utils2);
var config = {};
var genCrystals = (opts) => {
  const { newPoly: newPoly2, N: N2, Q: Q2, F: F2, ROOT_OF_UNITY: ROOT_OF_UNITY2, brvBits } = opts;
  const mod3 = (a, modulo2 = Q2) => {
    const result = a % modulo2 | 0;
    return (result >= 0 ? result | 0 : modulo2 + result | 0) | 0;
  };
  const smod2 = (a, modulo2 = Q2) => {
    const r2 = mod3(a, modulo2) | 0;
    return (r2 > modulo2 >> 1 ? r2 - modulo2 | 0 : r2) | 0;
  };
  function getZettas() {
    const out = newPoly2(N2);
    for (let i2 = 0; i2 < N2; i2++) {
      const b = reverseBits(i2, brvBits);
      const p = BigInt(ROOT_OF_UNITY2) ** BigInt(b) % BigInt(Q2);
      out[i2] = Number(p) | 0;
    }
    return out;
  }
  const nttZetas = getZettas();
  const field = {
    add: (a, b) => mod3((a | 0) + (b | 0)) | 0,
    sub: (a, b) => mod3((a | 0) - (b | 0)) | 0,
    mul: (a, b) => mod3((a | 0) * (b | 0)) | 0,
    inv: (_a5) => {
      throw new Error("not implemented");
    }
  };
  const nttOpts = {
    N: N2,
    roots: nttZetas,
    invertButterflies: true,
    skipStages: 0,
    brp: false
  };
  const dif = FFTCore(field, { dit: false, ...nttOpts });
  const dit = FFTCore(field, { dit: true, ...nttOpts });
  const NTT2 = {
    encode: (r2) => {
      return dif(r2);
    },
    decode: (r2) => {
      dit(r2);
      for (let i2 = 0; i2 < r2.length; i2++)
        r2[i2] = mod3(F2 * r2[i2]);
      return r2;
    }
  };
  const bitsCoder2 = (d, c) => {
    const mask = getMask(d);
    const bytesLen = d * (N2 / 8);
    return {
      bytesLen,
      encode: (poly) => {
        const r2 = new Uint8Array(bytesLen);
        for (let i2 = 0, buf = 0, bufLen = 0, pos = 0; i2 < poly.length; i2++) {
          buf |= (c.encode(poly[i2]) & mask) << bufLen;
          bufLen += d;
          for (; bufLen >= 8; bufLen -= 8, buf >>= 8)
            r2[pos++] = buf & getMask(bufLen);
        }
        return r2;
      },
      decode: (bytes) => {
        const r2 = newPoly2(N2);
        for (let i2 = 0, buf = 0, bufLen = 0, pos = 0; i2 < bytes.length; i2++) {
          buf |= bytes[i2] << bufLen;
          bufLen += 8;
          for (; bufLen >= d; bufLen -= d, buf >>= d)
            r2[pos++] = c.decode(buf & mask);
        }
        return r2;
      }
    };
  };
  return { mod: mod3, smod: smod2, nttZetas, NTT: NTT2, bitsCoder: bitsCoder2 };
};
var createXofShake = (shake) => (seed, blockLen) => {
  if (!blockLen)
    blockLen = shake.blockLen;
  const _seed = new Uint8Array(seed.length + 2);
  _seed.set(seed);
  const seedLen = seed.length;
  const buf = new Uint8Array(blockLen);
  let h = shake.create({});
  let calls = 0;
  let xofs = 0;
  return {
    stats: () => ({ calls, xofs }),
    get: (x, y) => {
      _seed[seedLen + 0] = x;
      _seed[seedLen + 1] = y;
      h.destroy();
      h = shake.create({}).update(_seed);
      calls++;
      return () => {
        xofs++;
        return h.xofInto(buf);
      };
    },
    clean: () => {
      h.destroy();
      cleanBytes(buf, _seed);
    }
  };
};
var XOF128 = createXofShake(shake128);
var XOF256 = createXofShake(shake256);
function validateInternalOpts(opts) {
  validateOpts(opts);
  if (opts.externalMu !== void 0)
    abool(opts.externalMu, "opts.externalMu");
}
var N = 256;
var Q = 8380417;
var ROOT_OF_UNITY = 1753;
var F = 8347681;
var D = 13;
var GAMMA2_1 = Math.floor((Q - 1) / 88) | 0;
var GAMMA2_2 = Math.floor((Q - 1) / 32) | 0;
var PARAMS = {
  2: { K: 4, L: 4, D, GAMMA1: 2 ** 17, GAMMA2: GAMMA2_1, TAU: 39, ETA: 2, OMEGA: 80 },
  3: { K: 6, L: 5, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 49, ETA: 4, OMEGA: 55 },
  5: { K: 8, L: 7, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 60, ETA: 2, OMEGA: 75 }
};
var newPoly = (n2) => new Int32Array(n2);
var { mod: mod2, smod, NTT, bitsCoder } = genCrystals({
  N,
  Q,
  F,
  ROOT_OF_UNITY,
  newPoly,
  brvBits: 8
});
var id = (n2) => n2;
var polyCoder = (d, compress = id, verify = id) => bitsCoder(d, {
  encode: (i2) => compress(verify(i2)),
  decode: (i2) => verify(compress(i2))
});
var polyAdd = (a, b) => {
  for (let i2 = 0; i2 < a.length; i2++)
    a[i2] = mod2(a[i2] + b[i2]);
  return a;
};
var polySub = (a, b) => {
  for (let i2 = 0; i2 < a.length; i2++)
    a[i2] = mod2(a[i2] - b[i2]);
  return a;
};
var polyShiftl = (p) => {
  for (let i2 = 0; i2 < N; i2++)
    p[i2] <<= D;
  return p;
};
var polyChknorm = (p, B) => {
  for (let i2 = 0; i2 < N; i2++)
    if (Math.abs(smod(p[i2])) >= B)
      return true;
  return false;
};
var MultiplyNTTs = (a, b) => {
  const c = newPoly(N);
  for (let i2 = 0; i2 < a.length; i2++)
    c[i2] = mod2(a[i2] * b[i2]);
  return c;
};
function RejNTTPoly(xof) {
  const r2 = newPoly(N);
  for (let j = 0; j < N; ) {
    const b = xof();
    if (b.length % 3)
      throw new Error("RejNTTPoly: unaligned block");
    for (let i2 = 0; j < N && i2 <= b.length - 3; i2 += 3) {
      const t2 = (b[i2 + 0] | b[i2 + 1] << 8 | b[i2 + 2] << 16) & 8388607;
      if (t2 < Q)
        r2[j++] = t2;
    }
  }
  return r2;
}
function getDilithium(opts) {
  const { K: K2, L: L3, GAMMA1, GAMMA2, TAU, ETA, OMEGA } = opts;
  const { CRH_BYTES, TR_BYTES, C_TILDE_BYTES, XOF128: XOF1282, XOF256: XOF2562, securityLevel } = opts;
  if (![2, 4].includes(ETA))
    throw new Error("Wrong ETA");
  if (![1 << 17, 1 << 19].includes(GAMMA1))
    throw new Error("Wrong GAMMA1");
  if (![GAMMA2_1, GAMMA2_2].includes(GAMMA2))
    throw new Error("Wrong GAMMA2");
  const BETA = TAU * ETA;
  const decompose = (r2) => {
    const rPlus = mod2(r2);
    const r0 = smod(rPlus, 2 * GAMMA2) | 0;
    if (rPlus - r0 === Q - 1)
      return { r1: 0 | 0, r0: r0 - 1 | 0 };
    const r1 = Math.floor((rPlus - r0) / (2 * GAMMA2)) | 0;
    return { r1, r0 };
  };
  const HighBits = (r2) => decompose(r2).r1;
  const LowBits = (r2) => decompose(r2).r0;
  const MakeHint = (z2, r2) => {
    const res0 = z2 <= GAMMA2 || z2 > Q - GAMMA2 || z2 === Q - GAMMA2 && r2 === 0 ? 0 : 1;
    return res0;
  };
  const UseHint = (h, r2) => {
    const m = Math.floor((Q - 1) / (2 * GAMMA2));
    const { r1, r0 } = decompose(r2);
    if (h === 1)
      return r0 > 0 ? mod2(r1 + 1, m) | 0 : mod2(r1 - 1, m) | 0;
    return r1 | 0;
  };
  const Power2Round = (r2) => {
    const rPlus = mod2(r2);
    const r0 = smod(rPlus, 2 ** D) | 0;
    return { r1: Math.floor((rPlus - r0) / 2 ** D) | 0, r0 };
  };
  const hintCoder = {
    bytesLen: OMEGA + K2,
    encode: (h) => {
      if (h === false)
        throw new Error("hint.encode: hint is false");
      const res = new Uint8Array(OMEGA + K2);
      for (let i2 = 0, k = 0; i2 < K2; i2++) {
        for (let j = 0; j < N; j++)
          if (h[i2][j] !== 0)
            res[k++] = j;
        res[OMEGA + i2] = k;
      }
      return res;
    },
    decode: (buf) => {
      const h = [];
      let k = 0;
      for (let i2 = 0; i2 < K2; i2++) {
        const hi = newPoly(N);
        if (buf[OMEGA + i2] < k || buf[OMEGA + i2] > OMEGA)
          return false;
        for (let j = k; j < buf[OMEGA + i2]; j++) {
          if (j > k && buf[j] <= buf[j - 1])
            return false;
          hi[buf[j]] = 1;
        }
        k = buf[OMEGA + i2];
        h.push(hi);
      }
      for (let j = k; j < OMEGA; j++)
        if (buf[j] !== 0)
          return false;
      return h;
    }
  };
  const ETACoder = polyCoder(ETA === 2 ? 3 : 4, (i2) => ETA - i2, (i2) => {
    if (!(-ETA <= i2 && i2 <= ETA))
      throw new Error(`malformed key s1/s3 ${i2} outside of ETA range [${-ETA}, ${ETA}]`);
    return i2;
  });
  const T0Coder = polyCoder(13, (i2) => (1 << D - 1) - i2);
  const T1Coder = polyCoder(10);
  const ZCoder = polyCoder(GAMMA1 === 1 << 17 ? 18 : 20, (i2) => smod(GAMMA1 - i2));
  const W1Coder = polyCoder(GAMMA2 === GAMMA2_1 ? 6 : 4);
  const W1Vec = vecCoder(W1Coder, K2);
  const publicCoder = splitCoder("publicKey", 32, vecCoder(T1Coder, K2));
  const secretCoder = splitCoder("secretKey", 32, 32, TR_BYTES, vecCoder(ETACoder, L3), vecCoder(ETACoder, K2), vecCoder(T0Coder, K2));
  const sigCoder = splitCoder("signature", C_TILDE_BYTES, vecCoder(ZCoder, L3), hintCoder);
  const CoefFromHalfByte = ETA === 2 ? (n2) => n2 < 15 ? 2 - n2 % 5 : false : (n2) => n2 < 9 ? 4 - n2 : false;
  function RejBoundedPoly(xof) {
    const r2 = newPoly(N);
    for (let j = 0; j < N; ) {
      const b = xof();
      for (let i2 = 0; j < N && i2 < b.length; i2 += 1) {
        const d1 = CoefFromHalfByte(b[i2] & 15);
        const d2 = CoefFromHalfByte(b[i2] >> 4 & 15);
        if (d1 !== false)
          r2[j++] = d1;
        if (j < N && d2 !== false)
          r2[j++] = d2;
      }
    }
    return r2;
  }
  const SampleInBall = (seed) => {
    const pre = newPoly(N);
    const s = shake256.create({}).update(seed);
    const buf = new Uint8Array(shake256.blockLen);
    s.xofInto(buf);
    const masks = buf.slice(0, 8);
    for (let i2 = N - TAU, pos = 8, maskPos = 0, maskBit = 0; i2 < N; i2++) {
      let b = i2 + 1;
      for (; b > i2; ) {
        b = buf[pos++];
        if (pos < shake256.blockLen)
          continue;
        s.xofInto(buf);
        pos = 0;
      }
      pre[i2] = pre[b];
      pre[b] = 1 - ((masks[maskPos] >> maskBit++ & 1) << 1);
      if (maskBit >= 8) {
        maskPos++;
        maskBit = 0;
      }
    }
    return pre;
  };
  const polyPowerRound = (p) => {
    const res0 = newPoly(N);
    const res1 = newPoly(N);
    for (let i2 = 0; i2 < p.length; i2++) {
      const { r0, r1 } = Power2Round(p[i2]);
      res0[i2] = r0;
      res1[i2] = r1;
    }
    return { r0: res0, r1: res1 };
  };
  const polyUseHint = (u, h) => {
    for (let i2 = 0; i2 < N; i2++)
      u[i2] = UseHint(h[i2], u[i2]);
    return u;
  };
  const polyMakeHint = (a, b) => {
    const v = newPoly(N);
    let cnt = 0;
    for (let i2 = 0; i2 < N; i2++) {
      const h = MakeHint(a[i2], b[i2]);
      v[i2] = h;
      cnt += h;
    }
    return { v, cnt };
  };
  const signRandBytes = 32;
  const seedCoder = splitCoder("seed", 32, 64, 32);
  const internal2 = {
    info: { type: "internal-ml-dsa" },
    lengths: {
      secretKey: secretCoder.bytesLen,
      publicKey: publicCoder.bytesLen,
      seed: 32,
      signature: sigCoder.bytesLen,
      signRand: signRandBytes
    },
    keygen: (seed) => {
      const seedDst = new Uint8Array(32 + 2);
      const randSeed = seed === void 0;
      if (randSeed)
        seed = randomBytes2(32);
      abytes(seed, 32, "seed");
      seedDst.set(seed);
      if (randSeed)
        cleanBytes(seed);
      seedDst[32] = K2;
      seedDst[33] = L3;
      const [rho, rhoPrime, K_] = seedCoder.decode(shake256(seedDst, { dkLen: seedCoder.bytesLen }));
      const xofPrime = XOF2562(rhoPrime);
      const s1 = [];
      for (let i2 = 0; i2 < L3; i2++)
        s1.push(RejBoundedPoly(xofPrime.get(i2 & 255, i2 >> 8 & 255)));
      const s2 = [];
      for (let i2 = L3; i2 < L3 + K2; i2++)
        s2.push(RejBoundedPoly(xofPrime.get(i2 & 255, i2 >> 8 & 255)));
      const s1Hat = s1.map((i2) => NTT.encode(i2.slice()));
      const t0 = [];
      const t1 = [];
      const xof = XOF1282(rho);
      const t2 = newPoly(N);
      for (let i2 = 0; i2 < K2; i2++) {
        cleanBytes(t2);
        for (let j = 0; j < L3; j++) {
          const aij = RejNTTPoly(xof.get(j, i2));
          polyAdd(t2, MultiplyNTTs(aij, s1Hat[j]));
        }
        NTT.decode(t2);
        const { r0, r1 } = polyPowerRound(polyAdd(t2, s2[i2]));
        t0.push(r0);
        t1.push(r1);
      }
      const publicKey = publicCoder.encode([rho, t1]);
      const tr2 = shake256(publicKey, { dkLen: TR_BYTES });
      const secretKey = secretCoder.encode([rho, K_, tr2, s1, s2, t0]);
      xof.clean();
      xofPrime.clean();
      cleanBytes(rho, rhoPrime, K_, s1, s2, s1Hat, t2, t0, t1, tr2, seedDst);
      return { publicKey, secretKey };
    },
    getPublicKey: (secretKey) => {
      const [rho, _K, _tr, s1, s2, _t0] = secretCoder.decode(secretKey);
      const xof = XOF1282(rho);
      const s1Hat = s1.map((p) => NTT.encode(p.slice()));
      const t1 = [];
      const tmp = newPoly(N);
      for (let i2 = 0; i2 < K2; i2++) {
        tmp.fill(0);
        for (let j = 0; j < L3; j++) {
          const aij = RejNTTPoly(xof.get(j, i2));
          polyAdd(tmp, MultiplyNTTs(aij, s1Hat[j]));
        }
        NTT.decode(tmp);
        polyAdd(tmp, s2[i2]);
        const { r1 } = polyPowerRound(tmp);
        t1.push(r1);
      }
      xof.clean();
      cleanBytes(tmp, s1Hat, _t0, s1, s2);
      return publicCoder.encode([rho, t1]);
    },
    // NOTE: random is optional.
    sign: (msg, secretKey, opts2 = {}) => {
      validateSigOpts2(opts2);
      validateInternalOpts(opts2);
      let { extraEntropy: random, externalMu = false } = opts2;
      const [rho, _K, tr2, s1, s2, t0] = secretCoder.decode(secretKey);
      const A = [];
      const xof = XOF1282(rho);
      for (let i2 = 0; i2 < K2; i2++) {
        const pv = [];
        for (let j = 0; j < L3; j++)
          pv.push(RejNTTPoly(xof.get(j, i2)));
        A.push(pv);
      }
      xof.clean();
      for (let i2 = 0; i2 < L3; i2++)
        NTT.encode(s1[i2]);
      for (let i2 = 0; i2 < K2; i2++) {
        NTT.encode(s2[i2]);
        NTT.encode(t0[i2]);
      }
      const mu = externalMu ? msg : shake256.create({ dkLen: CRH_BYTES }).update(tr2).update(msg).digest();
      const rnd = random === false ? new Uint8Array(32) : random === void 0 ? randomBytes2(signRandBytes) : random;
      abytes(rnd, 32, "extraEntropy");
      const rhoprime = shake256.create({ dkLen: CRH_BYTES }).update(_K).update(rnd).update(mu).digest();
      abytes(rhoprime, CRH_BYTES);
      const x256 = XOF2562(rhoprime, ZCoder.bytesLen);
      main_loop: for (let kappa = 0; ; ) {
        const y = [];
        for (let i2 = 0; i2 < L3; i2++, kappa++)
          y.push(ZCoder.decode(x256.get(kappa & 255, kappa >> 8)()));
        const z2 = y.map((i2) => NTT.encode(i2.slice()));
        const w2 = [];
        for (let i2 = 0; i2 < K2; i2++) {
          const wi = newPoly(N);
          for (let j = 0; j < L3; j++)
            polyAdd(wi, MultiplyNTTs(A[i2][j], z2[j]));
          NTT.decode(wi);
          w2.push(wi);
        }
        const w1 = w2.map((j) => j.map(HighBits));
        const cTilde = shake256.create({ dkLen: C_TILDE_BYTES }).update(mu).update(W1Vec.encode(w1)).digest();
        const cHat = NTT.encode(SampleInBall(cTilde));
        const cs1 = s1.map((i2) => MultiplyNTTs(i2, cHat));
        for (let i2 = 0; i2 < L3; i2++) {
          polyAdd(NTT.decode(cs1[i2]), y[i2]);
          if (polyChknorm(cs1[i2], GAMMA1 - BETA))
            continue main_loop;
        }
        let cnt = 0;
        const h = [];
        for (let i2 = 0; i2 < K2; i2++) {
          const cs2 = NTT.decode(MultiplyNTTs(s2[i2], cHat));
          const r0 = polySub(w2[i2], cs2).map(LowBits);
          if (polyChknorm(r0, GAMMA2 - BETA))
            continue main_loop;
          const ct0 = NTT.decode(MultiplyNTTs(t0[i2], cHat));
          if (polyChknorm(ct0, GAMMA2))
            continue main_loop;
          polyAdd(r0, ct0);
          const hint = polyMakeHint(r0, w1[i2]);
          h.push(hint.v);
          cnt += hint.cnt;
        }
        if (cnt > OMEGA)
          continue;
        x256.clean();
        const res = sigCoder.encode([cTilde, cs1, h]);
        cleanBytes(cTilde, cs1, h, cHat, w1, w2, z2, y, rhoprime, mu, s1, s2, t0, ...A);
        return res;
      }
      throw new Error("Unreachable code path reached, report this error");
    },
    verify: (sig, msg, publicKey, opts2 = {}) => {
      validateInternalOpts(opts2);
      const { externalMu = false } = opts2;
      const [rho, t1] = publicCoder.decode(publicKey);
      const tr2 = shake256(publicKey, { dkLen: TR_BYTES });
      if (sig.length !== sigCoder.bytesLen)
        return false;
      const [cTilde, z2, h] = sigCoder.decode(sig);
      if (h === false)
        return false;
      for (let i2 = 0; i2 < L3; i2++)
        if (polyChknorm(z2[i2], GAMMA1 - BETA))
          return false;
      const mu = externalMu ? msg : shake256.create({ dkLen: CRH_BYTES }).update(tr2).update(msg).digest();
      const c = NTT.encode(SampleInBall(cTilde));
      const zNtt = z2.map((i2) => i2.slice());
      for (let i2 = 0; i2 < L3; i2++)
        NTT.encode(zNtt[i2]);
      const wTick1 = [];
      const xof = XOF1282(rho);
      for (let i2 = 0; i2 < K2; i2++) {
        const ct12d = MultiplyNTTs(NTT.encode(polyShiftl(t1[i2])), c);
        const Az = newPoly(N);
        for (let j = 0; j < L3; j++) {
          const aij = RejNTTPoly(xof.get(j, i2));
          polyAdd(Az, MultiplyNTTs(aij, zNtt[j]));
        }
        const wApprox = NTT.decode(polySub(Az, ct12d));
        wTick1.push(polyUseHint(wApprox, h[i2]));
      }
      xof.clean();
      const c2 = shake256.create({ dkLen: C_TILDE_BYTES }).update(mu).update(W1Vec.encode(wTick1)).digest();
      for (const t2 of h) {
        const sum = t2.reduce((acc, i2) => acc + i2, 0);
        if (!(sum <= OMEGA))
          return false;
      }
      for (const t2 of z2)
        if (polyChknorm(t2, GAMMA1 - BETA))
          return false;
      return equalBytes(cTilde, c2);
    }
  };
  return {
    info: { type: "ml-dsa" },
    internal: internal2,
    securityLevel,
    keygen: internal2.keygen,
    lengths: internal2.lengths,
    getPublicKey: internal2.getPublicKey,
    sign: (msg, secretKey, opts2 = {}) => {
      validateSigOpts2(opts2);
      const M2 = getMessage(msg, opts2.context);
      const res = internal2.sign(M2, secretKey, opts2);
      cleanBytes(M2);
      return res;
    },
    verify: (sig, msg, publicKey, opts2 = {}) => {
      validateVerOpts(opts2);
      return internal2.verify(sig, getMessage(msg, opts2.context), publicKey);
    },
    prehash: (hash2) => {
      checkHash(hash2, securityLevel);
      return {
        info: { type: "hashml-dsa" },
        securityLevel,
        lengths: internal2.lengths,
        keygen: internal2.keygen,
        getPublicKey: internal2.getPublicKey,
        sign: (msg, secretKey, opts2 = {}) => {
          validateSigOpts2(opts2);
          const M2 = getMessagePrehash(hash2, msg, opts2.context);
          const res = internal2.sign(M2, secretKey, opts2);
          cleanBytes(M2);
          return res;
        },
        verify: (sig, msg, publicKey, opts2 = {}) => {
          validateVerOpts(opts2);
          return internal2.verify(sig, getMessagePrehash(hash2, msg, opts2.context), publicKey);
        }
      };
    }
  };
}
var ml_dsa44 = getDilithium({
  ...PARAMS[2],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 32,
  XOF128,
  XOF256,
  securityLevel: 128
});
var ml_dsa65 = getDilithium({
  ...PARAMS[3],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 48,
  XOF128,
  XOF256,
  securityLevel: 192
});
var ml_dsa87 = getDilithium({
  ...PARAMS[5],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 64,
  XOF128,
  XOF256,
  securityLevel: 256
});
var mlDsa = Object.freeze(Object.defineProperty({
  __proto__: null,
  PARAMS,
  ml_dsa44,
  ml_dsa65,
  ml_dsa87
}, Symbol.toStringTag, { value: "Module" }));
var require$$0$1 = getAugmentedNamespace(mlDsa);
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig) return config;
  hasRequiredConfig = 1;
  Object.defineProperty(config, "__esModule", { value: true });
  config.DEFAULT_SECURITY_LEVEL = config.MLDSASecurityLevel = void 0;
  config.getMLDSAConfig = getMLDSAConfig;
  config.findNetworkByVersion = findNetworkByVersion;
  const ml_dsa_js_1 = require$$0$1;
  const networks_js_1 = requireNetworks();
  var MLDSASecurityLevel;
  (function(MLDSASecurityLevel2) {
    MLDSASecurityLevel2[MLDSASecurityLevel2["LEVEL2"] = 44] = "LEVEL2";
    MLDSASecurityLevel2[MLDSASecurityLevel2["LEVEL3"] = 65] = "LEVEL3";
    MLDSASecurityLevel2[MLDSASecurityLevel2["LEVEL5"] = 87] = "LEVEL5";
  })(MLDSASecurityLevel || (config.MLDSASecurityLevel = MLDSASecurityLevel = {}));
  const BASE_CONFIGS = {
    [MLDSASecurityLevel.LEVEL2]: {
      level: MLDSASecurityLevel.LEVEL2,
      privateKeySize: 2560,
      publicKeySize: 1312,
      signatureSize: 2420,
      algorithm: ml_dsa_js_1.ml_dsa44
    },
    [MLDSASecurityLevel.LEVEL3]: {
      level: MLDSASecurityLevel.LEVEL3,
      privateKeySize: 4032,
      publicKeySize: 1952,
      signatureSize: 3309,
      algorithm: ml_dsa_js_1.ml_dsa65
    },
    [MLDSASecurityLevel.LEVEL5]: {
      level: MLDSASecurityLevel.LEVEL5,
      privateKeySize: 4896,
      publicKeySize: 2592,
      signatureSize: 4627,
      algorithm: ml_dsa_js_1.ml_dsa87
    }
  };
  config.DEFAULT_SECURITY_LEVEL = MLDSASecurityLevel.LEVEL2;
  function getMLDSAConfig(level2, network) {
    const baseConfig = BASE_CONFIGS[level2];
    if (!baseConfig) {
      throw new TypeError(`Invalid ML-DSA security level: ${level2}. Must be MLDSASecurityLevel.LEVEL2 (44), LEVEL3 (65), or LEVEL5 (87)`);
    }
    return {
      ...baseConfig,
      network
    };
  }
  function findNetworkByVersion(version2) {
    const commonNetworks = [networks_js_1.BITCOIN, networks_js_1.TESTNET, networks_js_1.REGTEST];
    for (const network of commonNetworks) {
      if (version2 === network.bip32.private) {
        return { network, isPrivate: true };
      }
      if (version2 === network.bip32.public) {
        return { network, isPrivate: false };
      }
    }
    return null;
  }
  return config;
}
var hasRequiredMldsa;
function requireMldsa() {
  var _ID;
  if (hasRequiredMldsa) return mldsa;
  hasRequiredMldsa = 1;
  var __createBinding = mldsa && mldsa.__createBinding || (Object.create ? (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  }) : (function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  }));
  var __setModuleDefault = mldsa && mldsa.__setModuleDefault || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
    o["default"] = v;
  });
  var __importStar = mldsa && mldsa.__importStar || /* @__PURE__ */ (function() {
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar2 = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar2[ar2.length] = k;
        return ar2;
      };
      return ownKeys(o);
    };
    return function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k = ownKeys(mod3), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod3, k[i2]);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
  })();
  Object.defineProperty(mldsa, "__esModule", { value: true });
  mldsa.QuantumBIP32Factory = void 0;
  const utils_js_1 = require$$0$2;
  const crypto3 = __importStar(requireCrypto2());
  const tools = __importStar(require$$2$1);
  const types_js_1 = requireTypes$1();
  const bs58check2 = __importStar(require$$4$2);
  const config_js_1 = requireConfig();
  const networks_js_1 = requireNetworks();
  const CHAIN_CODE_SIZE = 32;
  const HIGHEST_BIT = 2147483648;
  const BITCOIN_SEED = tools.fromUtf8("Bitcoin seed");
  class QuantumBip32Signer {
    constructor(_privateKey, _publicKey, config2) {
      __publicField(this, "_privateKey");
      __publicField(this, "_publicKey");
      __publicField(this, "config");
      this._privateKey = _privateKey;
      this._publicKey = _publicKey;
      this.config = config2;
    }
    get publicKey() {
      if (!this._publicKey) {
        throw new Error("Public key not available");
      }
      return this._publicKey;
    }
    get privateKey() {
      return this._privateKey;
    }
    sign(hash2) {
      if (!this._privateKey) {
        throw new Error("Missing private key");
      }
      const signature2 = this.config.algorithm.sign(hash2, this._privateKey, {
        extraEntropy: (0, utils_js_1.randomBytes)(32)
      });
      return signature2;
    }
    verify(hash2, signature2) {
      return this.config.algorithm.verify(signature2, hash2, this._publicKey);
    }
  }
  const _QuantumBIP32 = class _QuantumBIP32 extends QuantumBip32Signer {
    constructor(_privateKey, _publicKey, chainCode, config2, _depth = 0, _index = 0, _parentFingerprint = 0) {
      super(_privateKey, _publicKey, config2);
      __publicField(this, "chainCode");
      __publicField(this, "_depth");
      __publicField(this, "_index");
      __publicField(this, "_parentFingerprint");
      __privateAdd(this, _ID);
      this.chainCode = chainCode;
      this._depth = _depth;
      this._index = _index;
      this._parentFingerprint = _parentFingerprint;
    }
    get depth() {
      return this._depth;
    }
    get index() {
      return this._index;
    }
    get parentFingerprint() {
      return this._parentFingerprint;
    }
    get identifier() {
      if (__privateGet(this, _ID) === void 0)
        __privateSet(this, _ID, crypto3.hash160(this.publicKey));
      return __privateGet(this, _ID);
    }
    get fingerprint() {
      return this.identifier.subarray(0, 4);
    }
    get securityLevel() {
      return this.config.level;
    }
    get network() {
      return this.config.network;
    }
    isNeutered() {
      return this._privateKey === void 0;
    }
    neutered() {
      return new _QuantumBIP32(void 0, this.publicKey, this.chainCode, this.config, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const version2 = !this.isNeutered() ? this.config.network.bip32.private : this.config.network.bip32.public;
      const isPrivate = !this.isNeutered();
      const keySize = isPrivate ? this.config.privateKeySize : this.config.publicKeySize;
      const bufferSize = 4 + 1 + 4 + 4 + 32 + keySize;
      const buffer2 = new Uint8Array(bufferSize);
      let offset = 0;
      tools.writeUInt32(buffer2, offset, version2, "BE");
      offset += 4;
      tools.writeUInt8(buffer2, offset, this.depth);
      offset += 1;
      tools.writeUInt32(buffer2, offset, this.parentFingerprint, "BE");
      offset += 4;
      tools.writeUInt32(buffer2, offset, this.index, "BE");
      offset += 4;
      buffer2.set(this.chainCode, offset);
      offset += 32;
      if (isPrivate) {
        buffer2.set(this._privateKey, offset);
      } else {
        buffer2.set(this._publicKey, offset);
      }
      return bs58check2.encode(buffer2);
    }
    /**
     * Derive a child key using BIP32 HMAC chain for seed derivation,
     * then ML-DSA for key generation
     */
    derive(index) {
      if (index !== index >>> 0)
        throw new TypeError("Expected UInt32, got " + index);
      if (this.isNeutered()) {
        throw new TypeError("Cannot derive child keys without private key");
      }
      const isHardened = index >= HIGHEST_BIT;
      let data;
      if (isHardened) {
        const privateKeyHash = crypto3.hash256(this._privateKey);
        data = new Uint8Array(1 + 32 + 4);
        data[0] = 0;
        data.set(privateKeyHash, 1);
        tools.writeUInt32(data, 33, index, "BE");
      } else {
        const privateKeyHash = crypto3.hash256(this._privateKey);
        data = new Uint8Array(32 + 4);
        data.set(privateKeyHash, 0);
        tools.writeUInt32(data, 32, index, "BE");
      }
      const I2 = crypto3.hmacSHA512(this.chainCode, data);
      const IL = I2.slice(0, 32);
      const IR = I2.slice(32);
      const { secretKey: privateKey, publicKey } = this.config.algorithm.keygen(IL);
      return new _QuantumBIP32(privateKey, publicKey, IR, this.config, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, "BE"));
    }
    deriveHardened(index) {
      if (!Number.isInteger(index) || index < 0 || index > 2147483647)
        throw new TypeError("Expected UInt31, got " + index);
      return this.derive(index + HIGHEST_BIT);
    }
    derivePath(path) {
      (0, types_js_1.validateBip32Path)(path);
      let splitPath = path.split("/");
      if (splitPath[0] === "m") {
        if (this.parentFingerprint) {
          throw new TypeError("Expected master, got child");
        }
        splitPath = splitPath.slice(1);
      }
      return splitPath.reduce((prevHd, indexStr) => {
        let index;
        if (indexStr.slice(-1) === `'`) {
          index = parseInt(indexStr.slice(0, -1), 10);
          return prevHd.deriveHardened(index);
        } else {
          index = parseInt(indexStr, 10);
          return prevHd.derive(index);
        }
      }, this);
    }
  };
  _ID = new WeakMap();
  let QuantumBIP32 = _QuantumBIP32;
  function fromSeed(seed, network, securityLevel) {
    if (!(seed instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (seed.length < 16) {
      throw new TypeError("Seed should be at least 128 bits");
    }
    if (seed.length > 64) {
      throw new TypeError("Seed should be at most 512 bits");
    }
    const config2 = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
    const I2 = crypto3.hmacSHA512(BITCOIN_SEED, seed);
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    const { secretKey: privateKey, publicKey } = config2.algorithm.keygen(IL);
    return new QuantumBIP32(
      privateKey,
      publicKey,
      IR,
      // Chain code
      config2,
      0,
      // depth
      0,
      // index
      0
    );
  }
  function fromBase58(inString) {
    const buffer2 = bs58check2.decode(inString);
    const version2 = tools.readUInt32(buffer2, 0, "BE");
    const match = (0, config_js_1.findNetworkByVersion)(version2);
    if (!match) {
      throw new TypeError("Unknown network version");
    }
    const { network, isPrivate } = match;
    const headerSize = 4 + 1 + 4 + 4 + 32;
    const keyDataSize = buffer2.length - headerSize;
    let securityLevel;
    if (isPrivate) {
      if (keyDataSize === 2560) {
        securityLevel = config_js_1.MLDSASecurityLevel.LEVEL2;
      } else if (keyDataSize === 4032) {
        securityLevel = config_js_1.MLDSASecurityLevel.LEVEL3;
      } else if (keyDataSize === 4896) {
        securityLevel = config_js_1.MLDSASecurityLevel.LEVEL5;
      } else {
        throw new TypeError(`Invalid private key size: ${keyDataSize}`);
      }
    } else {
      if (keyDataSize === 1312) {
        securityLevel = config_js_1.MLDSASecurityLevel.LEVEL2;
      } else if (keyDataSize === 1952) {
        securityLevel = config_js_1.MLDSASecurityLevel.LEVEL3;
      } else if (keyDataSize === 2592) {
        securityLevel = config_js_1.MLDSASecurityLevel.LEVEL5;
      } else {
        throw new TypeError(`Invalid public key size: ${keyDataSize}`);
      }
    }
    const config2 = (0, config_js_1.getMLDSAConfig)(securityLevel, network);
    const expectedSize = isPrivate ? 4 + 1 + 4 + 4 + 32 + config2.privateKeySize : 4 + 1 + 4 + 4 + 32 + config2.publicKeySize;
    if (buffer2.length !== expectedSize) {
      throw new TypeError(`Invalid buffer length: expected ${expectedSize}, got ${buffer2.length}`);
    }
    let offset = 4;
    const depth = buffer2[offset];
    offset += 1;
    const parentFingerprint = tools.readUInt32(buffer2, offset, "BE");
    if (depth === 0 && parentFingerprint !== 0) {
      throw new TypeError("Invalid parent fingerprint");
    }
    offset += 4;
    const index = tools.readUInt32(buffer2, offset, "BE");
    if (depth === 0 && index !== 0) {
      throw new TypeError("Invalid index");
    }
    offset += 4;
    const chainCode = buffer2.slice(offset, offset + 32);
    offset += 32;
    if (isPrivate) {
      const privateKey = buffer2.slice(offset, offset + config2.privateKeySize);
      const publicKey = config2.algorithm.getPublicKey(privateKey);
      return new QuantumBIP32(privateKey, publicKey, chainCode, config2, depth, index, parentFingerprint);
    } else {
      const publicKey = buffer2.slice(offset, offset + config2.publicKeySize);
      return new QuantumBIP32(void 0, publicKey, chainCode, config2, depth, index, parentFingerprint);
    }
  }
  function fromPublicKey(publicKey, chainCode, network, securityLevel) {
    const config2 = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
    if (publicKey.length !== config2.publicKeySize) {
      throw new TypeError(`Invalid public key length for ML-DSA-${securityLevel}: expected ${config2.publicKeySize}, got ${publicKey.length}`);
    }
    if (chainCode.length !== CHAIN_CODE_SIZE) {
      throw new TypeError(`Invalid chain code length: expected ${CHAIN_CODE_SIZE}, got ${chainCode.length}`);
    }
    return new QuantumBIP32(void 0, publicKey, chainCode, config2, 0, 0, 0);
  }
  function fromPrivateKey(privateKey, chainCode, network, securityLevel) {
    const config2 = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
    if (privateKey.length !== config2.privateKeySize) {
      throw new TypeError(`Invalid private key length for ML-DSA-${securityLevel}: expected ${config2.privateKeySize}, got ${privateKey.length}`);
    }
    if (chainCode.length !== CHAIN_CODE_SIZE) {
      throw new TypeError(`Invalid chain code length: expected ${CHAIN_CODE_SIZE}, got ${chainCode.length}`);
    }
    const publicKey = config2.algorithm.getPublicKey(privateKey);
    return new QuantumBIP32(privateKey, publicKey, chainCode, config2, 0, 0, 0);
  }
  function fromKeyPair(privateKey, publicKey, chainCode, network, securityLevel) {
    const config2 = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
    if (privateKey.length !== config2.privateKeySize) {
      throw new TypeError(`Invalid private key length for ML-DSA-${securityLevel}: expected ${config2.privateKeySize}, got ${privateKey.length}`);
    }
    if (publicKey.length !== config2.publicKeySize) {
      throw new TypeError(`Invalid public key length for ML-DSA-${securityLevel}: expected ${config2.publicKeySize}, got ${publicKey.length}`);
    }
    if (chainCode.length !== CHAIN_CODE_SIZE) {
      throw new TypeError(`Invalid chain code length: expected ${CHAIN_CODE_SIZE}, got ${chainCode.length}`);
    }
    return new QuantumBIP32(privateKey, publicKey, chainCode, config2, 0, 0, 0);
  }
  function fromPrecomputed(privateKey, publicKey, chainCode, depth, index, parentFingerprint, network, securityLevel) {
    const config2 = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
    return new QuantumBIP32(privateKey, publicKey, chainCode, config2, depth, index, parentFingerprint);
  }
  mldsa.QuantumBIP32Factory = {
    fromSeed,
    fromBase58,
    fromPublicKey,
    fromPrivateKey,
    fromKeyPair,
    fromPrecomputed
  };
  return mldsa;
}
var hasRequiredQuantum;
function requireQuantum() {
  if (hasRequiredQuantum) return quantum;
  hasRequiredQuantum = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getMLDSAConfig = exports$1.DEFAULT_SECURITY_LEVEL = exports$1.MLDSASecurityLevel = exports$1.QuantumBIP32Factory = void 0;
    var mldsa_js_1 = requireMldsa();
    Object.defineProperty(exports$1, "QuantumBIP32Factory", { enumerable: true, get: function() {
      return mldsa_js_1.QuantumBIP32Factory;
    } });
    var config_js_1 = requireConfig();
    Object.defineProperty(exports$1, "MLDSASecurityLevel", { enumerable: true, get: function() {
      return config_js_1.MLDSASecurityLevel;
    } });
    Object.defineProperty(exports$1, "DEFAULT_SECURITY_LEVEL", { enumerable: true, get: function() {
      return config_js_1.DEFAULT_SECURITY_LEVEL;
    } });
    Object.defineProperty(exports$1, "getMLDSAConfig", { enumerable: true, get: function() {
      return config_js_1.getMLDSAConfig;
    } });
  })(quantum);
  return quantum;
}
var derivationPaths = {};
var hasRequiredDerivationPaths;
function requireDerivationPaths() {
  if (hasRequiredDerivationPaths) return derivationPaths;
  hasRequiredDerivationPaths = 1;
  Object.defineProperty(derivationPaths, "__esModule", { value: true });
  derivationPaths.QuantumDerivationPath = derivationPaths.DerivationPath = void 0;
  derivationPaths.getQuantumPath = getQuantumPath;
  derivationPaths.getBitcoinPath = getBitcoinPath;
  var DerivationPath;
  (function(DerivationPath2) {
    DerivationPath2["BIP44"] = "m/44'/0'/0'/0/0";
    DerivationPath2["BIP49"] = "m/49'/0'/0'/0/0";
    DerivationPath2["BIP84"] = "m/84'/0'/0'/0/0";
    DerivationPath2["BIP86"] = "m/86'/0'/0'/0/0";
    DerivationPath2["BIP360"] = "m/360'/0'/0'/0/0";
  })(DerivationPath || (derivationPaths.DerivationPath = DerivationPath = {}));
  var QuantumDerivationPath;
  (function(QuantumDerivationPath2) {
    QuantumDerivationPath2["STANDARD"] = "m/360'/0'/0'/0/0";
    QuantumDerivationPath2["CHANGE"] = "m/360'/0'/0'/1/0";
    QuantumDerivationPath2["ACCOUNT_0_ADDRESS_0"] = "m/360'/0'/0'/0/0";
    QuantumDerivationPath2["ACCOUNT_0_ADDRESS_1"] = "m/360'/0'/0'/0/1";
    QuantumDerivationPath2["ACCOUNT_1_ADDRESS_0"] = "m/360'/1'/0'/0/0";
  })(QuantumDerivationPath || (derivationPaths.QuantumDerivationPath = QuantumDerivationPath = {}));
  function getQuantumPath(account = 0, addressIndex = 0, isChange = false) {
    const changeIndex = isChange ? 1 : 0;
    return `m/360'/${account}'/${changeIndex}'/${addressIndex}`;
  }
  function getBitcoinPath(bipType, account = 0, addressIndex = 0, isChange = false) {
    const changeIndex = isChange ? 1 : 0;
    return `m/${bipType}'/0'/${account}'/${changeIndex}/${addressIndex}`;
  }
  return derivationPaths;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.getBitcoinPath = exports$1.getQuantumPath = exports$1.QuantumDerivationPath = exports$1.DerivationPath = exports$1.getMLDSAConfig = exports$1.DEFAULT_SECURITY_LEVEL = exports$1.MLDSASecurityLevel = exports$1.QuantumBIP32Factory = exports$1.REGTEST = exports$1.TESTNET = exports$1.BITCOIN = exports$1.BIP32Factory = exports$1.default = void 0;
    var bip32_js_1 = requireBip32();
    Object.defineProperty(exports$1, "default", { enumerable: true, get: function() {
      return bip32_js_1.BIP32Factory;
    } });
    Object.defineProperty(exports$1, "BIP32Factory", { enumerable: true, get: function() {
      return bip32_js_1.BIP32Factory;
    } });
    var networks_js_1 = requireNetworks();
    Object.defineProperty(exports$1, "BITCOIN", { enumerable: true, get: function() {
      return networks_js_1.BITCOIN;
    } });
    Object.defineProperty(exports$1, "TESTNET", { enumerable: true, get: function() {
      return networks_js_1.TESTNET;
    } });
    Object.defineProperty(exports$1, "REGTEST", { enumerable: true, get: function() {
      return networks_js_1.REGTEST;
    } });
    var index_js_1 = requireQuantum();
    Object.defineProperty(exports$1, "QuantumBIP32Factory", { enumerable: true, get: function() {
      return index_js_1.QuantumBIP32Factory;
    } });
    Object.defineProperty(exports$1, "MLDSASecurityLevel", { enumerable: true, get: function() {
      return index_js_1.MLDSASecurityLevel;
    } });
    Object.defineProperty(exports$1, "DEFAULT_SECURITY_LEVEL", { enumerable: true, get: function() {
      return index_js_1.DEFAULT_SECURITY_LEVEL;
    } });
    Object.defineProperty(exports$1, "getMLDSAConfig", { enumerable: true, get: function() {
      return index_js_1.getMLDSAConfig;
    } });
    var derivation_paths_js_1 = requireDerivationPaths();
    Object.defineProperty(exports$1, "DerivationPath", { enumerable: true, get: function() {
      return derivation_paths_js_1.DerivationPath;
    } });
    Object.defineProperty(exports$1, "QuantumDerivationPath", { enumerable: true, get: function() {
      return derivation_paths_js_1.QuantumDerivationPath;
    } });
    Object.defineProperty(exports$1, "getQuantumPath", { enumerable: true, get: function() {
      return derivation_paths_js_1.getQuantumPath;
    } });
    Object.defineProperty(exports$1, "getBitcoinPath", { enumerable: true, get: function() {
      return derivation_paths_js_1.getBitcoinPath;
    } });
  })(cjs);
  return cjs;
}
var cjsExports = requireCjs();
var bip32 = getDefaultExportFromCjs$1(cjsExports);
var BIP32factory = typeof bip32 === "function" ? bip32 : cjsExports.BIP32Factory;
if (!BIP32factory) {
  throw new Error("Failed to load BIP32 library");
}
var Point = secp256k1.Point;
var CURVE_N = Point.Fn.ORDER;
var TAP_TAG = new Uint8Array([84, 97, 112, 84, 119, 101, 97, 107]);
var TAP_TAG_HASH = sha256$1(TAP_TAG);
function tapTweakHash(x) {
  return sha256$1(concatBytes(TAP_TAG_HASH, TAP_TAG_HASH, x));
}
var _EcKeyPair = class _EcKeyPair {
  /**
   * Generate a keypair from a WIF
   * @param {string} wif - The WIF to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromWIF(wif, network = bitcoin$1) {
    return st.fromWIF(backend, wif, network);
  }
  /**
   * Generate a keypair from a private key
   * @param {Uint8Array} privateKey - The private key to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromPrivateKey(privateKey, network = bitcoin$1) {
    return st.fromPrivateKey(backend, privateKey, network);
  }
  /**
   * Generate a keypair from a public key
   * @param {Uint8Array} publicKey - The public key to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromPublicKey(publicKey, network = bitcoin$1) {
    return st.fromPublicKey(backend, publicKey, network);
  }
  /**
   * Generate a multi-sig address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(pubKeys, minimumSignatureRequired, network = bitcoin$1) {
    const publicKeys = this.verifyPubKeys(pubKeys, network);
    if (publicKeys.length !== pubKeys.length)
      throw new Error(`Contains invalid public keys`);
    const p2ms$1 = p2ms({
      m: minimumSignatureRequired,
      pubkeys: publicKeys,
      network
    });
    const p2wsh$1 = p2wsh({ redeem: p2ms$1, network });
    const address = p2wsh$1.address;
    if (!address) {
      throw new Error("Failed to generate address");
    }
    return address;
  }
  /**
   * Verify public keys and return the public keys
   * @param {Uint8Array[]} pubKeys - The public keys to verify
   * @param {Network} network - The network to use
   * @returns {Uint8Array[]} - The verified public keys
   * @throws {Error} - If the key cannot be regenerated
   */
  static verifyPubKeys(pubKeys, network = bitcoin$1) {
    return pubKeys.map((pubKey) => {
      const key = _EcKeyPair.fromPublicKey(pubKey, network);
      if (!key) {
        throw new Error("Failed to regenerate key");
      }
      return key.publicKey;
    });
  }
  /**
   * Get a P2WPKH address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The address
   */
  static getP2WPKHAddress(keyPair, network = bitcoin$1) {
    const res = p2wpkh({ pubkey: keyPair.publicKey, network });
    if (!res.address) {
      throw new Error("Failed to generate wallet");
    }
    return res.address;
  }
  /**
   * Get the address of a tweaked public key
   * @param {string} tweakedPubKeyHex - The tweaked public key hex string
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static tweakedPubKeyToAddress(tweakedPubKeyHex, network) {
    if (tweakedPubKeyHex.startsWith("0x")) {
      tweakedPubKeyHex = tweakedPubKeyHex.slice(2);
    }
    let tweakedPubKeyBuffer = fromHex$1(tweakedPubKeyHex);
    if (tweakedPubKeyBuffer.length !== 32) {
      tweakedPubKeyBuffer = toXOnly(tweakedPubKeyBuffer);
    }
    return _EcKeyPair.tweakedPubKeyBufferToAddress(tweakedPubKeyBuffer, network);
  }
  /**
   * Get the address of a tweaked public key
   * @param {Uint8Array} tweakedPubKeyBuffer - The tweaked public key buffer
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static tweakedPubKeyBufferToAddress(tweakedPubKeyBuffer, network) {
    const { address } = p2tr({
      pubkey: tweakedPubKeyBuffer,
      network
    });
    if (!address) {
      throw new Error("Failed to generate Taproot address");
    }
    return address;
  }
  /**
   * Generate a P2OP address
   * @param bytes - The bytes to use for the P2OP address
   * @param network - The network to use
   * @param deploymentVersion - The deployment version (default is 0)
   * @returns {string} - The generated P2OP address
   */
  static p2op(bytes, network = bitcoin$1, deploymentVersion = 0) {
    const witnessProgram = concat$1([
      new Uint8Array([deploymentVersion]),
      bitcoin.crypto.hash160(bytes)
    ]);
    if (witnessProgram.length < 2 || witnessProgram.length > 40) {
      throw new Error("Witness program must be 2-40 bytes.");
    }
    const scriptData = compile([opcodes.OP_16, witnessProgram]);
    return fromOutputScript(scriptData, network);
  }
  /**
   * Get the address of a xOnly tweaked public key
   * @param {string} tweakedPubKeyHex - The xOnly tweaked public key hex string
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static xOnlyTweakedPubKeyToAddress(tweakedPubKeyHex, network) {
    if (tweakedPubKeyHex.startsWith("0x")) {
      tweakedPubKeyHex = tweakedPubKeyHex.slice(2);
    }
    const tweakedPubKeyBuffer = fromHex$1(tweakedPubKeyHex);
    if (tweakedPubKeyBuffer.length !== 32) {
      throw new Error("Invalid xOnly public key length");
    }
    const { address } = p2tr({
      pubkey: tweakedPubKeyBuffer,
      network
    });
    if (!address) {
      throw new Error("Failed to generate Taproot address");
    }
    return address;
  }
  /**
   * Tweak a public key
   * @param {Uint8Array | string} pub - The public key to tweak
   * @returns {Uint8Array} - The tweaked public key
   * @throws {Error} - If the public key cannot be tweaked
   */
  static tweakPublicKey(pub) {
    if (typeof pub === "string" && pub.startsWith("0x"))
      pub = pub.slice(2);
    const hexStr = typeof pub === "string" ? pub : toHex$1(pub);
    const P2 = Point.fromHex(hexStr);
    const Peven = (P2.y & 1n) === 0n ? P2 : P2.negate();
    const xBytes = Peven.toBytes(true).subarray(1);
    const tBytes = tapTweakHash(xBytes);
    const t2 = mod(bytesToNumberBE(tBytes), CURVE_N);
    const Q2 = Peven.add(Point.BASE.multiply(t2));
    return Q2.toBytes(true);
  }
  /**
   * Tweak a batch of public keys
   * @param {readonly Uint8Array[]} pubkeys - The public keys to tweak
   * @param {bigint} tweakScalar - The scalar to use for tweaking
   * @returns {Uint8Array[]} - The tweaked public keys
   */
  static tweakBatchSharedT(pubkeys, tweakScalar) {
    const T = Point.BASE.multiply(tweakScalar);
    return pubkeys.map((bytes) => {
      const P2 = Point.fromHex(toHex$1(bytes));
      const P_even = P2.y % 2n === 0n ? P2 : P2.negate();
      const Q2 = P_even.add(T);
      return Q2.toBytes(true);
    });
  }
  /**
   * Generate a random wallet with both classical and quantum keys
   *
   * @param network - The network to use
   * @param securityLevel - The ML-DSA security level for quantum keys (default: LEVEL2/44)
   * @returns An object containing both classical and quantum key information
   */
  static generateWallet(network = bitcoin$1, securityLevel = cjsExports.MLDSASecurityLevel.LEVEL2) {
    const keyPair = st.makeRandom(backend, network, {
      rng: (size) => {
        return randomBytes(size);
      }
    });
    const wallet = this.getP2WPKHAddress(keyPair, network);
    if (!wallet) {
      throw new Error("Failed to generate wallet");
    }
    const quantumKeyPair = this.generateQuantumKeyPair(securityLevel, network);
    return {
      address: wallet,
      privateKey: keyPair.toWIF(),
      publicKey: toHex$1(keyPair.publicKey),
      quantumPrivateKey: toHex$1(quantumKeyPair.privateKey),
      quantumPublicKey: toHex$1(quantumKeyPair.publicKey)
    };
  }
  /**
   * Generate a random quantum ML-DSA keypair
   *
   * This creates a standalone quantum-resistant keypair without using BIP32 derivation.
   * The keys are generated using cryptographically secure random bytes.
   *
   * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
   * @param network - The Bitcoin network (default: bitcoin mainnet)
   * @returns A random ML-DSA keypair
   */
  static generateQuantumKeyPair(securityLevel = cjsExports.MLDSASecurityLevel.LEVEL2, network = bitcoin$1) {
    const randomSeed = randomBytes(64);
    const quantumRoot = cjsExports.QuantumBIP32Factory.fromSeed(randomSeed, network, securityLevel);
    if (!quantumRoot.privateKey || !quantumRoot.publicKey) {
      throw new Error("Failed to generate quantum keypair");
    }
    return {
      privateKey: new Uint8Array(quantumRoot.privateKey),
      publicKey: new Uint8Array(quantumRoot.publicKey)
    };
  }
  /**
   * Verify that a contract address is a valid p2tr address
   * @param {string} contractAddress - The contract address to verify
   * @param {Network} network - The network to use
   * @returns {boolean} - Whether the address is valid
   */
  static verifyContractAddress(contractAddress, network = bitcoin$1) {
    return !!toOutputScript(contractAddress, network);
  }
  /**
   * Get the legacy segwit address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getLegacySegwitAddress(keyPair, network = bitcoin$1) {
    const wallet = p2sh({
      redeem: p2wpkh({ pubkey: keyPair.publicKey, network }),
      network
    });
    if (!wallet.address) {
      throw new Error("Failed to generate wallet");
    }
    return wallet.address;
  }
  /**
   * Get the legacy address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getLegacyAddress(keyPair, network = bitcoin$1) {
    const wallet = p2pkh({ pubkey: keyPair.publicKey, network });
    if (!wallet.address) {
      throw new Error("Failed to generate wallet");
    }
    return wallet.address;
  }
  /**
   * Get the legacy address from a public key
   * @param publicKey
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getP2PKH(publicKey, network = bitcoin$1) {
    const wallet = p2pkh({ pubkey: publicKey, network });
    if (!wallet.address) {
      throw new Error("Failed to generate wallet");
    }
    return wallet.address;
  }
  /**
   * Get the P2PK output from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getP2PKAddress(keyPair, network = bitcoin$1) {
    const wallet = p2pk({ pubkey: keyPair.publicKey, network });
    if (!wallet.output) {
      throw new Error("Failed to generate wallet");
    }
    return "0x" + toHex$1(wallet.output);
  }
  /**
   * Generate a random keypair
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static generateRandomKeyPair(network = bitcoin$1) {
    return st.makeRandom(backend, network, {
      rng: (size) => {
        return randomBytes(size);
      }
    });
  }
  /**
   * Generate a BIP32 keypair from a seed
   * @param {Uint8Array} seed - The seed to generate the keypair from
   * @param {Network} network - The network to use
   * @returns {BIP32Interface} - The generated keypair
   */
  static fromSeed(seed, network = bitcoin$1) {
    return this.BIP32.fromSeed(seed, network);
  }
  /**
   * Get taproot address from keypair
   * @param {UniversalSigner | Signer} keyPair - The keypair to get the taproot address for
   * @param {Network} network - The network to use
   * @returns {string} - The taproot address
   */
  static getTaprootAddress(keyPair, network = bitcoin$1) {
    const { address } = p2tr({
      internalPubkey: toXOnly(keyPair.publicKey),
      network
    });
    if (!address) {
      throw new Error(`Failed to generate sender address for transaction`);
    }
    return address;
  }
  /**
   * Get taproot address from address
   * @param {string} inAddr - The address to convert to taproot
   * @param {Network} network - The network to use
   * @returns {string} - The taproot address
   */
  static getTaprootAddressFromAddress(inAddr, network = bitcoin$1) {
    const { address } = p2tr({
      address: inAddr,
      network
    });
    if (!address) {
      throw new Error(`Failed to generate sender address for transaction`);
    }
    return address;
  }
  /**
   * Get a keypair from a given seed.
   * @param {Uint8Array} seed - The seed to generate the key pair from
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated key pair
   */
  static fromSeedKeyPair(seed, network = bitcoin$1) {
    const fromSeed = this.BIP32.fromSeed(seed, network);
    const privKey = fromSeed.privateKey;
    if (!privKey)
      throw new Error("Failed to generate key pair");
    return st.fromPrivateKey(backend, privKey, network);
  }
};
__publicField(_EcKeyPair, "BIP32", BIP32factory(backend));
__publicField(_EcKeyPair, "ECPairSigner", st);
Point.BASE.precompute(8);
var EcKeyPair = _EcKeyPair;
var Features;
(function(Features2) {
  Features2[Features2["ACCESS_LIST"] = 1] = "ACCESS_LIST";
  Features2[Features2["EPOCH_SUBMISSION"] = 2] = "EPOCH_SUBMISSION";
  Features2[Features2["MLDSA_LINK_PUBKEY"] = 4] = "MLDSA_LINK_PUBKEY";
})(Features || (Features = {}));
var FeaturePriority;
(function(FeaturePriority2) {
  FeaturePriority2[FeaturePriority2["ACCESS_LIST"] = 1] = "ACCESS_LIST";
  FeaturePriority2[FeaturePriority2["EPOCH_SUBMISSION"] = 2] = "EPOCH_SUBMISSION";
  FeaturePriority2[FeaturePriority2["MLDSA_LINK_PUBKEY"] = 3] = "MLDSA_LINK_PUBKEY";
})(FeaturePriority || (FeaturePriority = {}));
var ADDRESS_BYTE_LENGTH = 32;
var EXTENDED_ADDRESS_BYTE_LENGTH = 64;
var SCHNORR_SIGNATURE_BYTE_LENGTH = 64;
var U256_BYTE_LENGTH = 32;
var U128_BYTE_LENGTH = 16;
var U64_BYTE_LENGTH = 8;
var U32_BYTE_LENGTH = 4;
var U16_BYTE_LENGTH = 2;
var U8_BYTE_LENGTH = 1;
var I128_BYTE_LENGTH = 16;
var I64_BYTE_LENGTH = 8;
var I32_BYTE_LENGTH = 4;
var I16_BYTE_LENGTH = 2;
var I8_BYTE_LENGTH = 1;
function assertArgument(check2, message, name, value) {
  {
    throw new Error(`${message} (${name}: ${value})`);
  }
}
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal = getGlobal();
anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha1":
      return sha1.create();
    case "sha256":
      return sha256$1.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
var hexPattern = /^[0-9a-fA-F]+$/;
var BitcoinUtils = class _BitcoinUtils {
  /**
   * Converts satoshi to BTC
   * @param {number} btc - The amount in BTC
   * @returns {bigint} The amount in satoshi
   */
  static btcToSatoshi(btc) {
    return BigInt(btc * 1e8);
  }
  /**
   * Generates random bytes.
   * @public
   * @returns {Uint8Array} The random bytes
   */
  static rndBytes() {
    return _BitcoinUtils.getSafeRandomValues(64);
  }
  static getSafeRandomValues(length) {
    if (typeof globalThis.window !== "undefined" && globalThis.window.crypto && typeof globalThis.window.crypto.getRandomValues === "function") {
      const array = new Uint8Array(length);
      window.crypto.getRandomValues(array);
      return array;
    } else if (globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
      const array = new Uint8Array(length);
      globalThis.crypto.getRandomValues(array);
      return array;
    } else {
      console.log(`No secure random number generator available. Please upgrade your environment.`, globalThis.window.crypto, globalThis.crypto);
      throw new Error("No secure random number generator available. Please upgrade your environment.");
    }
  }
  static isValidHex(hex) {
    return hexPattern.test(hex);
  }
  /**
   * Hashes the given data
   * @param {Uint8Array} data - The data to hash
   * @returns {string} The hashed data
   */
  static opnetHash(data) {
    const hashed = createHash("sha512");
    hashed.update(data);
    const hash2 = hashed.digest();
    return `0x${toHex$1(new Uint8Array(hash2))}`;
  }
};
var P2WDADetector = class {
  /**
   * Check if a UTXO is a P2WDA output by examining its script structure
   */
  static isP2WDAUTXO(utxo) {
    if (!utxo.witnessScript) {
      return false;
    }
    const witnessScript = utxo.witnessScript instanceof Uint8Array ? utxo.witnessScript : fromHex$1(utxo.witnessScript);
    return this.isP2WDAWitnessScript(witnessScript);
  }
  /**
   * Check if a witness script follows the P2WDA pattern
   */
  static isP2WDAWitnessScript(witnessScript) {
    try {
      const decompiled = decompile(witnessScript);
      if (!decompiled || decompiled.length !== 7) {
        return false;
      }
      for (let i2 = 0; i2 < 5; i2++) {
        if (decompiled[i2] !== opcodes.OP_2DROP) {
          return false;
        }
      }
      return decompiled[5] instanceof Uint8Array && decompiled[5].length === 33 && // Compressed public key
      decompiled[6] === opcodes.OP_CHECKSIG;
    } catch {
      return false;
    }
  }
  /**
   * Generate a P2WDA address from a public key
   */
  static generateP2WDAAddress(publicKey, network) {
    if (publicKey.length !== 33) {
      throw new Error("Public key must be 33 bytes (compressed)");
    }
    const witnessScript = compile([
      opcodes.OP_2DROP,
      opcodes.OP_2DROP,
      opcodes.OP_2DROP,
      opcodes.OP_2DROP,
      opcodes.OP_2DROP,
      publicKey,
      opcodes.OP_CHECKSIG
    ]);
    const p2wsh$1 = p2wsh({
      redeem: { output: witnessScript },
      network
    });
    if (!p2wsh$1.address || !p2wsh$1.output) {
      throw new Error("Failed to generate P2WDA address");
    }
    return {
      address: p2wsh$1.address,
      witnessScript,
      scriptPubKey: p2wsh$1.output
    };
  }
  /**
   * Extract the public key from a P2WDA witness script
   */
  static extractPublicKeyFromP2WDA(witnessScript) {
    try {
      const decompiled = decompile(witnessScript);
      if (!decompiled || decompiled.length !== 7) {
        return null;
      }
      for (let i2 = 0; i2 < 5; i2++) {
        if (decompiled[i2] !== opcodes.OP_2DROP) {
          return null;
        }
      }
      if (decompiled[5] instanceof Uint8Array && decompiled[5].length === 33 && decompiled[6] === opcodes.OP_CHECKSIG) {
        return decompiled[5];
      }
      return null;
    } catch {
      return null;
    }
  }
  /**
   * Create witness data for a simple P2WDA spend (no operation data)
   */
  static createSimpleP2WDAWitness(transactionSignature, witnessScript) {
    const witnessStack = [transactionSignature];
    for (let i2 = 0; i2 < 10; i2++) {
      witnessStack.push(new Uint8Array(0));
    }
    witnessStack.push(witnessScript);
    return witnessStack;
  }
  /**
   * Validate P2WDA operation data signature
   */
  static validateP2WDASignature(_publicKey, dataSignature, _operationData) {
    return dataSignature.length === 64;
  }
  /**
   * Calculate the witness size for P2WDA transaction estimation
   */
  static estimateP2WDAWitnessSize(dataSize = 0) {
    return 72 + dataSize + 39 + 12;
  }
  /**
   * Check if a scriptPubKey is a P2WSH that could be P2WDA
   */
  static couldBeP2WDA(scriptPubKey) {
    return scriptPubKey.length === 34 && scriptPubKey[0] === 0 && scriptPubKey[1] === 32;
  }
};
var AddressTypes;
(function(AddressTypes2) {
  AddressTypes2["P2PKH"] = "P2PKH";
  AddressTypes2["P2OP"] = "P2OP";
  AddressTypes2["P2SH_OR_P2SH_P2WPKH"] = "P2SH_OR_P2SH-P2WPKH";
  AddressTypes2["P2PK"] = "P2PK";
  AddressTypes2["P2TR"] = "P2TR";
  AddressTypes2["P2MR"] = "P2MR";
  AddressTypes2["P2WPKH"] = "P2WPKH";
  AddressTypes2["P2WSH"] = "P2WSH";
  AddressTypes2["P2WDA"] = "P2WDA";
})(AddressTypes || (AddressTypes = {}));
var AddressVerificator = class _AddressVerificator {
  static isValidP2TRAddress(inAddress, network) {
    if (!inAddress || inAddress.length < 50)
      return false;
    let isValidTapRootAddress = false;
    try {
      toOutputScript(inAddress, network);
      const decodedAddress = fromBech32(inAddress);
      isValidTapRootAddress = decodedAddress.version === 1;
    } catch {
    }
    return isValidTapRootAddress;
  }
  /**
   * Validates that the given address is a valid P2MR (BIP 360) address.
   * Checks for witness version 2 with a 32-byte Merkle root program.
   */
  static isValidP2MRAddress(inAddress, network) {
    if (!inAddress || inAddress.length < 50)
      return false;
    let isValidP2MR = false;
    try {
      toOutputScript(inAddress, network);
      const decodedAddress = fromBech32(inAddress);
      isValidP2MR = decodedAddress.version === 2 && decodedAddress.data.length === 32;
    } catch {
    }
    return isValidP2MR;
  }
  static isP2WPKHAddress(inAddress, network) {
    if (!inAddress || inAddress.length < 20 || inAddress.length > 50)
      return false;
    let isValidSegWitAddress = false;
    try {
      const decodedAddress = fromBech32(inAddress);
      toOutputScript(inAddress, network);
      isValidSegWitAddress = decodedAddress.version === 0 && decodedAddress.data.length === 20;
    } catch {
    }
    return isValidSegWitAddress;
  }
  static isP2WDAWitnessScript(witnessScript) {
    return P2WDADetector.isP2WDAWitnessScript(witnessScript);
  }
  static isP2PKHOrP2SH(addy, network) {
    try {
      const decodedBase58 = fromBase58Check(addy);
      if (decodedBase58.version === network.pubKeyHash) {
        return true;
      }
      return decodedBase58.version === network.scriptHash;
    } catch (error) {
      return false;
    }
  }
  static isValidPublicKey(input, network) {
    try {
      if (input.startsWith("0x")) {
        input = input.slice(2);
      }
      if (!BitcoinUtils.isValidHex(input)) {
        return false;
      }
      if (input.length === 64) {
        return true;
      }
      const pubKeyBuffer = fromHex$1(input);
      if (input.length === 130 && pubKeyBuffer[0] === 6 || pubKeyBuffer[0] === 7) {
        return true;
      }
      if (input.length === 66 || input.length === 130) {
        EcKeyPair.fromPublicKey(pubKeyBuffer, network);
        return true;
      }
    } catch (e) {
      return false;
    }
    return false;
  }
  static isValidMLDSAPublicKey(input) {
    try {
      let byteLength2;
      if (typeof input !== "string" && input instanceof Uint8Array) {
        byteLength2 = input.length;
      } else {
        if (input.startsWith("0x")) {
          input = input.slice(2);
        }
        if (!BitcoinUtils.isValidHex(input)) {
          return null;
        }
        byteLength2 = input.length / 2;
      }
      switch (byteLength2) {
        case 1312:
          return cjsExports.MLDSASecurityLevel.LEVEL2;
        case 1952:
          return cjsExports.MLDSASecurityLevel.LEVEL3;
        case 2592:
          return cjsExports.MLDSASecurityLevel.LEVEL5;
        default:
          return null;
      }
    } catch (e) {
      return null;
    }
  }
  static isValidP2OPAddress(inAddress, network) {
    if (!inAddress || inAddress.length < 20)
      return false;
    try {
      const decodedAddress = fromBech32(inAddress);
      const validPrefix = decodedAddress.prefix === network.bech32 || decodedAddress.prefix === network.bech32Opnet;
      if (!validPrefix) {
        return false;
      }
      return decodedAddress.version === 16 && decodedAddress.data.length === 21;
    } catch {
      return false;
    }
  }
  static requireRedeemScript(addy, network) {
    try {
      const decodedBase58 = fromBase58Check(addy);
      if (decodedBase58.version === network.pubKeyHash) {
        return false;
      }
      return decodedBase58.version === network.scriptHash;
    } catch {
      return false;
    }
  }
  static detectAddressType(addy, network) {
    if (_AddressVerificator.isValidPublicKey(addy, network)) {
      return AddressTypes.P2PK;
    }
    try {
      const decodedBase58 = fromBase58Check(addy);
      if (decodedBase58.version === network.pubKeyHash) {
        return AddressTypes.P2PKH;
      }
      if (decodedBase58.version === network.scriptHash) {
        return AddressTypes.P2SH_OR_P2SH_P2WPKH;
      }
    } catch {
    }
    try {
      const decodedBech32 = fromBech32(addy);
      if ((decodedBech32.prefix === network.bech32Opnet || decodedBech32.prefix === network.bech32) && decodedBech32.version === 16 && decodedBech32.data.length === 21) {
        return AddressTypes.P2OP;
      }
      if (decodedBech32.prefix === network.bech32) {
        if (decodedBech32.version === 0 && decodedBech32.data.length === 20) {
          return AddressTypes.P2WPKH;
        }
        if (decodedBech32.version === 0 && decodedBech32.data.length === 32) {
          return AddressTypes.P2WSH;
        }
        if (decodedBech32.version === 1 && decodedBech32.data.length === 32) {
          return AddressTypes.P2TR;
        }
        if (decodedBech32.version === 2 && decodedBech32.data.length === 32) {
          return AddressTypes.P2MR;
        }
      }
    } catch {
    }
    return null;
  }
  static detectAddressTypeWithWitnessScript(addy, network, witnessScript) {
    const baseType = _AddressVerificator.detectAddressType(addy, network);
    if (baseType === AddressTypes.P2WSH && witnessScript) {
      if (_AddressVerificator.isP2WDAWitnessScript(witnessScript)) {
        return AddressTypes.P2WDA;
      }
    }
    return baseType;
  }
  static validateP2WDAAddress(address, network, witnessScript) {
    try {
      const addressType = _AddressVerificator.detectAddressType(address, network);
      if (addressType !== AddressTypes.P2WSH) {
        return {
          isValid: false,
          isPotentiallyP2WDA: false,
          isDefinitelyP2WDA: false,
          error: "Not a P2WSH address"
        };
      }
      if (!witnessScript) {
        return {
          isValid: true,
          isPotentiallyP2WDA: true,
          isDefinitelyP2WDA: false
        };
      }
      if (!_AddressVerificator.isP2WDAWitnessScript(witnessScript)) {
        return {
          isValid: true,
          isPotentiallyP2WDA: true,
          isDefinitelyP2WDA: false,
          error: "Witness script does not match P2WDA pattern"
        };
      }
      const p2wsh$1 = p2wsh({
        redeem: { output: witnessScript },
        network
      });
      if (p2wsh$1.address !== address) {
        return {
          isValid: false,
          isPotentiallyP2WDA: false,
          isDefinitelyP2WDA: false,
          error: "Witness script does not match address"
        };
      }
      const publicKey = P2WDADetector.extractPublicKeyFromP2WDA(witnessScript);
      if (!publicKey) {
        return {
          isValid: false,
          isPotentiallyP2WDA: false,
          isDefinitelyP2WDA: false,
          error: "Failed to extract public key from witness script"
        };
      }
      return {
        isValid: true,
        isPotentiallyP2WDA: true,
        isDefinitelyP2WDA: true,
        publicKey
      };
    } catch (error) {
      return {
        isValid: false,
        isPotentiallyP2WDA: false,
        isDefinitelyP2WDA: false,
        error: error.message
      };
    }
  }
};
var P = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
var Secp256k1PointDeriver = class {
  constructor(maxTries = 1e4) {
    /**
     * The maximum increments to try before giving up on deriving a valid x.
     */
    __publicField(this, "maxTries");
    this.maxTries = maxTries;
  }
  /**
   * Main entry point.
   * Given a 32-byte input, ensures we obtain a "real" x on secp256k1.
   * - If the given x is valid, we use it.
   * - Otherwise, we increment x (mod p) until we find one whose (x^3 + 7) is a quadratic residue.
   * Then we return { x, y1, y2 } for that valid point.
   *
   * @param xBytes A 32-byte Uint8Array for the candidate x
   * @param failOnInvalidX (optional) whether to throw if the given x is not a valid curve point, defaults to true
   * @param maxTries (optional) number of increments to attempt, defaults to this.maxTries
   * @returns An object { x: bigint; y1: bigint; y2: bigint } describing a valid curve point
   * @throws If no valid x found within maxTries
   */
  findOrDeriveValidPoint(xBytes, failOnInvalidX = true, maxTries = this.maxTries) {
    if (xBytes.length !== 32) {
      throw new Error("xBytes must be exactly 32 bytes.");
    }
    let xCandidate = this.bytesToBigInt(xBytes) % P;
    let sqrtVal = this.isValidX(xCandidate);
    if (failOnInvalidX && sqrtVal === null) {
      throw new Error(`The given x is not a valid curve point.`);
    }
    let tries = 0;
    while (sqrtVal === null) {
      xCandidate = (xCandidate + 1n) % P;
      sqrtVal = this.isValidX(xCandidate);
      tries++;
      if (tries > maxTries) {
        throw new Error(`Could not find a valid X point within ${maxTries} increments.`);
      }
    }
    const y1 = sqrtVal;
    const y2 = (P - y1) % P;
    return { x: xCandidate, y1, y2 };
  }
  /**
   * Given two candidate y values, returns the one with the smaller y-coordinate.
   * @param {bigint} y
   * @param {bigint} y2
   */
  getCanonicalY(y, y2) {
    return y < y2 ? y : y2;
  }
  /**
   * Creates a 65-byte "hybrid public key" from the specified x and y.
   * - First byte:
   *   - 0x06 if y is even
   *   - 0x07 if y is odd
   * - Next 32 bytes: x
   * - Last 32 bytes: y
   *
   * @param x X-coordinate as a bigint
   * @param y Y-coordinate as a bigint
   * @returns A Uint8Array of length 65
   */
  getHybridPublicKey(x, y) {
    const prefix = y % 2n === 0n ? 6 : 7;
    const xBytes = this.bigIntTo32Bytes(x);
    const yBytes = this.bigIntTo32Bytes(y);
    const hybrid = new Uint8Array(65);
    hybrid[0] = prefix;
    hybrid.set(xBytes, 1);
    hybrid.set(yBytes, 33);
    return hybrid;
  }
  /**
   * Checks if (x^3 + 7) is a quadratic residue mod p.
   * Returns the square root if it is, or null if not.
   */
  isValidX(x) {
    const alpha = (this.modPow(x, 3n, P) + 7n) % P;
    return this.sqrtModP(alpha, P);
  }
  /**
   * Computes base^exp (mod m) using exponentiation by squaring.
   */
  modPow(base2, exp, m) {
    let result = 1n;
    let cur = base2 % m;
    let e = exp;
    while (e > 0) {
      if ((e & 1n) === 1n) {
        result = result * cur % m;
      }
      cur = cur * cur % m;
      e >>= 1n;
    }
    return result;
  }
  /**
   * sqrtModP(a, p):
   *   Attempts to compute the square root of `a` modulo prime `p`.
   *   Returns the root if it exists, or null if `a` is not a quadratic residue.
   *
   * Since p  3 (mod 4), we can do:
   *   sqrt(a) = a^((p+1)/4) mod p
   */
  sqrtModP(a, prime) {
    const root = this.modPow(a, prime + 1n >> 2n, prime);
    if (root * root % prime !== a % prime) {
      return null;
    }
    return root;
  }
  /**
   * Convert a 32-byte Uint8Array (big-endian) to a BigInt.
   */
  bytesToBigInt(bytes) {
    let b = 0n;
    for (const byte of bytes) {
      b = b << 8n | BigInt(byte);
    }
    return b;
  }
  /**
   * Convert a BigInt to a 32-byte array (big-endian).
   */
  bigIntTo32Bytes(value) {
    const bytes = new Uint8Array(32);
    for (let i2 = 31; i2 >= 0; i2--) {
      bytes[i2] = Number(value & 0xffn);
      value >>= 8n;
    }
    return bytes;
  }
};
var ContractAddressBase = class {
  constructor() {
    __publicField(this, "deriver", new Secp256k1PointDeriver());
  }
  generateHybridKeyFromHash(input) {
    const p = this.deriver.findOrDeriveValidPoint(new Uint8Array(input), false);
    const y = this.deriver.getCanonicalY(p.y1, p.y2);
    return new Uint8Array(this.deriver.getHybridPublicKey(p.x, y));
  }
};
var ContractAddress = new ContractAddressBase();
var _TimeLockGenerator = class _TimeLockGenerator {
  /**
   * Generate a P2WSH address with CSV timelock
   * Note: This uses ECDSA, not Schnorr (Schnorr only available in Taproot)
   */
  static generateTimeLockAddress(publicKey, network = bitcoin$1, csvBlocks = _TimeLockGenerator.CSV_BLOCKS) {
    const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
    const p2wsh2 = bitcoin.payments.p2wsh({
      redeem: { output: witnessScript },
      network
    });
    if (!p2wsh2.address) {
      throw new Error("Failed to generate P2WSH address");
    }
    return {
      address: p2wsh2.address,
      witnessScript
    };
  }
  /**
   * Generate a P2TR address with CSV time lock
   * Note: This uses Schnorr signatures
   */
  static generateTimeLockAddressP2TR(publicKey, network = bitcoin$1, csvBlocks = _TimeLockGenerator.CSV_BLOCKS) {
    if (publicKey.length !== 32) {
      throw new Error("Public key must be 32 bytes for Taproot");
    }
    const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
    const taproot = bitcoin.payments.p2tr({
      redeem: { output: witnessScript },
      network,
      internalPubkey: _TimeLockGenerator.UNSPENDABLE_INTERNAL_KEY
    });
    if (!taproot.address) {
      throw new Error("Failed to generate P2TR address");
    }
    return taproot.address;
  }
  /**
   * Generate a P2MR address with CSV time lock
   * Note: This uses Schnorr signatures within a P2MR (BIP 360) script tree
   */
  static generateTimeLockAddressP2MR(publicKey, network = bitcoin$1, csvBlocks = _TimeLockGenerator.CSV_BLOCKS) {
    if (publicKey.length !== 32) {
      throw new Error("Public key must be 32 bytes for P2MR");
    }
    const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
    const scriptTree = { output: witnessScript, version: 192 };
    const p2mr$1 = p2mr({ scriptTree, network });
    if (!p2mr$1.address) {
      throw new Error("Failed to generate P2MR address");
    }
    return p2mr$1.address;
  }
  static generateTimeLockScript(publicKey, csvBlocks = _TimeLockGenerator.CSV_BLOCKS) {
    return compile([
      number.encode(csvBlocks),
      opcodes.OP_CHECKSEQUENCEVERIFY,
      opcodes.OP_DROP,
      publicKey,
      opcodes.OP_CHECKSIG
    ]);
  }
};
__publicField(_TimeLockGenerator, "UNSPENDABLE_INTERNAL_KEY", fromHex$1("50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0"));
__publicField(_TimeLockGenerator, "CSV_BLOCKS", 75);
var TimeLockGenerator = _TimeLockGenerator;
var validMLDSALengths = [1312, 1952, 2592];
var _p2tr, _p2op, _network11, _originalPublicKey, _keyPair, _uncompressed, _tweakedUncompressed, _p2wda, _mldsaPublicKey, _cachedBigInt, _cachedBigIntTweaked, _cachedUint64Array, _originalMDLSAPublicKey, _mldsaLevel, _pendingLegacyKey, _legacyProcessed, _tweakedPublicKey;
var _Address = class _Address extends Uint8Array {
  constructor(mldsaPublicKey, publicKeyOrTweak) {
    super(ADDRESS_BYTE_LENGTH);
    __privateAdd(this, _p2tr);
    __privateAdd(this, _p2op);
    __privateAdd(this, _network11);
    __privateAdd(this, _originalPublicKey);
    __privateAdd(this, _keyPair);
    __privateAdd(this, _uncompressed);
    __privateAdd(this, _tweakedUncompressed);
    __privateAdd(this, _p2wda);
    __privateAdd(this, _mldsaPublicKey);
    __privateAdd(this, _cachedBigInt);
    __privateAdd(this, _cachedBigIntTweaked);
    __privateAdd(this, _cachedUint64Array);
    __privateAdd(this, _originalMDLSAPublicKey);
    __privateAdd(this, _mldsaLevel);
    // Lazy loading state - defers expensive EC operations until actually needed
    __privateAdd(this, _pendingLegacyKey);
    __privateAdd(this, _legacyProcessed, false);
    // After processing, this is 32-byte tweaked x-only (same as original behavior)
    __privateAdd(this, _tweakedPublicKey);
    if (!mldsaPublicKey) {
      return;
    }
    if (publicKeyOrTweak) {
      const validLengths = [ADDRESS_BYTE_LENGTH, 33, 65];
      if (!validLengths.includes(publicKeyOrTweak.length)) {
        throw new Error(`Invalid public key length ${publicKeyOrTweak.length}`);
      }
      __privateSet(this, _pendingLegacyKey, new Uint8Array(publicKeyOrTweak.length));
      __privateGet(this, _pendingLegacyKey).set(publicKeyOrTweak);
    }
    this.setMldsaKey(mldsaPublicKey);
  }
  /**
   * Prevent TypedArray methods (subarray, slice, etc.) from creating Address
   * instances. Without this, @noble/hashes and other libraries that call
   * subarray() on an Address would invoke the Address constructor that recomputes
   * everything leading to bad performance.
   */
  static get [Symbol.species]() {
    return Uint8Array;
  }
  get mldsaLevel() {
    return __privateGet(this, _mldsaLevel);
  }
  set mldsaLevel(level2) {
    __privateSet(this, _mldsaLevel, level2);
  }
  get originalMDLSAPublicKey() {
    return __privateGet(this, _originalMDLSAPublicKey);
  }
  set originalMDLSAPublicKey(key) {
    __privateSet(this, _originalMDLSAPublicKey, key ? new Uint8Array(key) : void 0);
  }
  /**
   * If available, this will return the original public key associated with the address.
   * @returns {Uint8Array} The original public key used to create the address.
   */
  get originalPublicKey() {
    this.ensureLegacyProcessed();
    return __privateGet(this, _originalPublicKey);
  }
  get mldsaPublicKey() {
    return __privateGet(this, _mldsaPublicKey);
  }
  /**
   * Get the legacy public key (32-byte tweaked x-only after processing).
   * Triggers lazy processing if not yet done.
   */
  get legacyPublicKey() {
    this.ensureLegacyProcessed();
    return __privateGet(this, _tweakedPublicKey);
  }
  /**
   * Get the key pair for the address
   * @description This is only for internal use. Please use address.tweakedBytes instead.
   */
  get keyPair() {
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _keyPair)) {
      throw new Error("Legacy public key not set for address");
    }
    return __privateGet(this, _keyPair);
  }
  static dead() {
    return _Address.fromString(
      "0x0000000000000000000000000000000000000000000000000000000000000000",
      // DEAD ADDRESS
      "0x04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"
    );
  }
  /**
   * Create an address from a hex string
   * @param {string} mldsaPublicKey The ml-dsa public key in hex format
   * @param {string} legacyPublicKey The classical public key in hex format
   * @returns {Address} The address
   */
  static fromString(mldsaPublicKey, legacyPublicKey) {
    if (!mldsaPublicKey) {
      throw new Error("Invalid public key");
    }
    if (mldsaPublicKey.startsWith("0x")) {
      mldsaPublicKey = mldsaPublicKey.slice(2);
    }
    if (!BitcoinUtils.isValidHex(mldsaPublicKey)) {
      throw new Error('You must only pass public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.');
    }
    let classicBuffer;
    if (legacyPublicKey) {
      if (legacyPublicKey.startsWith("0x")) {
        legacyPublicKey = legacyPublicKey.slice(2);
      }
      if (!BitcoinUtils.isValidHex(legacyPublicKey)) {
        throw new Error('You must only pass classical public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.');
      }
      classicBuffer = fromHex$1(legacyPublicKey);
    }
    return new _Address(fromHex$1(mldsaPublicKey), classicBuffer);
  }
  /**
   * Create an address from a public key
   * @returns {Address} The address
   * @param {ArrayLike<number>} bytes The public key
   */
  static wrap(bytes) {
    return new _Address(bytes);
  }
  static uncompressedToCompressed(publicKey) {
    const buffer2 = Uint8Array.from(publicKey);
    const x = buffer2.slice(1, 33);
    const y = buffer2.slice(33);
    const compressed = new Uint8Array(33);
    compressed[0] = 2 + (y[y.length - 1] & 1);
    compressed.set(x, 1);
    return compressed;
  }
  /**
   * Creates an Address instance from a BigInt value.
   *
   * Converts a 256-bit unsigned integer into a 32-byte address by splitting it
   * into four 64-bit chunks and writing them in big-endian format using DataView.
   * This is the inverse operation of toBigInt().
   *
   * @param {bigint} value - The 256-bit unsigned integer to convert (0 to 2^256-1)
   * @param {bigint} [tweakedValue] - Optional tweaked public key as a 256-bit unsigned integer
   * @returns {Address} A new Address instance containing the converted value
   *
   * @throws {RangeError} If the value is negative or exceeds 2^256-1
   *
   * @example
   * ```typescript
   * const bigIntValue = 12345678901234567890n;
   * const address = Address.fromBigInt(bigIntValue);
   * console.log(address.toHex()); // 0x0000000000000000000000000000000000000000000000000000abc123...
   * ```
   */
  static fromBigInt(value, tweakedValue) {
    const address = _Address.bigintToUint8Array(value);
    const legacyAddress = tweakedValue !== void 0 ? _Address.bigintToUint8Array(tweakedValue) : void 0;
    return new _Address(address, legacyAddress);
  }
  /**
   * Creates an Address instance from four 64-bit unsigned integers.
   *
   * Constructs a 32-byte address by combining four 64-bit big-endian unsigned integers.
   * This is the inverse operation of toUint64Array() and provides an efficient way
   * to create addresses from word-aligned data.
   *
   * @param {bigint} w0 - Most significant 64 bits (bytes 0-7)
   * @param {bigint} w1 - Second 64 bits (bytes 8-15)
   * @param {bigint} w2 - Third 64 bits (bytes 16-23)
   * @param {bigint} w3 - Least significant 64 bits (bytes 24-31)
   * @returns {Address} A new Address instance containing the combined value
   *
   * @throws {RangeError} If any value exceeds 64 bits (2^64-1)
   *
   * @example
   * ```typescript
   * const address = Address.fromUint64Array(
   *     0x0123456789abcdefn,
   *     0xfedcba9876543210n,
   *     0x1111222233334444n,
   *     0x5555666677778888n
   * );
   * console.log(address.toHex());
   * ```
   */
  static fromUint64Array(w0, w1, w2, w3) {
    const buffer2 = new Uint8Array(32);
    const view = new DataView(buffer2.buffer);
    view.setBigUint64(0, w0, false);
    view.setBigUint64(8, w1, false);
    view.setBigUint64(16, w2, false);
    view.setBigUint64(24, w3, false);
    return new _Address(buffer2);
  }
  static bigintToUint8Array(value) {
    const buffer2 = new Uint8Array(32);
    const view = new DataView(buffer2.buffer);
    view.setBigUint64(0, value >> 192n & 0xffffffffffffffffn, false);
    view.setBigUint64(8, value >> 128n & 0xffffffffffffffffn, false);
    view.setBigUint64(16, value >> 64n & 0xffffffffffffffffn, false);
    view.setBigUint64(24, value & 0xffffffffffffffffn, false);
    return buffer2;
  }
  [Symbol.dispose]() {
    var _a5, _b2;
    this.fill(0);
    __privateSet(this, _p2tr, void 0);
    __privateSet(this, _p2op, void 0);
    __privateSet(this, _network11, void 0);
    __privateSet(this, _originalPublicKey, void 0);
    __privateSet(this, _keyPair, void 0);
    __privateSet(this, _uncompressed, void 0);
    __privateSet(this, _tweakedUncompressed, void 0);
    __privateSet(this, _p2wda, void 0);
    (_a5 = __privateGet(this, _mldsaPublicKey)) == null ? void 0 : _a5.fill(0);
    __privateSet(this, _mldsaPublicKey, void 0);
    __privateSet(this, _cachedBigInt, void 0);
    __privateSet(this, _cachedBigIntTweaked, void 0);
    __privateSet(this, _cachedUint64Array, void 0);
    (_b2 = __privateGet(this, _originalMDLSAPublicKey)) == null ? void 0 : _b2.fill(0);
    __privateSet(this, _originalMDLSAPublicKey, void 0);
    __privateSet(this, _mldsaLevel, void 0);
    __privateSet(this, _legacyProcessed, false);
    __privateSet(this, _tweakedPublicKey, void 0);
  }
  /**
   * Converts the address to four 64-bit unsigned integers.
   *
   * Splits the 32-byte (256-bit) address into four 64-bit big-endian unsigned integers.
   * This representation is useful for efficient storage, comparison operations, or
   * interfacing with systems that work with 64-bit word sizes.
   *
   * @returns {[bigint, bigint, bigint, bigint]} An array of four 64-bit unsigned integers
   *          representing the address from most significant to least significant bits
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...');
   * const [w0, w1, w2, w3] = address.toUint64Array();
   * console.log(w0); // Most significant 64 bits
   * console.log(w3); // Least significant 64 bits
   * ```
   */
  toUint64Array() {
    if (__privateGet(this, _cachedUint64Array) !== void 0) {
      return __privateGet(this, _cachedUint64Array);
    }
    const view = new DataView(this.buffer, this.byteOffset, 32);
    __privateSet(this, _cachedUint64Array, [
      view.getBigUint64(0, false),
      view.getBigUint64(8, false),
      view.getBigUint64(16, false),
      view.getBigUint64(24, false)
    ]);
    return __privateGet(this, _cachedUint64Array);
  }
  /**
   * Check if the address is the dead address
   * @returns {boolean}
   */
  isDead() {
    for (let i2 = 0; i2 < ADDRESS_BYTE_LENGTH; i2++) {
      if (this[i2] !== 0) {
        return false;
      }
    }
    return true;
  }
  /**
   * Converts the address to a hex string
   * @returns {string} The hex string
   */
  toHex() {
    return "0x" + toHex$1(this);
  }
  /**
   * Converts the classical public key to a hex string
   * @returns {string} The hex string
   */
  tweakedToHex() {
    const key = this.legacyPublicKey;
    if (!key) {
      throw new Error("Legacy public key not set");
    }
    return "0x" + toHex$1(key);
  }
  /**
   * Converts the address content (SHA256 hash of ML-DSA public key) to a Uint8Array
   * @returns {Uint8Array} The Uint8Array containing the hashed ML-DSA public key
   */
  toBuffer() {
    return new Uint8Array(this);
  }
  /**
   * Converts the classical public key to a Uint8Array
   * @returns {Uint8Array} The Uint8Array
   */
  tweakedPublicKeyToBuffer() {
    const key = this.legacyPublicKey;
    if (!key) {
      throw new Error("Legacy public key not set");
    }
    return new Uint8Array(key);
  }
  toUncompressedHex() {
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _uncompressed)) {
      throw new Error("Legacy public key not set");
    }
    return "0x" + toHex$1(__privateGet(this, _uncompressed).uncompressed);
  }
  toUncompressedBuffer() {
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _uncompressed)) {
      throw new Error("Legacy public key not set");
    }
    return __privateGet(this, _uncompressed).uncompressed;
  }
  toHybridPublicKeyHex() {
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _uncompressed)) {
      throw new Error("Legacy public key not set");
    }
    return "0x" + toHex$1(__privateGet(this, _uncompressed).hybrid);
  }
  toHybridPublicKeyBuffer() {
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _uncompressed)) {
      throw new Error("Legacy public key not set");
    }
    return __privateGet(this, _uncompressed).hybrid;
  }
  originalPublicKeyBuffer() {
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _originalPublicKey)) {
      throw new Error("Legacy public key not set");
    }
    return new Uint8Array(__privateGet(this, _originalPublicKey));
  }
  /**
   * Converts the address to a BigInt representation.
   *
   * This method uses an optimized DataView approach to read the 32-byte address
   * as four 64-bit big-endian unsigned integers, then combines them using bitwise
   * operations. This is approximately 10-20x faster than string-based conversion.
   *
   * @returns {bigint} The address as a 256-bit unsigned integer
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...');
   * const bigIntValue = address.toBigInt();
   * console.log(bigIntValue); // 123456789...n
   * ```
   */
  toBigInt() {
    if (__privateGet(this, _cachedBigInt) !== void 0) {
      return __privateGet(this, _cachedBigInt);
    }
    const view = new DataView(this.buffer, this.byteOffset, 32);
    __privateSet(this, _cachedBigInt, view.getBigUint64(0, false) << 192n | view.getBigUint64(8, false) << 128n | view.getBigUint64(16, false) << 64n | view.getBigUint64(24, false));
    return __privateGet(this, _cachedBigInt);
  }
  /**
   * Converts the tweaked public key to a BigInt representation.
   *
   * This method uses an optimized DataView approach to read the 32-byte address
   * as four 64-bit big-endian unsigned integers, then combines them using bitwise
   * operations. This is approximately 10-20x faster than string-based conversion.
   *
   * @returns {bigint} The address as a 256-bit unsigned integer
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...', '0xtweaked...');
   * const bigIntValue = address.tweakedToBigInt();
   * console.log(bigIntValue); // 123456789...n
   * ```
   */
  tweakedToBigInt() {
    if (!this.legacyPublicKey) {
      throw new Error("Legacy public key not set");
    }
    if (__privateGet(this, _cachedBigIntTweaked) !== void 0) {
      return __privateGet(this, _cachedBigIntTweaked);
    }
    const view = new DataView(this.legacyPublicKey.buffer, this.byteOffset, 32);
    __privateSet(this, _cachedBigIntTweaked, view.getBigUint64(0, false) << 192n | view.getBigUint64(8, false) << 128n | view.getBigUint64(16, false) << 64n | view.getBigUint64(24, false));
    return __privateGet(this, _cachedBigIntTweaked);
  }
  equals(a) {
    const b = this;
    if (a.length !== b.length) {
      return false;
    }
    for (let i2 = 0; i2 < b.length; i2++) {
      if (b[i2] !== a[i2]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Check if the address is bigger than another address
   * @returns {boolean} If bigger
   */
  lessThan(a) {
    const b = this;
    for (let i2 = 0; i2 < ADDRESS_BYTE_LENGTH; i2++) {
      const thisByte = b[i2];
      const aByte = a[i2];
      if (thisByte < aByte) {
        return true;
      } else if (thisByte > aByte) {
        return false;
      }
    }
    return false;
  }
  /**
   * Check if the address is smaller than another address
   * @returns {boolean} If smaller
   */
  greaterThan(a) {
    const b = this;
    for (let i2 = 0; i2 < ADDRESS_BYTE_LENGTH; i2++) {
      const thisByte = b[i2];
      const aByte = a[i2];
      if (thisByte > aByte) {
        return true;
      } else if (thisByte < aByte) {
        return false;
      }
    }
    return false;
  }
  /**
   * Set the public key
   * @param {ArrayLike<number>} mldsaPublicKey ML-DSA public key
   * @returns {void}
   */
  set(mldsaPublicKey) {
    this.setMldsaKey(mldsaPublicKey);
  }
  /**
   * Check if the public key is valid
   * @param {Network} network The network
   * @returns {boolean} If the public key is valid
   */
  isValidLegacyPublicKey(network) {
    const key = this.legacyPublicKey;
    if (!key) {
      throw new Error(`Legacy key not set.`);
    }
    return AddressVerificator.isValidPublicKey(toHex$1(key), network);
  }
  /**
   * Get the public key as address
   */
  p2pk() {
    return this.toHex();
  }
  /**
   * Get the address in p2wpkh format
   * @param {Network} network The network
   */
  p2wpkh(network) {
    return EcKeyPair.getP2WPKHAddress(this.keyPair, network);
  }
  /**
   * Get the address in p2pkh format
   * @param {Network} network The network
   */
  p2pkh(network) {
    return EcKeyPair.getLegacyAddress(this.keyPair, network);
  }
  /**
   * Get the address in p2sh-p2wpkh format
   * @param {Network} network The network
   */
  p2shp2wpkh(network) {
    return EcKeyPair.getLegacySegwitAddress(this.keyPair, network);
  }
  /**
   * Convert the address to a string
   */
  toString() {
    return this.toHex();
  }
  /**
   * Convert the address to a JSON string
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * Get the address in p2tr format
   * @param {Network} network The network
   */
  p2tr(network) {
    if (__privateGet(this, _p2tr) && __privateGet(this, _network11) === network) {
      return __privateGet(this, _p2tr);
    }
    const key = this.legacyPublicKey;
    if (!key) {
      throw new Error("Legacy public key not set");
    }
    const p2trAddy = EcKeyPair.tweakedPubKeyBufferToAddress(key, network);
    if (p2trAddy) {
      __privateSet(this, _network11, network);
      __privateSet(this, _p2tr, p2trAddy);
      return p2trAddy;
    }
    throw new Error("Legacy public key not set");
  }
  /**
   * Generate a P2WDA (Pay-to-Witness-Data-Authentication) address
   *
   * P2WDA addresses are a special type of P2WSH address that allows embedding
   * authenticated data directly in the witness field, achieving 75% cost reduction
   * through Bitcoin's witness discount.
   *
   * The witness script pattern is: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   * This allows up to 10 witness data fields (5 * 2 = 10), where each field
   * can hold up to 80 bytes of data due to relay rules.
   *
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The P2WDA address
   * @throws {Error} If the public key is not set or address generation fails
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x02...');
   * const p2wdaAddress = address.p2wda(networks.bitcoin);
   * console.log(p2wdaAddress); // bc1q...
   * ```
   */
  p2wda(network) {
    if (__privateGet(this, _p2wda) && __privateGet(this, _network11) === network) {
      return __privateGet(this, _p2wda);
    }
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _originalPublicKey)) {
      throw new Error("Cannot create P2WDA address: public key not set");
    }
    const publicKeyBuffer = new Uint8Array(__privateGet(this, _originalPublicKey));
    if (publicKeyBuffer.length !== 33) {
      throw new Error("P2WDA requires a compressed public key (33 bytes)");
    }
    try {
      const p2wdaInfo = P2WDADetector.generateP2WDAAddress(publicKeyBuffer, network);
      __privateSet(this, _network11, network);
      __privateSet(this, _p2wda, p2wdaInfo);
      return {
        address: p2wdaInfo.address,
        witnessScript: p2wdaInfo.witnessScript
      };
    } catch (error) {
      throw new Error(`Failed to generate P2WDA address: ${error.message}`, {
        cause: error
      });
    }
  }
  /**
   * Generate a P2WSH address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The timelocked address and its witness script
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSV(duration, network) {
    const n2 = Number(duration);
    if (n2 < 1 || n2 > 65535) {
      throw new Error("CSV block number must be between 1 and 65535");
    }
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _originalPublicKey)) {
      throw new Error("Cannot create CSV address: public key not set");
    }
    const publicKeyBuffer = new Uint8Array(__privateGet(this, _originalPublicKey));
    return TimeLockGenerator.generateTimeLockAddress(publicKeyBuffer, network, n2);
  }
  /**
   * Generate a P2TR address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The timelocked address and its witness script
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSVTweaked(duration, network) {
    const n2 = Number(duration);
    if (n2 < 1 || n2 > 65535) {
      throw new Error("CSV block number must be between 1 and 65535");
    }
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _originalPublicKey)) {
      throw new Error("Cannot create CSV address: public key not set");
    }
    return TimeLockGenerator.generateTimeLockAddressP2TR(this.tweakedPublicKeyToBuffer(), network, n2);
  }
  /**
   * Generate a P2MR address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created. Uses P2MR (BIP 360) instead of P2TR.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {string} The timelocked P2MR address
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSVP2MR(duration, network) {
    const n2 = Number(duration);
    if (n2 < 1 || n2 > 65535) {
      throw new Error("CSV block number must be between 1 and 65535");
    }
    this.ensureLegacyProcessed();
    if (!__privateGet(this, _tweakedPublicKey)) {
      throw new Error("Cannot create CSV P2MR address: public key not set");
    }
    return TimeLockGenerator.generateTimeLockAddressP2MR(this.tweakedPublicKeyToBuffer(), network, n2);
  }
  /**
   * Returns the OPNet address encoded in bech32m format, derived from the SHA256 hash of the ML-DSA public key
   * (which is what the Address internally stores).
   *
   * This method generates a P2OP (Pay-to-OPNet) address using witness version 16, suitable for
   * quantum-resistant transactions on the OPNet protocol.
   *
   * @param network - The Bitcoin network to use (mainnet, testnet, regtest)
   * @returns The P2OP address in bech32m format
   */
  p2op(network) {
    if (__privateGet(this, _p2op) && __privateGet(this, _network11) === network) {
      return __privateGet(this, _p2op);
    }
    const p2opAddy = EcKeyPair.p2op(this, network);
    if (p2opAddy) {
      __privateSet(this, _network11, network);
      __privateSet(this, _p2op, p2opAddy);
      return p2opAddy;
    }
    throw new Error("ML-DSA public key not set");
  }
  toTweakedHybridPublicKeyHex() {
    this.ensureLegacyProcessed();
    this.ensureTweakedUncompressed();
    if (!__privateGet(this, _tweakedUncompressed)) {
      throw new Error("Legacy public key not set");
    }
    return "0x" + toHex$1(__privateGet(this, _tweakedUncompressed));
  }
  toTweakedHybridPublicKeyBuffer() {
    this.ensureLegacyProcessed();
    this.ensureTweakedUncompressed();
    if (!__privateGet(this, _tweakedUncompressed)) {
      throw new Error("Legacy public key not set");
    }
    return __privateGet(this, _tweakedUncompressed);
  }
  /**
   * Lazily generates the tweaked uncompressed/hybrid key from the legacy public key.
   * Only called when toTweakedHybridPublicKey* methods are accessed.
   */
  ensureTweakedUncompressed() {
    if (__privateGet(this, _tweakedUncompressed))
      return;
    const key = __privateGet(this, _tweakedPublicKey);
    if (!key)
      return;
    if (key.length === ADDRESS_BYTE_LENGTH && !__privateGet(this, _originalPublicKey)) {
      try {
        __privateSet(this, _tweakedUncompressed, ContractAddress.generateHybridKeyFromHash(key));
      } catch {
      }
    }
  }
  /**
   * Sets the MLDSA key portion of the address.
   * @param {ArrayLike<number>} mldsaPublicKey - The MLDSA public key or its hash
   */
  setMldsaKey(mldsaPublicKey) {
    if (mldsaPublicKey.length === ADDRESS_BYTE_LENGTH) {
      const buf = new Uint8Array(ADDRESS_BYTE_LENGTH);
      buf.set(mldsaPublicKey);
      super.set(buf);
    } else {
      if (!validMLDSALengths.includes(mldsaPublicKey.length)) {
        throw new Error(`Invalid ML-DSA public key length: ${mldsaPublicKey.length}. Expected 1312 (ML-DSA-44/LEVEL2), 1952 (ML-DSA-65/LEVEL3), or 2592 (ML-DSA-87/LEVEL5) bytes.`);
      }
      __privateSet(this, _mldsaPublicKey, new Uint8Array(mldsaPublicKey.length));
      __privateGet(this, _mldsaPublicKey).set(mldsaPublicKey);
      const hashedPublicKey = sha256$1(new Uint8Array(mldsaPublicKey));
      const buf = new Uint8Array(ADDRESS_BYTE_LENGTH);
      buf.set(hashedPublicKey);
      super.set(buf);
    }
  }
  /**
   * Lazy processing of legacy key - defers expensive EC operations until actually needed.
   * Does the EXACT same logic as the original set() method did for legacy keys.
   */
  ensureLegacyProcessed() {
    if (__privateGet(this, _legacyProcessed))
      return;
    __privateSet(this, _legacyProcessed, true);
    const pending = __privateGet(this, _pendingLegacyKey);
    if (!pending)
      return;
    if (pending.length === ADDRESS_BYTE_LENGTH) {
      __privateSet(this, _tweakedPublicKey, pending);
    } else {
      this.autoFormat(pending);
    }
  }
  /**
   * Processes a 33 or 65 byte public key, performing EC operations.
   * Sets #tweakedPublicKey to 32-byte tweaked x-only (same as original behavior).
   */
  autoFormat(publicKey) {
    const firstByte = publicKey[0];
    if (firstByte === 3 || firstByte === 2) ;
    else if (firstByte === 4 || firstByte === 6 || firstByte === 7) {
      publicKey = _Address.uncompressedToCompressed(publicKey);
    }
    __privateSet(this, _originalPublicKey, Uint8Array.from(publicKey));
    __privateSet(this, _keyPair, EcKeyPair.fromPublicKey(__privateGet(this, _originalPublicKey)));
    __privateSet(this, _uncompressed, decompressPublicKey(__privateGet(this, _originalPublicKey)));
    const tweakedBytes = toXOnly(EcKeyPair.tweakPublicKey(__privateGet(this, _originalPublicKey)));
    __privateSet(this, _tweakedUncompressed, ContractAddress.generateHybridKeyFromHash(tweakedBytes));
    __privateSet(this, _tweakedPublicKey, new Uint8Array(ADDRESS_BYTE_LENGTH));
    __privateGet(this, _tweakedPublicKey).set(tweakedBytes);
  }
};
_p2tr = new WeakMap();
_p2op = new WeakMap();
_network11 = new WeakMap();
_originalPublicKey = new WeakMap();
_keyPair = new WeakMap();
_uncompressed = new WeakMap();
_tweakedUncompressed = new WeakMap();
_p2wda = new WeakMap();
_mldsaPublicKey = new WeakMap();
_cachedBigInt = new WeakMap();
_cachedBigIntTweaked = new WeakMap();
_cachedUint64Array = new WeakMap();
_originalMDLSAPublicKey = new WeakMap();
_mldsaLevel = new WeakMap();
_pendingLegacyKey = new WeakMap();
_legacyProcessed = new WeakMap();
_tweakedPublicKey = new WeakMap();
var Address = _Address;
var FastMap = class _FastMap {
  constructor(iterable) {
    __publicField(this, "_keys", []);
    __publicField(this, "_values", {});
    if (iterable instanceof _FastMap) {
      this.setAll(iterable);
    } else {
      if (iterable) {
        for (const [key, value] of iterable) {
          this.set(key, value);
        }
      }
    }
  }
  get size() {
    return this._keys.length;
  }
  setAll(map) {
    this._keys = [...map._keys];
    this._values = { ...map._values };
  }
  addAll(map) {
    for (const [key, value] of map.entries()) {
      this.set(key, value);
    }
  }
  *keys() {
    yield* this._keys;
  }
  *values() {
    for (const key of this._keys) {
      yield this._values[key];
    }
  }
  *entries() {
    for (const key of this._keys) {
      yield [key, this._values[key]];
    }
  }
  set(key, value) {
    if (!this.has(key)) {
      this._keys.push(key);
    }
    this._values[key] = value;
    return this;
  }
  indexOf(key) {
    if (!this.has(key)) {
      return -1;
    }
    for (let i2 = 0; i2 < this._keys.length; i2++) {
      if (this._keys[i2] === key) {
        return i2;
      }
    }
    throw new Error("Key not found, this should not happen.");
  }
  get(key) {
    return this._values[key];
  }
  has(key) {
    return Object.prototype.hasOwnProperty.call(this._values, key);
  }
  delete(key) {
    if (!this.has(key)) {
      return false;
    }
    const index = this.indexOf(key);
    this._keys.splice(index, 1);
    delete this._values[key];
    return true;
  }
  clear() {
    this._keys = [];
    this._values = {};
  }
  [Symbol.dispose]() {
    this.clear();
  }
  forEach(callback, thisArg) {
    for (const key of this._keys) {
      callback.call(thisArg, this._values[key], key, this);
    }
  }
  *[Symbol.iterator]() {
    for (const key of this._keys) {
      yield [key, this._values[key]];
    }
  }
};
var AddressMap = class {
  constructor(iterable) {
    __publicField(this, "items");
    this.items = new FastMap();
    if (iterable) {
      for (const [key, value] of iterable) {
        this.set(key, value);
      }
    }
  }
  get size() {
    return this.items.size;
  }
  set(key, value) {
    const keyBigInt = key.toBigInt();
    this.items.set(keyBigInt, value);
    return this;
  }
  get(key) {
    return this.items.get(key.toBigInt());
  }
  has(key) {
    return this.items.has(key.toBigInt());
  }
  delete(key) {
    const keyBigInt = key.toBigInt();
    return this.items.delete(keyBigInt);
  }
  clear() {
    this.items.clear();
  }
  [Symbol.dispose]() {
    this.clear();
  }
  indexOf(address) {
    return this.items.indexOf(address.toBigInt());
  }
  /**
   * WARNING, THIS RETURN NEW COPY OF THE KEYS
   */
  *entries() {
    for (const [keyBigInt, value] of this.items.entries()) {
      yield [Address.fromBigInt(keyBigInt), value];
    }
  }
  *keys() {
    for (const keyBigInt of this.items.keys()) {
      yield Address.fromBigInt(keyBigInt);
    }
  }
  *values() {
    for (const value of this.items.values()) {
      yield value;
    }
  }
  forEach(callback, thisArg) {
    for (const [keyBigInt, value] of this.items.entries()) {
      const key = Address.fromBigInt(keyBigInt);
      callback.call(thisArg, value, key, this);
    }
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
};
var ExtendedAddressMap = class {
  constructor(iterable) {
    // Store tweaked bigint -> index mapping for fast lookup
    __publicField(this, "indexMap");
    // Store actual addresses and values
    __publicField(this, "_keys", []);
    __publicField(this, "_values", []);
    this.indexMap = new FastMap();
    if (iterable) {
      for (const [key, value] of iterable) {
        this.set(key, value);
      }
    }
  }
  get size() {
    return this._keys.length;
  }
  set(key, value) {
    const keyBigInt = key.tweakedToBigInt();
    const existingIndex = this.indexMap.get(keyBigInt);
    if (existingIndex !== void 0) {
      this._values[existingIndex] = value;
    } else {
      const newIndex = this._keys.length;
      this._keys.push(key);
      this._values.push(value);
      this.indexMap.set(keyBigInt, newIndex);
    }
    return this;
  }
  get(key) {
    const keyBigInt = key.tweakedToBigInt();
    const index = this.indexMap.get(keyBigInt);
    if (index === void 0) {
      return void 0;
    }
    return this._values[index];
  }
  has(key) {
    return this.indexMap.has(key.tweakedToBigInt());
  }
  delete(key) {
    const keyBigInt = key.tweakedToBigInt();
    const index = this.indexMap.get(keyBigInt);
    if (index === void 0) {
      return false;
    }
    this._keys.splice(index, 1);
    this._values.splice(index, 1);
    this.indexMap.clear();
    for (let i2 = 0; i2 < this._keys.length; i2++) {
      this.indexMap.set(this._keys[i2].tweakedToBigInt(), i2);
    }
    return true;
  }
  clear() {
    this.indexMap.clear();
    this._keys = [];
    this._values = [];
  }
  [Symbol.dispose]() {
    this.clear();
  }
  indexOf(address) {
    const index = this.indexMap.get(address.tweakedToBigInt());
    return index !== void 0 ? index : -1;
  }
  *entries() {
    for (let i2 = 0; i2 < this._keys.length; i2++) {
      yield [this._keys[i2], this._values[i2]];
    }
  }
  *keys() {
    for (const key of this._keys) {
      yield key;
    }
  }
  *values() {
    for (const value of this._values) {
      yield value;
    }
  }
  forEach(callback, thisArg) {
    for (let i2 = 0; i2 < this._keys.length; i2++) {
      callback.call(thisArg, this._values[i2], this._keys[i2], this);
    }
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
};
var BufferHelper = class {
  static bufferToUint8Array(buffer2) {
    const result = new Uint8Array(buffer2.byteLength);
    result.set(buffer2);
    return result;
  }
  static uint8ArrayToHex(input) {
    return toHex$1(input);
  }
  static hexToUint8Array(input) {
    let hex = input;
    if (hex.length >= 2 && hex[0] === "0" && (hex[1] === "x" || hex[1] === "X")) {
      hex = hex.slice(2);
    }
    if (hex.length % 2 !== 0) {
      hex = "0" + hex;
    }
    return fromHex$1(hex);
  }
  static pointerToUint8Array(pointer) {
    if (pointer < 0n) {
      throw new RangeError("Pointer cannot be negative");
    }
    const hex = pointer.toString(16).padStart(64, "0");
    if (hex.length > 64) {
      throw new RangeError("Pointer exceeds 256-bit range");
    }
    return fromHex$1(hex);
  }
  static uint8ArrayToPointer(input) {
    if (input.length === 0) {
      return 0n;
    }
    return BigInt("0x" + toHex$1(input));
  }
  static valueToUint8Array(value, length = U256_BYTE_LENGTH) {
    if (value < 0n) {
      throw new RangeError("Value cannot be negative");
    }
    const hex = value.toString(16).padStart(length * 2, "0");
    if (hex.length > length * 2) {
      throw new RangeError(`Value exceeds ${length}-byte range`);
    }
    return fromHex$1(hex);
  }
  static uint8ArrayToValue(input) {
    if (input.length === 0) {
      return 0n;
    }
    return BigInt("0x" + toHex$1(input));
  }
};
__publicField(BufferHelper, "EXPECTED_BUFFER_LENGTH", 32);
var BinaryReader = class {
  constructor(bytes) {
    __publicField(this, "buffer");
    __publicField(this, "currentOffset", 0);
    this.buffer = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  }
  get byteLength() {
    return this.buffer.byteLength;
  }
  // Helpers for comparisons; unchanged
  static stringCompare(a, b) {
    return a.localeCompare(b);
  }
  static bigintCompare(a, b) {
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  }
  static numberCompare(a, b) {
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  }
  setBuffer(bytes) {
    this.buffer = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    this.currentOffset = 0;
  }
  length() {
    return this.buffer.byteLength;
  }
  bytesLeft() {
    return this.buffer.byteLength - this.currentOffset;
  }
  // ------------------- Signed Integer Readers ------------------- //
  /**
   * Reads a single signed byte (i8).
   */
  readI8() {
    this.verifyEnd(this.currentOffset + I8_BYTE_LENGTH);
    const value = this.buffer.getInt8(this.currentOffset);
    this.currentOffset += I8_BYTE_LENGTH;
    return value;
  }
  /**
   * Reads a signed 16-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI16(be2 = true) {
    this.verifyEnd(this.currentOffset + I16_BYTE_LENGTH);
    const value = this.buffer.getInt16(this.currentOffset, !be2);
    this.currentOffset += I16_BYTE_LENGTH;
    return value;
  }
  /**
   * Reads a signed 32-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI32(be2 = true) {
    this.verifyEnd(this.currentOffset + I32_BYTE_LENGTH);
    const value = this.buffer.getInt32(this.currentOffset, !be2);
    this.currentOffset += I32_BYTE_LENGTH;
    return value;
  }
  /**
   * Reads a signed 64-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI64(be2 = true) {
    this.verifyEnd(this.currentOffset + I64_BYTE_LENGTH);
    const value = this.buffer.getBigInt64(this.currentOffset, !be2);
    this.currentOffset += I64_BYTE_LENGTH;
    return value;
  }
  // ------------------- Unsigned Integer Readers ------------------- //
  /**
   * Reads a single unsigned byte (u8).
   */
  readU8() {
    this.verifyEnd(this.currentOffset + U8_BYTE_LENGTH);
    const value = this.buffer.getUint8(this.currentOffset);
    this.currentOffset += U8_BYTE_LENGTH;
    return value;
  }
  /**
   * Reads an unsigned 16-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU16(be2 = true) {
    this.verifyEnd(this.currentOffset + U16_BYTE_LENGTH);
    const value = this.buffer.getUint16(this.currentOffset, !be2);
    this.currentOffset += U16_BYTE_LENGTH;
    return value;
  }
  /**
   * Reads an unsigned 32-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU32(be2 = true) {
    this.verifyEnd(this.currentOffset + U32_BYTE_LENGTH);
    const value = this.buffer.getUint32(this.currentOffset, !be2);
    this.currentOffset += U32_BYTE_LENGTH;
    return value;
  }
  /**
   * Reads an unsigned 64-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU64(be2 = true) {
    this.verifyEnd(this.currentOffset + U64_BYTE_LENGTH);
    const value = this.buffer.getBigUint64(this.currentOffset, !be2);
    this.currentOffset += U64_BYTE_LENGTH;
    return value;
  }
  /**
   * Reads a 128-bit unsigned integer. By default, read big-endian.
   * @param be - Endianness; true => big-endian (default).
   */
  readU128(be2 = true) {
    const raw = this.readBytes(U128_BYTE_LENGTH);
    let bytes = raw;
    if (!be2) {
      bytes = this.reverseBytes(raw);
    }
    return BigInt("0x" + this.toHexString(bytes));
  }
  /**
   * Reads a 256-bit unsigned integer. Same approach as readU128.
   * @param be - Endianness; true => big-endian (default).
   */
  readU256(be2 = true) {
    const raw = this.readBytes(U256_BYTE_LENGTH);
    let bytes = raw;
    if (!be2) {
      bytes = this.reverseBytes(raw);
    }
    return BigInt("0x" + this.toHexString(bytes));
  }
  /**
   * Reads a 128-bit signed integer. Interpret the sign bit if big-endian.
   * @param be - Endianness; true => big-endian (default).
   */
  readI128(be2 = true) {
    const raw = this.readBytes(I128_BYTE_LENGTH);
    let bytes = raw;
    if (!be2) {
      bytes = this.reverseBytes(raw);
    }
    let value = BigInt("0x" + this.toHexString(bytes));
    const signBitMask = 128;
    if (bytes[0] & signBitMask) {
      const twoTo128 = BigInt(1) << BigInt(128);
      value = value - twoTo128;
    }
    return value;
  }
  /**
   * Read a boolean (u8 != 0).
   */
  readBoolean() {
    return this.readU8() !== 0;
  }
  /**
   * Reads 32 bits
   */
  readSelector() {
    return this.readU32(true);
  }
  /**
   * Reads a raw sequence of bytes (length must be known).
   * If zeroStop = true, stops if we encounter 0x00 early.
   */
  readBytes(length, zeroStop = false) {
    this.verifyEnd(this.currentOffset + length);
    let bytes = new Uint8Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      const b = this.buffer.getUint8(this.currentOffset++);
      if (zeroStop && b === 0) {
        bytes = new Uint8Array(bytes.subarray(0, i2));
        break;
      }
      bytes[i2] = b;
    }
    return bytes;
  }
  /**
   * Reads a string of the given length in raw bytes. By default, do NOT zero-stop
   * (matching how we wrote the raw bytes).
   */
  readString(length) {
    const textDecoder = new TextDecoder();
    const bytes = this.readBytes(length, false);
    return textDecoder.decode(bytes);
  }
  /**
   * Reads a string that was written as [u16 length][raw bytes].
   */
  readStringWithLength(be2 = true) {
    const length = this.readU32(be2);
    return this.readString(length);
  }
  /**
   * Reads an address (32 bytes MLDSA key hash only).
   */
  readAddress() {
    const bytes = Array.from(this.readBytes(ADDRESS_BYTE_LENGTH));
    return new Address(bytes);
  }
  /**
   * Reads the tweaked public key portion (32 bytes) and returns it as a raw Uint8Array.
   * Use this when you only need the tweaked key without the full Address object.
   */
  readTweakedPublicKey() {
    this.verifyEnd(this.currentOffset + ADDRESS_BYTE_LENGTH);
    return this.readBytes(ADDRESS_BYTE_LENGTH);
  }
  /**
   * Reads a full address with both MLDSA key hash and tweaked public key (64 bytes total).
   * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
   *
   * This is the equivalent of btc-runtime's readExtendedAddress().
   *
   * @returns An Address instance with both keys set
   */
  readExtendedAddress() {
    this.verifyEnd(this.currentOffset + EXTENDED_ADDRESS_BYTE_LENGTH);
    const tweakedPublicKey = Array.from(this.readBytes(ADDRESS_BYTE_LENGTH));
    const mldsaKeyHash = Array.from(this.readBytes(ADDRESS_BYTE_LENGTH));
    return new Address(mldsaKeyHash, tweakedPublicKey);
  }
  /**
   * Reads a Schnorr signature with its associated full Address.
   * Format: [64 bytes full Address][64 bytes signature]
   *
   * Used for deserializing signed data where both the signer's address
   * and their Schnorr signature are stored together.
   *
   * @returns A SchnorrSignature containing the address and signature
   */
  readSchnorrSignature() {
    this.verifyEnd(this.currentOffset + EXTENDED_ADDRESS_BYTE_LENGTH + SCHNORR_SIGNATURE_BYTE_LENGTH);
    const address = this.readExtendedAddress();
    const signature2 = this.readBytes(SCHNORR_SIGNATURE_BYTE_LENGTH);
    return { address, signature: signature2 };
  }
  /**
   * Reads bytes written as [u32 length][bytes].
   * @param maxLength if > 0, enforces an upper bound
   * @param be
   */
  readBytesWithLength(maxLength = 0, be2 = true) {
    const length = this.readU32(be2);
    if (maxLength > 0 && length > maxLength) {
      throw new Error("Data length exceeds maximum length.");
    }
    return this.readBytes(length);
  }
  // ------------------ Array readers ------------------ //
  readArrayOfBuffer(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readBytesWithLength();
    }
    return result;
  }
  readAddressArray(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readAddress();
    }
    return result;
  }
  readU256Array(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readU256(be2);
    }
    return result;
  }
  readU128Array(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readU128(be2);
    }
    return result;
  }
  readU64Array(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readU64(be2);
    }
    return result;
  }
  readU32Array(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readU32(be2);
    }
    return result;
  }
  readU16Array(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readU16(be2);
    }
    return result;
  }
  readU8Array() {
    const length = this.readU16(true);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readU8();
    }
    return result;
  }
  readStringArray(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readStringWithLength(be2);
    }
    return result;
  }
  readBytesArray(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readBytesWithLength(0, be2);
    }
    return result;
  }
  /**
   * Reads [u16 length][ (address, u256) pairs ].
   */
  readAddressValueTuple(be2 = true) {
    const length = this.readU16(be2);
    const result = new AddressMap();
    for (let i2 = 0; i2 < length; i2++) {
      const address = this.readAddress();
      const value = this.readU256(be2);
      if (result.has(address)) {
        throw new Error("Duplicate address found in map");
      }
      result.set(address, value);
    }
    return result;
  }
  /**
   * Reads an array of full addresses (64 bytes each).
   * Format: [u16 length][FullAddress 0][FullAddress 1]...
   */
  readExtendedAddressArray(be2 = true) {
    const length = this.readU16(be2);
    const result = new Array(length);
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = this.readExtendedAddress();
    }
    return result;
  }
  /**
   * Reads a map of full Address -> u256 using the tweaked key for map lookup.
   * Format: [u16 length][FullAddress key][u256 value]...
   *
   * This is the equivalent of btc-runtime's readExtendedAddressMapU256().
   */
  readExtendedAddressMapU256(be2 = true) {
    const length = this.readU16(be2);
    const result = new ExtendedAddressMap();
    for (let i2 = 0; i2 < length; i2++) {
      const address = this.readExtendedAddress();
      const value = this.readU256(be2);
      if (result.has(address)) {
        throw new Error("Duplicate tweaked address found in map");
      }
      result.set(address, value);
    }
    return result;
  }
  // --------------------------------------------------- //
  getOffset() {
    return this.currentOffset;
  }
  setOffset(offset) {
    this.currentOffset = offset;
  }
  /**
   * Verifies we have enough bytes in the buffer to read up to `size`.
   */
  verifyEnd(size) {
    if (size > this.buffer.byteLength) {
      throw new Error(`Attempt to read beyond buffer length: requested up to byte offset ${size}, but buffer is only ${this.buffer.byteLength} bytes.`);
    }
  }
  /**
   * Utility: reverses a byte array in-place or returns a reversed copy.
   */
  reverseBytes(bytes) {
    const out = new Uint8Array(bytes.length);
    for (let i2 = 0; i2 < bytes.length; i2++) {
      out[i2] = bytes[bytes.length - 1 - i2];
    }
    return out;
  }
  /**
   * Utility: turn bytes into a hex string without `0x` prefix.
   */
  toHexString(bytes) {
    return Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");
  }
};
var BinaryWriter = class _BinaryWriter {
  constructor(length = 0) {
    __publicField(this, "currentOffset", 0);
    __publicField(this, "buffer");
    this.buffer = this.getDefaultBuffer(length);
  }
  static estimateArrayOfBufferLength(values) {
    if (values.length > 65535)
      throw new Error("Array size is too large");
    let totalLength = U16_BYTE_LENGTH;
    for (let i2 = 0; i2 < values.length; i2++) {
      totalLength += U32_BYTE_LENGTH + values[i2].length;
    }
    return totalLength;
  }
  writeU8(value) {
    if (value > 255)
      throw new Error("u8 value is too large.");
    this.allocSafe(U8_BYTE_LENGTH);
    this.buffer.setUint8(this.currentOffset++, value);
  }
  writeU16(value, be2 = true) {
    if (value > 65535)
      throw new Error("u16 value is too large.");
    this.allocSafe(U16_BYTE_LENGTH);
    this.buffer.setUint16(this.currentOffset, value, !be2);
    this.currentOffset += 2;
  }
  writeU32(value, be2 = true) {
    if (value > 4294967295)
      throw new Error("u32 value is too large.");
    this.allocSafe(U32_BYTE_LENGTH);
    this.buffer.setUint32(this.currentOffset, value, !be2);
    this.currentOffset += 4;
  }
  writeU64(value, be2 = true) {
    if (value > 18446744073709551615n)
      throw new Error("u64 value is too large.");
    this.allocSafe(U64_BYTE_LENGTH);
    this.buffer.setBigUint64(this.currentOffset, value, !be2);
    this.currentOffset += 8;
  }
  // ------------------- Signed Integer Writers ------------------- //
  /**
   * Writes a signed 8-bit integer.
   */
  writeI8(value) {
    if (value < -128 || value > 127)
      throw new Error("i8 value is out of range.");
    this.allocSafe(I8_BYTE_LENGTH);
    this.buffer.setInt8(this.currentOffset, value);
    this.currentOffset += I8_BYTE_LENGTH;
  }
  /**
   * Writes a signed 16-bit integer. By default big-endian (be = true).
   */
  writeI16(value, be2 = true) {
    if (value < -32768 || value > 32767)
      throw new Error("i16 value is out of range.");
    this.allocSafe(I16_BYTE_LENGTH);
    this.buffer.setInt16(this.currentOffset, value, !be2);
    this.currentOffset += I16_BYTE_LENGTH;
  }
  /**
   * Writes a signed 32-bit integer. By default big-endian (be = true).
   */
  writeI32(value, be2 = true) {
    if (value < -2147483648 || value > 2147483647)
      throw new Error("i32 value is out of range.");
    this.allocSafe(I32_BYTE_LENGTH);
    this.buffer.setInt32(this.currentOffset, value, !be2);
    this.currentOffset += I32_BYTE_LENGTH;
  }
  /**
   * Writes a signed 64-bit integer. By default big-endian (be = true).
   */
  writeI64(value, be2 = true) {
    if (value < -9223372036854775808n || value > 9223372036854775807n) {
      throw new Error("i64 value is out of range.");
    }
    this.allocSafe(I64_BYTE_LENGTH);
    this.buffer.setBigInt64(this.currentOffset, value, !be2);
    this.currentOffset += I64_BYTE_LENGTH;
  }
  // ---------------------------------------------------------------- //
  writeSelector(value) {
    this.writeU32(value, true);
  }
  writeBoolean(value) {
    this.writeU8(value ? 1 : 0);
  }
  writeI128(bigIntValue, be2 = true) {
    if (bigIntValue > 170141183460469231731687303715884105727n || bigIntValue < -170141183460469231731687303715884105728n) {
      throw new Error("i128 value is too large.");
    }
    this.allocSafe(I128_BYTE_LENGTH);
    const bytesToHex3 = BufferHelper.valueToUint8Array(bigIntValue, I128_BYTE_LENGTH);
    if (bytesToHex3.byteLength !== I128_BYTE_LENGTH) {
      throw new Error(`Invalid i128 value: ${bigIntValue}`);
    }
    if (be2) {
      for (let i2 = 0; i2 < bytesToHex3.byteLength; i2++) {
        this.writeU8(bytesToHex3[i2]);
      }
    } else {
      for (let i2 = bytesToHex3.byteLength - 1; i2 >= 0; i2--) {
        this.writeU8(bytesToHex3[i2]);
      }
    }
  }
  writeU256(bigIntValue, be2 = true) {
    if (bigIntValue > 115792089237316195423570985008687907853269984665640564039457584007913129639935n && bigIntValue < 0n) {
      throw new Error("u256 value is too large or negative.");
    }
    this.allocSafe(U256_BYTE_LENGTH);
    const bytesToHex3 = BufferHelper.valueToUint8Array(bigIntValue);
    if (bytesToHex3.byteLength !== U256_BYTE_LENGTH) {
      throw new Error(`Invalid u256 value: ${bigIntValue}`);
    }
    if (be2) {
      for (let i2 = 0; i2 < bytesToHex3.byteLength; i2++) {
        this.writeU8(bytesToHex3[i2]);
      }
    } else {
      for (let i2 = bytesToHex3.byteLength - 1; i2 >= 0; i2--) {
        this.writeU8(bytesToHex3[i2]);
      }
    }
  }
  writeU128(bigIntValue, be2 = true) {
    if (bigIntValue > 340282366920938463463374607431768211455n && bigIntValue < 0n) {
      throw new Error("u128 value is too large or negative.");
    }
    this.allocSafe(U128_BYTE_LENGTH);
    const bytesToHex3 = BufferHelper.valueToUint8Array(bigIntValue, U128_BYTE_LENGTH);
    if (bytesToHex3.byteLength !== U128_BYTE_LENGTH) {
      throw new Error(`Invalid u128 value: ${bigIntValue}`);
    }
    if (be2) {
      for (let i2 = 0; i2 < bytesToHex3.byteLength; i2++) {
        this.writeU8(bytesToHex3[i2]);
      }
    } else {
      for (let i2 = bytesToHex3.byteLength - 1; i2 >= 0; i2--) {
        this.writeU8(bytesToHex3[i2]);
      }
    }
  }
  writeBytes(value) {
    this.allocSafe(value.byteLength);
    for (let i2 = 0; i2 < value.byteLength; i2++) {
      this.writeU8(value[i2]);
    }
  }
  writeString(value) {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(value);
    this.allocSafe(bytes.length);
    this.writeBytes(bytes);
  }
  writeStringWithLength(value) {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(value);
    this.allocSafe(U32_BYTE_LENGTH + bytes.length);
    this.writeU32(bytes.length);
    this.writeBytes(bytes);
  }
  /**
   * Writes an address (32 bytes MLDSA key hash only).
   */
  writeAddress(value) {
    this.verifyAddress(value);
    this.writeBytes(value);
  }
  /**
   * Writes the tweaked public key from an Address (32 bytes).
   * @param value - The Address containing the tweaked public key
   */
  writeTweakedPublicKey(value) {
    const tweakedKey = value.tweakedPublicKeyToBuffer();
    this.allocSafe(ADDRESS_BYTE_LENGTH);
    this.writeBytes(tweakedKey);
  }
  /**
   * Writes a full address with both tweaked public key and MLDSA key hash (64 bytes total).
   * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
   *
   * This is the equivalent of btc-runtime's writeExtendedAddress().
   *
   * @param value - The Address containing both keys
   */
  writeExtendedAddress(value) {
    this.allocSafe(EXTENDED_ADDRESS_BYTE_LENGTH);
    this.writeTweakedPublicKey(value);
    this.writeBytes(value);
  }
  /**
   * Writes a Schnorr signature with its associated full Address.
   * Format: [64 bytes full Address][64 bytes signature]
   *
   * Used for serializing signed data where both the signer's address
   * and their Schnorr signature need to be stored together.
   *
   * @param address - The signer's Address (with both MLDSA and tweaked keys)
   * @param signature - The 64-byte Schnorr signature
   * @throws {Error} If signature is not exactly 64 bytes
   */
  writeSchnorrSignature(address, signature2) {
    if (signature2.length !== SCHNORR_SIGNATURE_BYTE_LENGTH) {
      throw new Error(`Invalid Schnorr signature length: expected ${SCHNORR_SIGNATURE_BYTE_LENGTH}, got ${signature2.length}`);
    }
    this.allocSafe(EXTENDED_ADDRESS_BYTE_LENGTH + SCHNORR_SIGNATURE_BYTE_LENGTH);
    this.writeExtendedAddress(address);
    this.writeBytes(signature2);
  }
  getBuffer(clear = true) {
    const buf = new Uint8Array(this.buffer.byteLength);
    for (let i2 = 0; i2 < this.buffer.byteLength; i2++) {
      buf[i2] = this.buffer.getUint8(i2);
    }
    if (clear)
      this.clear();
    return buf;
  }
  reset() {
    this.currentOffset = 0;
    this.buffer = this.getDefaultBuffer(4);
  }
  toBytesReader() {
    return new BinaryReader(this.getBuffer());
  }
  getOffset() {
    return this.currentOffset;
  }
  setOffset(offset) {
    this.currentOffset = offset;
  }
  clear() {
    this.currentOffset = 0;
    this.buffer = this.getDefaultBuffer();
  }
  [Symbol.dispose]() {
    this.clear();
  }
  allocSafe(size) {
    if (this.currentOffset + size > this.buffer.byteLength) {
      this.resize(size);
    }
  }
  writeAddressValueTuple(map, be2 = true) {
    if (map.size > 65535)
      throw new Error("Map size is too large");
    this.writeU16(map.size, be2);
    const keys = Array.from(map.keys());
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const value = map.get(key);
      if (value === null || value === void 0)
        throw new Error("Value not found");
      this.writeAddress(key);
      this.writeU256(value, be2);
    }
  }
  /**
   * Writes a map of full Address -> u256 using the tweaked key for map lookup.
   * Format: [u16 length][FullAddress key][u256 value]...
   *
   * This is the equivalent of btc-runtime's writeExtendedAddressMapU256().
   */
  writeExtendedAddressMapU256(map, be2 = true) {
    if (map.size > 65535)
      throw new Error("Map size is too large");
    this.writeU16(map.size, be2);
    for (const [key, value] of map.entries()) {
      this.writeExtendedAddress(key);
      this.writeU256(value, be2);
    }
  }
  writeBytesWithLength(value) {
    this.writeU32(value.length);
    this.writeBytes(value);
  }
  writeArrayOfBuffer(values, be2 = true) {
    const totalLength = _BinaryWriter.estimateArrayOfBufferLength(values);
    this.allocSafe(totalLength);
    this.writeU16(values.length, be2);
    for (let i2 = 0; i2 < values.length; i2++) {
      this.writeU32(values[i2].length, be2);
      this.writeBytes(values[i2]);
    }
  }
  writeAddressArray(value) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeAddress(value[i2]);
    }
  }
  /**
   * Writes an array of full addresses (64 bytes each).
   * Format: [u16 length][FullAddress 0][FullAddress 1]...
   */
  writeExtendedAddressArray(value) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.allocSafe(U16_BYTE_LENGTH + value.length * EXTENDED_ADDRESS_BYTE_LENGTH);
    this.writeU16(value.length);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeExtendedAddress(value[i2]);
    }
  }
  writeU32Array(value, be2 = true) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length, be2);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeU32(value[i2], be2);
    }
  }
  writeU256Array(value, be2 = true) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length, be2);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeU256(value[i2], be2);
    }
  }
  writeU128Array(value, be2 = true) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length, be2);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeU128(value[i2], be2);
    }
  }
  writeStringArray(value) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeStringWithLength(value[i2]);
    }
  }
  writeU16Array(value, be2 = true) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length, be2);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeU16(value[i2], be2);
    }
  }
  writeU8Array(value) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeU8(value[i2]);
    }
  }
  writeU64Array(value, be2 = true) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length, be2);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeU64(value[i2], be2);
    }
  }
  writeBytesArray(value) {
    if (value.length > 65535)
      throw new Error("Array size is too large");
    this.writeU16(value.length);
    for (let i2 = 0; i2 < value.length; i2++) {
      this.writeBytesWithLength(value[i2]);
    }
  }
  verifyAddress(pubKey) {
    if (pubKey.byteLength > ADDRESS_BYTE_LENGTH) {
      throw new Error(`Address is too long ${pubKey.byteLength} > ${ADDRESS_BYTE_LENGTH} bytes`);
    }
  }
  resize(size) {
    const buf = new Uint8Array(this.buffer.byteLength + size);
    for (let i2 = 0; i2 < this.buffer.byteLength; i2++) {
      buf[i2] = this.buffer.getUint8(i2);
    }
    this.buffer = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  getDefaultBuffer(length = 0) {
    return new DataView(new ArrayBuffer(length));
  }
};
var _Generator = class _Generator {
  constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
    /**
     * The public key of the sender
     * @protected
     */
    __publicField(this, "senderPubKey");
    /**
     * The public key of the sender
     * @protected
     */
    __publicField(this, "xSenderPubKey");
    /**
     * The public key of the contract salt
     * @protected
     */
    __publicField(this, "contractSaltPubKey");
    /**
     * The network to use
     * @protected
     */
    __publicField(this, "network", bitcoin$1);
    this.senderPubKey = senderPubKey;
    this.contractSaltPubKey = contractSaltPubKey;
    this.network = network;
    this.xSenderPubKey = toXOnly(senderPubKey);
  }
  buildHeader(features) {
    let flags = 0;
    for (const feature of features) {
      flags |= feature;
    }
    const bytesU24 = alloc(3);
    bytesU24[0] = flags >> 16 & 255;
    bytesU24[1] = flags >> 8 & 255;
    bytesU24[2] = flags & 255;
    return Uint8Array.from([this.senderPubKey[0], ...bytesU24]);
  }
  getHeader(maxPriority, features = []) {
    const writer = new BinaryWriter(12);
    writer.writeBytes(this.buildHeader(features));
    writer.writeU64(maxPriority);
    return new Uint8Array(writer.getBuffer());
  }
  /**
   * Split a buffer into chunks
   * @param {Uint8Array} buffer - The buffer to split
   * @param {number} chunkSize - The size of each chunk
   * @protected
   * @returns {Array<Uint8Array[]>} - The chunks
   */
  splitBufferIntoChunks(buffer2, chunkSize = _Generator.DATA_CHUNK_SIZE) {
    const chunks = [];
    for (let i2 = 0; i2 < buffer2.length; i2 += chunkSize) {
      const dataLength = Math.min(chunkSize, buffer2.length - i2);
      const buf2 = alloc(dataLength);
      for (let j = 0; j < dataLength; j++) {
        buf2[j] = buffer2[i2 + j];
      }
      chunks.push([buf2]);
    }
    return chunks;
  }
  encodeFeature(feature, finalBuffer) {
    switch (feature.opcode) {
      case Features.ACCESS_LIST: {
        return this.encodeAccessListFeature(feature, finalBuffer);
      }
      case Features.EPOCH_SUBMISSION: {
        return this.encodeChallengeSubmission(feature, finalBuffer);
      }
      case Features.MLDSA_LINK_PUBKEY: {
        return this.encodeLinkRequest(feature, finalBuffer);
      }
      default:
        throw new Error(`Unknown feature type: ${feature.opcode}`);
    }
  }
  encodeAccessListFeature(feature, finalBuffer) {
    const writer = new BinaryWriter();
    writer.writeU16(Object.keys(feature.data).length);
    for (const contract in feature.data) {
      const parsedContract = Address.fromString(contract);
      const data = feature.data[contract];
      writer.writeAddress(parsedContract);
      writer.writeU32(data.length);
      for (const pointer of data) {
        const pointerBuffer = Uint8Array.from(atob(pointer), (c) => c.charCodeAt(0));
        if (pointerBuffer.length !== 32) {
          throw new Error(`Invalid pointer length: ${pointerBuffer.length}`);
        }
        writer.writeBytes(pointerBuffer);
      }
    }
    finalBuffer.writeBytesWithLength(Compressor.compress(new Uint8Array(writer.getBuffer())));
  }
  encodeChallengeSubmission(feature, finalBuffer) {
    if ("verifySignature" in feature.data && !feature.data.verifySignature()) {
      throw new Error("Invalid signature in challenge submission feature");
    }
    const writer = new BinaryWriter();
    writer.writeBytes(feature.data.publicKey.toBuffer());
    writer.writeBytes(feature.data.solution);
    if (feature.data.graffiti) {
      writer.writeBytesWithLength(feature.data.graffiti);
    }
    finalBuffer.writeBytesWithLength(writer.getBuffer());
  }
  encodeLinkRequest(feature, finalBuffer) {
    const data = feature.data;
    const writer = new BinaryWriter();
    writer.writeU8(data.level);
    writer.writeBytes(data.hashedPublicKey);
    writer.writeBoolean(data.verifyRequest);
    if (data.verifyRequest) {
      if (!data.publicKey || !data.mldsaSignature) {
        throw new Error("MLDSA public key and signature required when verifyRequest is true");
      }
      writer.writeBytes(data.publicKey);
      writer.writeBytes(data.mldsaSignature);
    }
    if (!data.legacySignature || data.legacySignature.length !== 64) {
      throw new Error("Legacy signature must be exactly 64 bytes");
    }
    writer.writeBytes(data.legacySignature);
    finalBuffer.writeBytesWithLength(writer.getBuffer());
  }
};
/**
 * The maximum size of a data chunk
 */
__publicField(_Generator, "DATA_CHUNK_SIZE", 512);
/**
 * The magic number of OPNet
 */
__publicField(_Generator, "MAGIC", fromUtf8$1("op"));
var Generator = _Generator;
var CalldataGenerator = class extends Generator {
  constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
    super(senderPubKey, contractSaltPubKey, network);
  }
  /**
   * Get the public key as a buffer
   * @param {Uint8Array[]} witnessKeys - The public keys
   * @param {Network} network - The network to use
   * @private
   * @returns {Uint8Array} - The public key as a buffer
   */
  static getPubKeyAsBuffer(witnessKeys, network) {
    let finalBuffer = new Uint8Array(0);
    for (const pubKey of witnessKeys) {
      const key = EcKeyPair.fromPublicKey(pubKey, network);
      if (!key.compressed) {
        throw new Error("Public key must be compressed");
      }
      if (pubKey.byteLength !== 33) {
        throw new Error(`Public key must be 33 bytes, got ${pubKey.byteLength} bytes.`);
      }
      finalBuffer = concat$1([finalBuffer, pubKey]);
    }
    const compressed = Compressor.compress(finalBuffer);
    if (compressed.byteLength >= finalBuffer.byteLength) {
      return finalBuffer;
    }
    return compressed;
  }
  /**
   * Compile an interaction bitcoin script
   * @param {Uint8Array} calldata - The calldata to use
   * @param {Uint8Array} contractSecret - The contract secret
   * @param {IChallengeSolution} challenge
   * @param maxPriority - Amount of satoshis to spend max on priority fee
   * @param {Feature<Features>[]} featuresRaw - The features to use
   * @returns {Uint8Array} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(calldata, contractSecret, challenge, maxPriority, featuresRaw = []) {
    if (!this.contractSaltPubKey)
      throw new Error("Contract salt public key not set");
    const dataChunks = this.splitBufferIntoChunks(calldata);
    if (!dataChunks.length)
      throw new Error("No data chunks found");
    const featuresList = [];
    const featureData = [];
    if (featuresRaw && featuresRaw.length) {
      const features = featuresRaw.sort((a, b) => a.priority - b.priority);
      const finalBuffer = new BinaryWriter();
      for (let i2 = 0; i2 < features.length; i2++) {
        const feature = features[i2];
        featuresList.push(feature.opcode);
        this.encodeFeature(feature, finalBuffer);
      }
      featureData.push(...this.splitBufferIntoChunks(new Uint8Array(finalBuffer.getBuffer())));
    }
    let compiledData = [
      this.getHeader(maxPriority, featuresList),
      opcodes.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      challenge.publicKey.toBuffer(),
      opcodes.OP_TOALTSTACK,
      challenge.solution,
      opcodes.OP_TOALTSTACK,
      this.xSenderPubKey,
      opcodes.OP_DUP,
      opcodes.OP_HASH256,
      hash256(this.xSenderPubKey),
      opcodes.OP_EQUALVERIFY,
      opcodes.OP_CHECKSIGVERIFY,
      this.contractSaltPubKey,
      opcodes.OP_CHECKSIGVERIFY,
      opcodes.OP_HASH160,
      hash160(contractSecret),
      opcodes.OP_EQUALVERIFY,
      opcodes.OP_DEPTH,
      opcodes.OP_1,
      opcodes.OP_NUMEQUAL,
      opcodes.OP_IF,
      Generator.MAGIC
    ];
    compiledData = compiledData.concat(...featureData, ...[opcodes.OP_1NEGATE, ...dataChunks, opcodes.OP_ELSE, opcodes.OP_1, opcodes.OP_ENDIF]);
    const asm = compiledData.flat();
    const compiled = compile(asm);
    const decompiled = decompile(compiled);
    if (!decompiled) {
      throw new Error("Failed to decompile script??");
    }
    return compiled;
  }
};
var CustomGenerator = class extends Generator {
  constructor(senderPubKey, network = bitcoin$1) {
    super(senderPubKey, void 0, network);
  }
  /**
   * Compile an interaction bitcoin script
   * @param compiledData - The compiled data
   * @returns {Uint8Array} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(compiledData) {
    const asm = compiledData.flat();
    const compiled = compile(asm);
    const decompiled = decompile(compiled);
    if (!decompiled) {
      throw new Error("Failed to decompile script??");
    }
    return compiled;
  }
};
var OPNET_DEPLOYMENT_VERSION = 0;
var versionBuffer = Uint8Array.from([OPNET_DEPLOYMENT_VERSION]);
var DeploymentGenerator = class extends Generator {
  constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
    super(senderPubKey, contractSaltPubKey, network);
  }
  /**
   * Compile a bitcoin script representing a contract deployment
   * @param {Uint8Array} contractBytecode - The contract bytecode
   * @param {Uint8Array} contractSalt - The contract salt
   * @param {ChallengeSolution} challenge - The challenge for reward
   * @param {bigint} maxPriority - The maximum priority for the contract
   * @param {Uint8Array} [calldata] - The calldata to be passed to the contract
   * @param {Feature<Features>[]} [features] - Optional features to include in the script
   * @returns {Uint8Array} - The compiled script
   */
  compile(contractBytecode, contractSalt, challenge, maxPriority, calldata, features) {
    const asm = this.getAsm(contractBytecode, contractSalt, challenge, maxPriority, calldata, features);
    const compiled = compile(asm);
    const decompiled = decompile(compiled);
    if (!decompiled) {
      throw new Error("Failed to decompile script??");
    }
    return compiled;
  }
  getAsm(contractBytecode, contractSalt, challenge, maxPriority, calldata, featuresRaw) {
    if (!this.contractSaltPubKey)
      throw new Error("Contract salt public key not set");
    const dataChunks = this.splitBufferIntoChunks(contractBytecode);
    const calldataChunks = calldata ? this.splitBufferIntoChunks(calldata) : [];
    const featuresList = [];
    const featureData = [];
    if (featuresRaw && featuresRaw.length) {
      const features = featuresRaw.sort((a, b) => a.priority - b.priority);
      const finalBuffer = new BinaryWriter();
      for (let i2 = 0; i2 < features.length; i2++) {
        const feature = features[i2];
        featuresList.push(feature.opcode);
        this.encodeFeature(feature, finalBuffer);
      }
      featureData.push(...this.splitBufferIntoChunks(new Uint8Array(finalBuffer.getBuffer())));
    }
    const compiledData = [
      this.getHeader(maxPriority, featuresList),
      opcodes.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      challenge.publicKey.toBuffer(),
      opcodes.OP_TOALTSTACK,
      challenge.solution,
      opcodes.OP_TOALTSTACK,
      this.xSenderPubKey,
      opcodes.OP_DUP,
      opcodes.OP_HASH256,
      hash256(this.xSenderPubKey),
      opcodes.OP_EQUALVERIFY,
      opcodes.OP_CHECKSIGVERIFY,
      this.contractSaltPubKey,
      opcodes.OP_CHECKSIGVERIFY,
      opcodes.OP_HASH256,
      hash256(contractSalt),
      opcodes.OP_EQUALVERIFY,
      opcodes.OP_DEPTH,
      opcodes.OP_1,
      opcodes.OP_NUMEQUAL,
      opcodes.OP_IF,
      Generator.MAGIC,
      ...featureData,
      opcodes.OP_0,
      ...calldataChunks,
      opcodes.OP_1NEGATE,
      ...dataChunks,
      opcodes.OP_ELSE,
      opcodes.OP_1,
      opcodes.OP_ENDIF
    ];
    return compiledData.flat();
  }
};
function lightenColor(color, percent) {
  color = color.replace("#", "");
  const num = parseInt(color, 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, B = (num >> 8 & 255) + amt, G2 = (num & 255) + amt;
  return (16777216 + (R < 255 ? R < 1 ? 0 : R : 255) * 65536 + (B < 255 ? B < 1 ? 0 : B : 255) * 256 + (G2 < 255 ? G2 < 1 ? 0 : G2 : 255)).toString(16).slice(1);
}
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code2) => `\x1B[${code2 + offset}m`;
var wrapAnsi256 = (offset = 0) => (code2) => `\x1B[${38 + offset};5;${code2}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles$1 = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(styles$1.modifier);
var foregroundColorNames = Object.keys(styles$1.color);
var backgroundColorNames = Object.keys(styles$1.bgColor);
[...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles$1)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles$1[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles$1[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles$1, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles$1, "codes", {
    value: codes,
    enumerable: false
  });
  styles$1.color.close = "\x1B[39m";
  styles$1.bgColor.close = "\x1B[49m";
  styles$1.color.ansi = wrapAnsi16();
  styles$1.color.ansi256 = wrapAnsi256();
  styles$1.color.ansi16m = wrapAnsi16m();
  styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles$1, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code2) {
        if (code2 < 8) {
          return 30 + code2;
        }
        if (code2 < 16) {
          return 90 + (code2 - 8);
        }
        let red;
        let green;
        let blue;
        if (code2 >= 232) {
          red = ((code2 - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code2 -= 16;
          const remainder = code2 % 36;
          red = Math.floor(code2 / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles$1;
}
var ansiStyles = assembleStyles();
var level = (() => {
  if (!("navigator" in globalThis)) {
    return 0;
  }
  if (globalThis.navigator.userAgentData) {
    const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
    if (brand && brand.version > 93) {
      return 3;
    }
  }
  if (/\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent)) {
    return 1;
  }
  return 0;
})();
var colorSupport = level !== 0 && {
  level
};
var supportsColor = {
  stdout: colorSupport,
  stderr: colorSupport
};
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
var { stdout: stdoutColor, stderr: stderrColor } = supportsColor;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var Chalk = class {
  constructor(options) {
    return chalkFactory(options);
  }
};
var chalkFactory = (options) => {
  const chalk = (...strings2) => strings2.join(" ");
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level2, type2, ...arguments_) => {
  if (model === "rgb") {
    if (level2 === "ansi16m") {
      return ansiStyles[type2].ansi16m(...arguments_);
    }
    if (level2 === "ansi256") {
      return ansiStyles[type2].ansi256(ansiStyles.rgbToAnsi256(...arguments_));
    }
    return ansiStyles[type2].ansi(ansiStyles.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level2, type2, ...ansiStyles.hexToRgb(...arguments_));
  }
  return ansiStyles[type2][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const { level: level2 } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level2], "color", ...arguments_), ansiStyles.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const { level: level2 } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level2], "bgColor", ...arguments_), ansiStyles.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level2) {
      this[GENERATOR].level = level2;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
createChalk();
createChalk({ level: stderrColor ? stderrColor.level : 0 });
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SharedLogger_pink;
var _SharedLogger_lightPink;
var _SharedLogger_purple;
var _SharedLogger_lightPurple;
var _SharedLogger_lighterPurple;
var _SharedLogger_green;
var _SharedLogger_lightGreen;
var _SharedLogger_moca;
var _SharedLogger_lightMoca;
var _SharedLogger_orange;
var _SharedLogger_lightOrange;
var _SharedLogger_red;
var _SharedLogger_lightRed;
var _SharedLogger_white;
var _SharedLogger_lightWhite;
var _SharedLogger_darkred;
var _SharedLogger_lightdarkred;
var SharedLogger = class {
  constructor(chalk = new Chalk()) {
    this.chalk = chalk;
    this.moduleName = "";
    this.logColor = "#00bfff";
    this.enableLogs = true;
    this.hideLogs = false;
    _SharedLogger_pink.set(this, "#ff00ff");
    _SharedLogger_lightPink.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_pink, "f"), 75));
    _SharedLogger_purple.set(this, "#9400d3");
    _SharedLogger_lightPurple.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_purple, "f"), 15));
    _SharedLogger_lighterPurple.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_lightPurple, "f"), 15));
    _SharedLogger_green.set(this, "#7cfc00");
    _SharedLogger_lightGreen.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_green, "f"), 15));
    _SharedLogger_moca.set(this, "#ffdead");
    _SharedLogger_lightMoca.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_moca, "f"), 15));
    _SharedLogger_orange.set(this, "#ff8c00");
    _SharedLogger_lightOrange.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_orange, "f"), 15));
    _SharedLogger_red.set(this, "#ff4500");
    _SharedLogger_lightRed.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_red, "f"), 15));
    _SharedLogger_white.set(this, "#ffffff");
    _SharedLogger_lightWhite.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_white, "f"), 15));
    _SharedLogger_darkred.set(this, "#8b0000");
    _SharedLogger_lightdarkred.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_darkred, "f"), 15));
    this.prefix = "";
    this.moduleName = this.constructor.name;
  }
  setLogPrefix(prefix) {
    this.prefix = prefix;
  }
  getStartPrefix() {
    return this.prefix;
  }
  disable() {
    this.enableLogs = false;
  }
  enable() {
    this.enableLogs = true;
  }
  fancyLog(msg1, highlight1, msg2, highlight2, msg3) {
    if (!this.enableLogs)
      return;
    console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg1) + " " + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(highlight1) + " " + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg2) + " " + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lighterPurple, "f"))(highlight2) + " " + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg3));
  }
  log(...args) {
    if (!this.enableLogs)
      return;
    if (!this.hideLogs) {
      const light = lightenColor(this.logColor, 15);
      console.log(this.chalk.hex(this.logColor)(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(light)(...args));
    }
  }
  lightOrangeLog(...args) {
    if (!this.enableLogs)
      return;
    if (!this.hideLogs) {
      console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(...args));
    }
  }
  error(...args) {
    if (!this.enableLogs)
      return;
    console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_red, "f"))(`${this.getStartPrefix()}[${this.moduleName} ERROR]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightRed, "f"))(...args));
  }
  warn(...args) {
    if (!this.enableLogs)
      return;
    console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_orange, "f"))(`${this.getStartPrefix()}[${this.moduleName} WARN]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(...args));
  }
  debug(...args) {
    if (!this.enableLogs)
      return;
    if (!this.hideLogs) {
      console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_moca, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightMoca, "f"))(...args));
    }
  }
  success(...args) {
    if (!this.enableLogs)
      return;
    if (!this.hideLogs) {
      console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_green, "f"))(`${this.getStartPrefix()}[${this.moduleName} SUCCESS]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightGreen, "f"))(...args));
    }
  }
  fail(...args) {
    if (!this.enableLogs)
      return;
    if (!this.hideLogs) {
      console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_red, "f"))(`${this.getStartPrefix()}[${this.moduleName} FAIL]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightRed, "f"))(...args));
    }
  }
  debugBright(...args) {
    if (!this.enableLogs)
      return;
    if (!this.hideLogs) {
      console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_purple, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightPurple, "f"))(...args));
    }
  }
  important(...args) {
    if (!this.enableLogs)
      return;
    console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} IMPORTANT]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightPink, "f"))(...args));
  }
  panic(...args) {
    if (!this.enableLogs)
      return;
    console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_darkred, "f"))(`${this.getStartPrefix()}[${this.moduleName} HELP PANIC]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightdarkred, "f"))(...args));
  }
  info(...args) {
    if (!this.enableLogs)
      return;
    console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(...args));
  }
  securityNotice(...args) {
    if (!this.enableLogs)
      return;
    console.log(this.chalk.hex("#22d8e6")(`${this.getStartPrefix()}[${this.moduleName} SECURITY NOTICE]: `) + this.chalk.hex("#22e3e6")(...args));
  }
  traceLog(...args) {
    if (!this.enableLogs)
      return;
    console.log(this.chalk.hex("#ffffff")(`${this.getStartPrefix()}[${this.moduleName} TRACE LOG]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightWhite, "f"))(...args));
  }
};
_SharedLogger_pink = /* @__PURE__ */ new WeakMap(), _SharedLogger_lightPink = /* @__PURE__ */ new WeakMap(), _SharedLogger_purple = /* @__PURE__ */ new WeakMap(), _SharedLogger_lightPurple = /* @__PURE__ */ new WeakMap(), _SharedLogger_lighterPurple = /* @__PURE__ */ new WeakMap(), _SharedLogger_green = /* @__PURE__ */ new WeakMap(), _SharedLogger_lightGreen = /* @__PURE__ */ new WeakMap(), _SharedLogger_moca = /* @__PURE__ */ new WeakMap(), _SharedLogger_lightMoca = /* @__PURE__ */ new WeakMap(), _SharedLogger_orange = /* @__PURE__ */ new WeakMap(), _SharedLogger_lightOrange = /* @__PURE__ */ new WeakMap(), _SharedLogger_red = /* @__PURE__ */ new WeakMap(), _SharedLogger_lightRed = /* @__PURE__ */ new WeakMap(), _SharedLogger_white = /* @__PURE__ */ new WeakMap(), _SharedLogger_lightWhite = /* @__PURE__ */ new WeakMap(), _SharedLogger_darkred = /* @__PURE__ */ new WeakMap(), _SharedLogger_lightdarkred = /* @__PURE__ */ new WeakMap();
var Logger = class extends SharedLogger {
  constructor() {
    super();
  }
};
var DebugLevel;
(function(DebugLevel2) {
  DebugLevel2[DebugLevel2["NONE"] = 0] = "NONE";
  DebugLevel2[DebugLevel2["ERROR"] = 1] = "ERROR";
  DebugLevel2[DebugLevel2["WARN"] = 2] = "WARN";
  DebugLevel2[DebugLevel2["INFO"] = 3] = "INFO";
  DebugLevel2[DebugLevel2["DEBUG"] = 4] = "DEBUG";
  DebugLevel2[DebugLevel2["TRACE"] = 5] = "TRACE";
  DebugLevel2[DebugLevel2["ALL"] = 6] = "ALL";
})(DebugLevel || (DebugLevel = {}));
var _HashCommitmentGenerator = class _HashCommitmentGenerator extends Logger {
  constructor(publicKey, network = bitcoin$1) {
    super();
    __publicField(this, "logColor", "#4a90d9");
    __publicField(this, "publicKey");
    __publicField(this, "network");
    if (publicKey.length !== 33) {
      throw new Error("Public key must be 33 bytes (compressed)");
    }
    this.publicKey = publicKey;
    this.network = network;
  }
  /**
   * Calculate the maximum number of inputs per standard reveal transaction.
   *
   * Standard tx weight limit: 400,000
   * With max chunks per input (~10,385 weight), only ~38 inputs fit
   *
   * @returns Maximum inputs per reveal tx (~38 with max chunks)
   */
  static calculateMaxInputsPerTx() {
    const txOverhead = 40;
    const outputOverhead = 200;
    const availableWeight = _HashCommitmentGenerator.MAX_STANDARD_WEIGHT - txOverhead - outputOverhead;
    return Math.floor(availableWeight / _HashCommitmentGenerator.WEIGHT_PER_INPUT);
  }
  /**
   * Calculate maximum data per standard reveal transaction.
   *
   * @returns Maximum data in bytes (~300KB with batched chunks at 70 chunks/output)
   */
  static calculateMaxDataPerTx() {
    return _HashCommitmentGenerator.calculateMaxInputsPerTx() * _HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT * _HashCommitmentGenerator.MAX_CHUNK_SIZE;
  }
  /**
   * Estimate the number of P2WSH outputs needed for a given data size.
   *
   * @param dataSize Data size in bytes
   * @returns Number of P2WSH outputs needed
   */
  static estimateOutputCount(dataSize) {
    return Math.ceil(dataSize / (_HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT * _HashCommitmentGenerator.MAX_CHUNK_SIZE));
  }
  /**
   * Estimate the number of 80-byte chunks for a given data size.
   *
   * @param dataSize Data size in bytes
   * @returns Number of 80-byte chunks needed
   */
  static estimateChunkCount(dataSize) {
    return Math.ceil(dataSize / _HashCommitmentGenerator.MAX_CHUNK_SIZE);
  }
  /**
   * Validate that a witness script is a valid multi-hash committed script.
   *
   * Script structure: (OP_HASH160 <hash> OP_EQUALVERIFY)+ <pubkey> OP_CHECKSIG
   *
   * @param witnessScript The witness script to validate
   * @returns true if valid hash-committed script
   */
  static validateHashCommittedScript(witnessScript) {
    try {
      const decompiled = decompile(witnessScript);
      if (!decompiled || decompiled.length < 5) {
        return false;
      }
      const lastIdx = decompiled.length - 1;
      if (decompiled[lastIdx] !== opcodes.OP_CHECKSIG) {
        return false;
      }
      const pubkey = decompiled[lastIdx - 1];
      if (!(pubkey instanceof Uint8Array) || pubkey.length !== 33) {
        return false;
      }
      const hashParts = decompiled.slice(0, -2);
      if (hashParts.length % 3 !== 0 || hashParts.length === 0) {
        return false;
      }
      for (let i2 = 0; i2 < hashParts.length; i2 += 3) {
        const hash2 = hashParts[i2 + 1];
        if (hashParts[i2] !== opcodes.OP_HASH160 || !(hash2 instanceof Uint8Array) || hash2.length !== 20 || hashParts[i2 + 2] !== opcodes.OP_EQUALVERIFY) {
          return false;
        }
      }
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Extract all data hashes from a hash-committed witness script.
   *
   * @param witnessScript The witness script
   * @returns Array of 20-byte data hashes (in data order), or null if invalid
   */
  static extractDataHashes(witnessScript) {
    try {
      const decompiled = decompile(witnessScript);
      if (!decompiled || !_HashCommitmentGenerator.validateHashCommittedScript(witnessScript)) {
        return null;
      }
      const hashParts = decompiled.slice(0, -2);
      const hashes = [];
      for (let i2 = 0; i2 < hashParts.length; i2 += 3) {
        hashes.push(hashParts[i2 + 1]);
      }
      return hashes.reverse();
    } catch {
      return null;
    }
  }
  /**
   * Extract the public key from a hash-committed witness script.
   *
   * @param witnessScript The witness script
   * @returns The 33-byte public key, or null if invalid script
   */
  static extractPublicKey(witnessScript) {
    try {
      const decompiled = decompile(witnessScript);
      if (!decompiled || !_HashCommitmentGenerator.validateHashCommittedScript(witnessScript)) {
        return null;
      }
      return decompiled[decompiled.length - 2];
    } catch {
      return null;
    }
  }
  /**
   * Verify that data chunks match their committed hashes.
   *
   * @param dataChunks Array of data chunks (in order)
   * @param witnessScript The witness script containing the hash commitments
   * @returns true if all chunks match their commitments
   */
  static verifyChunkCommitments(dataChunks, witnessScript) {
    const committedHashes = _HashCommitmentGenerator.extractDataHashes(witnessScript);
    if (!committedHashes || committedHashes.length !== dataChunks.length) {
      return false;
    }
    for (let i2 = 0; i2 < dataChunks.length; i2++) {
      const actualHash = hash160(dataChunks[i2]);
      if (!equals(committedHashes[i2], actualHash)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Estimate fees for a complete CHCT flow (setup + reveal).
   *
   * @param dataSize Data size in bytes (before compression)
   * @param feeRate Fee rate in sat/vB
   * @param compressionRatio Expected compression ratio (default: 0.7)
   * @returns Fee estimates
   */
  static estimateFees(dataSize, feeRate, compressionRatio = 0.7) {
    const compressedSize = Math.ceil(dataSize * compressionRatio);
    const outputCount = _HashCommitmentGenerator.estimateOutputCount(compressedSize);
    const chunkCount = _HashCommitmentGenerator.estimateChunkCount(compressedSize);
    const setupInputVBytes = 2 * 58;
    const setupOutputVBytes = outputCount * 43 + 43;
    const setupOverhead = 11;
    const setupVBytes = setupOverhead + setupInputVBytes + setupOutputVBytes;
    const revealWeight = 40 + outputCount * _HashCommitmentGenerator.WEIGHT_PER_INPUT + 200;
    const revealVBytes = Math.ceil(revealWeight / 4);
    const setupFee = BigInt(Math.ceil(setupVBytes * feeRate));
    const revealFee = BigInt(Math.ceil(revealVBytes * feeRate));
    const totalFee = setupFee + revealFee;
    const outputsValue = BigInt(outputCount) * _HashCommitmentGenerator.MIN_OUTPUT_VALUE;
    const totalCost = totalFee + outputsValue;
    return {
      compressedSize,
      outputCount,
      chunkCount,
      setupVBytes,
      revealVBytes,
      setupFee,
      revealFee,
      totalFee,
      outputsValue,
      totalCost
    };
  }
  /**
   * Calculate the HASH160 of a data chunk.
   * HASH160 = RIPEMD160(SHA256(data))
   */
  hashChunk(data) {
    return hash160(data);
  }
  /**
   * Generate a hash-committed witness script for multiple data chunks.
   *
   * Script structure (for N chunks):
   * OP_HASH160 <hash_N> OP_EQUALVERIFY
   * OP_HASH160 <hash_N-1> OP_EQUALVERIFY
   * ...
   * OP_HASH160 <hash_1> OP_EQUALVERIFY
   * <pubkey> OP_CHECKSIG
   *
   * Hashes are in reverse order because witness stack is LIFO.
   * Witness stack: [sig, data_1, data_2, ..., data_N, witnessScript]
   * Stack before execution: [sig, data_1, data_2, ..., data_N] (data_N on top)
   *
   * @param dataHashes Array of HASH160 values (in data order, will be reversed in script)
   * @returns The compiled witness script
   */
  generateWitnessScript(dataHashes) {
    if (dataHashes.length === 0) {
      throw new Error("At least one data hash is required");
    }
    if (dataHashes.length > _HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT) {
      throw new Error(`Too many chunks: ${dataHashes.length} exceeds limit of ${_HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT}`);
    }
    for (const hash2 of dataHashes) {
      if (hash2.length !== 20) {
        throw new Error(`HASH160 requires 20-byte hash, got ${hash2.length}`);
      }
    }
    const scriptParts = [];
    for (let i2 = dataHashes.length - 1; i2 >= 0; i2--) {
      scriptParts.push(opcodes.OP_HASH160);
      scriptParts.push(dataHashes[i2]);
      scriptParts.push(opcodes.OP_EQUALVERIFY);
    }
    scriptParts.push(this.publicKey);
    scriptParts.push(opcodes.OP_CHECKSIG);
    return compile(scriptParts);
  }
  /**
   * Generate a P2WSH address from a witness script.
   *
   * @param witnessScript The witness script
   * @returns P2WSH address info
   */
  generateP2WSHAddress(witnessScript) {
    const p2wsh$1 = p2wsh({
      redeem: { output: witnessScript },
      network: this.network
    });
    if (!p2wsh$1.address || !p2wsh$1.output) {
      throw new Error("Failed to generate P2WSH address");
    }
    return {
      address: p2wsh$1.address,
      witnessScript,
      scriptPubKey: p2wsh$1.output
    };
  }
  /**
   * Split data into chunks and generate hash-committed P2WSH outputs.
   *
   * Each output commits to up to 98 data chunks (80 bytes each = 7,840 bytes).
   * This is MUCH more efficient than one output per chunk.
   *
   * @param data The data to chunk and commit
   * @param maxChunkSize Maximum bytes per stack item (default: 80, P2WSH stack item limit)
   * @returns Array of hash-committed P2WSH outputs
   */
  prepareChunks(data, maxChunkSize = _HashCommitmentGenerator.MAX_CHUNK_SIZE) {
    if (maxChunkSize > _HashCommitmentGenerator.MAX_CHUNK_SIZE) {
      throw new Error(`Chunk size ${maxChunkSize} exceeds P2WSH stack item limit of ${_HashCommitmentGenerator.MAX_CHUNK_SIZE}`);
    }
    if (data.length === 0) {
      throw new Error("Data cannot be empty");
    }
    const allChunks = [];
    let offset = 0;
    while (offset < data.length) {
      const chunkSize = Math.min(maxChunkSize, data.length - offset);
      allChunks.push(new Uint8Array(data.subarray(offset, offset + chunkSize)));
      offset += chunkSize;
    }
    const outputs2 = [];
    let chunkIndex = 0;
    while (chunkIndex < allChunks.length) {
      const chunksForThisOutput = allChunks.slice(chunkIndex, chunkIndex + _HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT);
      const dataChunks = chunksForThisOutput;
      const dataHashes = dataChunks.map((chunk) => this.hashChunk(chunk));
      const witnessScript = this.generateWitnessScript(dataHashes);
      const p2wsh2 = this.generateP2WSHAddress(witnessScript);
      outputs2.push({
        address: p2wsh2.address,
        witnessScript: p2wsh2.witnessScript,
        scriptPubKey: p2wsh2.scriptPubKey,
        dataHashes,
        dataChunks,
        chunkStartIndex: chunkIndex
      });
      chunkIndex += chunksForThisOutput.length;
    }
    const totalChunks = allChunks.length;
    this.log(`Prepared ${outputs2.length} P2WSH outputs with ${totalChunks} chunks (${data.length} bytes, ~${Math.ceil(data.length / outputs2.length)} bytes/output)`);
    return outputs2;
  }
};
/**
 * Maximum chunk size per Bitcoin P2WSH stack item limit.
 * See policy.h: MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80
 */
__publicField(_HashCommitmentGenerator, "MAX_CHUNK_SIZE", 80);
/**
 * Maximum stack items per P2WSH input.
 * See policy.h: MAX_STANDARD_P2WSH_STACK_ITEMS = 100
 */
__publicField(_HashCommitmentGenerator, "MAX_STACK_ITEMS", 100);
/**
 * Maximum total witness size (serialized).
 * See policy.cpp: GetSerializeSize(tx.vin[i].scriptWitness.stack) > g_script_size_policy_limit
 * Default: 1650 bytes
 */
__publicField(_HashCommitmentGenerator, "MAX_WITNESS_SIZE", 1650);
/** Maximum weight per standard transaction */
__publicField(_HashCommitmentGenerator, "MAX_STANDARD_WEIGHT", 4e5);
/** Minimum satoshis per output (dust limit) */
__publicField(_HashCommitmentGenerator, "MIN_OUTPUT_VALUE", 330n);
/**
 * Bytes per hash commitment in witness script.
 * OP_HASH160 (1) + push (1) + hash (20) + OP_EQUALVERIFY (1) = 23 bytes
 */
__publicField(_HashCommitmentGenerator, "BYTES_PER_COMMITMENT", 23);
/**
 * Fixed overhead in witness serialization:
 * - Stack item count: 1 byte
 * - Signature: 73 bytes (72 + 1 length prefix)
 * - Script length prefix: 3 bytes (varInt for sizes 253-65535)
 * - Script base (pubkey + checksig): 35 bytes
 */
__publicField(_HashCommitmentGenerator, "WITNESS_FIXED_OVERHEAD", 1 + 73 + 3 + 35);
/**
 * Per-chunk overhead in witness:
 * - Data: 81 bytes (80 + 1 length prefix)
 * - Script commitment: 23 bytes
 * Total: 104 bytes per chunk
 */
__publicField(_HashCommitmentGenerator, "WITNESS_PER_CHUNK_OVERHEAD", _HashCommitmentGenerator.MAX_CHUNK_SIZE + 1 + _HashCommitmentGenerator.BYTES_PER_COMMITMENT);
/**
 * Maximum data chunks per P2WSH output.
 * Limited by total witness size: (1650 - 112) / 104 = 14 chunks
 */
__publicField(_HashCommitmentGenerator, "MAX_CHUNKS_PER_OUTPUT", Math.floor((_HashCommitmentGenerator.MAX_WITNESS_SIZE - _HashCommitmentGenerator.WITNESS_FIXED_OVERHEAD) / _HashCommitmentGenerator.WITNESS_PER_CHUNK_OVERHEAD));
/** Base weight per input (non-witness): 41 bytes * 4 = 164 */
__publicField(_HashCommitmentGenerator, "INPUT_BASE_WEIGHT", 164);
/**
 * Witness weight per input with max chunks:
 * Total witness size is ~1566 bytes (under 1650 limit)
 * Witness bytes count as 1 weight unit each.
 */
__publicField(_HashCommitmentGenerator, "INPUT_WITNESS_WEIGHT_MAX", _HashCommitmentGenerator.MAX_WITNESS_SIZE);
// Use max as upper bound
/** Total weight per input (with max chunks) */
__publicField(_HashCommitmentGenerator, "WEIGHT_PER_INPUT", _HashCommitmentGenerator.INPUT_BASE_WEIGHT + _HashCommitmentGenerator.INPUT_WITNESS_WEIGHT_MAX);
var HashCommitmentGenerator = _HashCommitmentGenerator;
var _MultiSignGenerator = class _MultiSignGenerator {
  static compile(vaultPublicKeys, minimumSignatures = 0, internal2) {
    if (minimumSignatures < 2) {
      throw new Error("Minimum signatures must be greater than 1");
    }
    if (vaultPublicKeys.length < minimumSignatures) {
      throw new Error("The amount of public keys is lower than the minimum required");
    }
    if (minimumSignatures > _MultiSignGenerator.MAXIMUM_SUPPORTED_SIGNATURE) {
      throw new Error(`The maximum amount of signatures is ${_MultiSignGenerator.MAXIMUM_SUPPORTED_SIGNATURE}`);
    }
    const minimumRequired = alloc(1);
    minimumRequired[0] = minimumSignatures;
    vaultPublicKeys = vaultPublicKeys.filter((buf, index, self2) => index === self2.findIndex((otherBuf) => equals(buf, otherBuf)));
    vaultPublicKeys = vaultPublicKeys.sort((a, b) => compare$2(a, b));
    let included = false;
    const data = vaultPublicKeys.map((key) => {
      const newKey = toXOnly(key);
      if (internal2 && !included)
        included = equals(internal2, newKey);
      return newKey;
    });
    if (internal2 && !included)
      data.push(internal2);
    const compiledData = [
      // Push the initial 0 (for OP_CHECKSIGADD)
      opcodes.OP_0,
      // For each public key, add CHECKSIGADD operation
      ...data.flatMap((key) => [
        key,
        // Push the public key
        opcodes.OP_CHECKSIGADD
        // Add the public key to the signature set
      ]),
      // Finally, compare the sum with the minimum required signatures
      minimumRequired,
      opcodes.OP_NUMEQUAL
      // Use NUMEQUALVERIFY to ensure the correct number of signatures
    ];
    const asm = compiledData.flat();
    const compiled = compile(asm);
    const decompiled = decompile(compiled);
    if (!decompiled) {
      throw new Error("Failed to decompile script.");
    }
    return compiled;
  }
};
__publicField(_MultiSignGenerator, "MAXIMUM_SUPPORTED_SIGNATURE", 255);
var MultiSignGenerator = _MultiSignGenerator;
var _P2WDAGenerator = class _P2WDAGenerator extends Generator {
  constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
    super(senderPubKey, contractSaltPubKey, network);
  }
  /**
   * Validate that operation data will fit in P2WDA witness fields
   *
   * @param dataSize Size of the operation data
   * @param maxWitnessFields Maximum number of witness fields (default 10)
   * @param maxBytesPerWitness Maximum bytes per witness field (default 80)
   * @returns true if data will fit, false otherwise
   */
  static validateWitnessSize(dataSize, maxWitnessFields = 10, maxBytesPerWitness = 80) {
    const signatureSize = 64;
    const compressionRatio = 0.7;
    const totalSize = dataSize + signatureSize;
    const compressedSize = Math.ceil(totalSize * compressionRatio);
    const requiredFields = Math.ceil(compressedSize / maxBytesPerWitness);
    return requiredFields <= maxWitnessFields;
  }
  /**
   * Compile operation data for P2WDA witness embedding
   *
   * This creates a binary structure containing all operation information
   * without Bitcoin script opcodes. The structure is:
   *
   * [version(1)] [header(12)] [contract(32)] [challenge_pubkey(33)] [challenge_solution(32)]
   * [calldata_length(4)] [calldata] [features_length(2)] [features_data]
   *
   * @param calldata The compressed calldata for the contract interaction
   * @param contractSecret The 32-byte contract secret
   * @param challenge The challenge solution for epoch rewards
   * @param maxPriority Maximum priority fee in satoshis
   * @param featuresRaw Optional features like access lists
   * @returns Raw operation data ready for signing and compression
   */
  compile(calldata, contractSecret, challenge, maxPriority, featuresRaw = []) {
    if (!this.contractSaltPubKey) {
      throw new Error("Contract salt public key not set");
    }
    if (contractSecret.length !== 32) {
      throw new Error("Contract secret must be exactly 32 bytes");
    }
    const writer = new BinaryWriter();
    writer.writeU8(_P2WDAGenerator.P2WDA_VERSION);
    const features = featuresRaw.sort((a, b) => a.priority - b.priority);
    writer.writeBytes(this.getHeader(maxPriority, features.map((f) => f.opcode)));
    writer.writeBytes(contractSecret);
    writer.writeBytes(challenge.publicKey.toBuffer());
    writer.writeBytes(challenge.solution);
    writer.writeU32(calldata.length);
    writer.writeBytes(calldata);
    this.writeFeatures(writer, features);
    return new Uint8Array(writer.getBuffer());
  }
  getHeader(maxPriority, features = []) {
    return super.getHeader(maxPriority, features);
  }
  /**
   * Write features section to the operation data
   *
   * Features are encoded as:
   * [feature_count(2)] [feature1_opcode(1)] [feature1_length(4)] [feature1_data] ...
   *
   * @param writer Binary writer to write to
   * @param features Array of features to encode
   */
  writeFeatures(writer, features) {
    writer.writeU16(features.length);
    for (const feature of features) {
      writer.writeU8(feature.opcode);
      this.encodeFeature(feature, writer);
    }
  }
};
__publicField(_P2WDAGenerator, "P2WDA_VERSION", 1);
var P2WDAGenerator = _P2WDAGenerator;
var AddressGenerator = class {
  // Generate a valid SegWit address from random bytes
  static generatePKSH(sha256Hash, network) {
    if (sha256Hash.length !== 32)
      throw new Error("Invalid hash length");
    const pkh = ripemd1602(sha256Hash);
    return this.toSegwitAddress(pkh, network);
  }
  // Generate a valid Taproot address from a public key
  static generateTaprootAddress(pubKey, network) {
    if (pubKey.length !== 32)
      throw new Error("Invalid public key length");
    const words = distExports.bech32m.toWords(pubKey);
    words.unshift(1);
    return distExports.bech32m.encode(network.bech32, words);
  }
  // Convert a hash to a SegWit address
  static toSegwitAddress(pkh, network) {
    const words = distExports.bech32.toWords(pkh);
    words.unshift(0);
    return distExports.bech32.encode(network.bech32, words);
  }
};
function isUniversalSigner(signer) {
  return "privateKey" in signer && signer.privateKey != null;
}
var TweakedSigner = class {
  /**
   * Tweak a signer
   * @param {UniversalSigner} signer - The signer to tweak (must have privateKey)
   * @param {TweakSettings} opts - The tweak settings
   * @returns {UniversalSigner} - The tweaked signer
   */
  static tweakSigner(signer, opts = {}) {
    let privateKey = signer.privateKey;
    if (!privateKey) {
      throw new Error("Private key is required for tweaking signer!");
    }
    if (signer.publicKey[0] === 3) {
      privateKey = backend.privateNegate(privateKey);
    }
    const tweakedPrivateKey = backend.privateAdd(privateKey, tapTweakHash$1(toXOnly(signer.publicKey), opts.tweakHash));
    if (!tweakedPrivateKey) {
      throw new Error("Invalid tweaked private key!");
    }
    return EcKeyPair.fromPrivateKey(tweakedPrivateKey, opts.network);
  }
};
function isOPWallet(wallet) {
  return typeof wallet === "object" && wallet !== null && "web3" in wallet && typeof wallet.web3 === "object" && "getMLDSAPublicKey" in wallet.web3 && "signMLDSAMessage" in wallet.web3;
}
var MessageSignerBase = class {
  sha256(message) {
    return sha256$12(message);
  }
  async trySignSchnorrWithOPWallet(message) {
    const wallet = this.getOPWallet();
    if (!wallet) {
      return null;
    }
    const messageBuffer = typeof message === "string" ? new TextEncoder().encode(message) : message;
    const hashedMessage = this.sha256(messageBuffer);
    const messageHex = toHex$1(hashedMessage);
    const signatureHex = await wallet.web3.signSchnorr(messageHex);
    return {
      signature: fromHex$1(signatureHex),
      message: hashedMessage
    };
  }
  async trySignMLDSAWithOPWallet(message) {
    const wallet = this.getOPWallet();
    if (!wallet) {
      return null;
    }
    const messageBuffer = typeof message === "string" ? new TextEncoder().encode(message) : message;
    const hashedMessage = this.sha256(messageBuffer);
    const messageHex = toHex$1(hashedMessage);
    const result = await wallet.web3.signMLDSAMessage(messageHex);
    return {
      signature: fromHex$1(result.signature),
      message: hashedMessage,
      publicKey: fromHex$1(result.publicKey),
      securityLevel: result.securityLevel
    };
  }
  async signMessageAuto(message, keypair) {
    if (!keypair) {
      const walletResult = await this.trySignSchnorrWithOPWallet(message);
      if (walletResult) {
        return walletResult;
      }
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    return this.signMessage(keypair, message);
  }
  async tweakAndSignMessageAuto(message, keypair, network) {
    if (!keypair) {
      const walletResult = await this.trySignSchnorrWithOPWallet(message);
      if (walletResult) {
        return walletResult;
      }
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    if (!network) {
      throw new Error("Network is required when signing with a local keypair.");
    }
    return this.tweakAndSignMessage(keypair, message, network);
  }
  async signMLDSAMessageAuto(message, mldsaKeypair) {
    if (!mldsaKeypair) {
      const walletResult = await this.trySignMLDSAWithOPWallet(message);
      if (walletResult) {
        return walletResult;
      }
      throw new Error("No ML-DSA keypair provided and OP_WALLET is not available.");
    }
    return this.signMLDSAMessage(mldsaKeypair, message);
  }
  async verifyMLDSAWithOPWallet(message, signature2) {
    const wallet = this.getOPWallet();
    if (!wallet) {
      return null;
    }
    const messageBuffer = typeof message === "string" ? new TextEncoder().encode(message) : message;
    const hashedMessage = this.sha256(messageBuffer);
    const mldsaSignature = {
      signature: toHex$1(signature2.signature),
      publicKey: toHex$1(signature2.publicKey),
      securityLevel: signature2.securityLevel,
      messageHash: toHex$1(hashedMessage)
    };
    return wallet.web3.verifyMLDSASignature(toHex$1(hashedMessage), mldsaSignature);
  }
  async getMLDSAPublicKeyFromOPWallet() {
    const wallet = this.getOPWallet();
    if (!wallet) {
      return null;
    }
    const publicKeyHex = await wallet.web3.getMLDSAPublicKey();
    return fromHex$1(publicKeyHex);
  }
  tweakAndSignMessage(keypair, message, network) {
    const tweaked = TweakedSigner.tweakSigner(keypair, { network });
    return this.signMessage(tweaked, message);
  }
  signMessage(keypair, message) {
    if (typeof message === "string") {
      message = new TextEncoder().encode(message);
    }
    if (!keypair.privateKey) {
      throw new Error("Private key not found in keypair.");
    }
    const hashedMessage = this.sha256(message);
    if (!backend.signSchnorr) {
      throw new Error("backend.signSchnorr is not available.");
    }
    return {
      signature: backend.signSchnorr(hashedMessage, keypair.privateKey),
      message: hashedMessage
    };
  }
  verifySignature(publicKey, message, signature2) {
    if (typeof message === "string") {
      message = new TextEncoder().encode(message);
    }
    if (signature2.length !== 64) {
      throw new Error("Invalid signature length.");
    }
    const hashedMessage = this.sha256(message);
    if (!backend.verifySchnorr) {
      throw new Error("backend.verifySchnorr is not available.");
    }
    return backend.verifySchnorr(hashedMessage, toXOnly(publicKey), signature2);
  }
  tweakAndVerifySignature(publicKey, message, signature2) {
    const tweakedPublicKey = EcKeyPair.tweakPublicKey(publicKey);
    return this.verifySignature(tweakedPublicKey, message, signature2);
  }
  signMLDSAMessage(mldsaKeypair, message) {
    if (typeof message === "string") {
      message = new TextEncoder().encode(message);
    }
    if (!mldsaKeypair.privateKey) {
      throw new Error("ML-DSA private key not found in keypair.");
    }
    const hashedMessage = this.sha256(message);
    const signature2 = mldsaKeypair.sign(hashedMessage);
    return {
      signature: new Uint8Array(signature2),
      message: hashedMessage,
      publicKey: new Uint8Array(mldsaKeypair.publicKey),
      securityLevel: mldsaKeypair.securityLevel
    };
  }
  verifyMLDSASignature(mldsaKeypair, message, signature2) {
    if (typeof message === "string") {
      message = new TextEncoder().encode(message);
    }
    const hashedMessage = this.sha256(message);
    return mldsaKeypair.verify(hashedMessage, signature2);
  }
  isOPWalletAvailable() {
    return this.getOPWallet() !== null;
  }
  getOPWallet() {
    if (typeof window === "undefined") {
      return null;
    }
    const _window = window;
    if (!_window.opnet || !isOPWallet(_window.opnet)) {
      return null;
    }
    return _window.opnet;
  }
};
var MessageSigner = new MessageSignerBase();
var src = {};
var _wordlists = {};
var require$$02 = JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]');
var require$$12 = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
var require$$22 = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
var require$$3 = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
var require$$4 = JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","academie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquerir","acronyme","acteur","actif","actuel","adepte","adequat","adhesif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aerer","aeronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agreable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algebre","algue","aliener","aliment","alleger","alliage","allouer","allumer","alourdir","alpaga","altesse","alveole","amateur","ambigu","ambre","amenager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","aneantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","aperitif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","arteriel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","banniere","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","belier","belote","benefice","berceau","berger","berline","bermuda","besace","besogne","betail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","breche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","cafeine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","camera","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cedille","ceinture","celeste","cellule","cendrier","censurer","central","cercle","cerebral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chequier","chercher","cheval","chien","chiffre","chignon","chimere","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinema","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohesion","coiffer","coincer","colere","colibri","colline","colmater","colonel","combat","comedie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortege","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","creature","crediter","cremeux","creuser","crevette","cribler","crier","cristal","critere","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillere","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","debattre","debiter","deborder","debrider","debutant","decaler","decembre","dechirer","decider","declarer","decorer","decrire","decupler","dedale","deductif","deesse","defensif","defiler","defrayer","degager","degivrer","deglutir","degrafer","dejeuner","delice","deloger","demander","demeurer","demolir","denicher","denouer","dentelle","denuder","depart","depenser","dephaser","deplacer","deposer","deranger","derober","desastre","descente","desert","designer","desobeir","dessiner","destrier","detacher","detester","detourer","detresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","differer","digerer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","eblouir","ecarter","echarpe","echelle","eclairer","eclipse","eclore","ecluse","ecole","economie","ecorce","ecouter","ecraser","ecremer","ecrivain","ecrou","ecume","ecureuil","edifier","eduquer","effacer","effectif","effigie","effort","effrayer","effusion","egaliser","egarer","ejecter","elaborer","elargir","electron","elegant","elephant","eleve","eligible","elitisme","eloge","elucider","eluder","emballer","embellir","embryon","emeraude","emission","emmener","emotion","emouvoir","empereur","employer","emporter","emprise","emulsion","encadrer","enchere","enclave","encoche","endiguer","endosser","endroit","enduire","energie","enfance","enfermer","enfouir","engager","engin","englober","enigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","enumerer","envahir","enviable","envoyer","enzyme","eolien","epaissir","epargne","epatant","epaule","epicerie","epidemie","epier","epilogue","epine","episode","epitaphe","epoque","epreuve","eprouver","epuisant","equerre","equipe","eriger","erosion","erreur","eruption","escalier","espadon","espece","espiegle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","etagere","etaler","etanche","etatique","eteindre","etendoir","eternel","ethanol","ethique","ethnie","etirer","etoffer","etoile","etonnant","etourdir","etrange","etroit","etude","euphorie","evaluer","evasion","eventail","evidence","eviter","evolutif","evoquer","exact","exagerer","exaucer","exceller","excitant","exclusif","excuse","executer","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expedier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","febrile","feconder","federer","felin","femme","femur","fendoir","feodal","fermer","feroce","ferveur","festival","feuille","feutre","fevrier","fiasco","ficeler","fictif","fidele","figure","filature","filetage","filiere","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fleau","fleche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougere","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","fregate","freiner","frelon","fremir","frenesie","frere","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","geant","gelatine","gelule","gendarme","general","genie","genou","gentil","geologie","geometre","geranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyere","guepard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","helium","hematome","herbe","herisson","hermine","heron","hesiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogene","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiene","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","imperial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inedit","ineptie","inexact","infini","infliger","informer","infusion","ingerer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irreel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvenile","kayak","kimono","kiosque","label","labial","labourer","lacerer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","legal","leger","legume","lessive","lettre","levier","lexique","lezard","liasse","liberer","libre","licence","licorne","liege","lievre","ligature","ligoter","ligue","limer","limite","limonade","limpide","lineaire","lingot","lionceau","liquide","lisiere","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumiere","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","malefice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","materiel","matiere","matraque","maudire","maussade","mauve","maximal","mechant","meconnu","medaille","medecin","mediter","meduse","meilleur","melange","melodie","membre","memoire","menacer","mener","menhir","mensonge","mentor","mercredi","merite","merle","messager","mesure","metal","meteore","methode","metier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","mineral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murene","murmure","muscle","museum","musicien","mutation","muter","mutuel","myriade","myrtille","mystere","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nebuleux","nectar","nefaste","negation","negliger","negocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numero","nuptial","nuque","nutritif","obeir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","ocean","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onereux","onirique","opale","opaque","operer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygene","ozone","paisible","palace","palmares","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pasteque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pelican","pelle","pelouse","peluche","pendule","penetrer","penible","pensif","penurie","pepite","peplum","perdrix","perforer","periode","permuter","perplexe","persil","perte","peser","petale","petit","petrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","piece","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poesie","poete","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","ponderer","poney","portique","position","posseder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","precieux","predire","prefixe","prelude","prenom","presence","pretexte","prevoir","primitif","prince","prison","priver","probleme","proceder","prodige","profond","progres","proie","projeter","prologue","promener","propre","prospere","proteger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quietude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","reactif","reagir","realiser","reanimer","recevoir","reciter","reclamer","recolter","recruter","reculer","recycler","rediger","redouter","refaire","reflexe","reformer","refrain","refuge","regalien","region","reglage","regulier","reiterer","rejeter","rejouer","relatif","relever","relief","remarque","remede","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","reserve","resineux","resoudre","respect","rester","resultat","retablir","retenir","reticule","retomber","retracer","reunion","reussir","revanche","revivre","revolte","revulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","riviere","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scelerat","scenario","sceptre","schema","science","scinder","score","scrutin","sculpter","seance","secable","secher","secouer","secreter","sedatif","seduire","seigneur","sejour","selectif","semaine","sembler","semence","seminal","senateur","sensible","sentence","separer","sequence","serein","sergent","serieux","serrure","serum","service","sesame","sevir","sevrage","sextuple","sideral","siecle","sieger","siffler","sigle","signal","silence","silicium","simple","sincere","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","special","sphere","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succes","sucre","suffixe","suggerer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symetrie","synapse","syntaxe","systeme","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","temoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tetine","texte","theme","theorie","therapie","thorax","tibia","tiede","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolerant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trefle","tremper","tresor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","vegetal","vehicule","veinard","veloce","vendredi","venerer","venger","venimeux","ventouse","verdure","verin","vernir","verrou","verser","vertu","veston","veteran","vetuste","vexant","vexer","viaduc","viande","victoire","vidange","video","vignette","vigueur","vilain","village","vinaigre","violon","vipere","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xenon","yacht","zebre","zenith","zeste","zoologie"]');
var require$$5 = JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]');
var require$$6 = JSON.parse('["abaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","accion","aceite","acelga","acento","aceptar","acido","aclarar","acne","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aereo","afectar","aficion","afinar","afirmar","agil","agitar","agonia","agosto","agotar","agregar","agrio","agua","agudo","aguila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacran","alambre","alarma","alba","album","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodon","aliado","aliento","alivio","alma","almeja","almibar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ambar","ambito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","anden","anemia","angulo","anillo","animo","anis","anotar","antena","antiguo","antojo","anual","anular","anuncio","anadir","anejo","ano","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","arana","arar","arbitro","arbol","arbusto","archivo","arco","arder","ardilla","arduo","area","arido","aries","armonia","arnes","aroma","arpa","arpon","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","aspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","atico","atleta","atomo","atraer","atroz","atun","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avion","aviso","ayer","ayuda","ayuno","azafran","azar","azote","azucar","azufre","azul","baba","babor","bache","bahia","baile","bajar","balanza","balcon","balde","bambu","banco","banda","bano","barba","barco","barniz","barro","bascula","baston","basura","batalla","bateria","batir","batuta","baul","bazar","bebe","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsai","borde","borrar","bosque","bote","botin","boveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufon","buho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzon","caballo","cabeza","cabina","cabra","cacao","cadaver","cadena","caer","cafe","caida","caiman","caja","cajon","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cancer","candil","canela","canguro","canica","canto","cana","canon","caoba","caos","capaz","capitan","capote","captar","capucha","cara","carbon","carcel","careta","carga","carino","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","celebre","celoso","celula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","cesped","cetro","chacal","chaleco","champu","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclon","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","cipres","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clinica","cobre","coccion","cochino","cocina","coco","codigo","codo","cofre","coger","cohete","cojin","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","comodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazon","corbata","corcho","cordon","corona","correr","coser","cosmos","costa","craneo","crater","crear","crecer","creido","crema","cria","crimen","cripta","crisis","cromo","cronica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupon","cupula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","datil","deber","debil","decada","decir","dedo","defensa","definir","dejar","delfin","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvio","detalle","detener","deuda","dia","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","dificil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseno","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragon","droga","ducha","duda","duelo","dueno","dulce","duo","duque","durar","dureza","duro","ebano","ebrio","echar","eco","ecuador","edad","edicion","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","elite","elixir","elogio","eludir","embudo","emitir","emocion","empate","empeno","empleo","empresa","enano","encargo","enchufe","encia","enemigo","enero","enfado","enfermo","engano","enigma","enlace","enorme","enredo","ensayo","ensenar","entero","entrar","envase","envio","epoca","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espia","esposa","espuma","esqui","estar","este","estilo","estufa","etapa","eterno","etica","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","exito","experto","explicar","exponer","extremo","fabrica","fabula","fachada","facil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraon","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fertil","fervor","festin","fiable","fianza","fiar","fibra","ficcion","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","fluor","fobia","foca","fogata","fogon","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","fragil","franja","frase","fraude","freir","freno","fresa","frio","frito","fruta","fuego","fuente","fuerza","fuga","fumar","funcion","funda","furgon","furia","fusil","futbol","futuro","gacela","gafas","gaita","gajo","gala","galeria","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilan","gemelo","gemir","gen","genero","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","grafico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grua","grueso","grumo","grupo","guante","guapo","guardia","guerra","guia","guino","guion","guiso","guitarra","gusano","gustar","haber","habil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazana","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","heroe","hervir","hielo","hierro","higado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","humedo","humilde","humo","hundir","huracan","hurto","icono","ideal","idioma","idolo","iglesia","iglu","igual","ilegal","ilusion","imagen","iman","imitar","impar","imperio","imponer","impulso","incapaz","indice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interes","intimo","intuir","inutil","invierno","ira","iris","ironia","isla","islote","jabali","jabon","jamon","jarabe","jardin","jarra","jaula","jazmin","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","jupiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladron","lagarto","lagrima","laguna","laico","lamer","lamina","lampara","lana","lancha","langosta","lanza","lapiz","largo","larva","lastima","lata","latex","latir","laurel","lavar","lazo","leal","leccion","leche","lector","leer","legion","legumbre","lejano","lengua","lento","lena","leon","leopardo","lesion","letal","letra","leve","leyenda","libertad","libro","licor","lider","lidiar","lienzo","liga","ligero","lima","limite","limon","limpio","lince","lindo","linea","lingote","lino","linterna","liquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","locion","loco","locura","logica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maiz","maldad","maleta","malla","malo","mama","mambo","mamut","manco","mando","manejar","manga","maniqui","manjar","mano","manso","manta","manana","mapa","maquina","mar","marco","marea","marfil","margen","marido","marmol","marron","martes","marzo","masa","mascara","masivo","matar","materia","matiz","matriz","maximo","mayor","mazorca","mecha","medalla","medio","medula","mejilla","mejor","melena","melon","memoria","menor","mensaje","mente","menu","mercado","merengue","merito","mes","meson","meta","meter","metodo","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millon","mimo","mina","minero","minimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","mocion","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","mono","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","movil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muneca","mural","muro","musculo","museo","musgo","musica","muslo","nacar","nacion","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","nausea","naval","nave","navidad","necio","nectar","negar","negocio","negro","neon","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","ninez","nino","nitido","nivel","nobleza","noche","nomina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","nucleo","nudillo","nudo","nuera","nueve","nuez","nulo","numero","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","oceano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oido","oir","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opcion","opera","opinar","oponer","optar","optica","opuesto","oracion","orador","oral","orbita","orca","orden","oreja","organo","orgia","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadia","oscuro","osezno","oso","ostra","otono","otro","oveja","ovulo","oxido","oxigeno","oyente","ozono","pacto","padre","paella","pagina","pago","pais","pajaro","palabra","palco","paleta","palido","palma","paloma","palpar","pan","panal","panico","pantera","panuelo","papa","papel","papilla","paquete","parar","parcela","pared","parir","paro","parpado","parque","parrafo","parte","pasar","paseo","pasion","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peaton","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldano","pelea","peligro","pellejo","pelo","peluca","pena","pensar","penon","peon","peor","pepino","pequeno","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pesimo","pestana","petalo","petroleo","pez","pezuna","picar","pichon","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","pina","piojo","pipa","pirata","pisar","piscina","piso","pista","piton","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesia","poeta","polen","policia","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porcion","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","principe","prision","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","proximo","prueba","publico","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmon","pulpo","pulso","puma","punto","punal","puno","pupa","pupila","pure","quedar","queja","quemar","querer","queso","quieto","quimica","quince","quitar","rabano","rabia","rabo","racion","radical","raiz","rama","rampa","rancho","rango","rapaz","rapido","rapto","rasgo","raspa","rato","rayo","raza","razon","reaccion","realidad","rebano","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refran","refugio","regalo","regir","regla","regreso","rehen","reino","reir","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","reves","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rigido","rigor","rincon","rinon","rio","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubi","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sabado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmon","salon","salsa","salto","salud","salvar","samba","sancion","sandia","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sarten","sastre","satan","sauna","saxofon","seccion","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","senal","senor","separar","sepia","sequia","ser","serie","sermon","servir","sesenta","sesion","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","silaba","silbar","silencio","silla","simbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","solido","soltar","solucion","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sosten","sotano","suave","subir","suceso","sudor","suegra","suelo","sueno","suerte","sufrir","sujeto","sultan","sumar","superar","suplir","suponer","supremo","sur","surco","sureno","surgir","susto","sutil","tabaco","tabique","tabla","tabu","taco","tacto","tajo","talar","talco","talento","talla","talon","tamano","tambor","tango","tanque","tapa","tapete","tapia","tapon","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazon","teatro","techo","tecla","tecnica","tejado","tejer","tejido","tela","telefono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoria","terapia","terco","termino","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburon","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","timido","timo","tinta","tio","tipico","tipo","tira","tiron","titan","titere","titulo","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","torax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","toxico","trabajo","tractor","traer","trafico","trago","traje","tramo","trance","trato","trauma","trazar","trebol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tuberia","tubo","tuerto","tumba","tumor","tunel","tunica","turbina","turismo","turno","tutor","ubicar","ulcera","umbral","unidad","unir","universo","uno","untar","una","urbano","urbe","urgente","urna","usar","usuario","util","utopia","uva","vaca","vacio","vacuna","vagar","vago","vaina","vajilla","vale","valido","valle","valor","valvula","vampiro","vara","variar","varon","vaso","vecino","vector","vehiculo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","via","viaje","vibrar","vicio","victima","vida","video","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","vinedo","violin","viral","virgo","virtud","visor","vispera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcan","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]');
var require$$7 = JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]');
var require$$8 = JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]');
var require$$9 = JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');
var hasRequired_wordlists;
function require_wordlists() {
  if (hasRequired_wordlists) return _wordlists;
  hasRequired_wordlists = 1;
  Object.defineProperty(_wordlists, "__esModule", { value: true });
  const wordlists = {};
  _wordlists.wordlists = wordlists;
  let _default;
  _wordlists._default = _default;
  try {
    _wordlists._default = _default = require$$02;
    wordlists.czech = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$12;
    wordlists.chinese_simplified = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$22;
    wordlists.chinese_traditional = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$3;
    wordlists.korean = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$4;
    wordlists.french = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$5;
    wordlists.italian = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$6;
    wordlists.spanish = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$7;
    wordlists.japanese = _default;
    wordlists.JA = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$8;
    wordlists.portuguese = _default;
  } catch (err2) {
  }
  try {
    _wordlists._default = _default = require$$9;
    wordlists.english = _default;
    wordlists.EN = _default;
  } catch (err2) {
  }
  return _wordlists;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  Object.defineProperty(src, "__esModule", { value: true });
  const sha256_1 = requireSha256();
  const sha512_1 = requireSha512();
  const pbkdf2_1 = requirePbkdf2();
  const utils_1 = requireUtils();
  const _wordlists_1 = require_wordlists();
  let DEFAULT_WORDLIST = _wordlists_1._default;
  const INVALID_MNEMONIC = "Invalid mnemonic";
  const INVALID_ENTROPY = "Invalid entropy";
  const INVALID_CHECKSUM = "Invalid mnemonic checksum";
  const WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
  function normalize(str) {
    return (str || "").normalize("NFKD");
  }
  function lpad(str, padString, length) {
    while (str.length < length) {
      str = padString + str;
    }
    return str;
  }
  function binaryToByte(bin) {
    return parseInt(bin, 2);
  }
  function bytesToBinary(bytes) {
    return bytes.map((x) => lpad(x.toString(2), "0", 8)).join("");
  }
  function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash2 = sha256_1.sha256(Uint8Array.from(entropyBuffer));
    return bytesToBinary(Array.from(hash2)).slice(0, CS);
  }
  function salt(password) {
    return "mnemonic" + (password || "");
  }
  function mnemonicToSeedSync(mnemonic, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
      c: 2048,
      dkLen: 64
    });
    return Buffer.from(res);
  }
  src.mnemonicToSeedSync = mnemonicToSeedSync;
  function mnemonicToSeed(mnemonic, password) {
    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
      c: 2048,
      dkLen: 64
    }).then((res) => Buffer.from(res));
  }
  src.mnemonicToSeed = mnemonicToSeed;
  function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
      throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic).split(" ");
    if (words.length % 3 !== 0) {
      throw new Error(INVALID_MNEMONIC);
    }
    const bits = words.map((word) => {
      const index = wordlist.indexOf(word);
      if (index === -1) {
        throw new Error(INVALID_MNEMONIC);
      }
      return lpad(index.toString(2), "0", 11);
    }).join("");
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
      throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
      throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
      throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
      throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString("hex");
  }
  src.mnemonicToEntropy = mnemonicToEntropy;
  function entropyToMnemonic(entropy, wordlist) {
    if (!Buffer.isBuffer(entropy)) {
      entropy = Buffer.from(entropy, "hex");
    }
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
      throw new Error(WORDLIST_REQUIRED);
    }
    if (entropy.length < 16) {
      throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
      throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
      throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary) => {
      const index = binaryToByte(binary);
      return wordlist[index];
    });
    return wordlist[0] === "" ? words.join("") : words.join(" ");
  }
  src.entropyToMnemonic = entropyToMnemonic;
  function generateMnemonic(strength, rng, wordlist) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
      throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
    return entropyToMnemonic(rng(strength / 8), wordlist);
  }
  src.generateMnemonic = generateMnemonic;
  function validateMnemonic(mnemonic, wordlist) {
    try {
      mnemonicToEntropy(mnemonic, wordlist);
    } catch (e) {
      return false;
    }
    return true;
  }
  src.validateMnemonic = validateMnemonic;
  function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
      DEFAULT_WORDLIST = result;
    } else {
      throw new Error('Could not find wordlist for language "' + language + '"');
    }
  }
  src.setDefaultWordlist = setDefaultWordlist;
  function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
      throw new Error("No Default Wordlist set");
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
      if (lang === "JA" || lang === "EN") {
        return false;
      }
      return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
  }
  src.getDefaultWordlist = getDefaultWordlist;
  var _wordlists_2 = require_wordlists();
  src.wordlists = _wordlists_2.wordlists;
  return src;
}
requireSrc();
var MnemonicStrength;
(function(MnemonicStrength2) {
  MnemonicStrength2[MnemonicStrength2["MINIMUM"] = 128] = "MINIMUM";
  MnemonicStrength2[MnemonicStrength2["LOW"] = 160] = "LOW";
  MnemonicStrength2[MnemonicStrength2["MEDIUM"] = 192] = "MEDIUM";
  MnemonicStrength2[MnemonicStrength2["HIGH"] = 224] = "HIGH";
  MnemonicStrength2[MnemonicStrength2["MAXIMUM"] = 256] = "MAXIMUM";
})(MnemonicStrength || (MnemonicStrength = {}));
var BIPStandard;
(function(BIPStandard2) {
  BIPStandard2[BIPStandard2["BIP44"] = 44] = "BIP44";
  BIPStandard2[BIPStandard2["BIP49"] = 49] = "BIP49";
  BIPStandard2[BIPStandard2["BIP84"] = 84] = "BIP84";
  BIPStandard2[BIPStandard2["BIP86"] = 86] = "BIP86";
})(BIPStandard || (BIPStandard = {}));
cjsExports.BIP32Factory(backend);
var MLDSAPublicKeyMetadata;
(function(MLDSAPublicKeyMetadata2) {
  MLDSAPublicKeyMetadata2[MLDSAPublicKeyMetadata2["MLDSA44"] = 1312] = "MLDSA44";
  MLDSAPublicKeyMetadata2[MLDSAPublicKeyMetadata2["MLDSA65"] = 1952] = "MLDSA65";
  MLDSAPublicKeyMetadata2[MLDSAPublicKeyMetadata2["MLDSA87"] = 2592] = "MLDSA87";
})(MLDSAPublicKeyMetadata || (MLDSAPublicKeyMetadata = {}));
function getLevelFromPublicKeyLength(length) {
  switch (length) {
    case MLDSAPublicKeyMetadata.MLDSA44:
      return cjsExports.MLDSASecurityLevel.LEVEL2;
    case MLDSAPublicKeyMetadata.MLDSA65:
      return cjsExports.MLDSASecurityLevel.LEVEL3;
    case MLDSAPublicKeyMetadata.MLDSA87:
      return cjsExports.MLDSASecurityLevel.LEVEL5;
    default:
      throw new Error(`Invalid MLDSA public key length: ${length}`);
  }
}
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["Bitcoin"] = 0] = "Bitcoin";
  ChainId2[ChainId2["Fractal"] = 1] = "Fractal";
})(ChainId || (ChainId = {}));
function isTaprootInput(input) {
  return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (isP2TR(input.witnessUtxo.script) || isP2MR(input.witnessUtxo.script)));
}
function getInputRelevantScript(input) {
  if (input.redeemScript) {
    return input.redeemScript;
  }
  if (input.witnessScript) {
    return input.witnessScript;
  }
  if (input.witnessUtxo) {
    return input.witnessUtxo.script;
  }
  if (input.nonWitnessUtxo) ;
  return null;
}
function canSignNonTaprootInput(input, publicKey) {
  if (input.nonWitnessUtxo && !input.redeemScript && !input.witnessScript && !input.witnessUtxo || input.redeemScript) {
    return true;
  }
  const script2 = getInputRelevantScript(input);
  if (script2) {
    return pubkeyInScript(publicKey, script2);
  }
  return false;
}
function pubkeyInScript(pubkey, script2) {
  return pubkeyPositionInScript(pubkey, script2) !== -1;
}
var WalletNetworks;
(function(WalletNetworks2) {
  WalletNetworks2["Mainnet"] = "mainnet";
  WalletNetworks2["Testnet"] = "testnet";
  WalletNetworks2["OpnetTestnet"] = "opnetTestnet";
  WalletNetworks2["Regtest"] = "regtest";
})(WalletNetworks || (WalletNetworks = {}));
var UnisatChainType;
(function(UnisatChainType2) {
  UnisatChainType2["BITCOIN_MAINNET"] = "BITCOIN_MAINNET";
  UnisatChainType2["BITCOIN_TESTNET"] = "BITCOIN_TESTNET";
  UnisatChainType2["BITCOIN_TESTNET4"] = "BITCOIN_TESTNET4";
  UnisatChainType2["BITCOIN_REGTEST"] = "BITCOIN_REGTEST";
  UnisatChainType2["BITCOIN_SIGNET"] = "BITCOIN_SIGNET";
  UnisatChainType2["OPNET_TESTNET"] = "OPNET_TESTNET";
  UnisatChainType2["FRACTAL_BITCOIN_MAINNET"] = "FRACTAL_BITCOIN_MAINNET";
  UnisatChainType2["FRACTAL_BITCOIN_TESTNET"] = "FRACTAL_BITCOIN_TESTNET";
  UnisatChainType2["DOGECOIN_MAINNET"] = "DOGECOIN_MAINNET";
  UnisatChainType2["DOGECOIN_TESTNET"] = "DOGECOIN_TESTNET";
  UnisatChainType2["DOGECOIN_REGTEST"] = "DOGECOIN_REGTEST";
  UnisatChainType2["LITECOIN_MAINNET"] = "LITECOIN_MAINNET";
  UnisatChainType2["LITECOIN_TESTNET"] = "LITECOIN_TESTNET";
  UnisatChainType2["LITECOIN_REGTEST"] = "LITECOIN_REGTEST";
  UnisatChainType2["BITCOINCASH_MAINNET"] = "BITCOINCASH_MAINNET";
  UnisatChainType2["BITCOINCASH_TESTNET"] = "BITCOINCASH_TESTNET";
  UnisatChainType2["BITCOINCASH_REGTEST"] = "BITCOINCASH_REGTEST";
  UnisatChainType2["DASH_MAINNET"] = "DASH_MAINNET";
  UnisatChainType2["DASH_TESTNET"] = "DASH_TESTNET";
  UnisatChainType2["DASH_REGTEST"] = "DASH_REGTEST";
})(UnisatChainType || (UnisatChainType = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["ecdsa"] = "ecdsa";
  MessageType2["bip322"] = "bip322-simple";
})(MessageType || (MessageType = {}));
var SignatureType;
(function(SignatureType2) {
  SignatureType2["ecdsa"] = "ecdsa";
  SignatureType2["schnorr"] = "schnorr";
})(SignatureType || (SignatureType = {}));
function toTweakedParallelKeyPair(untweakedSigner, tweakedSigner) {
  return {
    publicKey: ln(untweakedSigner.publicKey),
    getPrivateKey() {
      if (!tweakedSigner.privateKey) {
        throw new Error("Tweaked signer does not have a private key");
      }
      return zt(tweakedSigner.privateKey);
    },
    sign(hash2, lowR) {
      return tweakedSigner.sign(hash2, lowR);
    },
    signSchnorr(hash2) {
      if (!tweakedSigner.signSchnorr) {
        throw new Error("Tweaked signer does not support Schnorr signing");
      }
      return tweakedSigner.signSchnorr(hash2);
    }
  };
}
var TransactionType;
(function(TransactionType2) {
  TransactionType2[TransactionType2["GENERIC"] = 0] = "GENERIC";
  TransactionType2[TransactionType2["FUNDING"] = 1] = "FUNDING";
  TransactionType2[TransactionType2["DEPLOYMENT"] = 2] = "DEPLOYMENT";
  TransactionType2[TransactionType2["INTERACTION"] = 3] = "INTERACTION";
  TransactionType2[TransactionType2["MULTI_SIG"] = 4] = "MULTI_SIG";
  TransactionType2[TransactionType2["CUSTOM_CODE"] = 5] = "CUSTOM_CODE";
  TransactionType2[TransactionType2["CANCEL"] = 6] = "CANCEL";
  TransactionType2[TransactionType2["CONSOLIDATED_SETUP"] = 7] = "CONSOLIDATED_SETUP";
  TransactionType2[TransactionType2["CONSOLIDATED_REVEAL"] = 8] = "CONSOLIDATED_REVEAL";
})(TransactionType || (TransactionType = {}));
function witnessStackToScriptWitness(witness) {
  let buffer2 = new Uint8Array(0);
  function concatBuffers(a, b) {
    const result = new Uint8Array(a.length + b.length);
    result.set(a, 0);
    result.set(b, a.length);
    return result;
  }
  function writeSlice(slice) {
    buffer2 = concatBuffers(buffer2, slice);
  }
  function writeVarInt(i2) {
    const currentLen = buffer2.length;
    const varintLen = encodingLength$1(i2);
    const newBuffer = new Uint8Array(currentLen + varintLen);
    newBuffer.set(buffer2, 0);
    buffer2 = newBuffer;
    encode$k(i2, buffer2, currentLen);
  }
  function writeVarSlice(slice) {
    writeVarInt(slice.length);
    writeSlice(slice);
  }
  function writeVector(vector) {
    writeVarInt(vector.length);
    vector.forEach(writeVarSlice);
  }
  writeVector(witness);
  return buffer2;
}
var TransactionSequence;
(function(TransactionSequence2) {
  TransactionSequence2[TransactionSequence2["REPLACE_BY_FEE"] = 4294967293] = "REPLACE_BY_FEE";
  TransactionSequence2[TransactionSequence2["FINAL"] = 4294967295] = "FINAL";
})(TransactionSequence || (TransactionSequence = {}));
var CSVModes;
(function(CSVModes2) {
  CSVModes2[CSVModes2["BLOCKS"] = 0] = "BLOCKS";
  CSVModes2[CSVModes2["TIMESTAMPS"] = 1] = "TIMESTAMPS";
})(CSVModes || (CSVModes = {}));
var TweakedTransaction = class _TweakedTransaction extends Logger {
  constructor(data) {
    var _a5;
    super();
    __publicField(this, "logColor", "#00ffe1");
    __publicField(this, "finalized", false);
    /**
     * @description Was the transaction signed?
     */
    __publicField(this, "signer");
    /**
     * @description Tweaked signer
     */
    __publicField(this, "tweakedSigner");
    /**
     * @description The network of the transaction
     */
    __publicField(this, "network");
    /**
     * @description Was the transaction signed?
     */
    __publicField(this, "signed", false);
    /**
     * @description The sighash types of the transaction
     * @protected
     */
    __publicField(this, "sighashTypes");
    /**
     * @description The script data of the transaction
     */
    __publicField(this, "scriptData", null);
    /**
     * @description The tap data of the transaction
     */
    __publicField(this, "tapData", null);
    /**
     * @description The inputs of the transaction
     */
    __publicField(this, "inputs", []);
    /**
     * @description The sequence of the transaction
     * @protected
     */
    __publicField(this, "sequence", TransactionSequence.REPLACE_BY_FEE);
    /**
     * The tap leaf script
     * @protected
     */
    __publicField(this, "tapLeafScript", null);
    /**
     * Add a non-witness utxo to the transaction
     * @protected
     */
    __publicField(this, "nonWitnessUtxo");
    /**
     * Is the transaction being generated inside a browser?
     * @protected
     */
    __publicField(this, "isBrowser", false);
    /**
     * Track which inputs contain CSV scripts
     * @protected
     */
    __publicField(this, "csvInputIndices", /* @__PURE__ */ new Set());
    __publicField(this, "anchorInputIndices", /* @__PURE__ */ new Set());
    __publicField(this, "regenerated", false);
    __publicField(this, "ignoreSignatureErrors", false);
    __publicField(this, "noSignatures", false);
    __publicField(this, "unlockScript");
    __publicField(this, "txVersion", 2);
    __publicField(this, "_mldsaSigner", null);
    __publicField(this, "_hashedPublicKey", null);
    /**
     * Whether address rotation mode is enabled.
     * When true, each UTXO can be signed by a different signer.
     */
    __publicField(this, "addressRotationEnabled", false);
    /**
     * Map of addresses to their respective signers for address rotation mode.
     */
    __publicField(this, "signerMap", /* @__PURE__ */ new Map());
    /**
     * Map of input indices to their signers (resolved from UTXOs or signerMap).
     * Populated during input addition.
     */
    __publicField(this, "inputSignerMap", /* @__PURE__ */ new Map());
    /**
     * Cache of tweaked signers per input for address rotation mode.
     */
    __publicField(this, "tweakedSignerCache", /* @__PURE__ */ new Map());
    /**
     * Parallel signing configuration using worker threads.
     * When set, key-path taproot inputs are signed in parallel via workers.
     */
    __publicField(this, "parallelSigningConfig");
    /**
     * Whether to use P2MR (Pay-to-Merkle-Root, BIP 360) instead of P2TR.
     */
    __publicField(this, "useP2MR", false);
    __publicField(this, "customFinalizerP2SH", (inputIndex, input, scriptA, isSegwit, isP2SH, isP2WSH, _canRunChecks) => {
      const inputDecoded = this.inputs[inputIndex];
      if (isP2SH && input.partialSig && inputDecoded && inputDecoded.redeemScript) {
        const signatures = input.partialSig.map((sig) => sig.signature) || [];
        const scriptSig = compile([...signatures, inputDecoded.redeemScript]);
        return {
          finalScriptSig: scriptSig,
          finalScriptWitness: void 0
        };
      }
      if (this.anchorInputIndices.has(inputIndex)) {
        return {
          finalScriptSig: void 0,
          finalScriptWitness: Uint8Array.from([0])
        };
      }
      if (isP2WSH && isSegwit && input.witnessScript) {
        if (!input.partialSig || input.partialSig.length === 0) {
          throw new Error(`No signatures for P2WSH input #${inputIndex}`);
        }
        const isP2WDA = P2WDADetector.isP2WDAWitnessScript(input.witnessScript);
        if (isP2WDA) {
          return this.finalizeSecondaryP2WDA(inputIndex, input);
        }
        const isCSVInput = this.csvInputIndices.has(inputIndex);
        if (isCSVInput) {
          const witnessStack = [
            input.partialSig[0].signature,
            input.witnessScript
          ];
          return {
            finalScriptSig: void 0,
            finalScriptWitness: witnessStackToScriptWitness(witnessStack)
          };
        }
      }
      return getFinalScripts(inputIndex, input, scriptA, isSegwit, isP2SH, isP2WSH, true, this.unlockScript);
    });
    this.signer = data.signer;
    this.network = data.network;
    this.noSignatures = data.noSignatures || false;
    if (data.nonWitnessUtxo !== void 0) {
      this.nonWitnessUtxo = data.nonWitnessUtxo;
    }
    if (data.unlockScript !== void 0) {
      this.unlockScript = data.unlockScript;
    }
    this.isBrowser = typeof window !== "undefined";
    if (data.txVersion) {
      this.txVersion = data.txVersion;
    }
    if (data.mldsaSigner) {
      this._mldsaSigner = data.mldsaSigner;
      this._hashedPublicKey = MessageSigner.sha256(this._mldsaSigner.publicKey);
    }
    if ((_a5 = data.addressRotation) == null ? void 0 : _a5.enabled) {
      this.addressRotationEnabled = true;
      this.signerMap = data.addressRotation.signerMap;
    }
    if (data.parallelSigning) {
      this.parallelSigningConfig = data.parallelSigning;
    }
    if (data.useP2MR) {
      this.useP2MR = true;
    }
  }
  /**
   * Get the MLDSA signer
   * @protected
   */
  get mldsaSigner() {
    if (!this._mldsaSigner) {
      throw new Error("MLDSA Signer is not set");
    }
    return this._mldsaSigner;
  }
  /**
   * Get the hashed public key
   * @protected
   */
  get hashedPublicKey() {
    if (!this._hashedPublicKey) {
      throw new Error("Hashed public key is not set");
    }
    return this._hashedPublicKey;
  }
  /**
   * Whether parallel signing can be used for this transaction.
   * Requires parallelSigningConfig and excludes browser, address rotation, and no-signature modes.
   */
  get canUseParallelSigning() {
    return !!this.parallelSigningConfig && !this.addressRotationEnabled && !this.noSignatures;
  }
  /**
   * Read witnesses
   * @protected
   */
  static readScriptWitnessToWitnessStack(buffer2) {
    let offset = 0;
    function readSlice(n2) {
      const slice = new Uint8Array(buffer2.subarray(offset, offset + n2));
      offset += n2;
      return slice;
    }
    function readVarInt() {
      const varint = decode$j(buffer2, offset);
      offset += varint.bytes;
      return varint.numberValue || 0;
    }
    function readVarSlice() {
      const len = readVarInt();
      return readSlice(len);
    }
    function readVector() {
      const count = readVarInt();
      const vector = [];
      for (let i2 = 0; i2 < count; i2++) {
        vector.push(readVarSlice());
      }
      return vector;
    }
    return readVector();
  }
  /**
   * Pre-estimate the transaction fees for a Taproot transaction
   * @param {bigint} feeRate - The fee rate in satoshis per virtual byte
   * @param {bigint} numInputs - The number of inputs
   * @param {bigint} numOutputs - The number of outputs
   * @param {bigint} numWitnessElements - The number of witness elements (e.g., number of control blocks and witnesses)
   * @param {bigint} witnessElementSize - The average size of each witness element in bytes
   * @param {bigint} emptyWitness - The amount of empty witnesses
   * @param {bigint} [taprootControlWitnessSize=139n] - The size of the control block witness in bytes
   * @param {bigint} [taprootScriptSize=32n] - The size of the taproot script in bytes
   * @returns {bigint} - The estimated transaction fees
   */
  static preEstimateTaprootTransactionFees(feeRate, numInputs, numOutputs, numWitnessElements, witnessElementSize, emptyWitness, taprootControlWitnessSize = 32n, taprootScriptSize = 139n) {
    const txHeaderSize = 10n;
    const inputBaseSize = 41n;
    const outputSize = 68n;
    const taprootWitnessBaseSize = 1n;
    const baseTxSize = txHeaderSize + inputBaseSize * numInputs + outputSize * numOutputs;
    const witnessSize = numInputs * taprootWitnessBaseSize + numWitnessElements * witnessElementSize + taprootControlWitnessSize * numInputs + taprootScriptSize * numInputs + emptyWitness;
    const weight = baseTxSize * 3n + (baseTxSize + witnessSize);
    const vSize = weight / 4n;
    return vSize * feeRate;
  }
  static signInput(transaction, input, i2, signer, sighashTypes) {
    if (sighashTypes && sighashTypes[0])
      input.sighashType = sighashTypes[0];
    transaction.signInput(i2, signer, sighashTypes.length ? sighashTypes : void 0);
  }
  /**
   * Calculate the sign hash number
   * @description Calculates the sign hash
   * @protected
   * @returns {number}
   */
  static calculateSignHash(sighashTypes) {
    if (!sighashTypes) {
      throw new Error("Sighash types are required");
    }
    let signHash = 0;
    for (const sighashType2 of sighashTypes) {
      signHash |= sighashType2;
    }
    return signHash || 0;
  }
  [Symbol.dispose]() {
    this.inputs.length = 0;
    this.scriptData = null;
    this.tapData = null;
    this.tapLeafScript = null;
    delete this.tweakedSigner;
    this.csvInputIndices.clear();
    this.anchorInputIndices.clear();
    this.inputSignerMap.clear();
    this.tweakedSignerCache.clear();
    delete this.parallelSigningConfig;
  }
  /**
   * Check if address rotation mode is enabled.
   */
  isAddressRotationEnabled() {
    return this.addressRotationEnabled;
  }
  ignoreSignatureError() {
    this.ignoreSignatureErrors = true;
  }
  /**
   * @description Returns the script address
   * @returns {string}
   */
  getScriptAddress() {
    if (!this.scriptData || !this.scriptData.address) {
      throw new Error("Tap data is required");
    }
    return this.scriptData.address;
  }
  /**
   * @description Returns the transaction
   * @returns {Transaction}
   */
  getTransaction() {
    return this.transaction.extractTransaction(false);
  }
  /**
   * @description Returns the tap address
   * @returns {string}
   * @throws {Error} - If tap data is not set
   */
  getTapAddress() {
    if (!this.tapData || !this.tapData.address) {
      throw new Error("Tap data is required");
    }
    return this.tapData.address;
  }
  /**
   * @description Disables replace by fee on the transaction
   */
  disableRBF() {
    if (this.signed)
      throw new Error("Transaction is already signed");
    this.sequence = TransactionSequence.FINAL;
    for (const input of this.inputs) {
      if (this.csvInputIndices.has(this.inputs.indexOf(input))) {
        continue;
      }
      input.sequence = TransactionSequence.FINAL;
    }
  }
  /**
   * Get the tweaked hash
   * @private
   *
   * @returns {Uint8Array | undefined} The tweaked hash
   */
  getTweakerHash() {
    var _a5;
    return (_a5 = this.tapData) == null ? void 0 : _a5.hash;
  }
  /**
   * Pre-estimate the transaction fees
   * @param {bigint} feeRate - The fee rate
   * @param {bigint} numInputs - The number of inputs
   * @param {bigint} numOutputs - The number of outputs
   * @param {bigint} numSignatures - The number of signatures
   * @param {bigint} numPubkeys - The number of public keys
   * @returns {bigint} - The estimated transaction fees
   */
  preEstimateTransactionFees(feeRate, numInputs, numOutputs, numSignatures, numPubkeys) {
    const txHeaderSize = 10n;
    const inputBaseSize = 41n;
    const outputSize = 68n;
    const signatureSize = 144n;
    const pubkeySize = 34n;
    const baseTxSize = txHeaderSize + inputBaseSize * numInputs + outputSize * numOutputs;
    const redeemScriptSize = 1n + numPubkeys * (1n + pubkeySize) + 1n + numSignatures;
    const witnessSize = numSignatures * signatureSize + numPubkeys * pubkeySize + redeemScriptSize;
    const weight = baseTxSize * 3n + (baseTxSize + witnessSize);
    const vSize = weight / 4n;
    return vSize * feeRate;
  }
  /**
   * Get the signer for a specific input index.
   * Returns the input-specific signer if in rotation mode, otherwise the default signer.
   * @param inputIndex - The index of the input
   */
  getSignerForInput(inputIndex) {
    if (this.addressRotationEnabled) {
      const inputSigner = this.inputSignerMap.get(inputIndex);
      if (inputSigner) {
        return inputSigner;
      }
    }
    return this.signer;
  }
  /**
   * Register a signer for a specific input index.
   * Called during UTXO processing to map each input to its signer.
   * @param inputIndex - The index of the input
   * @param utxo - The UTXO being added
   */
  registerInputSigner(inputIndex, utxo) {
    var _a5;
    if (!this.addressRotationEnabled) {
      return;
    }
    if (utxo.signer) {
      this.inputSignerMap.set(inputIndex, utxo.signer);
      return;
    }
    const address = (_a5 = utxo.scriptPubKey) == null ? void 0 : _a5.address;
    if (address && this.signerMap.has(address)) {
      const signer = this.signerMap.get(address);
      if (signer) {
        this.inputSignerMap.set(inputIndex, signer);
        return;
      }
    }
  }
  /**
   * Get the x-only public key for a specific input's signer.
   * Used for taproot inputs in address rotation mode.
   * @param inputIndex - The index of the input
   */
  internalPubKeyToXOnlyForInput(inputIndex) {
    const signer = this.getSignerForInput(inputIndex);
    return toXOnly(signer.publicKey);
  }
  /**
   * Get the tweaked signer for a specific input.
   * Caches the result for efficiency.
   * @param inputIndex - The index of the input
   * @param useTweakedHash - Whether to use the tweaked hash
   */
  getTweakedSignerForInput(inputIndex, useTweakedHash = false) {
    if (!this.addressRotationEnabled) {
      if (useTweakedHash) {
        this.tweakSigner();
        return this.tweakedSigner;
      }
      return this.getTweakedSigner(useTweakedHash);
    }
    const cacheKey = inputIndex * 2 + (useTweakedHash ? 1 : 0);
    if (this.tweakedSignerCache.has(cacheKey)) {
      return this.tweakedSignerCache.get(cacheKey);
    }
    const signer = this.getSignerForInput(inputIndex);
    const tweaked = this.getTweakedSigner(useTweakedHash, signer);
    this.tweakedSignerCache.set(cacheKey, tweaked);
    return tweaked;
  }
  generateTapData() {
    if (this.useP2MR) {
      return {
        network: this.network,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      name: PaymentType.P2TR
    };
  }
  /**
   * Generates the script address.
   * @protected
   * @returns {TapPayment}
   */
  generateScriptAddress() {
    if (this.useP2MR) {
      return {
        network: this.network,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      name: PaymentType.P2TR
    };
  }
  /**
   * Returns the signer key.
   * @protected
   * @returns {Signer | UniversalSigner}
   */
  getSignerKey() {
    return this.signer;
  }
  /**
   * Signs an input of the transaction.
   * @param {Psbt} transaction - The transaction to sign
   * @param {PsbtInput} input - The input to sign
   * @param {number} i - The index of the input
   * @param {Signer} signer - The signer to use
   * @param {boolean} [reverse=false] - Should the input be signed in reverse
   * @param {boolean} [errored=false] - Was there an error
   * @protected
   */
  async signInput(transaction, input, i2, signer, reverse2 = false, errored = false) {
    if (this.anchorInputIndices.has(i2))
      return;
    const publicKey = signer.publicKey;
    let isTaproot = isTaprootInput(input);
    if (reverse2) {
      isTaproot = !isTaproot;
    }
    let signed = false;
    let didError = false;
    if (isTaproot) {
      try {
        await this.attemptSignTaproot(transaction, input, i2, signer, publicKey);
        signed = true;
      } catch (e) {
        this.error(`Failed to sign Taproot script path input ${i2} (reverse: ${reverse2}): ${e.message}`);
        didError = true;
      }
    } else {
      if (!reverse2 ? canSignNonTaprootInput(input, publicKey) : true) {
        try {
          await this.signNonTaprootInput(signer, transaction, i2);
          signed = true;
        } catch (e) {
          this.error(`Failed to sign non-Taproot input ${i2}: ${e.stack}`);
          didError = true;
        }
      }
    }
    if (!signed) {
      if (didError && errored) {
        throw new Error(`Failed to sign input ${i2} with the provided signer.`);
      }
      try {
        await this.signInput(transaction, input, i2, signer, true, didError);
      } catch {
        throw new Error(`Cannot sign input ${i2} with the provided signer.`);
      }
    }
  }
  splitArray(arr, chunkSize) {
    if (chunkSize <= 0) {
      throw new Error("Chunk size must be greater than 0.");
    }
    const result = [];
    for (let i2 = 0; i2 < arr.length; i2 += chunkSize) {
      result.push(arr.slice(i2, i2 + chunkSize));
    }
    return result;
  }
  /**
   * Signs all the inputs of the transaction.
   * @param {Psbt} transaction - The transaction to sign
   * @protected
   * @returns {Promise<void>}
   */
  async signInputs(transaction) {
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(transaction);
      return;
    }
    await this.signInputsNonWalletBased(transaction);
  }
  async signInputsNonWalletBased(transaction) {
    if (!this.noSignatures) {
      if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
        let parallelSignedIndices = /* @__PURE__ */ new Set();
        try {
          const result = await this.signKeyPathInputsParallel(transaction);
          if (result.success) {
            parallelSignedIndices = new Set(result.signatures.keys());
          }
        } catch (e) {
          this.error(`Parallel signing failed, falling back to sequential: ${e.message}`);
        }
        await this.signRemainingInputsSequential(transaction, parallelSignedIndices);
      } else {
        await this.signInputsSequential(transaction);
      }
    }
    for (let i2 = 0; i2 < transaction.data.inputs.length; i2++) {
      transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
    }
    this.finalized = true;
  }
  /**
   * Signs all inputs sequentially in batches of 20.
   * This is the original signing logic, used as fallback when parallel signing is unavailable.
   */
  async signInputsSequential(transaction) {
    const txs = transaction.data.inputs;
    const batchSize = 20;
    const batches = this.splitArray(txs, batchSize);
    for (let i2 = 0; i2 < batches.length; i2++) {
      const batch = batches[i2];
      const promises = [];
      const offset = i2 * batchSize;
      for (let j = 0; j < batch.length; j++) {
        const index = offset + j;
        const input = batch[j];
        try {
          const inputSigner = this.getSignerForInput(index);
          promises.push(this.signInput(transaction, input, index, inputSigner));
        } catch (e) {
          this.log(`Failed to sign input ${index}: ${e.stack}`);
        }
      }
      await Promise.all(promises);
    }
  }
  /**
   * Signs inputs that were not handled by parallel signing.
   * After parallel key-path signing, script-path taproot inputs, non-taproot inputs,
   * and any inputs that failed parallel signing need sequential signing.
   */
  async signRemainingInputsSequential(transaction, signedIndices) {
    const txs = transaction.data.inputs;
    const unsignedIndices = [];
    for (let i2 = 0; i2 < txs.length; i2++) {
      if (!signedIndices.has(i2)) {
        unsignedIndices.push(i2);
      }
    }
    if (unsignedIndices.length === 0)
      return;
    const batchSize = 20;
    const batches = this.splitArray(unsignedIndices, batchSize);
    for (const batch of batches) {
      const promises = [];
      for (const index of batch) {
        const input = txs[index];
        try {
          const inputSigner = this.getSignerForInput(index);
          promises.push(this.signInput(transaction, input, index, inputSigner));
        } catch (e) {
          this.log(`Failed to sign input ${index}: ${e.stack}`);
        }
      }
      await Promise.all(promises);
    }
  }
  /**
   * Converts the public key to x-only.
   * @protected
   * @returns {Uint8Array}
   */
  internalPubKeyToXOnly() {
    return toXOnly(this.signer.publicKey);
  }
  /**
   * Internal init.
   * @protected
   */
  internalInit() {
    const scriptParams = this.generateScriptAddress();
    const tapParams = this.generateTapData();
    if (scriptParams.name === PaymentType.P2MR) {
      this.scriptData = p2mr(scriptParams);
    } else {
      this.scriptData = p2tr(scriptParams);
    }
    if (tapParams.name === PaymentType.P2MR) {
      this.tapData = p2mr(tapParams);
    } else {
      this.tapData = p2tr(tapParams);
    }
  }
  /**
   * Tweak the signer for the interaction
   * @protected
   */
  tweakSigner() {
    if (this.tweakedSigner)
      return;
    const tweaked = this.getTweakedSigner(true);
    if (tweaked !== void 0) {
      this.tweakedSigner = tweaked;
    }
  }
  /**
   * Get the tweaked signer
   * @private
   * @returns {UniversalSigner} The tweaked signer
   */
  getTweakedSigner(useTweakedHash = false, signer = this.signer) {
    const settings = {
      network: this.network
    };
    if (useTweakedHash) {
      const tweakHash = this.getTweakerHash();
      if (tweakHash !== void 0) {
        settings.tweakHash = tweakHash;
      }
    }
    if (!isUniversalSigner(signer)) {
      return;
    }
    return TweakedSigner.tweakSigner(signer, settings);
  }
  /**
   * Signs key-path taproot inputs in parallel using worker threads.
   * @param transaction - The PSBT to sign
   * @param excludeIndices - Input indices to skip (e.g., script-path inputs already signed)
   * @returns The parallel signing result
   */
  async signKeyPathInputsParallel(transaction, excludeIndices) {
    const signer = this.signer;
    const tweakedSigner = this.getTweakedSigner(true);
    if (!tweakedSigner) {
      throw new Error("Cannot create tweaked signer for parallel signing");
    }
    const adapter = toTweakedParallelKeyPair(signer, tweakedSigner);
    const allTasks = prepareSigningTasks(transaction, adapter);
    const tasks = excludeIndices ? allTasks.filter((t2) => !excludeIndices.has(t2.inputIndex)) : allTasks;
    if (tasks.length === 0) {
      return {
        success: true,
        signatures: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map(),
        durationMs: 0
      };
    }
    let pool;
    let shouldShutdown = false;
    if (this.parallelSigningConfig && "signBatch" in this.parallelSigningConfig) {
      pool = this.parallelSigningConfig;
    } else {
      pool = WorkerSigningPool.getInstance(this.parallelSigningConfig);
      if (!pool.isPreservingWorkers)
        shouldShutdown = true;
    }
    try {
      await pool.initialize();
      const result = await pool.signBatch(tasks, adapter);
      if (result.success) {
        applySignaturesToPsbt(transaction, result, adapter);
      } else {
        const errorEntries = [...result.errors.entries()];
        const errorMsg = errorEntries.map(([idx, err2]) => `Input ${idx}: ${err2}`).join(", ");
        this.error(`Parallel signing had errors: ${errorMsg}`);
      }
      return result;
    } finally {
      if (shouldShutdown)
        await pool.shutdown();
    }
  }
  generateP2SHRedeemScript(customWitnessScript) {
    const p2wsh$1 = p2wsh({
      redeem: { output: customWitnessScript },
      network: this.network
    });
    const p2sh$1 = p2sh({
      redeem: p2wsh$1,
      network: this.network
    });
    return p2sh$1.output;
  }
  generateP2SHRedeemScriptLegacy(inputAddr) {
    const pubKeyHash = hash160(this.signer.publicKey);
    const redeemScript = compile([
      opcodes.OP_DUP,
      opcodes.OP_HASH160,
      pubKeyHash,
      opcodes.OP_EQUALVERIFY,
      opcodes.OP_CHECKSIG
    ]);
    const redeemScriptHash = hash160(redeemScript);
    const outputScript = compile([
      opcodes.OP_HASH160,
      redeemScriptHash,
      opcodes.OP_EQUAL
    ]);
    const p2wsh$1 = p2wsh({
      redeem: { output: redeemScript },
      // Use the custom redeem script
      network: this.network
    });
    const p2sh$1 = p2sh({
      redeem: p2wsh$1,
      // The P2WSH is wrapped inside the P2SH
      network: this.network
    });
    const address = fromOutputScript(outputScript, this.network);
    if (address === inputAddr && p2sh$1.redeem && p2sh$1.redeem.output) {
      return {
        redeemScript,
        outputScript: p2sh$1.redeem.output
      };
    }
    return;
  }
  generateP2SHP2PKHRedeemScript(inputAddr, inputIndex) {
    var _a5;
    const signer = this.addressRotationEnabled && inputIndex !== void 0 ? this.getSignerForInput(inputIndex) : this.signer;
    const pubkey = signer.publicKey;
    const w2 = p2wpkh({
      pubkey,
      network: this.network
    });
    const p = p2sh({
      redeem: w2,
      network: this.network
    });
    const address = p.address;
    const redeemScript = (_a5 = p.redeem) == null ? void 0 : _a5.output;
    if (!redeemScript) {
      throw new Error("Failed to generate P2SH-P2WPKH redeem script");
    }
    if (address === inputAddr && p.redeem && p.redeem.output && p.output) {
      return {
        redeemScript: p.redeem.output,
        outputScript: p.output
      };
    }
    return;
  }
  /**
   * Generate the PSBT input extended, supporting various script types
   * @param {UTXO} utxo The UTXO
   * @param {number} i The index of the input
   * @param {UTXO} _extra Extra UTXO
   * @protected
   * @returns {PsbtInputExtended} The PSBT input extended
   */
  generatePsbtInputExtended(utxo, i2, _extra = false) {
    var _a5;
    const scriptPub = fromHex$1(utxo.scriptPubKey.hex);
    const input = {
      hash: utxo.transactionId,
      index: utxo.outputIndex,
      sequence: this.sequence,
      witnessUtxo: {
        value: utxo.value,
        script: scriptPub
      }
    };
    if (isP2PKH(scriptPub)) {
      if (utxo.nonWitnessUtxo) {
        input.nonWitnessUtxo = utxo.nonWitnessUtxo instanceof Uint8Array ? utxo.nonWitnessUtxo : fromHex$1(utxo.nonWitnessUtxo);
      } else {
        throw new Error("Missing nonWitnessUtxo for P2PKH UTXO");
      }
    } else if (isP2WPKH(scriptPub) || isUnknownSegwitVersion(scriptPub)) ;
    else if (isP2WSHScript(scriptPub)) {
      this.processP2WSHInput(utxo, input, i2);
    } else if (isP2SHScript(scriptPub)) {
      let redeemScriptBuf;
      if (utxo.redeemScript) {
        redeemScriptBuf = utxo.redeemScript instanceof Uint8Array ? utxo.redeemScript : fromHex$1(utxo.redeemScript);
      } else {
        if (!utxo.scriptPubKey.address) {
          throw new Error("Missing redeemScript and no address to regenerate it for P2SH UTXO");
        }
        const legacyScripts = this.generateP2SHP2PKHRedeemScript(utxo.scriptPubKey.address, i2);
        if (!legacyScripts) {
          throw new Error("Missing redeemScript for P2SH UTXO and unable to regenerate");
        }
        redeemScriptBuf = legacyScripts.redeemScript;
      }
      input.redeemScript = redeemScriptBuf;
      const payment = p2sh({ redeem: { output: input.redeemScript } });
      if (!payment.redeem) {
        throw new Error("Failed to extract redeem script from P2SH UTXO");
      }
      const redeemOutput = payment.redeem.output;
      if (!redeemOutput) {
        throw new Error("Failed to extract redeem output from P2SH UTXO");
      }
      if (utxo.nonWitnessUtxo) {
        input.nonWitnessUtxo = utxo.nonWitnessUtxo instanceof Uint8Array ? utxo.nonWitnessUtxo : fromHex$1(utxo.nonWitnessUtxo);
      }
      if (isP2WPKH(redeemOutput)) {
        Reflect.deleteProperty(input, "nonWitnessUtxo");
      } else if (isP2WSHScript(redeemOutput)) {
        Reflect.deleteProperty(input, "nonWitnessUtxo");
        this.processP2WSHInput(utxo, input, i2);
      } else {
        Reflect.deleteProperty(input, "witnessUtxo");
      }
    } else if (isP2TR(scriptPub)) {
      if (this.sighashTypes) {
        const inputSign = _TweakedTransaction.calculateSignHash(this.sighashTypes);
        if (inputSign)
          input.sighashType = inputSign;
      }
      if (this.addressRotationEnabled) {
        input.tapInternalKey = this.internalPubKeyToXOnlyForInput(i2);
      } else {
        this.tweakSigner();
        input.tapInternalKey = this.internalPubKeyToXOnly();
      }
    } else if (isP2MR(scriptPub)) {
      if (this.sighashTypes) {
        const inputSign = _TweakedTransaction.calculateSignHash(this.sighashTypes);
        if (inputSign)
          input.sighashType = inputSign;
      }
      if (i2 === 0 && ((_a5 = this.tapData) == null ? void 0 : _a5.hash)) {
        input.tapMerkleRoot = this.tapData.hash;
      }
    } else if (isP2A(scriptPub)) {
      this.anchorInputIndices.add(i2);
      input.isPayToAnchor = true;
    } else if (isP2PK(scriptPub) || isP2MS(scriptPub)) {
      if (utxo.nonWitnessUtxo) {
        input.nonWitnessUtxo = utxo.nonWitnessUtxo instanceof Uint8Array ? utxo.nonWitnessUtxo : fromHex$1(utxo.nonWitnessUtxo);
      } else {
        throw new Error("Missing nonWitnessUtxo for P2PK or P2MS UTXO");
      }
    } else {
      this.error(`Unknown or unsupported script type for output: ${utxo.scriptPubKey.hex}`);
    }
    if (i2 === 0) {
      if (this.tapLeafScript) {
        input.tapLeafScript = [this.tapLeafScript];
      }
      if (this.nonWitnessUtxo) {
        input.nonWitnessUtxo = this.nonWitnessUtxo;
      }
    }
    return input;
  }
  processP2WSHInput(utxo, input, i2) {
    if (!utxo.witnessScript) {
      throw new Error("Missing witnessScript for P2WSH UTXO");
    }
    input.witnessScript = utxo.witnessScript instanceof Uint8Array ? utxo.witnessScript : fromHex$1(utxo.witnessScript);
    const decompiled = decompile(input.witnessScript);
    if (decompiled && this.isCSVScript(decompiled)) {
      const decompiled2 = decompile(input.witnessScript);
      if (decompiled2 && this.isCSVScript(decompiled2)) {
        this.csvInputIndices.add(i2);
        const csvBlocks = this.extractCSVBlocks(decompiled2);
        input.sequence = this.setCSVSequence(csvBlocks, this.sequence);
      }
    }
  }
  secondsToCSVTimeUnits(seconds) {
    return Math.floor(seconds / 512);
  }
  createTimeBasedCSV(seconds) {
    const timeUnits = this.secondsToCSVTimeUnits(seconds);
    if (timeUnits > 65535) {
      throw new Error(`Time units ${timeUnits} exceeds maximum of 65,535`);
    }
    return timeUnits | 1 << 22;
  }
  isCSVEnabled(sequence) {
    return (sequence & 1 << 31) === 0;
  }
  extractCSVValue(sequence) {
    return sequence & 65535;
  }
  /**
   * Finalize secondary P2WDA inputs with empty data
   */
  finalizeSecondaryP2WDA(inputIndex, input) {
    if (!input.partialSig || input.partialSig.length === 0) {
      throw new Error(`No signature for P2WDA input #${inputIndex}`);
    }
    if (!input.witnessScript) {
      throw new Error(`No witness script for P2WDA input #${inputIndex}`);
    }
    const witnessStack = P2WDADetector.createSimpleP2WDAWitness(input.partialSig[0].signature, input.witnessScript);
    return {
      finalScriptSig: void 0,
      finalScriptWitness: witnessStackToScriptWitness(witnessStack)
    };
  }
  async signInputsWalletBased(transaction) {
    const signer = this.signer;
    await signer.multiSignPsbt([transaction]);
    for (let i2 = 0; i2 < transaction.data.inputs.length; i2++) {
      transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
    }
    this.finalized = true;
  }
  isCSVScript(decompiled) {
    return decompiled.some((op) => op === opcodes.OP_CHECKSEQUENCEVERIFY);
  }
  setCSVSequence(csvBlocks, currentSequence) {
    if (this.txVersion < 2) {
      throw new Error("CSV requires transaction version 2 or higher");
    }
    if (csvBlocks > 65535) {
      throw new Error(`CSV blocks ${csvBlocks} exceeds maximum of 65,535`);
    }
    const isTimeBased = (csvBlocks & 1 << 22) !== 0;
    let sequence = csvBlocks & 65535;
    if (isTimeBased) {
      sequence |= 1 << 22;
    }
    if (currentSequence === TransactionSequence.REPLACE_BY_FEE) {
      sequence |= 1 << 25;
    }
    sequence = sequence & 2147483647;
    return sequence;
  }
  getCSVType(csvValue) {
    return csvValue & 1 << 22 ? CSVModes.TIMESTAMPS : CSVModes.BLOCKS;
  }
  extractCSVBlocks(decompiled) {
    for (let i2 = 0; i2 < decompiled.length; i2++) {
      if (decompiled[i2] === opcodes.OP_CHECKSEQUENCEVERIFY && i2 > 0) {
        const csvValue = decompiled[i2 - 1];
        if (csvValue instanceof Uint8Array) {
          return number.decode(csvValue);
        } else if (typeof csvValue === "number") {
          if (csvValue === opcodes.OP_0 || csvValue === opcodes.OP_FALSE) {
            return 0;
          } else if (csvValue === opcodes.OP_1NEGATE) {
            return -1;
          } else if (csvValue >= opcodes.OP_1 && csvValue <= opcodes.OP_16) {
            return csvValue - opcodes.OP_1 + 1;
          } else {
            throw new Error(`Unexpected raw number in script: ${csvValue}`);
          }
        }
      }
    }
    return 0;
  }
  async attemptSignTaproot(transaction, input, i2, signer, publicKey) {
    const isScriptSpend = this.isTaprootScriptSpend(input, publicKey);
    if (isScriptSpend) {
      await this.signTaprootInput(signer, transaction, i2);
    } else {
      let tweakedSigner;
      if (signer !== this.signer) {
        tweakedSigner = this.getTweakedSigner(true, signer);
      } else {
        if (!this.tweakedSigner)
          this.tweakSigner();
        tweakedSigner = this.tweakedSigner;
      }
      if (tweakedSigner) {
        try {
          await this.signTaprootInput(tweakedSigner, transaction, i2);
        } catch (e) {
          tweakedSigner = this.getTweakedSigner(false, this.signer);
          if (!tweakedSigner) {
            throw new Error(`Failed to obtain tweaked signer for input ${i2}.`, {
              cause: e
            });
          }
          await this.signTaprootInput(tweakedSigner, transaction, i2);
        }
      } else {
        this.error(`Failed to obtain tweaked signer for input ${i2}.`);
      }
    }
  }
  isTaprootScriptSpend(input, publicKey) {
    if (input.tapLeafScript && input.tapLeafScript.length > 0) {
      for (const tapLeafScript2 of input.tapLeafScript) {
        if (pubkeyInScript(publicKey, tapLeafScript2.script)) {
          return true;
        }
      }
    }
    return false;
  }
  async signTaprootInput(signer, transaction, i2, tapLeafHash) {
    if ("signTaprootInput" in signer) {
      try {
        await signer.signTaprootInput(transaction, i2, tapLeafHash);
      } catch {
        throw new Error("Failed to sign Taproot input with provided signer.");
      }
    } else {
      transaction.signTaprootInput(i2, signer);
    }
  }
  async signNonTaprootInput(signer, transaction, i2) {
    if ("signInput" in signer) {
      await signer.signInput(transaction, i2);
    } else {
      transaction.signInput(i2, signer);
    }
  }
};
function networkKey(network) {
  return `${network.messagePrefix}|${network.bech32}`;
}
var CHAIN_IDS = /* @__PURE__ */ new Map([
  [
    networkKey(bitcoin$1),
    new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      25,
      214,
      104,
      156,
      8,
      90,
      225,
      101,
      131,
      30,
      147,
      79,
      247,
      99,
      174,
      70,
      162,
      166,
      193,
      114,
      179,
      241,
      182,
      10,
      140,
      226,
      111
    ])
  ],
  [
    networkKey(testnet),
    new Uint8Array([
      0,
      0,
      0,
      0,
      9,
      51,
      234,
      1,
      173,
      14,
      233,
      132,
      32,
      151,
      121,
      186,
      174,
      195,
      206,
      217,
      15,
      163,
      244,
      8,
      113,
      149,
      38,
      248,
      215,
      127,
      73,
      67
    ])
  ],
  [
    networkKey(opnetTestnet),
    new Uint8Array([
      0,
      0,
      1,
      127,
      133,
      16,
      107,
      31,
      238,
      175,
      47,
      112,
      241,
      226,
      184,
      5,
      152,
      91,
      181,
      117,
      248,
      143,
      155,
      11,
      165,
      117,
      61,
      47,
      60,
      241,
      50,
      115
    ])
  ],
  [
    networkKey(regtest),
    new Uint8Array([
      15,
      145,
      136,
      241,
      60,
      183,
      178,
      199,
      31,
      42,
      51,
      94,
      58,
      79,
      195,
      40,
      191,
      91,
      235,
      67,
      96,
      18,
      175,
      202,
      89,
      11,
      26,
      17,
      70,
      110,
      34,
      6
    ])
  ]
]);
function getChainId(network) {
  const chainId = CHAIN_IDS.get(networkKey(network));
  if (!chainId)
    throw new Error("Unsupported network for chain ID retrieval");
  return chainId.slice();
}
var BITCOIN_PROTOCOL_ID = new Uint8Array([
  231,
  132,
  153,
  90,
  65,
  45,
  119,
  57,
  136,
  196,
  184,
  227,
  51,
  215,
  179,
  157,
  251,
  60,
  171,
  241,
  24,
  208,
  214,
  69,
  65,
  26,
  145,
  108,
  162,
  64,
  121,
  57
]);
var MINIMUM_AMOUNT_REWARD = 330n;
var MINIMUM_AMOUNT_CA = 297n;
var ANCHOR_SCRIPT = fromHex$1("51024e73");
var _TransactionBuilder = class _TransactionBuilder extends TweakedTransaction {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "logColor", "#785def");
    __publicField(this, "debugFees", false);
    // Cancel script
    __publicField(this, "LOCK_LEAF_SCRIPT");
    /**
     * @description The overflow fees of the transaction
     * @public
     */
    __publicField(this, "overflowFees", 0n);
    /**
     * @description Cost in satoshis of the transaction fee
     */
    __publicField(this, "transactionFee", 0n);
    /**
     * @description The estimated fees of the transaction
     */
    __publicField(this, "estimatedFees", 0n);
    /**
     * @param {ITransactionParameters} parameters - The transaction parameters
     */
    __publicField(this, "optionalOutputs");
    /**
     * @description The transaction itself.
     */
    __publicField(this, "transaction");
    /**
     * @description Inputs to update later on.
     */
    __publicField(this, "updateInputs", []);
    /**
     * @description The outputs of the transaction
     */
    __publicField(this, "outputs", []);
    /**
     * @description Output that will be used to pay the fees
     */
    __publicField(this, "feeOutput", null);
    /**
     * @description The total amount of satoshis in the inputs
     */
    __publicField(this, "totalInputAmount");
    /**
     * @description The signer of the transaction
     */
    __publicField(this, "signer");
    /**
     * @description The network where the transaction will be broadcasted
     */
    __publicField(this, "network");
    /**
     * @description The fee rate of the transaction
     */
    __publicField(this, "feeRate");
    /**
     * @description The opnet priority fee of the transaction
     */
    __publicField(this, "priorityFee");
    __publicField(this, "gasSatFee");
    /**
     * @description The utxos used in the transaction
     */
    __publicField(this, "utxos");
    /**
     * @description The inputs of the transaction
     * @protected
     */
    __publicField(this, "optionalInputs");
    /**
     * @description The address where the transaction is sent to
     * @protected
     */
    __publicField(this, "to");
    /**
     * @description The address where the transaction is sent from
     * @protected
     */
    __publicField(this, "from");
    /**
     * @description The maximum fee rate of the transaction
     */
    __publicField(this, "_maximumFeeRate", 1e8);
    /**
     * @description Is the destionation P2PK
     * @protected
     */
    __publicField(this, "isPubKeyDestination");
    /**
     * @description If the transaction need an anchor output
     * @protected
     */
    __publicField(this, "anchor");
    __publicField(this, "note");
    __publicField(this, "optionalOutputsAdded", false);
    if (parameters.estimatedFees) {
      this.estimatedFees = parameters.estimatedFees;
    }
    this.signer = parameters.signer;
    this.network = parameters.network;
    this.feeRate = parameters.feeRate;
    this.priorityFee = parameters.priorityFee ?? 0n;
    this.gasSatFee = parameters.gasSatFee ?? 0n;
    this.utxos = parameters.utxos;
    this.optionalInputs = parameters.optionalInputs || [];
    this.to = parameters.to || void 0;
    this.debugFees = parameters.debugFees || false;
    this.LOCK_LEAF_SCRIPT = this.defineLockScript();
    if (parameters.note) {
      if (typeof parameters.note === "string") {
        this.note = new TextEncoder().encode(parameters.note);
      } else {
        this.note = parameters.note;
      }
    }
    this.anchor = parameters.anchor ?? false;
    this.isPubKeyDestination = this.to ? AddressVerificator.isValidPublicKey(this.to, this.network) : false;
    this.optionalOutputs = parameters.optionalOutputs;
    this.from = _TransactionBuilder.getFrom(parameters.from, this.signer, this.network);
    this.totalInputAmount = this.calculateTotalUTXOAmount();
    const totalVOut = this.calculateTotalVOutAmount();
    if (totalVOut < this.totalInputAmount) {
      throw new Error(`Vout value is less than the value to send`);
    }
    this.transaction = new Psbt2({
      network: this.network,
      version: this.txVersion
    });
  }
  static getFrom(from, keypair, network) {
    return from || EcKeyPair.getTaprootAddress(keypair, network);
  }
  /**
   * @description Converts the witness stack to a script witness
   * @param {Uint8Array[]} witness - The witness stack
   * @protected
   * @returns {Uint8Array}
   */
  static witnessStackToScriptWitness(witness) {
    return witnessStackToScriptWitness(witness);
  }
  [Symbol.dispose]() {
    super[Symbol.dispose]();
    this.updateInputs.length = 0;
    this.outputs.length = 0;
    this.feeOutput = null;
    this.optionalOutputs = void 0;
    this.utxos = [];
    this.optionalInputs = [];
  }
  addOPReturn(buffer2) {
    const compileScript = compile([opcodes.OP_RETURN, buffer2]);
    this.addOutput({
      value: toSatoshi(0n),
      script: compileScript
    });
  }
  addAnchor() {
    this.addOutput({
      value: toSatoshi(0n),
      script: ANCHOR_SCRIPT
    });
  }
  async getFundingTransactionParameters() {
    if (!this.estimatedFees) {
      this.estimatedFees = await this.estimateTransactionFees();
    }
    return {
      utxos: this.utxos,
      to: this.getScriptAddress(),
      signer: this.signer,
      network: this.network,
      feeRate: this.feeRate,
      priorityFee: this.priorityFee ?? 0n,
      gasSatFee: this.gasSatFee ?? 0n,
      from: this.from,
      amount: this.estimatedFees,
      optionalInputs: this.optionalInputs,
      mldsaSigner: null,
      ...this.optionalOutputs !== void 0 ? { optionalOutputs: this.optionalOutputs } : {}
    };
  }
  /**
   * Set the destination address of the transaction
   * @param {string} address - The address to set
   */
  setDestinationAddress(address) {
    this.to = address;
  }
  /**
   * Set the maximum fee rate of the transaction in satoshis per byte
   * @param {number} feeRate - The fee rate to set
   * @public
   */
  setMaximumFeeRate(feeRate) {
    this._maximumFeeRate = feeRate;
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Transaction>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signTransaction() {
    if (!this.utxos.length) {
      throw new Error("No UTXOs specified");
    }
    if (this.to && !this.isPubKeyDestination && !EcKeyPair.verifyContractAddress(this.to, this.network)) {
      throw new Error("Invalid contract address. The contract address must be a taproot address.");
    }
    if (this.signed)
      throw new Error("Transaction is already signed");
    this.signed = true;
    await this.buildTransaction();
    const builtTx = await this.internalBuildTransaction(this.transaction);
    if (builtTx) {
      if (this.regenerated) {
        throw new Error("Transaction was regenerated");
      }
      return this.transaction.extractTransaction(true, true);
    }
    throw new Error("Could not sign transaction");
  }
  /**
   * @description Generates the transaction minimal signatures
   * @public
   */
  async generateTransactionMinimalSignatures(checkPartialSigs = false) {
    if (this.to && !this.isPubKeyDestination && !EcKeyPair.verifyContractAddress(this.to, this.network)) {
      throw new Error("Invalid contract address. The contract address must be a taproot address.");
    }
    await this.buildTransaction();
    if (this.transaction.data.inputs.length === 0) {
      const inputs2 = this.getInputs();
      const outputs2 = this.getOutputs();
      this.transaction.setMaximumFeeRate(this._maximumFeeRate);
      this.transaction.addInputs(inputs2, checkPartialSigs);
      for (let i2 = 0; i2 < this.updateInputs.length; i2++) {
        this.transaction.updateInput(i2, this.updateInputs[i2]);
      }
      this.transaction.addOutputs(outputs2);
    }
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Psbt>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signPSBT() {
    if (await this.signTransaction()) {
      return this.transaction;
    }
    throw new Error("Could not sign transaction");
  }
  /**
   * Add an input to the transaction.
   * @param {PsbtInputExtended} input - The input to add
   * @public
   * @returns {void}
   */
  addInput(input) {
    this.inputs.push(input);
  }
  /**
   * Add an output to the transaction.
   * @param {PsbtOutputExtended} output - The output to add
   * @param bypassMinCheck
   * @public
   * @returns {void}
   */
  addOutput(output, bypassMinCheck = false) {
    if (output.value === toSatoshi(0n)) {
      const scriptOutput = output;
      if (!scriptOutput.script || scriptOutput.script.length === 0) {
        throw new Error("Output value is 0 and no script provided");
      }
      if (scriptOutput.script.length < 2) {
        throw new Error("Output script is too short");
      }
      if (scriptOutput.script[0] !== opcodes.OP_RETURN && !equals(scriptOutput.script, ANCHOR_SCRIPT)) {
        throw new Error("Output script must start with OP_RETURN or be an ANCHOR when value is 0");
      }
    } else if (!bypassMinCheck && BigInt(output.value) < _TransactionBuilder.MINIMUM_DUST) {
      throw new Error(`Output value is less than the minimum dust ${output.value} < ${_TransactionBuilder.MINIMUM_DUST}`);
    }
    this.outputs.push(output);
  }
  /**
   * Returns the total value of all outputs added so far (excluding the fee/change output).
   * @public
   * @returns {bigint}
   */
  getTotalOutputValue() {
    return this.outputs.reduce((total, output) => total + BigInt(output.value), 0n);
  }
  /**
   * Receiver address.
   * @public
   * @returns {string} - The receiver address
   */
  toAddress() {
    return this.to;
  }
  /**
   * @description Returns the script address
   * @returns {string} - The script address
   */
  address() {
    var _a5;
    return (_a5 = this.tapData) == null ? void 0 : _a5.address;
  }
  /**
   * Estimates the transaction fees with accurate size calculation.
   *
   * @note The P2TR estimation is made for a 2-leaf tree with both a tapScriptSig and a tapInternalKey input, which is a common case for many transactions.
   * This provides a more accurate fee estimation for typical P2TR transactions, but may not be perfectly accurate for all possible script configurations.
   * Adjustments may be needed for more complex scripts or different leaf structures.
   *
   * @public
   * @returns {Promise<bigint>}
   */
  async estimateTransactionFees() {
    await Promise.resolve();
    const fakeTx = new Psbt2({ network: this.network });
    const inputs2 = this.getInputs();
    const outputs2 = this.getOutputs();
    fakeTx.addInputs(inputs2);
    fakeTx.addOutputs(outputs2);
    const dummySchnorrSig = new Uint8Array(64);
    const dummyEcdsaSig = new Uint8Array(72);
    const dummyCompressedPubkey = new Uint8Array(33).fill(2);
    const finalizer = (inputIndex, input) => {
      var _a5, _b2;
      if (input.isPayToAnchor || this.anchorInputIndices.has(inputIndex)) {
        return {
          finalScriptSig: void 0,
          finalScriptWitness: Uint8Array.from([0])
        };
      }
      if (input.witnessScript && P2WDADetector.isP2WDAWitnessScript(input.witnessScript)) {
        const dummyDataSlots = [];
        for (let i2 = 0; i2 < 10; i2++) {
          dummyDataSlots.push(new Uint8Array(0));
        }
        const dummyEcdsaSig2 = new Uint8Array(72);
        return {
          finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
            ...dummyDataSlots,
            dummyEcdsaSig2,
            input.witnessScript
          ])
        };
      }
      if (inputIndex === 0 && this.tapLeafScript) {
        const dummySecret = new Uint8Array(32);
        const dummyScript = this.tapLeafScript.script;
        const controlBlockSize = this.useP2MR ? 1 + 32 : 1 + 32 + 32;
        const dummyControlBlock = new Uint8Array(controlBlockSize);
        return {
          finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
            dummySecret,
            dummySchnorrSig,
            // It's a tapScriptSig, which is Schnorr
            dummySchnorrSig,
            // Second Schnorr signature
            dummyScript,
            dummyControlBlock
          ])
        };
      }
      if (input.witnessUtxo) {
        const script2 = input.witnessUtxo.script;
        const decompiled = bitcoin.script.decompile(script2);
        if (decompiled && decompiled.length === 5 && decompiled[0] === opcodes.OP_DUP && decompiled[1] === opcodes.OP_HASH160 && decompiled[3] === opcodes.OP_EQUALVERIFY && decompiled[4] === opcodes.OP_CHECKSIG) {
          return {
            finalScriptSig: bitcoin.script.compile([
              dummyEcdsaSig,
              dummyCompressedPubkey
            ]),
            finalScriptWitness: void 0
          };
        }
      }
      if (input.witnessScript) {
        if (this.csvInputIndices.has(inputIndex)) {
          return {
            finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
              dummyEcdsaSig,
              input.witnessScript
            ])
          };
        }
        if (input.redeemScript) {
          const dummyWitness = [dummyEcdsaSig, input.witnessScript];
          return {
            finalScriptSig: input.redeemScript,
            finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness(dummyWitness)
          };
        }
        const decompiled = bitcoin.script.decompile(input.witnessScript);
        if (decompiled && decompiled.length >= 4) {
          const firstOp = decompiled[0];
          const lastOp = decompiled[decompiled.length - 1];
          if (typeof firstOp === "number" && firstOp >= opcodes.OP_1 && lastOp === opcodes.OP_CHECKMULTISIG) {
            const m = firstOp - opcodes.OP_1 + 1;
            const signatures = [];
            for (let i2 = 0; i2 < m; i2++) {
              signatures.push(dummyEcdsaSig);
            }
            return {
              finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
                new Uint8Array(0),
                // OP_0 due to multisig bug
                ...signatures,
                input.witnessScript
              ])
            };
          }
        }
        return {
          finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
            dummyEcdsaSig,
            input.witnessScript
          ])
        };
      } else if (input.redeemScript) {
        const decompiled = bitcoin.script.decompile(input.redeemScript);
        if (decompiled && decompiled.length === 2 && decompiled[0] === opcodes.OP_0 && decompiled[1] instanceof Uint8Array && decompiled[1].length === 20) {
          return {
            finalScriptSig: input.redeemScript,
            finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
              dummyEcdsaSig,
              dummyCompressedPubkey
            ])
          };
        }
      }
      if (input.redeemScript && !input.witnessScript && !input.witnessUtxo) {
        return {
          finalScriptSig: bitcoin.script.compile([dummyEcdsaSig, input.redeemScript]),
          finalScriptWitness: void 0
        };
      }
      const inputScript = (_a5 = input.witnessUtxo) == null ? void 0 : _a5.script;
      if (!inputScript)
        return { finalScriptSig: void 0, finalScriptWitness: void 0 };
      if (input.tapInternalKey) {
        return {
          finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
            dummySchnorrSig
          ])
        };
      }
      if (inputScript.length === 22 && inputScript[0] === opcodes.OP_0) {
        return {
          finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
            dummyEcdsaSig,
            dummyCompressedPubkey
          ])
        };
      }
      if (((_b2 = input.redeemScript) == null ? void 0 : _b2.length) === 22 && input.redeemScript[0] === opcodes.OP_0) {
        return {
          finalScriptWitness: _TransactionBuilder.witnessStackToScriptWitness([
            dummyEcdsaSig,
            dummyCompressedPubkey
          ])
        };
      }
      return getFinalScripts(inputIndex, input, inputScript, true, !!input.redeemScript, !!input.witnessScript);
    };
    try {
      for (let i2 = 0; i2 < fakeTx.data.inputs.length; i2++) {
        const fullInput = inputs2[i2];
        if (fullInput) {
          fakeTx.finalizeInput(i2, (idx) => finalizer(idx, fullInput));
        }
      }
    } catch (e) {
      this.warn(`Could not finalize dummy tx: ${e.message}`);
    }
    const tx = fakeTx.extractTransaction(true, true);
    const size = tx.virtualSize();
    const fee = this.feeRate * size;
    const finalFee = BigInt(Math.ceil(fee));
    if (this.debugFees) {
      this.log(`Estimating fees: feeRate=${this.feeRate}, accurate_vSize=${size}, fee=${finalFee}n`);
    }
    return finalFee;
  }
  async rebuildFromBase64(base64) {
    this.transaction = Psbt2.fromBase64(base64, {
      network: this.network,
      version: this.txVersion
    });
    this.signed = false;
    this.sighashTypes = [Transaction.SIGHASH_ANYONECANPAY, Transaction.SIGHASH_ALL];
    return await this.signPSBT();
  }
  setPSBT(psbt) {
    this.transaction = psbt;
  }
  /**
   * Returns the inputs of the transaction.
   * @protected
   * @returns {PsbtInputExtended[]}
   */
  getInputs() {
    return this.inputs;
  }
  /**
   * Returns the outputs of the transaction.
   * @protected
   * @returns {PsbtOutputExtended[]}
   */
  getOutputs() {
    const outputs2 = [...this.outputs];
    if (this.feeOutput)
      outputs2.push(this.feeOutput);
    return outputs2;
  }
  getOptionalOutputValue() {
    if (!this.optionalOutputs)
      return 0n;
    let total = 0n;
    for (let i2 = 0; i2 < this.optionalOutputs.length; i2++) {
      total += BigInt(this.optionalOutputs[i2].value);
    }
    return total;
  }
  async addRefundOutput(amountSpent, expectRefund = false) {
    if (this.note) {
      this.addOPReturn(this.note);
    }
    if (this.anchor) {
      this.addAnchor();
    }
    this.feeOutput = this.createChangeOutput(_TransactionBuilder.MINIMUM_DUST);
    const feeWithChange = await this.estimateTransactionFees();
    const sendBackAmount = this.totalInputAmount - amountSpent - feeWithChange;
    if (this.debugFees) {
      this.log(`Fee with change: ${feeWithChange} sats, inputAmount=${this.totalInputAmount}, amountSpent=${amountSpent}, sendBackAmount=${sendBackAmount}`);
    }
    if (sendBackAmount >= _TransactionBuilder.MINIMUM_DUST) {
      this.feeOutput = this.createChangeOutput(sendBackAmount);
      this.overflowFees = sendBackAmount;
      this.transactionFee = feeWithChange;
    } else {
      this.feeOutput = null;
      this.overflowFees = 0n;
      const feeWithoutChange = await this.estimateTransactionFees();
      this.transactionFee = feeWithoutChange;
      if (this.debugFees) {
        this.warn(`Amount to send back (${sendBackAmount} sat) is less than minimum dust. Fee without change: ${feeWithoutChange} sats`);
      }
      if (this.totalInputAmount <= amountSpent) {
        throw new Error(`Insufficient funds: need ${amountSpent + feeWithoutChange} sats but only have ${this.totalInputAmount} sats`);
      }
      if (expectRefund && sendBackAmount < 0n) {
        throw new Error(`Insufficient funds: need at least ${-sendBackAmount} more sats to cover fees.`);
      }
    }
    if (this.debugFees) {
      this.log(`Final fee: ${this.transactionFee} sats, Change output: ${this.feeOutput ? `${this.feeOutput.value} sats` : "none"}`);
    }
  }
  defineLockScript() {
    return compile([toXOnly(this.signer.publicKey), opcodes.OP_CHECKSIG]);
  }
  /**
   * @description Adds the value to the output
   * @param {number | bigint} value - The value to add
   * @protected
   * @returns {void}
   */
  addValueToToOutput(value) {
    if (BigInt(value) < _TransactionBuilder.MINIMUM_DUST) {
      throw new Error(`Value to send is less than the minimum dust ${value} < ${_TransactionBuilder.MINIMUM_DUST}`);
    }
    for (let i2 = 0; i2 < this.outputs.length; i2++) {
      const output = this.outputs[i2];
      if ("address" in output && output.address === this.to) {
        this.outputs[i2] = {
          ...output,
          value: toSatoshi(BigInt(output.value) + BigInt(value))
        };
        return;
      }
    }
    throw new Error("Output not found");
  }
  generateLegacySignature() {
    this.tweakSigner();
    if (!this.tweakedSigner) {
      throw new Error("Tweaked signer is not defined");
    }
    const tweakedKey = toXOnly(this.tweakedSigner.publicKey);
    const originalKey = this.signer.publicKey;
    if (originalKey.length !== 33) {
      throw new Error("Original public key must be compressed (33 bytes)");
    }
    const chainId = getChainId(this.network);
    const writer = new BinaryWriter();
    writer.writeU8(cjsExports.MLDSASecurityLevel.LEVEL2);
    writer.writeBytes(this.hashedPublicKey);
    writer.writeBytes(tweakedKey);
    writer.writeBytes(originalKey);
    writer.writeBytes(BITCOIN_PROTOCOL_ID);
    writer.writeBytes(chainId);
    const message = writer.getBuffer();
    const signature2 = MessageSigner.signMessage(this.tweakedSigner, message);
    const isValid = MessageSigner.verifySignature(tweakedKey, message, signature2.signature);
    if (!isValid) {
      throw new Error("Could not verify generated legacy signature for MLDSA link request");
    }
    return new Uint8Array(signature2.signature);
  }
  generateMLDSASignature() {
    if (!this.mldsaSigner) {
      throw new Error("MLDSA signer is not defined");
    }
    this.tweakSigner();
    if (!this.tweakedSigner) {
      throw new Error("Tweaked signer is not defined");
    }
    const tweakedKey = toXOnly(this.tweakedSigner.publicKey);
    const originalKey = this.signer.publicKey;
    if (originalKey.length !== 33) {
      throw new Error("Original public key must be compressed (33 bytes)");
    }
    const chainId = getChainId(this.network);
    const level2 = getLevelFromPublicKeyLength(this.mldsaSigner.publicKey.length);
    if (level2 !== cjsExports.MLDSASecurityLevel.LEVEL2) {
      throw new Error("Only MLDSA level 2 is supported for link requests");
    }
    const writer = new BinaryWriter();
    writer.writeU8(level2);
    writer.writeBytes(this.hashedPublicKey);
    writer.writeBytes(this.mldsaSigner.publicKey);
    writer.writeBytes(tweakedKey);
    writer.writeBytes(originalKey);
    writer.writeBytes(BITCOIN_PROTOCOL_ID);
    writer.writeBytes(chainId);
    const message = writer.getBuffer();
    const signature2 = MessageSigner.signMLDSAMessage(this.mldsaSigner, message);
    const isValid = MessageSigner.verifyMLDSASignature(this.mldsaSigner, message, signature2.signature);
    if (!isValid) {
      throw new Error("Could not verify generated MLDSA signature for link request");
    }
    return new Uint8Array(signature2.signature);
  }
  generateMLDSALinkRequest(parameters, features) {
    const mldsaSigner = this.mldsaSigner;
    const legacySignature = this.generateLegacySignature();
    let mldsaSignature = null;
    if (parameters.revealMLDSAPublicKey) {
      mldsaSignature = this.generateMLDSASignature();
    }
    const mldsaRequest = {
      priority: FeaturePriority.MLDSA_LINK_PUBKEY,
      opcode: Features.MLDSA_LINK_PUBKEY,
      data: {
        verifyRequest: !!parameters.revealMLDSAPublicKey,
        publicKey: mldsaSigner.publicKey,
        hashedPublicKey: this.hashedPublicKey,
        level: getLevelFromPublicKeyLength(mldsaSigner.publicKey.length),
        legacySignature,
        mldsaSignature
      }
    };
    features.push(mldsaRequest);
  }
  /**
   * @description Returns the transaction opnet fee
   * @protected
   * @returns {bigint}
   */
  getTransactionOPNetFee() {
    const totalFee = this.priorityFee + this.gasSatFee;
    if (totalFee > _TransactionBuilder.MINIMUM_DUST) {
      return totalFee;
    }
    return _TransactionBuilder.MINIMUM_DUST;
  }
  /**
   * @description Returns the total amount of satoshis in the inputs
   * @protected
   * @returns {bigint}
   */
  calculateTotalUTXOAmount() {
    let total = 0n;
    for (const utxo of this.utxos) {
      total += utxo.value;
    }
    for (const utxo of this.optionalInputs) {
      total += utxo.value;
    }
    return total;
  }
  /**
   * @description Returns the total amount of satoshis in the outputs
   * @protected
   * @returns {bigint}
   */
  calculateTotalVOutAmount() {
    let total = 0n;
    for (const utxo of this.utxos) {
      total += utxo.value;
    }
    for (const utxo of this.optionalInputs) {
      total += utxo.value;
    }
    return total;
  }
  /**
   * @description Adds optional outputs to transaction and returns their total value in satoshi to calculate refund transaction
   * @protected
   * @returns {bigint}
   */
  addOptionalOutputsAndGetAmount() {
    if (!this.optionalOutputs || this.optionalOutputsAdded)
      return 0n;
    let refundedFromOptionalOutputs = 0n;
    for (let i2 = 0; i2 < this.optionalOutputs.length; i2++) {
      this.addOutput(this.optionalOutputs[i2]);
      refundedFromOptionalOutputs += BigInt(this.optionalOutputs[i2].value);
    }
    this.optionalOutputsAdded = true;
    return refundedFromOptionalOutputs;
  }
  /**
   * @description Adds the inputs from the utxos
   * @protected
   * @returns {void}
   */
  addInputsFromUTXO() {
    if (this.utxos.length) {
      if (this.totalInputAmount < _TransactionBuilder.MINIMUM_DUST) {
        throw new Error(`Total input amount is ${this.totalInputAmount} sat which is less than the minimum dust ${_TransactionBuilder.MINIMUM_DUST} sat.`);
      }
      for (let i2 = 0; i2 < this.utxos.length; i2++) {
        const utxo = this.utxos[i2];
        this.registerInputSigner(i2, utxo);
        const input = this.generatePsbtInputExtended(utxo, i2);
        this.addInput(input);
      }
    }
    if (this.optionalInputs) {
      for (let i2 = this.utxos.length; i2 < this.optionalInputs.length + this.utxos.length; i2++) {
        const utxo = this.optionalInputs[i2 - this.utxos.length];
        this.registerInputSigner(i2, utxo);
        const input = this.generatePsbtInputExtended(utxo, i2, true);
        this.addInput(input);
      }
    }
  }
  /**
   * Internal init.
   * @protected
   */
  internalInit() {
    this.verifyUTXOValidity();
    super.internalInit();
  }
  /**
   * Add an input update
   * @param {UpdateInput} input - The input to update
   * @protected
   * @returns {void}
   */
  updateInput(input) {
    this.updateInputs.push(input);
  }
  /**
   * Adds the fee to the output.
   * @param amountSpent
   * @param contractAddress
   * @param epochChallenge
   * @param addContractOutput
   * @protected
   */
  addFeeToOutput(amountSpent, contractAddress, epochChallenge, addContractOutput) {
    if (addContractOutput) {
      let amountToCA;
      if (amountSpent > MINIMUM_AMOUNT_REWARD + MINIMUM_AMOUNT_CA) {
        amountToCA = MINIMUM_AMOUNT_CA;
      } else {
        amountToCA = amountSpent;
      }
      this.addOutput({
        value: toSatoshi(amountToCA),
        address: contractAddress
      }, true);
      if (amountToCA === MINIMUM_AMOUNT_CA && amountSpent - MINIMUM_AMOUNT_CA > MINIMUM_AMOUNT_REWARD) {
        this.addOutput({
          value: toSatoshi(amountSpent - amountToCA),
          address: epochChallenge.address
        }, true);
      }
    } else {
      const amountToEpoch = amountSpent < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : amountSpent;
      this.addOutput({
        value: toSatoshi(amountToEpoch),
        address: epochChallenge.address
      }, true);
    }
  }
  /**
   * Returns the witness of the tap transaction.
   * @protected
   * @returns {Uint8Array}
   */
  getWitness() {
    if (!this.tapData || !this.tapData.witness) {
      throw new Error("Witness is required");
    }
    if (this.tapData.witness.length === 0) {
      throw new Error("Witness is empty");
    }
    return this.tapData.witness[this.tapData.witness.length - 1];
  }
  /**
   * Returns the tap output.
   * @protected
   * @returns {Uint8Array}
   */
  getTapOutput() {
    if (!this.tapData || !this.tapData.output) {
      throw new Error("Tap data is required");
    }
    return this.tapData.output;
  }
  /**
   * Verifies that the utxos are valid.
   * @protected
   */
  verifyUTXOValidity() {
    for (const utxo of this.utxos) {
      if (!utxo.scriptPubKey) {
        throw new Error("Address is required");
      }
    }
    for (const utxo of this.optionalInputs) {
      if (!utxo.scriptPubKey) {
        throw new Error("Address is required");
      }
    }
  }
  /**
   * Builds the transaction.
   * @param {Psbt} transaction - The transaction to build
   * @param checkPartialSigs
   * @protected
   * @returns {Promise<boolean>}
   * @throws {Error} - If something went wrong while building the transaction
   */
  async internalBuildTransaction(transaction, checkPartialSigs = false) {
    if (transaction.data.inputs.length === 0) {
      const inputs2 = this.getInputs();
      const outputs2 = this.getOutputs();
      transaction.setMaximumFeeRate(this._maximumFeeRate);
      transaction.addInputs(inputs2, checkPartialSigs);
      for (let i2 = 0; i2 < this.updateInputs.length; i2++) {
        transaction.updateInput(i2, this.updateInputs[i2]);
      }
      transaction.addOutputs(outputs2);
    }
    try {
      await this.signInputs(transaction);
      if (this.finalized) {
        this.transactionFee = BigInt(transaction.getFee());
      }
      return true;
    } catch (e) {
      const err2 = e;
      this.error(`[internalBuildTransaction] Something went wrong while getting building the transaction: ${err2.stack}`);
    }
    return false;
  }
  createChangeOutput(amount) {
    if (AddressVerificator.isValidP2TRAddress(this.from, this.network)) {
      return {
        value: toSatoshi(amount),
        address: this.from,
        tapInternalKey: this.internalPubKeyToXOnly()
      };
    } else if (AddressVerificator.isValidPublicKey(this.from, this.network)) {
      const pubKeyScript = compile([
        fromHex$1(this.from.startsWith("0x") ? this.from.slice(2) : this.from),
        opcodes.OP_CHECKSIG
      ]);
      return {
        value: toSatoshi(amount),
        script: pubKeyScript
      };
    } else {
      return {
        value: toSatoshi(amount),
        address: this.from
      };
    }
  }
};
__publicField(_TransactionBuilder, "MINIMUM_DUST", 330n);
var TransactionBuilder = _TransactionBuilder;
var CustomScriptTransaction = class extends TransactionBuilder {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", TransactionType.CUSTOM_CODE);
    /**
     * The contract address
     * @protected
     */
    __publicField(this, "_scriptAddress");
    /**
     * The tap leaf script
     * @private
     */
    __publicField(this, "tapLeafScript", null);
    /**
     * The target script redeem
     * @private
     */
    __publicField(this, "targetScriptRedeem", null);
    /**
     * The left over funds script redeem
     * @private
     */
    __publicField(this, "leftOverFundsScriptRedeem", null);
    /**
     * The compiled target script
     * @private
     */
    __publicField(this, "compiledTargetScript");
    /**
     * The script tree
     * @private
     */
    __publicField(this, "scriptTree");
    /**
     * The deployment bitcoin generator
     * @private
     */
    __publicField(this, "generator");
    /**
     * The contract seed
     * @private
     */
    __publicField(this, "scriptSeed");
    /**
     * The contract signer
     * @private
     */
    __publicField(this, "contractSigner");
    /**
     * The contract salt random bytes
     * @private
     */
    __publicField(this, "randomBytes");
    /**
     * The witnesses
     * @private
     */
    __publicField(this, "witnesses");
    __publicField(this, "annexData");
    /**
     * Finalize the transaction
     * @param _inputIndex
     * @param input
     */
    __publicField(this, "customFinalizer", (_inputIndex, input) => {
      if (!this.tapLeafScript) {
        throw new Error("Tap leaf script is required");
      }
      const scriptSolution = this.getScriptSolution(input);
      const witness = scriptSolution.concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      if (this.annexData && this.annexData.length > 0) {
        let annex;
        if (this.annexData[0] === 80) {
          annex = this.annexData;
        } else {
          const prefixed = new Uint8Array(this.annexData.length + 1);
          prefixed[0] = 80;
          prefixed.set(this.annexData, 1);
          annex = prefixed;
        }
        witness.push(annex);
      }
      return {
        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness)
      };
    });
    if (!parameters.script)
      throw new Error("Bitcoin script is required");
    if (!parameters.witnesses)
      throw new Error("Witness(es) are required");
    this.witnesses = parameters.witnesses;
    this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
    this.LOCK_LEAF_SCRIPT = this.defineLockScript();
    this.scriptSeed = this.getContractSeed();
    this.contractSigner = EcKeyPair.fromSeedKeyPair(this.scriptSeed, this.network);
    this.generator = new CustomGenerator(this.internalPubKeyToXOnly(), this.network);
    this.compiledTargetScript = this.generator.compile(parameters.script);
    this.scriptTree = this.getScriptTree();
    this.internalInit();
    this._scriptAddress = AddressGenerator.generatePKSH(this.scriptSeed, this.network);
  }
  /**
   * @description Get the contract address (PKSH)
   */
  get scriptAddress() {
    return this._scriptAddress;
  }
  /**
   * @description Get the P2TR address
   */
  get p2trAddress() {
    return this.to || this.getScriptAddress();
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the contract signer public key
   * @protected
   */
  contractSignerXOnlyPubKey() {
    return toXOnly(this.contractSigner.publicKey);
  }
  /**
   * Build the transaction
   * @protected
   */
  async buildTransaction() {
    if (!this.to) {
      this.to = this.getScriptAddress();
    }
    const selectedRedeem = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!selectedRedeem.redeemVersion) {
      throw new Error("Left over funds script redeem version is required");
    }
    if (!selectedRedeem.output) {
      throw new Error("Left over funds script redeem output is required");
    }
    this.tapLeafScript = {
      leafVersion: selectedRedeem.redeemVersion,
      script: selectedRedeem.output,
      controlBlock: this.getWitness()
    };
    this.addInputsFromUTXO();
    const amountSpent = this.getTransactionOPNetFee();
    this.addOutput({
      value: toSatoshi(amountSpent),
      address: this.to
    });
    await this.addRefundOutput(amountSpent + this.addOptionalOutputsAndGetAmount());
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(transaction) {
    if (!this.contractSigner) {
      await super.signInputs(transaction);
      return;
    }
    try {
      transaction.signInput(0, this.contractSigner);
    } catch {
    }
    transaction.signInput(0, this.getSignerKey());
    transaction.finalizeInput(0, this.customFinalizer);
    const signedIndices = /* @__PURE__ */ new Set([0]);
    if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
      try {
        const result = await this.signKeyPathInputsParallel(transaction, /* @__PURE__ */ new Set([0]));
        if (result.success) {
          for (const idx of result.signatures.keys())
            signedIndices.add(idx);
        }
      } catch (e) {
        this.error(`Parallel signing failed: ${e.message}`);
      }
    }
    for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
      if (!signedIndices.has(i2)) {
        transaction.signInput(i2, this.getSignerKey());
      }
    }
    for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
      try {
        transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
      } catch {
        transaction.finalizeInput(i2);
      }
    }
  }
  /**
   * Get the tap output
   * @protected
   */
  generateScriptAddress() {
    if (this.useP2MR) {
      return {
        network: this.network,
        scriptTree: this.scriptTree,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: PaymentType.P2TR
    };
  }
  /**
   * Generate the tap data
   * @protected
   */
  generateTapData() {
    const selectedRedeem = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!this.scriptTree) {
      throw new Error("Script tree is required");
    }
    if (this.useP2MR) {
      return {
        network: this.network,
        scriptTree: this.scriptTree,
        redeem: selectedRedeem,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: selectedRedeem,
      name: PaymentType.P2TR
    };
  }
  getScriptSolution(input) {
    if (!input.tapScriptSig) {
      throw new Error("Tap script signature is required");
    }
    const witnesses = [...this.witnesses];
    if (input.tapScriptSig) {
      for (const sig of input.tapScriptSig) {
        witnesses.push(sig.signature);
      }
    }
    return witnesses;
  }
  /**
   * Generate the contract seed for the deployment
   * @private
   */
  getContractSeed() {
    return hash256(this.randomBytes);
  }
  /**
   * Generate the redeem scripts
   * @private
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: PaymentType.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.compiledTargetScript,
      redeemVersion: 192
    };
    this.leftOverFundsScriptRedeem = {
      name: PaymentType.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.getLeafScript(),
      redeemVersion: 192
    };
  }
  /**
   * Get the second leaf script
   * @private
   */
  getLeafScript() {
    return this.LOCK_LEAF_SCRIPT;
  }
  /**
   * Get the script tree
   * @private
   */
  getScriptTree() {
    this.generateRedeemScripts();
    return [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.getLeafScript(),
        version: 192
      }
    ];
  }
};
var SharedInteractionTransaction = class extends TransactionBuilder {
  constructor(parameters) {
    super(parameters);
    // 1MB
    /**
     * Random salt for the interaction
     * @type {Uint8Array}
     */
    __publicField(this, "randomBytes");
    __publicField(this, "targetScriptRedeem", null);
    __publicField(this, "leftOverFundsScriptRedeem", null);
    __publicField(this, "challenge");
    __publicField(this, "epochChallenge");
    __publicField(this, "calldataGenerator");
    /**
     * Calldata for the interaction
     * @protected
     */
    __publicField(this, "calldata");
    /**
     * Script signer for the interaction
     * @protected
     */
    __publicField(this, "scriptSigner");
    /**
     * Disable auto refund
     * @protected
     */
    __publicField(this, "disableAutoRefund");
    /**
     * Transaction finalizer
     * @param {number} _inputIndex The input index
     * @param {PsbtInput} input The input
     */
    __publicField(this, "customFinalizer", (_inputIndex, input) => {
      if (!this.tapLeafScript) {
        throw new Error("Tap leaf script is required");
      }
      if (!this.contractSecret) {
        throw new Error("Contract secret is required");
      }
      const scriptSolution = this.getScriptSolution(input);
      const witness = scriptSolution.concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness)
      };
    });
    if (!parameters.calldata) {
      throw new Error("Calldata is required");
    }
    if (!parameters.challenge) {
      throw new Error("Challenge solution is required");
    }
    this.challenge = parameters.challenge;
    this.LOCK_LEAF_SCRIPT = this.defineLockScript();
    this.disableAutoRefund = parameters.disableAutoRefund || false;
    this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
    this.calldata = Compressor.compress(parameters.calldata);
    this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
    this.scriptSigner = this.generateKeyPairFromSeed();
    this.calldataGenerator = new CalldataGenerator(this.signer.publicKey, this.scriptSignerXOnlyPubKey(), this.network);
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the contract secret
   * @returns {Uint8Array} The contract secret
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the preimage
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get the internal pubkey as an x-only key
   * @protected
   * @returns {Uint8Array} The internal pubkey as an x-only key
   */
  scriptSignerXOnlyPubKey() {
    return toXOnly(this.scriptSigner.publicKey);
  }
  /**
   * Generate a key pair from the seed
   * @protected
   *
   * @returns {UniversalSigner} The key pair
   */
  generateKeyPairFromSeed() {
    return EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
  }
  /**
   * Build the transaction
   * @protected
   *
   * @throws {Error} If the left over funds script redeem is required
   * @throws {Error} If the left over funds script redeem version is required
   * @throws {Error} If the left over funds script redeem output is required
   * @throws {Error} If the to address is required
   */
  async buildTransaction() {
    const selectedRedeem = this.scriptSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!selectedRedeem.redeemVersion) {
      throw new Error("Left over funds script redeem version is required");
    }
    if (!selectedRedeem.output) {
      throw new Error("Left over funds script redeem output is required");
    }
    this.tapLeafScript = {
      leafVersion: selectedRedeem.redeemVersion,
      script: selectedRedeem.output,
      controlBlock: this.getWitness()
    };
    if (!this.regenerated) {
      this.addInputsFromUTXO();
    }
    await this.createMineableRewardOutputs();
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(transaction) {
    if (!this.scriptSigner) {
      await super.signInputs(transaction);
      return;
    }
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(transaction);
    } else {
      await this.signInputsNonWalletBased(transaction);
    }
  }
  generateScriptAddress() {
    if (this.useP2MR) {
      return {
        network: this.network,
        scriptTree: this.scriptTree,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: PaymentType.P2TR
    };
  }
  generateTapData() {
    const selectedRedeem = this.scriptSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!this.scriptTree) {
      throw new Error("Script tree is required");
    }
    if (this.useP2MR) {
      return {
        network: this.network,
        scriptTree: this.scriptTree,
        redeem: selectedRedeem,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: selectedRedeem,
      name: PaymentType.P2TR
    };
  }
  /**
   * Generate the script solution
   * @param {PsbtInput} input The input
   * @protected
   *
   * @returns {Uint8Array[]} The script solution
   */
  getScriptSolution(input) {
    if (!input.tapScriptSig) {
      throw new Error("Tap script signature is required");
    }
    return [
      this.contractSecret,
      input.tapScriptSig[0].signature,
      input.tapScriptSig[1].signature
    ];
  }
  /**
   * Get the script tree
   * @private
   *
   * @returns {Taptree} The script tree
   */
  getScriptTree() {
    if (!this.calldata) {
      throw new Error("Calldata is required");
    }
    this.generateRedeemScripts();
    return [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.LOCK_LEAF_SCRIPT,
        version: 192
      }
    ];
  }
  // custom for interactions
  async signInputsWalletBased(transaction) {
    const signer = this.signer;
    await this.signInput(transaction, transaction.data.inputs[0], 0, this.scriptSigner);
    await signer.multiSignPsbt([transaction]);
    for (let i2 = 0; i2 < transaction.data.inputs.length; i2++) {
      if (i2 === 0) {
        transaction.finalizeInput(i2, this.customFinalizer.bind(this));
      } else {
        try {
          transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
        } catch (e) {
          transaction.finalizeInput(i2);
        }
      }
    }
  }
  async signInputsNonWalletBased(transaction) {
    await this.signInput(transaction, transaction.data.inputs[0], 0, this.scriptSigner);
    await this.signInput(transaction, transaction.data.inputs[0], 0, this.getSignerKey());
    transaction.finalizeInput(0, this.customFinalizer.bind(this));
    if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
      let parallelSignedIndices = /* @__PURE__ */ new Set();
      try {
        const result = await this.signKeyPathInputsParallel(transaction, /* @__PURE__ */ new Set([0]));
        if (result.success) {
          parallelSignedIndices = new Set(result.signatures.keys());
        }
      } catch (e) {
        this.error(`Parallel signing failed, falling back to sequential: ${e.message}`);
      }
      for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
        if (!parallelSignedIndices.has(i2)) {
          await this.signInput(transaction, transaction.data.inputs[i2], i2, this.signer);
        }
      }
    } else {
      for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
        await this.signInput(transaction, transaction.data.inputs[i2], i2, this.signer);
      }
    }
    for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
      try {
        transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
      } catch {
        transaction.finalizeInput(i2);
      }
    }
    this.finalized = true;
  }
  async createMineableRewardOutputs() {
    if (!this.to)
      throw new Error("To address is required");
    const opnetFee = this.getTransactionOPNetFee();
    this.addFeeToOutput(opnetFee, this.to, this.epochChallenge, false);
    const actualOutputAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
    const optionalAmount = this.addOptionalOutputsAndGetAmount();
    if (!this.disableAutoRefund) {
      await this.addRefundOutput(actualOutputAmount + optionalAmount);
    }
  }
  /**
   * Generate the redeem scripts
   * @private
   *
   * @throws {Error} If the public keys are required
   * @throws {Error} If the leaf script is required
   * @throws {Error} If the leaf script version is required
   * @throws {Error} If the leaf script output is required
   * @throws {Error} If the target script redeem is required
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: PaymentType.P2TR,
      output: this.compiledTargetScript,
      redeemVersion: 192
    };
    this.leftOverFundsScriptRedeem = {
      name: PaymentType.P2TR,
      output: this.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
};
__publicField(SharedInteractionTransaction, "MAXIMUM_CALLDATA_SIZE", 1024 * 1024);
var _DeploymentTransaction = class _DeploymentTransaction extends TransactionBuilder {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", TransactionType.DEPLOYMENT);
    __publicField(this, "challenge");
    __publicField(this, "epochChallenge");
    /**
     * The contract address
     * @protected
     */
    __publicField(this, "_contractAddress");
    /**
     * The tap leaf script
     * @private
     */
    __publicField(this, "tapLeafScript", null);
    __publicField(this, "deploymentVersion", 0);
    /**
     * The target script redeem
     * @private
     */
    __publicField(this, "targetScriptRedeem", null);
    /**
     * The left over funds script redeem
     * @private
     */
    __publicField(this, "leftOverFundsScriptRedeem", null);
    /**
     * The compiled target script
     * @private
     */
    __publicField(this, "compiledTargetScript");
    /**
     * The script tree
     * @private
     */
    __publicField(this, "scriptTree");
    /**
     * The deployment bitcoin generator
     * @private
     */
    __publicField(this, "deploymentGenerator");
    /**
     * The contract seed
     * @private
     */
    __publicField(this, "contractSeed");
    /**
     * The contract bytecode
     * @private
     */
    __publicField(this, "bytecode");
    /**
     * Constructor calldata
     * @private
     */
    __publicField(this, "calldata");
    /**
     * The contract signer
     * @private
     */
    __publicField(this, "contractSigner");
    /**
     * The contract public key
     * @private
     */
    __publicField(this, "_contractPubKey");
    /**
     * The contract salt random bytes
     * @private
     */
    __publicField(this, "randomBytes");
    __publicField(this, "_computedAddress");
    /**
     * Finalize the transaction
     * @param _inputIndex
     * @param input
     */
    __publicField(this, "customFinalizer", (_inputIndex, input) => {
      if (!this.tapLeafScript) {
        throw new Error("Tap leaf script is required");
      }
      if (!input.tapScriptSig) {
        throw new Error("Tap script signature is required");
      }
      const scriptSolution = [
        this.randomBytes,
        input.tapScriptSig[0].signature,
        input.tapScriptSig[1].signature
      ];
      const witness = scriptSolution.concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness)
      };
    });
    if (!this.hashedPublicKey) {
      throw new Error("MLDSA signer must be defined to deploy a contract.");
    }
    this.bytecode = Compressor.compress(new Uint8Array([...versionBuffer, ...parameters.bytecode]));
    this.verifyBytecode();
    if (parameters.calldata) {
      this.calldata = parameters.calldata;
      this.verifyCalldata();
    }
    if (!parameters.challenge)
      throw new Error("Challenge solution is required");
    this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
    this.challenge = parameters.challenge;
    this.LOCK_LEAF_SCRIPT = this.defineLockScript();
    this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
    this.contractSeed = this.getContractSeed();
    this.contractSigner = EcKeyPair.fromSeedKeyPair(this.contractSeed, this.network);
    this.deploymentGenerator = new DeploymentGenerator(this.signer.publicKey, this.contractSignerXOnlyPubKey(), this.network);
    if (parameters.compiledTargetScript) {
      if (parameters.compiledTargetScript instanceof Uint8Array) {
        this.compiledTargetScript = parameters.compiledTargetScript;
      } else if (typeof parameters.compiledTargetScript === "string") {
        this.compiledTargetScript = fromHex$1(parameters.compiledTargetScript);
      } else {
        throw new Error("Invalid compiled target script format.");
      }
    } else {
      this.compiledTargetScript = this.deploymentGenerator.compile(this.bytecode, this.randomBytes, this.challenge, this.priorityFee, this.calldata, this.generateFeatures(parameters));
    }
    this.scriptTree = this.getScriptTree();
    this.internalInit();
    this._contractPubKey = "0x" + toHex$1(this.contractSeed);
    this._contractAddress = new Address(this.contractSeed);
  }
  /**
   * Get the contract public key
   */
  get contractPubKey() {
    return this._contractPubKey;
  }
  /**
   * @description Get the contract address (PKSH)
   */
  get contractAddress() {
    return this._contractAddress;
  }
  /**
   * @description Get the P2TR address
   */
  get p2trAddress() {
    return this.to || this.getScriptAddress();
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the contract bytecode
   * @returns {Uint8Array} The contract bytecode
   */
  getChallenge() {
    return this.challenge;
  }
  getContractAddress() {
    if (this._computedAddress) {
      return this._computedAddress;
    }
    this._computedAddress = EcKeyPair.p2op(this.contractSeed, this.network, this.deploymentVersion);
    return this._computedAddress;
  }
  /**
   * Get the contract signer public key
   * @protected
   */
  contractSignerXOnlyPubKey() {
    return toXOnly(this.contractSigner.publicKey);
  }
  /**
   * Build the transaction
   * @protected
   */
  async buildTransaction() {
    if (!this.to) {
      this.to = this.getScriptAddress();
    }
    const selectedRedeem = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!selectedRedeem.redeemVersion) {
      throw new Error("Left over funds script redeem version is required");
    }
    if (!selectedRedeem.output) {
      throw new Error("Left over funds script redeem output is required");
    }
    this.tapLeafScript = {
      leafVersion: selectedRedeem.redeemVersion,
      script: selectedRedeem.output,
      controlBlock: this.getWitness()
    };
    this.addInputsFromUTXO();
    const amountSpent = this.getTransactionOPNetFee();
    this.addFeeToOutput(amountSpent, this.getContractAddress(), this.epochChallenge, true);
    await this.addRefundOutput(amountSpent + this.addOptionalOutputsAndGetAmount());
  }
  async signInputsWalletBased(transaction) {
    const signer = this.signer;
    await this.signInput(transaction, transaction.data.inputs[0], 0, this.contractSigner);
    await signer.multiSignPsbt([transaction]);
    for (let i2 = 0; i2 < transaction.data.inputs.length; i2++) {
      if (i2 === 0) {
        transaction.finalizeInput(i2, this.customFinalizer.bind(this));
      } else {
        try {
          transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
        } catch (e) {
          transaction.finalizeInput(i2);
        }
      }
    }
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(transaction) {
    if (!this.contractSigner) {
      await super.signInputs(transaction);
      return;
    }
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(transaction);
      return;
    }
    transaction.signInput(0, this.contractSigner);
    transaction.signInput(0, this.getSignerKey());
    transaction.finalizeInput(0, this.customFinalizer.bind(this));
    const signedIndices = /* @__PURE__ */ new Set([0]);
    if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
      try {
        const result = await this.signKeyPathInputsParallel(transaction, /* @__PURE__ */ new Set([0]));
        if (result.success) {
          for (const idx of result.signatures.keys())
            signedIndices.add(idx);
        }
      } catch (e) {
        this.error(`Parallel signing failed: ${e.message}`);
      }
    }
    for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
      if (!signedIndices.has(i2)) {
        transaction.signInput(i2, this.getSignerKey());
      }
    }
    for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
      try {
        transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
      } catch {
        transaction.finalizeInput(i2);
      }
    }
  }
  /**
   * Get the tap output
   * @protected
   */
  generateScriptAddress() {
    if (this.useP2MR) {
      return {
        name: PaymentType.P2MR,
        network: this.network,
        scriptTree: this.scriptTree
      };
    }
    return {
      name: PaymentType.P2TR,
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree
    };
  }
  /**
   * Generate the tap data
   * @protected
   */
  generateTapData() {
    const selectedRedeem = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!this.scriptTree) {
      throw new Error("Script tree is required");
    }
    if (this.useP2MR) {
      return {
        name: PaymentType.P2MR,
        network: this.network,
        scriptTree: this.scriptTree,
        redeem: selectedRedeem
      };
    }
    return {
      name: PaymentType.P2TR,
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: selectedRedeem
    };
  }
  generateFeatures(parameters) {
    const features = [];
    const submission = parameters.challenge.getSubmission();
    if (submission) {
      features.push({
        priority: FeaturePriority.MLDSA_LINK_PUBKEY,
        opcode: Features.EPOCH_SUBMISSION,
        data: submission
      });
    }
    if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
      throw new Error("To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.");
    }
    if (parameters.linkMLDSAPublicKeyToAddress) {
      this.generateMLDSALinkRequest(parameters, features);
    }
    return features;
  }
  verifyCalldata() {
    if (this.calldata && this.calldata.length > SharedInteractionTransaction.MAXIMUM_CALLDATA_SIZE) {
      throw new Error("Calldata size overflow.");
    }
  }
  verifyBytecode() {
    if (!this.bytecode)
      throw new Error("Bytecode is required");
    if (this.bytecode.length > _DeploymentTransaction.MAXIMUM_CONTRACT_SIZE) {
      throw new Error("Contract size overflow.");
    }
  }
  /**
   * Generate the contract seed for the deployment
   * @private
   */
  getContractSeed() {
    if (!this.bytecode) {
      throw new Error("Bytecode is required");
    }
    const deployerPubKey = this.internalPubKeyToXOnly();
    const salt = hash256(this.randomBytes);
    const sha256OfBytecode = hash256(this.bytecode);
    const buf = concat$1([deployerPubKey, salt, sha256OfBytecode]);
    return hash256(buf);
  }
  /**
   * Generate the redeem scripts
   * @private
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: PaymentType.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.compiledTargetScript,
      redeemVersion: 192
    };
    this.leftOverFundsScriptRedeem = {
      name: PaymentType.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.getLeafScript(),
      redeemVersion: 192
    };
  }
  /**
   * Get the second leaf script
   * @private
   */
  getLeafScript() {
    return this.LOCK_LEAF_SCRIPT;
  }
  /**
   * Get the script tree
   * @private
   */
  getScriptTree() {
    if (!this.bytecode) {
      throw new Error("Contract bytecode is required");
    }
    this.generateRedeemScripts();
    return [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.getLeafScript(),
        version: 192
      }
    ];
  }
};
__publicField(_DeploymentTransaction, "MAXIMUM_CONTRACT_SIZE", 128 * 1024);
var DeploymentTransaction = _DeploymentTransaction;
var FundingTransaction = class extends TransactionBuilder {
  constructor(parameters) {
    var _a5;
    const mergedParams = ((_a5 = parameters.feeUtxos) == null ? void 0 : _a5.length) ? { ...parameters, utxos: [...parameters.utxos, ...parameters.feeUtxos] } : parameters;
    super(mergedParams);
    __publicField(this, "type", TransactionType.FUNDING);
    __publicField(this, "amount");
    __publicField(this, "splitInputsInto");
    __publicField(this, "autoAdjustAmount");
    this.amount = parameters.amount;
    this.splitInputsInto = parameters.splitInputsInto ?? 1;
    this.autoAdjustAmount = parameters.autoAdjustAmount ?? false;
    this.internalInit();
  }
  async buildTransaction() {
    if (!this.to) {
      throw new Error("Recipient address is required");
    }
    this.addInputsFromUTXO();
    if (this.autoAdjustAmount && this.amount >= this.totalInputAmount) {
      if (this.isPubKeyDestination) {
        const toHexClean = this.to.startsWith("0x") ? this.to.slice(2) : this.to;
        const pubKeyScript = compile([
          fromHex$1(toHexClean),
          opcodes.OP_CHECKSIG
        ]);
        this.addOutput({
          value: toSatoshi(this.amount),
          script: pubKeyScript
        });
      } else {
        this.addOutput({
          value: toSatoshi(this.amount),
          address: this.to
        });
      }
      const estimatedFee = await this.estimateTransactionFees();
      this.outputs.pop();
      const adjustedAmount = this.totalInputAmount - estimatedFee;
      if (adjustedAmount < TransactionBuilder.MINIMUM_DUST) {
        throw new Error(`Insufficient funds: after deducting fee of ${estimatedFee} sats, remaining amount ${adjustedAmount} sats is below minimum dust`);
      }
      this.amount = adjustedAmount;
    }
    if (this.splitInputsInto > 1) {
      this.splitInputs(this.amount);
    } else if (this.isPubKeyDestination) {
      const toHexClean = this.to.startsWith("0x") ? this.to.slice(2) : this.to;
      const pubKeyScript = compile([
        fromHex$1(toHexClean),
        opcodes.OP_CHECKSIG
      ]);
      this.addOutput({
        value: toSatoshi(this.amount),
        script: pubKeyScript
      });
    } else {
      this.addOutput({
        value: toSatoshi(this.amount),
        address: this.to
      });
    }
    const totalOutputAmount = this.amount + this.addOptionalOutputsAndGetAmount();
    await this.addRefundOutput(totalOutputAmount);
  }
  splitInputs(amountSpent) {
    if (!this.to) {
      throw new Error("Recipient address is required");
    }
    const splitAmount = amountSpent / BigInt(this.splitInputsInto);
    for (let i2 = 0; i2 < this.splitInputsInto; i2++) {
      if (this.isPubKeyDestination) {
        this.addOutput({
          value: toSatoshi(splitAmount),
          script: fromHex$1(this.to.slice(2))
        });
      } else {
        this.addOutput({
          value: toSatoshi(splitAmount),
          address: this.to
        });
      }
    }
  }
  getSignerKey() {
    return this.signer;
  }
};
var InteractionTransaction = class extends SharedInteractionTransaction {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", TransactionType.INTERACTION);
    __publicField(this, "compiledTargetScript");
    __publicField(this, "scriptTree");
    __publicField(this, "tapLeafScript", null);
    /**
     * Contract secret for the interaction
     * @protected
     */
    __publicField(this, "contractSecret");
    if (!parameters.contract) {
      throw new Error("parameters.contract is required for interaction transaction.");
    }
    this.contractSecret = fromHex$1(parameters.contract.startsWith("0x") ? parameters.contract.slice(2) : parameters.contract);
    if (this.contractSecret.length !== 32) {
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    }
    if (parameters.compiledTargetScript) {
      if (parameters.compiledTargetScript instanceof Uint8Array) {
        this.compiledTargetScript = parameters.compiledTargetScript;
      } else if (typeof parameters.compiledTargetScript === "string") {
        this.compiledTargetScript = fromHex$1(parameters.compiledTargetScript);
      } else {
        throw new Error("Invalid compiled target script format.");
      }
    } else {
      this.compiledTargetScript = this.calldataGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
    }
    this.scriptTree = this.getScriptTree();
    this.internalInit();
  }
  generateFeatures(parameters) {
    const features = [];
    if (parameters.loadedStorage) {
      features.push({
        priority: FeaturePriority.ACCESS_LIST,
        opcode: Features.ACCESS_LIST,
        data: parameters.loadedStorage
      });
    }
    const submission = parameters.challenge.getSubmission();
    if (submission) {
      features.push({
        priority: FeaturePriority.EPOCH_SUBMISSION,
        opcode: Features.EPOCH_SUBMISSION,
        data: submission
      });
    }
    if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
      throw new Error("To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.");
    }
    if (parameters.linkMLDSAPublicKeyToAddress) {
      this.generateMLDSALinkRequest(parameters, features);
    }
    return features;
  }
};
var _InteractionTransactionP2WDA = class _InteractionTransactionP2WDA extends TransactionBuilder {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", TransactionType.INTERACTION);
    __publicField(this, "epochChallenge");
    /**
     * Disable auto refund
     * @protected
     */
    __publicField(this, "disableAutoRefund");
    __publicField(this, "contractSecret");
    __publicField(this, "calldata");
    __publicField(this, "challenge");
    __publicField(this, "randomBytes");
    __publicField(this, "p2wdaGenerator");
    __publicField(this, "scriptSigner");
    __publicField(this, "p2wdaInputIndices", /* @__PURE__ */ new Set());
    /**
     * The compiled operation data from CalldataGenerator
     * This is exactly what would go in a taproot script, but we put it in witness instead
     */
    __publicField(this, "compiledOperationData", null);
    if (!parameters.to) {
      throw new Error("Contract address (to) is required");
    }
    if (!parameters.contract) {
      throw new Error("Contract secret is required");
    }
    if (!parameters.calldata) {
      throw new Error("Calldata is required");
    }
    if (!parameters.challenge) {
      throw new Error("Challenge solution is required");
    }
    this.disableAutoRefund = parameters.disableAutoRefund || false;
    this.contractSecret = fromHex$1(parameters.contract.startsWith("0x") ? parameters.contract.slice(2) : parameters.contract);
    this.calldata = Compressor.compress(parameters.calldata);
    this.challenge = parameters.challenge;
    this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
    this.scriptSigner = this.generateKeyPairFromSeed();
    this.p2wdaGenerator = new P2WDAGenerator(this.signer.publicKey, this.scriptSignerXOnlyPubKey(), this.network);
    if (this.contractSecret.length !== 32) {
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    }
    this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
    this.validateP2WDAInputs();
    if (parameters.compiledTargetScript) {
      if (parameters.compiledTargetScript instanceof Uint8Array) {
        this.compiledOperationData = parameters.compiledTargetScript;
      } else if (typeof parameters.compiledTargetScript === "string") {
        this.compiledOperationData = fromHex$1(parameters.compiledTargetScript);
      } else {
        throw new Error("Invalid compiled target script format.");
      }
    } else {
      this.compiledOperationData = this.p2wdaGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
    }
    this.validateOperationDataSize();
    this.internalInit();
  }
  /**
   * Get random bytes (for compatibility if needed elsewhere)
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the challenge (for compatibility if needed elsewhere)
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get contract secret (for compatibility if needed elsewhere)
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Build the transaction
   */
  async buildTransaction() {
    if (!this.regenerated) {
      this.addInputsFromUTXO();
    }
    await this.createMineableRewardOutputs();
  }
  async createMineableRewardOutputs() {
    if (!this.to)
      throw new Error("To address is required");
    const amountSpent = this.getTransactionOPNetFee();
    this.addFeeToOutput(amountSpent, this.to, this.epochChallenge, false);
    const amount = this.addOptionalOutputsAndGetAmount();
    if (!this.disableAutoRefund) {
      await this.addRefundOutput(amountSpent + amount);
    }
  }
  /**
   * Sign inputs with P2WDA-specific handling
   */
  async signInputs(transaction) {
    for (let i2 = 0; i2 < transaction.data.inputs.length; i2++) {
      await this.signInput(transaction, transaction.data.inputs[i2], i2, this.signer);
    }
    for (let i2 = 0; i2 < transaction.data.inputs.length; i2++) {
      if (this.p2wdaInputIndices.has(i2)) {
        if (i2 === 0) {
          transaction.finalizeInput(i2, this.finalizePrimaryP2WDA.bind(this));
        } else {
          transaction.finalizeInput(i2, this.finalizeSecondaryP2WDA.bind(this));
        }
      } else {
        transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
      }
    }
    this.finalized = true;
  }
  /**
   * Generate features array (same as InteractionTransaction)
   */
  generateFeatures(parameters) {
    const features = [];
    if (parameters.loadedStorage) {
      features.push({
        priority: FeaturePriority.ACCESS_LIST,
        opcode: Features.ACCESS_LIST,
        data: parameters.loadedStorage
      });
    }
    const submission = parameters.challenge.getSubmission();
    if (submission) {
      features.push({
        priority: FeaturePriority.EPOCH_SUBMISSION,
        opcode: Features.EPOCH_SUBMISSION,
        data: submission
      });
    }
    return features;
  }
  /**
   * Generate keypair from seed (same as SharedInteractionTransaction)
   */
  generateKeyPairFromSeed() {
    return EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
  }
  /**
   * Get script signer x-only pubkey (same as SharedInteractionTransaction)
   */
  scriptSignerXOnlyPubKey() {
    return toXOnly(this.scriptSigner.publicKey);
  }
  /**
   * Validate that input 0 is P2WDA
   */
  validateP2WDAInputs() {
    if (this.utxos.length === 0 || !P2WDADetector.isP2WDAUTXO(this.utxos[0])) {
      throw new Error("Input 0 must be a P2WDA UTXO");
    }
    for (let i2 = 0; i2 < this.utxos.length; i2++) {
      if (P2WDADetector.isP2WDAUTXO(this.utxos[i2])) {
        this.p2wdaInputIndices.add(i2);
      }
    }
    for (let i2 = 0; i2 < this.optionalInputs.length; i2++) {
      const actualIndex = this.utxos.length + i2;
      if (P2WDADetector.isP2WDAUTXO(this.optionalInputs[i2])) {
        this.p2wdaInputIndices.add(actualIndex);
      }
    }
  }
  /**
   * Validate the compiled operation data will fit in witness fields
   */
  validateOperationDataSize() {
    if (!this.compiledOperationData) {
      throw new Error("Operation data not compiled");
    }
    const estimatedSize = this.compiledOperationData.length;
    if (!P2WDAGenerator.validateWitnessSize(estimatedSize)) {
      const signatureSize = 64;
      const totalSize = estimatedSize + signatureSize;
      const compressedEstimate = Math.ceil(totalSize * 0.7);
      const requiredFields = Math.ceil(compressedEstimate / _InteractionTransactionP2WDA.MAX_BYTES_PER_WITNESS);
      throw new Error(`Please dont use P2WDA for this operation. Data too large. Raw size: ${estimatedSize} bytes, estimated compressed: ${compressedEstimate} bytes, needs ${requiredFields} witness fields, max is ${_InteractionTransactionP2WDA.MAX_WITNESS_FIELDS}`);
    }
  }
  /**
   * Finalize primary P2WDA input with the operation data
   * This is where we create the signature and compress everything
   */
  finalizePrimaryP2WDA(inputIndex, input) {
    if (!input.partialSig || input.partialSig.length === 0) {
      throw new Error(`No signature for P2WDA input #${inputIndex}`);
    }
    if (!input.witnessScript) {
      throw new Error(`No witness script for P2WDA input #${inputIndex}`);
    }
    if (!this.compiledOperationData) {
      throw new Error("Operation data not compiled");
    }
    const txSignature = input.partialSig[0].signature;
    const messageToSign = concat$1([txSignature, this.compiledOperationData]);
    const signedMessage = MessageSigner.signMessage(this.signer, messageToSign);
    const schnorrSignature = signedMessage.signature;
    const fullData = concat$1([schnorrSignature, this.compiledOperationData]);
    const compressedData = Compressor.compress(fullData);
    const chunks = this.splitIntoWitnessChunks(compressedData);
    if (chunks.length > _InteractionTransactionP2WDA.MAX_WITNESS_FIELDS) {
      throw new Error(`Compressed data needs ${chunks.length} witness fields, max is ${_InteractionTransactionP2WDA.MAX_WITNESS_FIELDS}`);
    }
    const witnessStack = [txSignature];
    for (let i2 = 0; i2 < _InteractionTransactionP2WDA.MAX_WITNESS_FIELDS; i2++) {
      witnessStack.push(i2 < chunks.length ? chunks[i2] : new Uint8Array(0));
    }
    witnessStack.push(input.witnessScript);
    return {
      finalScriptSig: void 0,
      finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witnessStack)
    };
  }
  /**
   * Split data into 80-byte chunks
   */
  splitIntoWitnessChunks(data) {
    const chunks = [];
    let offset = 0;
    while (offset < data.length) {
      const size = Math.min(_InteractionTransactionP2WDA.MAX_BYTES_PER_WITNESS, data.length - offset);
      chunks.push(data.slice(offset, offset + size));
      offset += size;
    }
    return chunks;
  }
};
__publicField(_InteractionTransactionP2WDA, "MAX_WITNESS_FIELDS", 10);
__publicField(_InteractionTransactionP2WDA, "MAX_BYTES_PER_WITNESS", 80);
var InteractionTransactionP2WDA = _InteractionTransactionP2WDA;
var CancelTransaction = class extends TransactionBuilder {
  constructor(parameters) {
    super({
      ...parameters,
      gasSatFee: 1n,
      isCancellation: true,
      priorityFee: 1n,
      calldata: new Uint8Array(0)
    });
    __publicField(this, "type", TransactionType.CANCEL);
    /**
     * The tap leaf script for spending
     */
    __publicField(this, "tapLeafScript", null);
    __publicField(this, "compiledTargetScript");
    __publicField(this, "scriptTree");
    __publicField(this, "contractSecret");
    __publicField(this, "leftOverFundsScriptRedeem", null);
    /**
     * Custom finalizer for the tap script spend
     */
    __publicField(this, "customFinalizer", (_inputIndex, input) => {
      if (!this.tapLeafScript) {
        throw new Error("Tap leaf script is required");
      }
      if (!input.tapScriptSig || input.tapScriptSig.length === 0) {
        throw new Error("Tap script signature is required");
      }
      const scriptSolution = [input.tapScriptSig[0].signature];
      const witness = scriptSolution.concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness)
      };
    });
    this.contractSecret = new Uint8Array(0);
    if (parameters.compiledTargetScript instanceof Uint8Array) {
      this.compiledTargetScript = parameters.compiledTargetScript;
    } else {
      this.compiledTargetScript = fromHex$1(parameters.compiledTargetScript);
    }
    this.scriptTree = this.getMinimalScriptTree();
    this.internalInit();
  }
  async buildTransaction() {
    if (!this.from) {
      throw new Error("From address is required");
    }
    if (!this.leftOverFundsScriptRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!this.leftOverFundsScriptRedeem.redeemVersion) {
      throw new Error("Left over funds script redeem version is required");
    }
    if (!this.leftOverFundsScriptRedeem.output) {
      throw new Error("Left over funds script redeem output is required");
    }
    this.tapLeafScript = {
      leafVersion: this.leftOverFundsScriptRedeem.redeemVersion,
      script: this.leftOverFundsScriptRedeem.output,
      controlBlock: this.getWitness()
    };
    this.addInputsFromUTXO();
    await this.addRefundOutput(0n, true);
    if (!this.feeOutput) {
      throw new Error("Must add extra UTXOs to cancel this transaction");
    }
  }
  /*protected override async buildTransaction(): Promise<void> {
          if (!this.from) {
              throw new Error('From address is required');
          }
  
          // For key-path spend, we don't need the tap leaf script
          this.tapLeafScript = null;
  
          this.addInputsFromUTXO();
          await this.addRefundOutput(0n);
      }*/
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  /*protected async signInputs(transaction: Psbt): Promise<void> {
          for (let i = 0; i < transaction.data.inputs.length; i++) {
              if (i === 0) {
                  transaction.signInput(0, this.getSignerKey());
  
                  transaction.finalizeInput(0, this.customFinalizer.bind(this));
              } else {
                  await super.signInputs(transaction);
              }
          }
      }*/
  /**
   * Generate the script address (for verification purposes)
   */
  generateScriptAddress() {
    if (this.useP2MR) {
      return {
        network: this.network,
        scriptTree: this.scriptTree,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: PaymentType.P2TR
    };
  }
  /**
   * Generate the tap data for spending
   */
  generateTapData() {
    const selectedRedeem = this.leftOverFundsScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!this.scriptTree) {
      throw new Error("Script tree is required");
    }
    if (this.useP2MR) {
      return {
        network: this.network,
        scriptTree: this.scriptTree,
        redeem: selectedRedeem,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: selectedRedeem,
      name: PaymentType.P2TR
    };
  }
  async signInputs(transaction) {
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(transaction);
    } else {
      await this.signInputsNonWalletBased(transaction);
    }
  }
  async signInputsWalletBased(transaction) {
    const signer = this.signer;
    await signer.multiSignPsbt([transaction]);
    for (let i2 = 0; i2 < transaction.data.inputs.length; i2++) {
      if (i2 === 0) {
        transaction.finalizeInput(i2, this.customFinalizer.bind(this));
      } else {
        try {
          transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
        } catch (e) {
          transaction.finalizeInput(i2);
        }
      }
    }
  }
  async signInputsNonWalletBased(transaction) {
    await this.signInput(transaction, transaction.data.inputs[0], 0, this.getSignerKey());
    transaction.finalizeInput(0, this.customFinalizer.bind(this));
    let parallelSignedIndices = /* @__PURE__ */ new Set();
    if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
      try {
        const result = await this.signKeyPathInputsParallel(transaction, /* @__PURE__ */ new Set([0]));
        if (result.success) {
          parallelSignedIndices = new Set(result.signatures.keys());
        }
      } catch (e) {
        this.error(`Parallel signing failed, falling back to sequential: ${e.message}`);
      }
    }
    for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
      if (!parallelSignedIndices.has(i2)) {
        await this.signInput(transaction, transaction.data.inputs[i2], i2, this.signer);
      }
    }
    for (let i2 = 1; i2 < transaction.data.inputs.length; i2++) {
      try {
        transaction.finalizeInput(i2, this.customFinalizerP2SH.bind(this));
      } catch {
        transaction.finalizeInput(i2);
      }
    }
  }
  /**
   * Generate the minimal script tree needed for recovery
   * This only includes the leftover funds script
   */
  getMinimalScriptTree() {
    this.generateLeftoverFundsRedeem();
    if (!this.leftOverFundsScriptRedeem || !this.leftOverFundsScriptRedeem.output) {
      throw new Error("Failed to generate leftover funds redeem script");
    }
    return [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.leftOverFundsScriptRedeem.output,
        version: 192
      }
    ];
  }
  /**
   * Generate the leftover funds redeem script
   */
  generateLeftoverFundsRedeem() {
    this.leftOverFundsScriptRedeem = {
      name: PaymentType.P2TR,
      output: this.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
};
var ConsolidatedInteractionTransaction = class extends TransactionBuilder {
  constructor(parameters) {
    super(parameters);
    __publicField(this, "type", TransactionType.INTERACTION);
    /** Random bytes for interaction (same as InteractionTransaction) */
    __publicField(this, "randomBytes");
    /** The contract address (same as InteractionTransaction.to) */
    __publicField(this, "contractAddress");
    /** The contract secret - 32 bytes (same as InteractionTransaction) */
    __publicField(this, "contractSecret");
    /** The compressed calldata (same as InteractionTransaction) */
    __publicField(this, "calldata");
    /** Challenge solution for epoch (same as InteractionTransaction) */
    __publicField(this, "challenge");
    /** Epoch challenge P2WSH address (same as InteractionTransaction) */
    __publicField(this, "epochChallenge");
    /** Script signer for interaction (same as InteractionTransaction) */
    __publicField(this, "scriptSigner");
    /** Calldata generator - produces same output as InteractionTransaction */
    __publicField(this, "calldataGenerator");
    /** Hash commitment generator for CHCT */
    __publicField(this, "hashCommitmentGenerator");
    /** The compiled operation data - SAME as InteractionTransaction's compiledTargetScript */
    __publicField(this, "compiledTargetScript");
    /** Generated hash-committed P2WSH outputs */
    __publicField(this, "commitmentOutputs");
    /** Disable auto refund (same as InteractionTransaction) */
    __publicField(this, "disableAutoRefund");
    /** Maximum chunk size (default: 80 bytes per P2WSH stack item limit) */
    __publicField(this, "maxChunkSize");
    /** Cached value per output (calculated once, used by setup and reveal) */
    __publicField(this, "cachedValuePerOutput", null);
    if (!parameters.to) {
      throw new Error("Contract address (to) is required");
    }
    if (!parameters.contract) {
      throw new Error("Contract secret (contract) is required");
    }
    if (!parameters.calldata) {
      throw new Error("Calldata is required");
    }
    if (!parameters.challenge) {
      throw new Error("Challenge solution is required");
    }
    this.contractAddress = parameters.to;
    this.contractSecret = fromHex$1(parameters.contract.startsWith("0x") ? parameters.contract.slice(2) : parameters.contract);
    this.disableAutoRefund = parameters.disableAutoRefund || false;
    this.maxChunkSize = parameters.maxChunkSize ?? HashCommitmentGenerator.MAX_CHUNK_SIZE;
    if (this.contractSecret.length !== 32) {
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    }
    this.calldata = Compressor.compress(parameters.calldata);
    this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
    this.scriptSigner = EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
    this.challenge = parameters.challenge;
    this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
    this.calldataGenerator = new CalldataGenerator(this.signer.publicKey, toXOnly(this.scriptSigner.publicKey), this.network);
    if (parameters.compiledTargetScript) {
      if (parameters.compiledTargetScript instanceof Uint8Array) {
        this.compiledTargetScript = parameters.compiledTargetScript;
      } else if (typeof parameters.compiledTargetScript === "string") {
        this.compiledTargetScript = fromHex$1(parameters.compiledTargetScript);
      } else {
        throw new Error("Invalid compiled target script format.");
      }
    } else {
      this.compiledTargetScript = this.calldataGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
    }
    this.hashCommitmentGenerator = new HashCommitmentGenerator(this.signer.publicKey, this.network);
    this.commitmentOutputs = this.hashCommitmentGenerator.prepareChunks(this.compiledTargetScript, this.maxChunkSize);
    this.validateOutputCount();
    const totalChunks = this.commitmentOutputs.reduce((sum, output) => sum + output.dataChunks.length, 0);
    this.log(`ConsolidatedInteractionTransaction: ${this.commitmentOutputs.length} outputs, ${totalChunks} chunks from ${this.compiledTargetScript.length} bytes compiled data`);
    this.internalInit();
  }
  /**
   * Get the compiled target script (same as InteractionTransaction).
   */
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the contract secret (same as InteractionTransaction).
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Get the random bytes (same as InteractionTransaction).
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the challenge solution (same as InteractionTransaction).
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get the commitment outputs for the setup transaction.
   */
  getCommitmentOutputs() {
    return this.commitmentOutputs;
  }
  /**
   * Get the number of P2WSH outputs.
   */
  getOutputCount() {
    return this.commitmentOutputs.length;
  }
  /**
   * Get the total number of 80-byte chunks across all outputs.
   */
  getTotalChunkCount() {
    return this.commitmentOutputs.reduce((sum, output) => sum + output.dataChunks.length, 0);
  }
  /**
   * Build both setup and reveal transactions.
   *
   * @returns Complete result with both transactions
   */
  async build() {
    const setupTx = await this.signTransaction();
    const setupTxId = setupTx.getId();
    const setup = {
      txHex: setupTx.toHex(),
      txId: setupTxId,
      outputs: this.commitmentOutputs,
      feesPaid: this.transactionFee,
      chunkCount: this.getTotalChunkCount(),
      totalDataSize: this.compiledTargetScript.length
    };
    this.log(`Setup transaction: ${setup.txId}`);
    const reveal = this.buildRevealTransaction(setupTxId);
    return {
      setup,
      reveal,
      totalFees: setup.feesPaid + reveal.feesPaid
    };
  }
  /**
   * Build the reveal transaction.
   * Spends the P2WSH commitment outputs, revealing the compiled data in witnesses.
   *
   * Output structure matches InteractionTransaction:
   * - Output to epochChallenge.address (miner reward)
   * - Change output (if any)
   *
   * @param setupTxId The transaction ID of the setup transaction
   */
  buildRevealTransaction(setupTxId) {
    const revealPsbt = new Psbt2({ network: this.network });
    const valuePerOutput = this.calculateValuePerOutput();
    for (let i2 = 0; i2 < this.commitmentOutputs.length; i2++) {
      const commitment = this.commitmentOutputs[i2];
      revealPsbt.addInput({
        hash: setupTxId,
        index: i2,
        witnessUtxo: {
          script: commitment.scriptPubKey,
          value: toSatoshi(valuePerOutput)
        },
        witnessScript: commitment.witnessScript
      });
    }
    const inputValue = BigInt(this.commitmentOutputs.length) * valuePerOutput;
    const opnetFee = this.getTransactionOPNetFee();
    const feeAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
    revealPsbt.addOutput({
      address: this.epochChallenge.address,
      value: toSatoshi(feeAmount)
    });
    const estimatedVBytes = this.estimateRevealVBytes();
    const revealFee = BigInt(Math.ceil(estimatedVBytes * this.feeRate));
    const changeValue = inputValue - feeAmount - revealFee;
    if (changeValue > TransactionBuilder.MINIMUM_DUST) {
      const refundAddress = this.getRefundAddress();
      revealPsbt.addOutput({
        address: refundAddress,
        value: toSatoshi(changeValue)
      });
    }
    for (let i2 = 0; i2 < this.commitmentOutputs.length; i2++) {
      revealPsbt.signInput(i2, this.signer);
    }
    for (let i2 = 0; i2 < this.commitmentOutputs.length; i2++) {
      const commitment = this.commitmentOutputs[i2];
      revealPsbt.finalizeInput(i2, (_inputIndex, input) => {
        return this.finalizeCommitmentInput(input, commitment);
      });
    }
    const revealTx = revealPsbt.extractTransaction();
    const result = {
      txHex: revealTx.toHex(),
      txId: revealTx.getId(),
      dataSize: this.compiledTargetScript.length,
      feesPaid: revealFee,
      inputCount: this.commitmentOutputs.length
    };
    this.log(`Reveal transaction: ${result.txId}`);
    return result;
  }
  /**
   * Get the value per commitment output (for external access).
   */
  getValuePerOutput() {
    return this.calculateValuePerOutput();
  }
  /**
   * Build the setup transaction.
   * Creates P2WSH outputs with hash commitments to the compiled data chunks.
   * This is called by signTransaction() in the base class.
   */
  async buildTransaction() {
    this.addInputsFromUTXO();
    const valuePerOutput = this.calculateValuePerOutput();
    for (const commitment of this.commitmentOutputs) {
      this.addOutput({
        value: toSatoshi(valuePerOutput),
        address: commitment.address
      });
    }
    const totalCommitmentValue = BigInt(this.commitmentOutputs.length) * valuePerOutput;
    const optionalAmount = this.addOptionalOutputsAndGetAmount();
    await this.addRefundOutput(totalCommitmentValue + optionalAmount);
  }
  /**
   * Finalize a commitment input.
   *
   * Witness stack: [signature, data_1, data_2, ..., data_N, witnessScript]
   *
   * The witness script verifies each data chunk against its committed hash.
   * If any data is wrong or missing, the transaction is INVALID at consensus level.
   */
  finalizeCommitmentInput(input, commitment) {
    if (!input.partialSig || input.partialSig.length === 0) {
      throw new Error("No signature for commitment input");
    }
    if (!input.witnessScript) {
      throw new Error("No witness script for commitment input");
    }
    const witnessStack = [
      input.partialSig[0].signature,
      // Signature for OP_CHECKSIG
      ...commitment.dataChunks,
      // All data chunks for OP_HASH160 verification
      input.witnessScript
      // The witness script
    ];
    return {
      finalScriptSig: void 0,
      finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witnessStack)
    };
  }
  /**
   * Estimate reveal transaction vBytes.
   */
  estimateRevealVBytes() {
    let witnessWeight = 0;
    for (const commitment of this.commitmentOutputs) {
      const numChunks = commitment.dataChunks.length;
      const chunkDataWeight = numChunks * 80;
      const scriptWeight = numChunks * 23 + 35;
      const sigWeight = 72;
      const overheadWeight = 20;
      witnessWeight += 164 + chunkDataWeight + scriptWeight + sigWeight + overheadWeight;
    }
    const weight = 40 + witnessWeight + 200;
    return Math.ceil(weight / 4);
  }
  /**
   * Calculate the required value per commitment output.
   * This must cover: dust minimum + share of reveal fee + share of OPNet fee
   */
  calculateValuePerOutput() {
    if (this.cachedValuePerOutput !== null) {
      return this.cachedValuePerOutput;
    }
    const numOutputs = this.commitmentOutputs.length;
    const opnetFee = this.getTransactionOPNetFee();
    const feeAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
    const estimatedVBytes = this.estimateRevealVBytes();
    const revealFee = BigInt(Math.ceil(estimatedVBytes * this.feeRate));
    const totalNeeded = feeAmount + revealFee + TransactionBuilder.MINIMUM_DUST;
    const valuePerOutput = BigInt(Math.ceil(Number(totalNeeded) / numOutputs));
    const minValue = HashCommitmentGenerator.MIN_OUTPUT_VALUE;
    this.cachedValuePerOutput = valuePerOutput > minValue ? valuePerOutput : minValue;
    return this.cachedValuePerOutput;
  }
  /**
   * Get refund address.
   */
  getRefundAddress() {
    if (this.from) {
      return this.from;
    }
    return AddressGenerator.generatePKSH(this.signer.publicKey, this.network);
  }
  /**
   * Generate features (same as InteractionTransaction).
   */
  generateFeatures(parameters) {
    const features = [];
    if (parameters.loadedStorage) {
      features.push({
        priority: FeaturePriority.ACCESS_LIST,
        opcode: Features.ACCESS_LIST,
        data: parameters.loadedStorage
      });
    }
    const submission = parameters.challenge.getSubmission();
    if (submission) {
      features.push({
        priority: FeaturePriority.EPOCH_SUBMISSION,
        opcode: Features.EPOCH_SUBMISSION,
        data: submission
      });
    }
    if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
      throw new Error("To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.");
    }
    if (parameters.linkMLDSAPublicKeyToAddress) {
      this.generateMLDSALinkRequest(parameters, features);
    }
    return features;
  }
  /**
   * Validate output count is within standard tx limits.
   */
  validateOutputCount() {
    const maxInputs = HashCommitmentGenerator.calculateMaxInputsPerTx();
    if (this.commitmentOutputs.length > maxInputs) {
      const maxData = HashCommitmentGenerator.calculateMaxDataPerTx();
      throw new Error(`Data too large: ${this.commitmentOutputs.length} P2WSH outputs needed, max ${maxInputs} per standard transaction (~${Math.floor(maxData / 1024)}KB). Compiled data: ${this.compiledTargetScript.length} bytes.`);
    }
  }
};
var TransactionFactory = class {
  constructor() {
    __publicField(this, "debug", false);
    __publicField(this, "DUMMY_PUBKEY", new Uint8Array(32).fill(1));
    __publicField(this, "P2TR_SCRIPT", Uint8Array.from([81, 32, ...this.DUMMY_PUBKEY]));
    __publicField(this, "INITIAL_FUNDING_ESTIMATE", 2000n);
    __publicField(this, "MAX_ITERATIONS", 10);
  }
  /**
   * @description Creates a cancellable transaction.
   * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} params - The cancel transaction parameters
   * @returns {Promise<CancelledTransaction>} - The cancelled transaction result
   */
  async createCancellableTransaction(params) {
    if (!params.to) {
      throw new Error('Field "to" not provided.');
    }
    if (!params.from) {
      throw new Error('Field "from" not provided.');
    }
    if (!params.utxos[0]) {
      throw new Error("Missing at least one UTXO.");
    }
    const opWalletCancel = await this.detectCancelOPWallet(params);
    if (opWalletCancel) {
      return opWalletCancel;
    }
    if (!("signer" in params)) {
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    }
    const cancel = new CancelTransaction(params);
    const signed = await cancel.signTransaction();
    const rawTx = signed.toHex();
    return {
      transaction: rawTx,
      nextUTXOs: this.getUTXOAsTransaction(signed, params.from, 0),
      inputUtxos: params.utxos
    };
  }
  /**
   * @description Generate a transaction with a custom script.
   * @param {ICustomTransactionParameters | ICustomTransactionWithoutSigner} interactionParameters - The custom transaction parameters
   * @returns {Promise<[string, string, UTXO[], UTXO[]]>} - The signed transaction tuple [fundingTx, customTx, nextUTXOs, inputUtxos]
   */
  async createCustomScriptTransaction(interactionParameters) {
    if (!interactionParameters.to) {
      throw new Error('Field "to" not provided.');
    }
    if (!interactionParameters.from) {
      throw new Error('Field "from" not provided.');
    }
    if (!interactionParameters.utxos[0]) {
      throw new Error("Missing at least one UTXO.");
    }
    if (!("signer" in interactionParameters)) {
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    }
    const inputs2 = this.parseOptionalInputs(interactionParameters.optionalInputs);
    const { finalTransaction, estimatedAmount } = await this.iterateFundingAmount({ ...interactionParameters, optionalInputs: inputs2 }, CustomScriptTransaction, async (tx) => {
      const fee = await tx.estimateTransactionFees();
      const priorityFee = this.getPriorityFee(interactionParameters);
      const optionalValue = tx.getOptionalOutputValue();
      return fee + priorityFee + optionalValue;
    }, "CustomScript");
    const parameters = await finalTransaction.getFundingTransactionParameters();
    parameters.utxos = interactionParameters.utxos;
    parameters.amount = estimatedAmount;
    const feeEstimationFunding = await this.createFundTransaction({
      ...parameters,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!feeEstimationFunding) {
      throw new Error("Could not sign funding transaction.");
    }
    parameters.estimatedFees = feeEstimationFunding.estimatedFees;
    const signedTransaction = await this.createFundTransaction({
      ...parameters,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!signedTransaction) {
      throw new Error("Could not sign funding transaction.");
    }
    const newParams = {
      ...interactionParameters,
      utxos: this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.to, 0),
      randomBytes: finalTransaction.getRndBytes(),
      nonWitnessUtxo: signedTransaction.tx.toBuffer(),
      estimatedFees: finalTransaction.estimatedFees,
      compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
      optionalInputs: inputs2
    };
    const customTransaction = new CustomScriptTransaction(newParams);
    const outTx = await customTransaction.signTransaction();
    return [
      signedTransaction.tx.toHex(),
      outTx.toHex(),
      this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.from, 1),
      interactionParameters.utxos
    ];
  }
  /**
   * @description Generates the required transactions.
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse>} - The signed transaction
   */
  async signInteraction(interactionParameters) {
    if (!interactionParameters.to) {
      throw new Error('Field "to" not provided.');
    }
    if (!interactionParameters.from) {
      throw new Error('Field "from" not provided.');
    }
    if (!interactionParameters.utxos[0]) {
      throw new Error("Missing at least one UTXO.");
    }
    const opWalletInteraction = await this.detectInteractionOPWallet(interactionParameters);
    if (opWalletInteraction) {
      return opWalletInteraction;
    }
    if (!("signer" in interactionParameters)) {
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    }
    const useP2WDA = this.hasP2WDAInputs(interactionParameters.utxos);
    if (useP2WDA) {
      return this.signP2WDAInteraction(interactionParameters);
    }
    const inputs2 = this.parseOptionalInputs(interactionParameters.optionalInputs);
    const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...interactionParameters, optionalInputs: inputs2 }, InteractionTransaction, async (tx) => {
      const fee = await tx.estimateTransactionFees();
      const outputsValue = tx.getTotalOutputValue();
      const total = fee + outputsValue;
      if (interactionParameters.subtractExtraUTXOFromAmountRequired && interactionParameters.optionalInputs && interactionParameters.optionalInputs.length > 0) {
        const optionalInputValue = interactionParameters.optionalInputs.reduce((sum, input) => sum + input.value, 0n);
        return total > optionalInputValue ? total - optionalInputValue : 0n;
      }
      return total;
    }, "Interaction");
    if (!challenge) {
      throw new Error("Failed to get challenge from interaction transaction");
    }
    const parameters = await finalTransaction.getFundingTransactionParameters();
    parameters.utxos = interactionParameters.utxos;
    parameters.amount = estimatedAmount;
    const feeEstimationFunding = await this.createFundTransaction({
      ...parameters,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!feeEstimationFunding) {
      throw new Error("Could not sign funding transaction.");
    }
    parameters.estimatedFees = feeEstimationFunding.estimatedFees;
    const signedTransaction = await this.createFundTransaction({
      ...parameters,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!signedTransaction) {
      throw new Error("Could not sign funding transaction.");
    }
    const fundingUTXO = this.getUTXOAsTransaction(signedTransaction.tx, finalTransaction.getScriptAddress(), 0);
    const newParams = {
      ...interactionParameters,
      utxos: fundingUTXO,
      randomBytes: finalTransaction.getRndBytes(),
      challenge,
      compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
      nonWitnessUtxo: signedTransaction.tx.toBuffer(),
      estimatedFees: finalTransaction.estimatedFees,
      optionalInputs: inputs2
    };
    const interactionTx = new InteractionTransaction(newParams);
    const outTx = await interactionTx.signTransaction();
    return {
      interactionAddress: finalTransaction.getScriptAddress(),
      fundingTransaction: signedTransaction.tx.toHex(),
      interactionTransaction: outTx.toHex(),
      estimatedFees: interactionTx.transactionFee,
      nextUTXOs: this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.from, 1),
      challenge: challenge.toRaw(),
      fundingUTXOs: fundingUTXO,
      fundingInputUtxos: interactionParameters.utxos,
      compiledTargetScript: toHex$1(interactionTx.exportCompiledTargetScript())
    };
  }
  /**
   * @description Generates a consolidated interaction transaction (CHCT system).
   *
   * Drop-in replacement for signInteraction that bypasses BIP110/Bitcoin Knots censorship.
   * Uses P2WSH with HASH160 commitments instead of Tapscript (which uses OP_IF and gets censored).
   *
   * Returns two transactions:
   * - Setup: Creates P2WSH outputs with hash commitments to data chunks
   * - Reveal: Spends those outputs, revealing data in witnesses
   *
   * Data integrity is consensus-enforced - if data is stripped/modified,
   * HASH160(data) != committed_hash and the transaction is INVALID.
   *
   * @param {IConsolidatedInteractionParameters} interactionParameters - Same parameters as signInteraction
   * @returns {Promise<ConsolidatedInteractionResponse>} - Both setup and reveal transactions
   */
  async signConsolidatedInteraction(interactionParameters) {
    if (!interactionParameters.to) {
      throw new Error('Field "to" not provided.');
    }
    if (!interactionParameters.from) {
      throw new Error('Field "from" not provided.');
    }
    if (!interactionParameters.utxos[0]) {
      throw new Error("Missing at least one UTXO.");
    }
    if (!("signer" in interactionParameters)) {
      throw new Error('Field "signer" not provided.');
    }
    if (!interactionParameters.challenge) {
      throw new Error('Field "challenge" not provided.');
    }
    const inputs2 = this.parseOptionalInputs(interactionParameters.optionalInputs);
    const consolidatedTx = new ConsolidatedInteractionTransaction({
      ...interactionParameters,
      optionalInputs: inputs2
    });
    const result = await consolidatedTx.build();
    return {
      setupTransaction: result.setup.txHex,
      revealTransaction: result.reveal.txHex,
      setupTxId: result.setup.txId,
      revealTxId: result.reveal.txId,
      totalFees: result.totalFees,
      chunkCount: result.setup.chunkCount,
      dataSize: result.setup.totalDataSize,
      challenge: consolidatedTx.getChallenge().toRaw(),
      inputUtxos: interactionParameters.utxos,
      compiledTargetScript: toHex$1(consolidatedTx.exportCompiledTargetScript())
    };
  }
  /**
   * @description Generates the required transactions.
   * @param {IDeploymentParameters} deploymentParameters - The deployment parameters
   * @returns {Promise<DeploymentResult>} - The signed transaction
   */
  async signDeployment(deploymentParameters) {
    const opWalletDeployment = await this.detectDeploymentOPWallet(deploymentParameters);
    if (opWalletDeployment) {
      return opWalletDeployment;
    }
    if (!("signer" in deploymentParameters)) {
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    }
    const inputs2 = this.parseOptionalInputs(deploymentParameters.optionalInputs);
    const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...deploymentParameters, optionalInputs: inputs2 }, DeploymentTransaction, async (tx) => {
      const fee = await tx.estimateTransactionFees();
      const priorityFee = this.getPriorityFee(deploymentParameters);
      const optionalValue = tx.getOptionalOutputValue();
      return fee + priorityFee + optionalValue;
    }, "Deployment");
    if (!challenge) {
      throw new Error("Failed to get challenge from deployment transaction");
    }
    const parameters = await finalTransaction.getFundingTransactionParameters();
    parameters.utxos = deploymentParameters.utxos;
    parameters.amount = estimatedAmount;
    const feeEstimationFunding = await this.createFundTransaction({
      ...parameters,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!feeEstimationFunding) {
      throw new Error("Could not sign funding transaction.");
    }
    parameters.estimatedFees = feeEstimationFunding.estimatedFees;
    const fundingTransaction = new FundingTransaction({
      ...parameters,
      optionalInputs: [],
      optionalOutputs: []
    });
    const signedTransaction = await fundingTransaction.signTransaction();
    if (!signedTransaction) {
      throw new Error("Could not sign funding transaction.");
    }
    const out = signedTransaction.outs[0];
    const newUtxo = {
      transactionId: signedTransaction.getId(),
      outputIndex: 0,
      scriptPubKey: {
        hex: toHex$1(out.script),
        address: finalTransaction.getScriptAddress()
      },
      value: BigInt(out.value)
    };
    const newParams = {
      ...deploymentParameters,
      utxos: [newUtxo],
      randomBytes: finalTransaction.getRndBytes(),
      compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
      challenge,
      nonWitnessUtxo: signedTransaction.toBuffer(),
      estimatedFees: finalTransaction.estimatedFees,
      optionalInputs: inputs2
    };
    const deploymentTx = new DeploymentTransaction(newParams);
    const outTx = await deploymentTx.signTransaction();
    const out2 = signedTransaction.outs[1];
    const refundUTXO = {
      transactionId: signedTransaction.getId(),
      outputIndex: 1,
      scriptPubKey: {
        hex: toHex$1(out2.script),
        address: deploymentParameters.from
      },
      value: BigInt(out2.value)
    };
    return {
      transaction: [signedTransaction.toHex(), outTx.toHex()],
      contractAddress: deploymentTx.getContractAddress(),
      contractPubKey: deploymentTx.contractPubKey,
      utxos: [refundUTXO],
      challenge: challenge.toRaw(),
      inputUtxos: deploymentParameters.utxos
    };
  }
  /**
   * @description Creates a funding transaction.
   * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
   * @returns {Promise<BitcoinTransferResponse>} - The signed transaction
   */
  async createBTCTransfer(parameters) {
    if (!parameters.from) {
      throw new Error('Field "from" not provided.');
    }
    const resp = await this.createFundTransaction(parameters);
    return {
      estimatedFees: resp.estimatedFees,
      original: resp.original,
      tx: resp.tx.toHex(),
      nextUTXOs: this.getAllNewUTXOs(resp.original, resp.tx, parameters.from),
      inputUtxos: parameters.utxos
    };
  }
  /**
   * Get all new UTXOs of a generated transaction.
   * @param {TransactionBuilder<TransactionType>} original - The original transaction
   * @param {Transaction} tx - The transaction
   * @param {string} to - The address to filter
   * @returns {UTXO[]} - The new UTXOs belonging to the specified address
   */
  getAllNewUTXOs(original, tx, to) {
    const outputs2 = original.getOutputs();
    const utxos = [];
    for (let i2 = 0; i2 < tx.outs.length; i2++) {
      const output = outputs2[i2];
      if ("address" in output) {
        if (output.address !== to)
          continue;
      } else {
        continue;
      }
      utxos.push(...this.getUTXOAsTransaction(tx, to, i2));
    }
    return utxos;
  }
  /**
   * Parse optional inputs and normalize nonWitnessUtxo format.
   * @param {UTXO[]} optionalInputs - The optional inputs to parse
   * @returns {UTXO[]} - The parsed inputs with normalized nonWitnessUtxo
   */
  parseOptionalInputs(optionalInputs) {
    return (optionalInputs || []).map((input) => {
      let nonWitness = input.nonWitnessUtxo;
      if (nonWitness && !(nonWitness instanceof Uint8Array) && typeof nonWitness === "object") {
        nonWitness = Uint8Array.from(Object.values(nonWitness));
      }
      return {
        ...input,
        nonWitnessUtxo: nonWitness
      };
    });
  }
  /**
   * Detect and use OP_WALLET for cancel transactions if available.
   * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} interactionParameters - The cancel parameters
   * @returns {Promise<CancelledTransaction | null>} - The cancelled transaction or null if OP_WALLET not available
   */
  async detectCancelOPWallet(interactionParameters) {
    if (typeof window === "undefined") {
      return null;
    }
    const _window = window;
    if (!_window || !_window.opnet || !_window.opnet.web3) {
      return null;
    }
    const opnet2 = _window.opnet.web3;
    const interaction = await opnet2.cancelTransaction({
      ...interactionParameters,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!interaction) {
      throw new Error("Could not sign interaction transaction.");
    }
    return {
      ...interaction,
      inputUtxos: interaction.inputUtxos ?? interactionParameters.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for interaction transactions if available.
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse | null>} - The interaction response or null if OP_WALLET not available
   */
  async detectInteractionOPWallet(interactionParameters) {
    if (typeof window === "undefined") {
      return null;
    }
    const _window = window;
    if (!_window || !_window.opnet || !_window.opnet.web3) {
      return null;
    }
    const opnet2 = _window.opnet.web3;
    const interaction = await opnet2.signInteraction({
      ...interactionParameters,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!interaction) {
      throw new Error("Could not sign interaction transaction.");
    }
    return {
      ...interaction,
      fundingInputUtxos: interaction.fundingInputUtxos ?? interactionParameters.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for deployment transactions if available.
   * @param {IDeploymentParameters | IDeploymentParametersWithoutSigner} deploymentParameters - The deployment parameters
   * @returns {Promise<DeploymentResult | null>} - The deployment result or null if OP_WALLET not available
   */
  async detectDeploymentOPWallet(deploymentParameters) {
    if (typeof window === "undefined") {
      return null;
    }
    const _window = window;
    if (!_window || !_window.opnet || !_window.opnet.web3) {
      return null;
    }
    const opnet2 = _window.opnet.web3;
    const deployment = await opnet2.deployContract({
      ...deploymentParameters,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!deployment) {
      throw new Error("Could not sign interaction transaction.");
    }
    return {
      ...deployment,
      inputUtxos: deployment.inputUtxos ?? deploymentParameters.utxos
    };
  }
  /**
   * Create and sign a funding transaction.
   * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
   * @returns {Promise<FundingTransactionResponse>} - The funding transaction response
   */
  async createFundTransaction(parameters) {
    if (!parameters.to)
      throw new Error('Field "to" not provided.');
    const fundingTransaction = new FundingTransaction(parameters);
    const signedTransaction = await fundingTransaction.signTransaction();
    if (!signedTransaction) {
      throw new Error("Could not sign funding transaction.");
    }
    return {
      tx: signedTransaction,
      original: fundingTransaction,
      estimatedFees: fundingTransaction.estimatedFees,
      nextUTXOs: this.getUTXOAsTransaction(signedTransaction, parameters.to, 0),
      inputUtxos: parameters.utxos
    };
  }
  /**
   * Check if the UTXOs contain any P2WDA inputs
   *
   * This method examines both main UTXOs and optional inputs to determine
   * if any of them are P2WDA addresses. P2WDA detection is based on the
   * witness script pattern: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   *
   * @param {UTXO[]} utxos - The main UTXOs to check
   * @returns {boolean} - true if any UTXO is P2WDA, false otherwise
   */
  hasP2WDAInputs(utxos) {
    return utxos.some((utxo) => P2WDADetector.isP2WDAUTXO(utxo));
  }
  /**
   * Sign a P2WDA interaction transaction
   *
   * P2WDA interactions are fundamentally different from standard OP_NET interactions.
   * Instead of using a two-transaction model (funding + interaction), P2WDA embeds
   * the operation data directly in the witness field of a single transaction.
   * This achieves significant cost savings through the witness discount.
   *
   * Key differences:
   * - Single transaction instead of two
   * - Operation data in witness field instead of taproot script
   * - 75% cost reduction for data storage
   * - No separate funding transaction needed
   *
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse>} - The signed P2WDA interaction response
   */
  async signP2WDAInteraction(interactionParameters) {
    if (!interactionParameters.from) {
      throw new Error('Field "from" not provided.');
    }
    if (!("signer" in interactionParameters)) {
      throw new Error("P2WDA interactions require a signer. OP_WALLET is not supported for P2WDA.");
    }
    const inputs2 = this.parseOptionalInputs(interactionParameters.optionalInputs);
    const p2wdaTransaction = new InteractionTransactionP2WDA({
      ...interactionParameters,
      optionalInputs: inputs2
    });
    const signedTx = await p2wdaTransaction.signTransaction();
    const txHex = signedTx.toHex();
    return {
      interactionAddress: null,
      fundingTransaction: null,
      interactionTransaction: txHex,
      estimatedFees: p2wdaTransaction.estimatedFees,
      nextUTXOs: this.getUTXOAsTransaction(signedTx, interactionParameters.from, signedTx.outs.length - 1),
      fundingUTXOs: [...interactionParameters.utxos, ...inputs2],
      fundingInputUtxos: interactionParameters.utxos,
      challenge: interactionParameters.challenge.toRaw(),
      compiledTargetScript: null
    };
  }
  /**
   * Get the priority fee from transaction parameters.
   * @param {ITransactionParameters} params - The transaction parameters
   * @returns {bigint} - The priority fee, minimum dust if below threshold
   */
  getPriorityFee(params) {
    const totalFee = params.priorityFee + params.gasSatFee;
    if (totalFee < TransactionBuilder.MINIMUM_DUST) {
      return TransactionBuilder.MINIMUM_DUST;
    }
    return totalFee;
  }
  /**
   * Common iteration logic for finding the correct funding amount.
   *
   * This method iteratively estimates the required funding amount by simulating
   * transactions until the amount converges or max iterations is reached.
   *
   * @param {P extends IInteractionParameters | IDeploymentParameters | ICustomTransactionParameters} params - The transaction parameters
   * @param {new (params: P) => T} TransactionClass - The transaction class constructor
   * @param {(tx: T extends InteractionTransaction | DeploymentTransaction | CustomScriptTransaction) => Promise<bigint>} calculateAmount - Function to calculate required amount
   * @param {string} debugPrefix - Prefix for debug logging
   * @returns {Promise<{finalTransaction: T extends InteractionTransaction | DeploymentTransaction | CustomScriptTransaction, estimatedAmount: bigint, challenge: IChallengeSolution | null}>} - The final transaction and estimated amount
   */
  async iterateFundingAmount(params, TransactionClass, calculateAmount, debugPrefix) {
    const randomBytes3 = "randomBytes" in params ? params.randomBytes ?? BitcoinUtils.rndBytes() : BitcoinUtils.rndBytes();
    const dummyAddress = Address.dead().p2tr(params.network);
    let estimatedFundingAmount = this.INITIAL_FUNDING_ESTIMATE;
    let previousAmount = 0n;
    let iterations = 0;
    let finalPreTransaction = null;
    let challenge = null;
    while (iterations < this.MAX_ITERATIONS && estimatedFundingAmount !== previousAmount) {
      previousAmount = estimatedFundingAmount;
      const dummyTx = new Transaction();
      dummyTx.addOutput(this.P2TR_SCRIPT, toSatoshi(estimatedFundingAmount));
      const simulatedFundedUtxo = {
        transactionId: toHex$1(new Uint8Array(32)),
        outputIndex: 0,
        scriptPubKey: {
          hex: toHex$1(this.P2TR_SCRIPT),
          address: dummyAddress
        },
        value: estimatedFundingAmount,
        nonWitnessUtxo: dummyTx.toBuffer()
      };
      let txParams;
      if ("challenge" in params && params.challenge) {
        const withChallenge = {
          ...params,
          utxos: [simulatedFundedUtxo],
          randomBytes: randomBytes3,
          challenge: challenge ?? params.challenge
        };
        txParams = withChallenge;
      } else {
        const withoutChallenge = {
          ...params,
          utxos: [simulatedFundedUtxo],
          randomBytes: randomBytes3
        };
        txParams = withoutChallenge;
      }
      const preTransaction = new TransactionClass(txParams);
      try {
        await preTransaction.generateTransactionMinimalSignatures();
        estimatedFundingAmount = await calculateAmount(preTransaction);
      } catch (error) {
        if (error instanceof Error) {
          const match = error.message.match(/need (\d+) sats but only have (\d+) sats/);
          if (match) {
            estimatedFundingAmount = BigInt(match[1]);
            if (this.debug) {
              console.log(`${debugPrefix}: Caught insufficient funds, updating to ${estimatedFundingAmount}`);
            }
          } else {
            throw error;
          }
        } else {
          throw new Error("Unknown error during fee estimation", { cause: error });
        }
      }
      finalPreTransaction = preTransaction;
      if ("getChallenge" in preTransaction && typeof preTransaction.getChallenge === "function") {
        challenge = preTransaction.getChallenge();
      }
      iterations++;
      if (this.debug) {
        console.log(`${debugPrefix} Iteration ${iterations}: Previous=${previousAmount}, New=${estimatedFundingAmount}`);
      }
    }
    if (!finalPreTransaction) {
      throw new Error(`Failed to converge on ${debugPrefix} funding amount`);
    }
    return {
      finalTransaction: finalPreTransaction,
      estimatedAmount: estimatedFundingAmount,
      challenge
    };
  }
  /**
   * Convert a transaction output to a UTXO.
   * @param {Transaction} tx - The transaction
   * @param {string} to - The address
   * @param {number} index - The output index
   * @returns {UTXO[]} - The UTXO array (empty if output doesn't exist)
   */
  getUTXOAsTransaction(tx, to, index) {
    if (!tx.outs[index])
      return [];
    const out = tx.outs[index];
    const newUtxo = {
      transactionId: tx.getId(),
      outputIndex: index,
      scriptPubKey: {
        hex: toHex$1(out.script),
        address: to
      },
      value: BigInt(out.value)
    };
    return [newUtxo];
  }
};
var _MultiSignTransaction = class _MultiSignTransaction extends TransactionBuilder {
  constructor(parameters) {
    if (!parameters.refundVault) {
      throw new Error("Refund vault is required");
    }
    if (!parameters.requestedAmount) {
      throw new Error("Requested amount is required");
    }
    if (!parameters.receiver) {
      throw new Error("Receiver is required");
    }
    super({
      ...parameters,
      signer: EcKeyPair.fromPrivateKey(sha256$12(new TextEncoder().encode("aaaaaaaa"))),
      priorityFee: 0n,
      gasSatFee: 0n
    });
    __publicField(this, "type", TransactionType.MULTI_SIG);
    __publicField(this, "targetScriptRedeem", null);
    __publicField(this, "leftOverFundsScriptRedeem", null);
    __publicField(this, "compiledTargetScript");
    __publicField(this, "scriptTree");
    __publicField(this, "publicKeys");
    __publicField(this, "minimumSignatures");
    __publicField(this, "originalInputCount", 0);
    __publicField(this, "requestedAmount");
    __publicField(this, "receiver");
    __publicField(this, "refundVault");
    /**
     * @description Sign hash types
     * @protected
     */
    __publicField(this, "sighashTypes", _MultiSignTransaction.signHashTypesArray);
    /**
     * Transaction finalizer
     * @param {number} _inputIndex The input index
     * @param {PsbtInput} input The input
     */
    __publicField(this, "customFinalizer", (_inputIndex, input) => {
      if (!this.tapLeafScript) {
        throw new Error("Tap leaf script is required");
      }
      const scriptSolution = this.getScriptSolution(input);
      const witness = scriptSolution.concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness)
      };
    });
    if (!parameters.pubkeys) {
      throw new Error("Pubkeys are required");
    }
    if (parameters.psbt) {
      this.log(`Using provided PSBT.`);
      this.transaction = parameters.psbt;
      this.originalInputCount = this.transaction.data.inputs.length;
    }
    this.refundVault = parameters.refundVault;
    this.requestedAmount = parameters.requestedAmount;
    this.receiver = parameters.receiver;
    this.publicKeys = parameters.pubkeys;
    this.minimumSignatures = parameters.minimumSignatures;
    this.compiledTargetScript = MultiSignGenerator.compile(parameters.pubkeys, this.minimumSignatures);
    this.scriptTree = this.getScriptTree();
    this.internalInit();
  }
  /**
   * Generate a multisig transaction from a base64 psbt.
   * @param {MultiSignFromBase64Params} params The parameters
   * @returns {MultiSignTransaction} The multisig transaction
   */
  static fromBase64(params) {
    const psbt = Psbt2.fromBase64(params.psbt, { network: params.network });
    return new _MultiSignTransaction({
      ...params,
      psbt
    });
  }
  /**
   * Verify if that public key already signed the transaction
   * @param {Psbt} psbt The psbt
   * @param {Uint8Array} signerPubKey The signer public key
   * @returns {boolean} True if the public key signed the transaction
   */
  static verifyIfSigned(psbt, signerPubKey) {
    let alreadySigned = false;
    for (let i2 = 1; i2 < psbt.data.inputs.length; i2++) {
      const input = psbt.data.inputs[i2];
      if (!input.finalScriptWitness) {
        continue;
      }
      const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
      if (decoded.length < 3) {
        continue;
      }
      for (let j = 0; j < decoded.length - 2; j += 3) {
        const pubKey = decoded[j + 2];
        if (equals(pubKey, signerPubKey)) {
          alreadySigned = true;
          break;
        }
      }
    }
    return alreadySigned;
  }
  /**
   * Partially sign the transaction
   * @returns {boolean} True if the transaction was signed
   * @public
   */
  static signPartial(psbt, signer, originalInputCount, minimums) {
    let signed = false;
    let final = true;
    for (let i2 = originalInputCount; i2 < psbt.data.inputs.length; i2++) {
      const input = psbt.data.inputs[i2];
      if (!input.tapInternalKey) {
        input.tapInternalKey = toXOnly(_MultiSignTransaction.numsPoint);
      }
      const partialSignatures = [];
      if (input.finalScriptWitness) {
        const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
        input.tapLeafScript = [
          {
            leafVersion: 192,
            script: decoded[decoded.length - 2],
            controlBlock: decoded[decoded.length - 1]
          }
        ];
        for (let j = 0; j < decoded.length - 2; j += 3) {
          partialSignatures.push({
            signature: decoded[j],
            leafHash: decoded[j + 1],
            pubkey: decoded[j + 2]
          });
        }
        input.tapScriptSig = (input.tapScriptSig || []).concat(partialSignatures);
      }
      Reflect.deleteProperty(input, "finalScriptWitness");
      const signHashTypes = _MultiSignTransaction.signHashTypesArray ? [_MultiSignTransaction.calculateSignHash(_MultiSignTransaction.signHashTypesArray)] : [];
      try {
        _MultiSignTransaction.signInput(psbt, input, i2, signer, signHashTypes);
        signed = true;
      } catch (e) {
        console.log(e);
      }
      if (signed) {
        if (!input.tapScriptSig)
          throw new Error("No new signatures for input");
        if (input.tapScriptSig.length !== minimums[i2 - originalInputCount]) {
          final = false;
        }
      }
    }
    return {
      signed,
      final: !signed ? false : final
    };
  }
  /**
   * Dedupe signatures
   * @param {TapScriptSig[]} original The original signatures
   * @param {TapScriptSig[]} partial The partial signatures
   * @returns {TapScriptSig[]} The deduped signatures
   */
  static dedupeSignatures(original, partial) {
    const signatures = /* @__PURE__ */ new Map();
    for (const sig of original) {
      signatures.set(toHex$1(sig.pubkey), sig);
    }
    for (const sig of partial) {
      if (!signatures.has(toHex$1(sig.pubkey))) {
        signatures.set(toHex$1(sig.pubkey), sig);
      }
    }
    return Array.from(signatures.values());
  }
  /**
   * Attempt to finalize the inputs
   * @param {Psbt} psbt The psbt
   * @param {number} startIndex The start index
   * @param {Uint8Array[]} orderedPubKeys The ordered public keys
   * @param {boolean} isFinal If the transaction is final
   * @returns {boolean} True if the inputs were finalized
   */
  static attemptFinalizeInputs(psbt, startIndex, orderedPubKeys, isFinal) {
    let finalizedInputs = 0;
    for (let i2 = startIndex; i2 < psbt.data.inputs.length; i2++) {
      try {
        const input = psbt.data.inputs[i2];
        if (!input.tapInternalKey) {
          input.tapInternalKey = toXOnly(_MultiSignTransaction.numsPoint);
        }
        const partialSignatures = [];
        if (input.finalScriptWitness) {
          const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
          for (let j = 0; j < decoded.length - 2; j += 3) {
            partialSignatures.push({
              signature: decoded[j],
              leafHash: decoded[j + 1],
              pubkey: decoded[j + 2]
            });
          }
          input.tapLeafScript = [
            {
              leafVersion: 192,
              script: decoded[decoded.length - 2],
              controlBlock: decoded[decoded.length - 1]
            }
          ];
          input.tapScriptSig = _MultiSignTransaction.dedupeSignatures(input.tapScriptSig || [], partialSignatures);
        }
        Reflect.deleteProperty(input, "finalScriptWitness");
        psbt.finalizeInput(i2, (inputIndex, input2) => {
          return _MultiSignTransaction.partialFinalizer(inputIndex, input2, [], orderedPubKeys[i2 - startIndex], isFinal);
        });
        finalizedInputs++;
      } catch (e) {
      }
    }
    return finalizedInputs === psbt.data.inputs.length - startIndex;
  }
  /**
   * Finalize the psbt multisig transaction
   */
  finalizeTransactionInputs() {
    let finalized = false;
    try {
      for (let i2 = this.originalInputCount; i2 < this.transaction.data.inputs.length; i2++) {
        this.transaction.finalizeInput(i2, this.customFinalizer.bind(this));
      }
      finalized = true;
    } catch (e) {
      this.error(`Error finalizing transaction inputs: ${e.stack}`);
    }
    return finalized;
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Psbt>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signPSBT() {
    if (await this.signTransaction()) {
      return this.transaction;
    }
    throw new Error("Could not sign transaction");
  }
  /**
   * Build the transaction
   * @protected
   *
   * @throws {Error} If the left over funds script redeem is required
   * @throws {Error} If the left over funds script redeem version is required
   * @throws {Error} If the left over funds script redeem output is required
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async buildTransaction() {
    const selectedRedeem = this.targetScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!selectedRedeem.redeemVersion) {
      throw new Error("Left over funds script redeem version is required");
    }
    if (!selectedRedeem.output) {
      throw new Error("Left over funds script redeem output is required");
    }
    this.tapLeafScript = {
      leafVersion: selectedRedeem.redeemVersion,
      script: selectedRedeem.output,
      controlBlock: this.getWitness()
    };
    this.addInputsFromUTXO();
    const outputLeftAmount = this.calculateOutputLeftAmountFromVaults(this.utxos);
    if (outputLeftAmount < 0) {
      throw new Error(`Output value left is negative ${outputLeftAmount}.`);
    }
    this.addOutput({
      address: this.refundVault,
      value: toSatoshi(outputLeftAmount)
    });
    this.addOutput({
      address: this.receiver,
      value: toSatoshi(this.requestedAmount)
    });
  }
  /**
   * Builds the transaction.
   * @param {Psbt} transaction - The transaction to build
   * @param checkPartialSigs
   * @protected
   * @returns {Promise<boolean>}
   * @throws {Error} - If something went wrong while building the transaction
   */
  async internalBuildTransaction(transaction, checkPartialSigs = false) {
    const inputs2 = this.getInputs();
    const outputs2 = this.getOutputs();
    transaction.setMaximumFeeRate(this._maximumFeeRate);
    transaction.addInputs(inputs2, checkPartialSigs);
    for (let i2 = 0; i2 < this.updateInputs.length; i2++) {
      transaction.updateInput(i2, this.updateInputs[i2]);
    }
    transaction.addOutputs(outputs2);
    try {
      await this.signInputs(transaction);
      return this.finalizeTransactionInputs();
    } catch (e) {
      const err2 = e;
      this.error(`[internalBuildTransaction] Something went wrong while getting building the transaction: ${err2.stack}`);
    }
    return false;
  }
  /**
   * Sign the inputs
   * @protected
   */
  async signInputs(_transaction) {
  }
  generateScriptAddress() {
    if (this.useP2MR) {
      return {
        network: this.network,
        scriptTree: this.scriptTree,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: toXOnly(_MultiSignTransaction.numsPoint),
      network: this.network,
      scriptTree: this.scriptTree,
      name: PaymentType.P2TR
    };
  }
  generateTapData() {
    const selectedRedeem = this.targetScriptRedeem;
    if (!selectedRedeem) {
      throw new Error("Left over funds script redeem is required");
    }
    if (!this.scriptTree) {
      throw new Error("Script tree is required");
    }
    if (this.useP2MR) {
      return {
        network: this.network,
        scriptTree: this.scriptTree,
        redeem: selectedRedeem,
        name: PaymentType.P2MR
      };
    }
    return {
      internalPubkey: toXOnly(_MultiSignTransaction.numsPoint),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: selectedRedeem,
      name: PaymentType.P2TR
    };
  }
  /**
   * Generate the script solution
   * @param {PsbtInput} input The input
   * @protected
   *
   * @returns {Uint8Array[]} The script solution
   */
  getScriptSolution(input) {
    if (!input.tapScriptSig) {
      return [];
    }
    return input.tapScriptSig.map((sig) => {
      return sig.signature;
    });
  }
  /**
   * Get the script tree
   * @private
   *
   * @returns {Taptree} The script tree
   */
  getScriptTree() {
    this.generateRedeemScripts();
    return [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: _MultiSignTransaction.LOCK_LEAF_SCRIPT,
        version: 192
      }
    ];
  }
  getTotalOutputAmount(utxos) {
    let total = 0n;
    for (const utxo of utxos) {
      total += utxo.value;
    }
    return total;
  }
  /**
   * @description Calculate the amount left to refund to the first vault.
   * @private
   * @returns {bigint} The amount left
   */
  calculateOutputLeftAmountFromVaults(utxos) {
    const total = this.getTotalOutputAmount(utxos);
    return total - this.requestedAmount;
  }
  /**
   * Generate the redeem scripts
   * @private
   *
   * @throws {Error} If the public keys are required
   * @throws {Error} If the leaf script is required
   * @throws {Error} If the leaf script version is required
   * @throws {Error} If the leaf script output is required
   * @throws {Error} If the target script redeem is required
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: PaymentType.P2TR,
      output: this.compiledTargetScript,
      redeemVersion: 192
    };
    this.leftOverFundsScriptRedeem = {
      name: PaymentType.P2TR,
      output: _MultiSignTransaction.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
};
__publicField(_MultiSignTransaction, "LOCK_LEAF_SCRIPT", compile([
  opcodes.OP_XOR,
  opcodes.OP_NOP,
  opcodes.OP_CODESEPARATOR
]));
__publicField(_MultiSignTransaction, "signHashTypesArray", [
  //Transaction.SIGHASH_ALL,
  //Transaction.SIGHASH_ANYONECANPAY,
]);
__publicField(_MultiSignTransaction, "numsPoint", fromHex$1("50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0"));
/**
 * Partially finalize a P2TR MS transaction
 * @param {number} inputIndex The input index
 * @param {PsbtInput} input The input
 * @param {Uint8Array[]} partialSignatures The partial signatures
 * @param {Uint8Array[]} orderedPubKeys The ordered public keys
 * @param {boolean} isFinal If the transaction is final
 */
__publicField(_MultiSignTransaction, "partialFinalizer", (inputIndex, input, partialSignatures, orderedPubKeys, isFinal) => {
  var _a5, _b2;
  if (!input.tapLeafScript || !((_a5 = input.tapLeafScript[0]) == null ? void 0 : _a5.script) || !((_b2 = input.tapLeafScript[0]) == null ? void 0 : _b2.controlBlock)) {
    throw new Error("Tap leaf script is required");
  }
  if (!input.tapScriptSig) {
    throw new Error(`No new signatures for input ${inputIndex}.`);
  }
  let scriptSolution = [];
  if (!isFinal) {
    scriptSolution = input.tapScriptSig.map((sig) => {
      return [sig.signature, sig.leafHash, sig.pubkey];
    }).flat();
  } else {
    for (const pubKey of orderedPubKeys) {
      let found = false;
      for (const sig of input.tapScriptSig) {
        if (equals(sig.pubkey, toXOnly(pubKey))) {
          scriptSolution.push(sig.signature);
          found = true;
        }
      }
      if (!found) {
        scriptSolution.push(new Uint8Array(0));
      }
    }
    scriptSolution = scriptSolution.reverse();
  }
  if (partialSignatures.length > 0) {
    scriptSolution = scriptSolution.concat(partialSignatures);
  }
  const tapLeaf = input.tapLeafScript[0];
  const witness = scriptSolution.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
  return {
    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness)
  };
});
var MultiSignTransaction = _MultiSignTransaction;
var Consensus;
(function(Consensus2) {
  Consensus2[Consensus2["Roswell"] = 0] = "Roswell";
  Consensus2[Consensus2["Rachel"] = 1] = "Rachel";
  Consensus2[Consensus2["Kecksburg"] = 2] = "Kecksburg";
  Consensus2[Consensus2["Phoenix"] = 3] = "Phoenix";
  Consensus2[Consensus2["Aurora"] = 4] = "Aurora";
  Consensus2[Consensus2["Rendlesham"] = 5] = "Rendlesham";
  Consensus2[Consensus2["Lazar"] = 6] = "Lazar";
  Consensus2[Consensus2["ShagHarbor"] = 7] = "ShagHarbor";
  Consensus2[Consensus2["Exeter"] = 8] = "Exeter";
  Consensus2[Consensus2["Stephenville"] = 9] = "Stephenville";
  Consensus2[Consensus2["Valensole"] = 10] = "Valensole";
  Consensus2[Consensus2["Socorro"] = 11] = "Socorro";
  Consensus2[Consensus2["Pascagoula"] = 12] = "Pascagoula";
  Consensus2[Consensus2["Tehran"] = 13] = "Tehran";
  Consensus2[Consensus2["Westall"] = 14] = "Westall";
  Consensus2[Consensus2["Hopkinsville"] = 15] = "Hopkinsville";
  Consensus2[Consensus2["Belgium"] = 16] = "Belgium";
  Consensus2[Consensus2["Breeze"] = 17] = "Breeze";
  Consensus2[Consensus2["Flatwoods"] = 18] = "Flatwoods";
  Consensus2[Consensus2["Maury"] = 20] = "Maury";
  Consensus2[Consensus2["Varginha"] = 21] = "Varginha";
  Consensus2[Consensus2["Trindade"] = 22] = "Trindade";
  Consensus2[Consensus2["Levelland"] = 23] = "Levelland";
  Consensus2[Consensus2["Wanaque"] = 24] = "Wanaque";
  Consensus2[Consensus2["Coyame"] = 25] = "Coyame";
  Consensus2[Consensus2["Delphos"] = 26] = "Delphos";
})(Consensus || (Consensus = {}));
var RoswellConsensus = {
  CONSENSUS: Consensus.Roswell
};
({
  [Consensus.Roswell]: RoswellConsensus
});
Consensus.Roswell;
function stringToBuffer(str) {
  return fromHex$1(str.startsWith("0x") ? str.slice(2) : str);
}
var EpochValidator = class {
  /**
   * Calculate SHA-1 hash
   */
  static sha1(data) {
    return sha1$1(data);
  }
  /**
   * Calculate mining preimage
   */
  static calculatePreimage(checksumRoot, publicKey, salt) {
    if (checksumRoot.length !== 32 || publicKey.length !== 32 || salt.length !== 32) {
      throw new Error("All inputs must be 32 bytes");
    }
    const preimage = new Uint8Array(32);
    for (let i2 = 0; i2 < 32; i2++) {
      preimage[i2] = checksumRoot[i2] ^ publicKey[i2] ^ salt[i2];
    }
    return preimage;
  }
  /**
   * Count matching bits between two hashes
   */
  static countMatchingBits(hash1, hash2) {
    let matchingBits = 0;
    if (hash1.length !== hash2.length) {
      throw new Error("Hashes must be of the same length");
    }
    const minLength = Math.min(hash1.length, hash2.length);
    for (let i2 = 0; i2 < minLength; i2++) {
      const byte1 = hash1[i2];
      const byte2 = hash2[i2];
      if (byte1 === byte2) {
        matchingBits += 8;
      } else {
        for (let bit = 7; bit >= 0; bit--) {
          if ((byte1 >> bit & 1) === (byte2 >> bit & 1)) {
            matchingBits++;
          } else {
            return matchingBits;
          }
        }
      }
    }
    return matchingBits;
  }
  /**
   * Verify an epoch solution using IPreimage
   */
  static verifySolution(challenge, log = false) {
    try {
      const verification = challenge.verification;
      const calculatedPreimage = this.calculatePreimage(verification.targetChecksum, challenge.publicKey.toBuffer(), challenge.salt);
      const computedSolution = this.sha1(calculatedPreimage);
      if (!equals(computedSolution, challenge.solution)) {
        return false;
      }
      const matchingBits = this.countMatchingBits(computedSolution, verification.targetHash);
      if (matchingBits !== challenge.difficulty) {
        return false;
      }
      const expectedStartBlock = challenge.epochNumber * this.BLOCKS_PER_EPOCH;
      const expectedEndBlock = expectedStartBlock + this.BLOCKS_PER_EPOCH - 1n;
      return !(verification.startBlock !== expectedStartBlock || verification.endBlock !== expectedEndBlock);
    } catch (error) {
      if (log)
        console.error("Verification error:", error);
      return false;
    }
  }
  /**
   * Get the mining target block for an epoch
   */
  static getMiningTargetBlock(epochNumber) {
    if (epochNumber === 0n) {
      return null;
    }
    return epochNumber * this.BLOCKS_PER_EPOCH - 1n;
  }
  /**
   * Validate epoch winner from raw data
   */
  static validateEpochWinner(epochData) {
    try {
      const epochNumber = BigInt(epochData.epochNumber);
      const publicKey = Address.fromString(epochData.mldsaPublicKey, epochData.legacyPublicKey);
      const solution = stringToBuffer(epochData.solution);
      const salt = stringToBuffer(epochData.salt);
      const difficulty = epochData.difficulty;
      const verification = {
        epochHash: stringToBuffer(epochData.verification.epochHash),
        epochRoot: stringToBuffer(epochData.verification.epochRoot),
        targetHash: stringToBuffer(epochData.verification.targetHash),
        targetChecksum: stringToBuffer(epochData.verification.targetChecksum),
        startBlock: BigInt(epochData.verification.startBlock),
        endBlock: BigInt(epochData.verification.endBlock),
        proofs: Object.freeze(epochData.verification.proofs.map((p) => stringToBuffer(p)))
      };
      const calculatedPreimage = this.calculatePreimage(verification.targetChecksum, publicKey.toBuffer(), salt);
      const computedSolution = this.sha1(calculatedPreimage);
      if (!equals(computedSolution, solution)) {
        return false;
      }
      const matchingBits = this.countMatchingBits(computedSolution, verification.targetHash);
      if (matchingBits !== difficulty) {
        return false;
      }
      const expectedStartBlock = epochNumber * this.BLOCKS_PER_EPOCH;
      const expectedEndBlock = expectedStartBlock + this.BLOCKS_PER_EPOCH - 1n;
      return !(verification.startBlock !== expectedStartBlock || verification.endBlock !== expectedEndBlock);
    } catch {
      return false;
    }
  }
  /**
   * Validate epoch winner from Preimage instance
   */
  static validateChallengeSolution(challenge) {
    return this.verifySolution(challenge);
  }
  /**
   * Calculate solution hash from preimage components
   * @param targetChecksum The target checksum (32 bytes)
   * @param publicKey The public key buffer (32 bytes)
   * @param salt The salt buffer (32 bytes)
   * @returns The SHA-1 hash of the preimage
   */
  static calculateSolution(targetChecksum, publicKey, salt) {
    const preimage = this.calculatePreimage(targetChecksum, publicKey, salt);
    return this.sha1(preimage);
  }
  /**
   * Check if a solution meets the minimum difficulty requirement
   */
  static checkDifficulty(solution, targetHash, minDifficulty) {
    const difficulty = this.countMatchingBits(solution, targetHash);
    return {
      valid: difficulty >= minDifficulty,
      difficulty
    };
  }
};
__publicField(EpochValidator, "BLOCKS_PER_EPOCH", 5n);
var ChallengeVerification = class {
  constructor(data) {
    __publicField(this, "epochHash");
    __publicField(this, "epochRoot");
    __publicField(this, "targetHash");
    __publicField(this, "targetChecksum");
    __publicField(this, "startBlock");
    __publicField(this, "endBlock");
    __publicField(this, "proofs");
    this.epochHash = stringToBuffer(data.epochHash);
    this.epochRoot = stringToBuffer(data.epochRoot);
    this.targetHash = stringToBuffer(data.targetHash);
    this.targetChecksum = stringToBuffer(data.targetChecksum);
    this.startBlock = BigInt(data.startBlock);
    this.endBlock = BigInt(data.endBlock);
    this.proofs = Object.freeze(data.proofs.map((proof) => stringToBuffer(proof)));
  }
};
var ChallengeSubmission = class {
  constructor(data, epochNumber) {
    __publicField(this, "epochNumber");
    __publicField(this, "publicKey");
    __publicField(this, "solution");
    __publicField(this, "graffiti");
    __publicField(this, "signature");
    this.epochNumber = epochNumber;
    this.publicKey = Address.fromString(data.mldsaPublicKey, data.legacyPublicKey);
    this.solution = stringToBuffer(data.solution);
    this.graffiti = data.graffiti ? stringToBuffer(data.graffiti) : void 0;
    this.signature = stringToBuffer(data.signature);
  }
  verifySignature() {
    const signatureDataWriter = new BinaryWriter();
    signatureDataWriter.writeAddress(this.publicKey);
    signatureDataWriter.writeU64(this.epochNumber);
    signatureDataWriter.writeBytes(this.solution);
    if (this.graffiti) {
      signatureDataWriter.writeBytes(this.graffiti);
    }
    const buffer2 = signatureDataWriter.getBuffer();
    return MessageSigner.verifySignature(this.publicKey.tweakedPublicKeyToBuffer(), buffer2, this.signature);
  }
};
var ChallengeSolution = class {
  constructor(data) {
    __publicField(this, "epochNumber");
    __publicField(this, "publicKey");
    __publicField(this, "solution");
    __publicField(this, "salt");
    __publicField(this, "graffiti");
    __publicField(this, "difficulty");
    __publicField(this, "verification");
    __publicField(this, "submission");
    this.epochNumber = BigInt(data.epochNumber);
    this.publicKey = Address.fromString(data.mldsaPublicKey, data.legacyPublicKey);
    this.solution = stringToBuffer(data.solution);
    this.salt = stringToBuffer(data.salt);
    this.graffiti = stringToBuffer(data.graffiti);
    this.difficulty = data.difficulty;
    this.verification = new ChallengeVerification(data.verification);
    this.submission = data.submission ? new ChallengeSubmission(data.submission, this.epochNumber + 2n) : data.submission;
  }
  /**
   * Static method to validate from raw data directly
   */
  static validateRaw(data) {
    return EpochValidator.validateEpochWinner(data);
  }
  verifySubmissionSignature() {
    if (!this.submission) {
      throw new Error("No submission provided in request.");
    }
    return this.submission.verifySignature();
  }
  getSubmission() {
    if (!this.submission) {
      return;
    }
    if (!this.verifySubmissionSignature()) {
      throw new Error("Invalid submission signature.");
    }
    return this.submission;
  }
  /**
   * Verify this challenge
   * @returns {boolean} True if the challenge is valid
   */
  verify() {
    return EpochValidator.validateChallengeSolution(this);
  }
  /**
   * Get the preimage challenge
   * @returns {Uint8Array} The solution/challenge as a Uint8Array
   */
  toBuffer() {
    return this.solution;
  }
  /**
   * Get the solution as a hex string
   * @returns {string} The solution as a hex string with 0x prefix
   */
  toHex() {
    return "0x" + toHex$1(this.solution);
  }
  /**
   * Convert to raw format for serialization
   */
  toRaw() {
    return {
      epochNumber: this.epochNumber.toString(),
      mldsaPublicKey: this.publicKey.toHex(),
      legacyPublicKey: this.publicKey.tweakedToHex(),
      solution: this.toHex(),
      salt: "0x" + toHex$1(this.salt),
      graffiti: "0x" + toHex$1(this.graffiti),
      difficulty: this.difficulty,
      verification: {
        epochHash: "0x" + toHex$1(this.verification.epochHash),
        epochRoot: "0x" + toHex$1(this.verification.epochRoot),
        targetHash: "0x" + toHex$1(this.verification.targetHash),
        targetChecksum: "0x" + toHex$1(this.verification.targetChecksum),
        startBlock: this.verification.startBlock.toString(),
        endBlock: this.verification.endBlock.toString(),
        proofs: this.verification.proofs.map((p) => "0x" + toHex$1(p))
      }
    };
  }
  /**
   * Calculate the expected solution hash for this challenge
   * @returns {Uint8Array} The calculated solution hash
   */
  calculateSolution() {
    return EpochValidator.calculateSolution(this.verification.targetChecksum, this.publicKey.toBuffer(), this.salt);
  }
  /**
   * Check if the challenge meets a specific difficulty requirement
   * @param {number} minDifficulty The minimum difficulty required
   * @returns {Promise<{valid: boolean; difficulty: number}>} Validation result
   */
  checkDifficulty(minDifficulty) {
    return EpochValidator.checkDifficulty(this.solution, this.verification.targetHash, minDifficulty);
  }
  /**
   * Get the mining target block for this epoch
   * @returns {bigint | null} The target block number or null if epoch 0
   */
  getMiningTargetBlock() {
    return EpochValidator.getMiningTargetBlock(this.epochNumber);
  }
};
var PSBTTypes;
(function(PSBTTypes2) {
  PSBTTypes2[PSBTTypes2["UNWRAP"] = 0] = "UNWRAP";
})(PSBTTypes || (PSBTTypes = {}));
var P2TR_MS = class {
  /**
   * Generate a multi-sig address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(pubKeys, minimumSignatureRequired, network = bitcoin$1) {
    const publicKeys = EcKeyPair.verifyPubKeys(pubKeys, network);
    if (publicKeys.length !== pubKeys.length)
      throw new Error(`Contains invalid public keys`);
    const multiSignParams = {
      network,
      utxos: [],
      pubkeys: pubKeys,
      minimumSignatures: minimumSignatureRequired,
      feeRate: 100,
      receiver: "a",
      requestedAmount: 1n,
      refundVault: "a",
      mldsaSigner: null
    };
    const address = new MultiSignTransaction(multiSignParams).getScriptAddress();
    if (!address) {
      throw new Error("Failed to generate address");
    }
    return address;
  }
};
var P2MR_MS = class {
  /**
   * Generate a multi-sig P2MR address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(pubKeys, minimumSignatureRequired, network = bitcoin$1) {
    const publicKeys = EcKeyPair.verifyPubKeys(pubKeys, network);
    if (publicKeys.length !== pubKeys.length)
      throw new Error(`Contains invalid public keys`);
    const multiSignParams = {
      network,
      utxos: [],
      pubkeys: publicKeys,
      minimumSignatures: minimumSignatureRequired,
      feeRate: 100,
      receiver: "a",
      requestedAmount: 1n,
      refundVault: "a",
      mldsaSigner: null,
      useP2MR: true
    };
    const address = new MultiSignTransaction(multiSignParams).getScriptAddress();
    if (!address) {
      throw new Error("Failed to generate address");
    }
    return address;
  }
};
var sha_js = { exports: {} };
var inherits = { exports: {} };
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser = { exports: {} };
var process = browser.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser.exports;
var process$1 = getDefaultExportFromCjs(browserExports);
var util = {};
var types = {};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _2 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = require_isNaN();
  sign = function sign2(number2) {
    if ($isNaN(number2) || number2 === 0) {
      return number2;
    }
    return number2 < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i2 = 0; i2 < a.length; i2 += 1) {
      arr[i2] = a[i2];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i2 = offset, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
      arr[j] = arrLike[i2];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      str += arr[i2];
      if (i2 + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs[i2] = "$" + i2;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = requireEsObjectAtoms();
  var $Error = requireEsErrors();
  var $EvalError = require_eval();
  var $RangeError = requireRange();
  var $ReferenceError = requireRef();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var $URIError = requireUri();
  var abs2 = requireAbs();
  var floor2 = requireFloor();
  var max2 = requireMax();
  var min2 = requireMin();
  var pow3 = requirePow();
  var round2 = requireRound();
  var sign2 = requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = requireGopd();
  var $defineProperty = requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow3,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn2 = doEval2("%AsyncGeneratorFunction%");
      if (fn2) {
        value = fn2.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number2, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i2 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = (function() {
    return isStandardArguments(arguments);
  })();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var callBound2 = requireCallBound();
  var hasToStringTag = requireShams()();
  var hasOwn = requireHasown();
  var gOPD2 = requireGopd();
  var fn2;
  if (hasToStringTag) {
    var $exec = callBound2("RegExp.prototype.exec");
    var isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    var badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn2 = function isRegex2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = (
        /** @type {NonNullable<typeof gOPD>} */
        gOPD2(
          /** @type {{ lastIndex?: unknown }} */
          value,
          "lastIndex"
        )
      );
      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(
          value,
          /** @type {string} */
          /** @type {unknown} */
          badStringifier
        );
      } catch (e) {
        return e === isRegexMarker;
      }
    };
  } else {
    var $toString = callBound2("Object.prototype.toString");
    var regexClass = "[object RegExp]";
    fn2 = function isRegex2(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  isRegex = fn2;
  return isRegex;
}
var safeRegexTest;
var hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var callBound2 = requireCallBound();
  var isRegex2 = requireIsRegex();
  var $exec = callBound2("RegExp.prototype.exec");
  var $TypeError = requireType();
  safeRegexTest = function regexTester(regex) {
    if (!isRegex2(regex)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s) {
      return $exec(regex, s) !== null;
    };
  };
  return safeRegexTest;
}
var generatorFunction;
var hasRequiredGeneratorFunction;
function requireGeneratorFunction() {
  if (hasRequiredGeneratorFunction) return generatorFunction;
  hasRequiredGeneratorFunction = 1;
  const cached = (
    /** @type {GeneratorFunctionConstructor} */
    (function* () {
    }).constructor
  );
  generatorFunction = () => cached;
  return generatorFunction;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var callBound2 = requireCallBound();
  var safeRegexTest2 = requireSafeRegexTest();
  var isFnRegex = safeRegexTest2(/^\s*(?:function)?\*/);
  var hasToStringTag = requireShams()();
  var getProto2 = requireGetProto();
  var toStr = callBound2("Object.prototype.toString");
  var fnToStr = callBound2("Function.prototype.toString");
  var getGeneratorFunction = requireGeneratorFunction();
  isGeneratorFunction = function isGeneratorFunction2(fn2) {
    if (typeof fn2 !== "function") {
      return false;
    }
    if (isFnRegex(fnToStr(fn2))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr(fn2);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto2) {
      return false;
    }
    var GeneratorFunction = getGeneratorFunction();
    return GeneratorFunction && getProto2(fn2) === GeneratorFunction.prototype;
  };
  return isGeneratorFunction;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_2) {
      if (_2 !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll2(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var forEach;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i2 = 0, len = array.length; i2 < len; i2++) {
      if (hasOwnProperty.call(array, i2)) {
        if (receiver == null) {
          iterator(array[i2], i2, array);
        } else {
          iterator.call(receiver, array[i2], i2, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string, iterator, receiver) {
    for (var i2 = 0, len = string.length; i2 < len; i2++) {
      if (receiver == null) {
        iterator(string.charAt(i2), i2, string);
      } else {
        iterator.call(receiver, string.charAt(i2), i2, string);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k in object) {
      if (hasOwnProperty.call(object, k)) {
        if (receiver == null) {
          iterator(object[k], k, object);
        } else {
          iterator.call(receiver, object[k], k, object);
        }
      }
    }
  };
  function isArray2(x) {
    return toStr.call(x) === "[object Array]";
  }
  forEach = function forEach2(list, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (isArray2(list)) {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  return forEach;
}
var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
  hasRequiredPossibleTypedArrayNames = 1;
  possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  return possibleTypedArrayNames;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = requirePossibleTypedArrayNames();
  var g = typeof globalThis === "undefined" ? globalThis : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i2 = 0; i2 < possibleNames.length; i2++) {
      if (typeof g[possibleNames[i2]] === "function") {
        out[out.length] = possibleNames[i2];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var callBind = { exports: {} };
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = requireEsDefineProperty();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var gopd2 = requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var define = requireDefineDataProperty();
  var hasDescriptors = requireHasPropertyDescriptors()();
  var gOPD2 = requireGopd();
  var $TypeError = requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn2, length) {
    if (typeof fn2 !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn2 && gOPD2) {
      var desc = gOPD2(fn2, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn2,
          "length",
          length,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn2,
          "length",
          length
        );
      }
    }
    return fn2;
  };
  return setFunctionLength;
}
var applyBind;
var hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var actualApply2 = requireActualApply();
  applyBind = function applyBind2() {
    return actualApply2(bind, $apply, arguments);
  };
  return applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module2) {
    var setFunctionLength2 = requireSetFunctionLength();
    var $defineProperty = requireEsDefineProperty();
    var callBindBasic = requireCallBindApplyHelpers();
    var applyBind2 = requireApplyBind();
    module2.exports = function callBind2(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength2(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind2 });
    } else {
      module2.exports.apply = applyBind2;
    }
  })(callBind);
  return callBind.exports;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach2 = requireForEach();
  var availableTypedArrays2 = requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = requireCallBound();
  var gOPD2 = requireGopd();
  var getProto2 = requireGetProto();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? globalThis : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i2 = 0; i2 < array.length; i2 += 1) {
      if (array[i2] === value) {
        return i2;
      }
    }
    return -1;
  };
  var cache = { __proto__: null };
  if (hasToStringTag && gOPD2 && getProto2) {
    forEach2(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr && getProto2) {
        var proto2 = getProto2(arr);
        var descriptor = gOPD2(proto2, Symbol.toStringTag);
        if (!descriptor && proto2) {
          var superProto = getProto2(proto2);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        if (descriptor && descriptor.get) {
          var bound = callBind2(descriptor.get);
          cache[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = bound;
        }
      }
    });
  } else {
    forEach2(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      var fn2 = arr.slice || arr.set;
      if (fn2) {
        var bound = (
          /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
          // @ts-expect-error TODO FIXME
          callBind2(fn2)
        );
        cache[
          /** @type {`$${import('.').TypedArrayName}`} */
          "$" + typedArray
        ] = bound;
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found = false;
    forEach2(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, typedArray) {
        if (!found) {
          try {
            if ("$" + getter(value) === typedArray) {
              found = /** @type {import('.').TypedArrayName} */
              $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      }
    );
    return found;
  };
  var trySlices = function tryAllSlices(value) {
    var found = false;
    forEach2(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, name) {
        if (!found) {
          try {
            getter(value);
            found = /** @type {import('.').TypedArrayName} */
            $slice(name, 1);
          } catch (e) {
          }
        }
      }
    );
    return found;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD2) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var isTypedArray;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = requireWhichTypedArray();
  isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports$1) {
    var isArgumentsObject = requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = requireWhichTypedArray();
    var isTypedArray2 = requireIsTypedArray();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports$1.isArgumentsObject = isArgumentsObject;
    exports$1.isGeneratorFunction = isGeneratorFunction2;
    exports$1.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports$1.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports$1.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports$1.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports$1.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports$1.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports$1.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports$1.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports$1.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports$1.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports$1.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports$1.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports$1.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports$1.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports$1.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports$1.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports$1.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports$1.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports$1.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports$1.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports$1.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports$1.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports$1.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports$1.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports$1.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports$1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports$1.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports$1.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports$1.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports$1.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports$1.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports$1.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports$1.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports$1, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types);
  return types;
}
var isBuffer;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer) return isBuffer;
  hasRequiredIsBuffer = 1;
  isBuffer = function isBuffer2(arg) {
    return arg instanceof Buffer;
  };
  return isBuffer;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports$1) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i2 = 0; i2 < keys.length; i2++) {
        descriptors[keys[i2]] = Object.getOwnPropertyDescriptor(obj, keys[i2]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports$1.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          objects.push(inspect(arguments[i2]));
        }
        return objects.join(" ");
      }
      var i2 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i2 >= len) return x2;
        switch (x2) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_2) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i2]; i2 < len; x = args[++i2]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports$1.deprecate = function(fn2, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn2;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports$1.deprecate(fn2, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports$1.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process$1.pid;
          debugs[set] = function() {
            var msg = exports$1.format.apply(exports$1, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports$1._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports$1.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports$1.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base2 = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n2 = value.name ? ": " + value.name : "";
        base2 = " [Function" + n2 + "]";
      }
      if (isRegExp(value)) {
        base2 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base2 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base2 = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base2 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base2, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber2(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i2 = 0, l = value.length; i2 < l; ++i2) {
        if (hasOwnProperty(value, String(i2))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i2),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base2, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
    }
    exports$1.types = requireTypes();
    function isArray2(ar2) {
      return Array.isArray(ar2);
    }
    exports$1.isArray = isArray2;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports$1.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports$1.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports$1.isNullOrUndefined = isNullOrUndefined;
    function isNumber2(arg) {
      return typeof arg === "number";
    }
    exports$1.isNumber = isNumber2;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports$1.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports$1.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports$1.isUndefined = isUndefined;
    function isRegExp(re2) {
      return isObject(re2) && objectToString(re2) === "[object RegExp]";
    }
    exports$1.isRegExp = isRegExp;
    exports$1.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports$1.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports$1.isDate = isDate;
    exports$1.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports$1.isError = isError;
    exports$1.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports$1.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports$1.isPrimitive = isPrimitive;
    exports$1.isBuffer = requireIsBuffer();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n2) {
      return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports$1.log = function() {
      console.log("%s - %s", timestamp(), exports$1.format.apply(exports$1, arguments));
    };
    exports$1.inherits = requireInherits();
    exports$1._extend = function(origin, add3) {
      if (!add3 || !isObject(add3)) return origin;
      var keys = Object.keys(add3);
      var i2 = keys.length;
      while (i2--) {
        origin[keys[i2]] = add3[keys[i2]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports$1.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn2 = original[kCustomPromisifiedSymbol];
        if (typeof fn2 !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
          value: fn2,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn2;
      }
      function fn2() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        args.push(function(err2, value) {
          if (err2) {
            promiseReject(err2);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err2) {
          promiseReject(err2);
        }
        return promise;
      }
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
        value: fn2,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn2,
        getOwnPropertyDescriptors(original)
      );
    };
    exports$1.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process$1.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports$1.callbackify = callbackify;
  })(util);
  return util;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = requireUtil();
    if (typeof util2.inherits !== "function") throw "";
    inherits.exports = util2.inherits;
  } catch (e) {
    inherits.exports = requireInherits_browser();
  }
  return inherits.exports;
}
var safeBuffer = { exports: {} };
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports$1) {
    Object.defineProperties(exports$1, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    var buffer2 = {};
    var base64Js2 = {};
    base64Js2.byteLength = byteLength2;
    base64Js2.toByteArray = toByteArray2;
    base64Js2.fromByteArray = fromByteArray2;
    var lookup2 = [];
    var revLookup2 = [];
    var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code2.length; i2 < len; ++i2) {
      lookup2[i2] = code2[i2];
      revLookup2[code2.charCodeAt(i2)] = i2;
    }
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
    function getLens2(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength2(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr2(_byteLength2(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i22;
      for (i22 = 0; i22 < len2; i22 += 4) {
        tmp = revLookup2[b64.charCodeAt(i22)] << 18 | revLookup2[b64.charCodeAt(i22 + 1)] << 12 | revLookup2[b64.charCodeAt(i22 + 2)] << 6 | revLookup2[b64.charCodeAt(i22 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup2[b64.charCodeAt(i22)] << 2 | revLookup2[b64.charCodeAt(i22 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup2[b64.charCodeAt(i22)] << 10 | revLookup2[b64.charCodeAt(i22 + 1)] << 4 | revLookup2[b64.charCodeAt(i22 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase642(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk2(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i22 = start; i22 < end; i22 += 3) {
        tmp = (uint8[i22] << 16 & 16711680) + (uint8[i22 + 1] << 8 & 65280) + (uint8[i22 + 2] & 255);
        output.push(tripletToBase642(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i22 = 0, len22 = len2 - extraBytes; i22 < len22; i22 += maxChunkLength) {
        parts.push(encodeChunk2(uint8, i22, i22 + maxChunkLength > len22 ? len22 : i22 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    var ieee7542 = {};
    ieee7542.read = function(buffer22, offset, isLE2, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i22 = isLE2 ? nBytes - 1 : 0;
      var d = isLE2 ? -1 : 1;
      var s = buffer22[offset + i22];
      i22 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer22[offset + i22], i22 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer22[offset + i22], i22 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    ieee7542.write = function(buffer22, value, offset, isLE2, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i22 = isLE2 ? 0 : nBytes - 1;
      var d = isLE2 ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt2 / c;
        } else {
          value += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer22[offset + i22] = m & 255, i22 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer22[offset + i22] = e & 255, i22 += d, e /= 256, eLen -= 8) {
      }
      buffer22[offset + i22 - d] |= s * 128;
    };
    (function(exports2) {
      const base64 = base64Js2;
      const ieee754$1 = ieee7542;
      const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports2.Buffer = Buffer22;
      exports2.SlowBuffer = SlowBuffer;
      exports2.INSPECT_MAX_BYTES = 50;
      const K_MAX_LENGTH = 2147483647;
      exports2.kMaxLength = K_MAX_LENGTH;
      const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer22.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer22.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto2 = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto2, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto2);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer22.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer22.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer22.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer22.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer22.prototype);
        return buf;
      }
      function Buffer22(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer22.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString2(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer22.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer22.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer22.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer22.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer22, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc2(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer22.alloc = function(size, fill, encoding) {
        return alloc2(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer22.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer22.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString2(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer22.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength22(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i22 = 0; i22 < length; i22 += 1) {
          buf[i22] = array[i22] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer22.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer22.isBuffer(obj)) {
          const len2 = checked(obj.length) | 0;
          const buf = createBuffer(len2);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len2);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer22.alloc(+length);
      }
      Buffer22.isBuffer = function isBuffer2(b) {
        return b != null && b._isBuffer === true && b !== Buffer22.prototype;
      };
      Buffer22.compare = function compare3(a, b) {
        if (isInstance(a, GlobalUint8Array)) a = Buffer22.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array)) b = Buffer22.from(b, b.offset, b.byteLength);
        if (!Buffer22.isBuffer(a) || !Buffer22.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i22 = 0, len2 = Math.min(x, y); i22 < len2; ++i22) {
          if (a[i22] !== b[i22]) {
            x = a[i22];
            y = b[i22];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer22.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer22.concat = function concat2(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer22.alloc(0);
        }
        let i22;
        if (length === void 0) {
          length = 0;
          for (i22 = 0; i22 < list.length; ++i22) {
            length += list[i22].length;
          }
        }
        const buffer22 = Buffer22.allocUnsafe(length);
        let pos = 0;
        for (i22 = 0; i22 < list.length; ++i22) {
          let buf = list[i22];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer22.length) {
              if (!Buffer22.isBuffer(buf)) buf = Buffer22.from(buf);
              buf.copy(buffer22, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer22,
                buf,
                pos
              );
            }
          } else if (!Buffer22.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer22, pos);
          }
          pos += buf.length;
        }
        return buffer22;
      };
      function byteLength22(string, encoding) {
        if (Buffer22.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len2 = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len2 === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len2;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len2 * 2;
            case "hex":
              return len2 >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer22.byteLength = byteLength22;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer22.prototype._isBuffer = true;
      function swap(b, n2, m) {
        const i22 = b[n2];
        b[n2] = b[m];
        b[m] = i22;
      }
      Buffer22.prototype.swap16 = function swap16() {
        const len2 = this.length;
        if (len2 % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i22 = 0; i22 < len2; i22 += 2) {
          swap(this, i22, i22 + 1);
        }
        return this;
      };
      Buffer22.prototype.swap32 = function swap32() {
        const len2 = this.length;
        if (len2 % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i22 = 0; i22 < len2; i22 += 4) {
          swap(this, i22, i22 + 3);
          swap(this, i22 + 1, i22 + 2);
        }
        return this;
      };
      Buffer22.prototype.swap64 = function swap64() {
        const len2 = this.length;
        if (len2 % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i22 = 0; i22 < len2; i22 += 8) {
          swap(this, i22, i22 + 7);
          swap(this, i22 + 1, i22 + 6);
          swap(this, i22 + 2, i22 + 5);
          swap(this, i22 + 3, i22 + 4);
        }
        return this;
      };
      Buffer22.prototype.toString = function toString3() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer22.prototype.toLocaleString = Buffer22.prototype.toString;
      Buffer22.prototype.equals = function equals3(b) {
        if (!Buffer22.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer22.compare(this, b) === 0;
      };
      Buffer22.prototype.inspect = function inspect() {
        let str = "";
        const max2 = exports2.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max2) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer22.prototype[customInspectSymbol] = Buffer22.prototype.inspect;
      }
      Buffer22.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer22.from(target, target.offset, target.byteLength);
        }
        if (!Buffer22.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len2 = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i22 = 0; i22 < len2; ++i22) {
          if (thisCopy[i22] !== targetCopy[i22]) {
            x = thisCopy[i22];
            y = targetCopy[i22];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer22, val, byteOffset, encoding, dir) {
        if (buffer22.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer22.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer22.length + byteOffset;
        if (byteOffset >= buffer22.length) {
          if (dir) return -1;
          else byteOffset = buffer22.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer22.from(val, encoding);
        }
        if (Buffer22.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer22, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer22, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer22, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer22, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        let i22;
        if (dir) {
          let foundIndex = -1;
          for (i22 = byteOffset; i22 < arrLength; i22++) {
            if (read(arr, i22) === read(val, foundIndex === -1 ? 0 : i22 - foundIndex)) {
              if (foundIndex === -1) foundIndex = i22;
              if (i22 - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i22 -= i22 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i22 = byteOffset; i22 >= 0; i22--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i22 + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i22;
          }
        }
        return -1;
      }
      Buffer22.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer22.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer22.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i22;
        for (i22 = 0; i22 < length; ++i22) {
          const parsed = parseInt(string.substr(i22 * 2, 2), 16);
          if (numberIsNaN(parsed)) return i22;
          buf[offset + i22] = parsed;
        }
        return i22;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer22.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer22.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i22 = start;
        while (i22 < end) {
          const firstByte = buf[i22];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i22 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i22 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i22 + 1];
                thirdByte = buf[i22 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i22 + 1];
                thirdByte = buf[i22 + 2];
                fourthByte = buf[i22 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i22 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      const MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len2 = codePoints.length;
        if (len2 <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i22 = 0;
        while (i22 < len2) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i22, i22 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i22 = start; i22 < end; ++i22) {
          ret += String.fromCharCode(buf[i22] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i22 = start; i22 < end; ++i22) {
          ret += String.fromCharCode(buf[i22]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len2 = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len2) end = len2;
        let out = "";
        for (let i22 = start; i22 < end; ++i22) {
          out += hexSliceLookupTable[buf[i22]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i22 = 0; i22 < bytes.length - 1; i22 += 2) {
          res += String.fromCharCode(bytes[i22] + bytes[i22 + 1] * 256);
        }
        return res;
      }
      Buffer22.prototype.slice = function slice(start, end) {
        const len2 = this.length;
        start = ~~start;
        end = end === void 0 ? len2 : ~~end;
        if (start < 0) {
          start += len2;
          if (start < 0) start = 0;
        } else if (start > len2) {
          start = len2;
        }
        if (end < 0) {
          end += len2;
          if (end < 0) end = 0;
        } else if (end > len2) {
          end = len2;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer22.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer22.prototype.readUintLE = Buffer22.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength3, this.length);
        let val = this[offset];
        let mul = 1;
        let i22 = 0;
        while (++i22 < byteLength3 && (mul *= 256)) {
          val += this[offset + i22] * mul;
        }
        return val;
      };
      Buffer22.prototype.readUintBE = Buffer22.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength3, this.length);
        }
        let val = this[offset + --byteLength3];
        let mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength3] * mul;
        }
        return val;
      };
      Buffer22.prototype.readUint8 = Buffer22.prototype.readUInt8 = function readUInt82(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer22.prototype.readUint16LE = Buffer22.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer22.prototype.readUint16BE = Buffer22.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer22.prototype.readUint32LE = Buffer22.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer22.prototype.readUint32BE = Buffer22.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer22.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer22.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer22.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength3, this.length);
        let val = this[offset];
        let mul = 1;
        let i22 = 0;
        while (++i22 < byteLength3 && (mul *= 256)) {
          val += this[offset + i22] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer22.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength3, this.length);
        let i22 = byteLength3;
        let mul = 1;
        let val = this[offset + --i22];
        while (i22 > 0 && (mul *= 256)) {
          val += this[offset + --i22] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer22.prototype.readInt8 = function readInt82(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer22.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer22.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer22.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer22.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer22.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer22.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer22.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, true, 23, 4);
      };
      Buffer22.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, false, 23, 4);
      };
      Buffer22.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, true, 52, 8);
      };
      Buffer22.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max2, min2) {
        if (!Buffer22.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer22.prototype.writeUintLE = Buffer22.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        let mul = 1;
        let i22 = 0;
        this[offset] = value & 255;
        while (++i22 < byteLength3 && (mul *= 256)) {
          this[offset + i22] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer22.prototype.writeUintBE = Buffer22.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset, byteLength3, maxBytes, 0);
        }
        let i22 = byteLength3 - 1;
        let mul = 1;
        this[offset + i22] = value & 255;
        while (--i22 >= 0 && (mul *= 256)) {
          this[offset + i22] = value / mul & 255;
        }
        return offset + byteLength3;
      };
      Buffer22.prototype.writeUint8 = Buffer22.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer22.prototype.writeUint16LE = Buffer22.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer22.prototype.writeUint16BE = Buffer22.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer22.prototype.writeUint32LE = Buffer22.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer22.prototype.writeUint32BE = Buffer22.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer22.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer22.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer22.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        let i22 = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i22 < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i22 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i22] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer22.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset, byteLength3, limit - 1, -limit);
        }
        let i22 = byteLength3 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i22] = value & 255;
        while (--i22 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i22 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i22] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength3;
      };
      Buffer22.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer22.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer22.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer22.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer22.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer22.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer22.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max2, min2) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer22.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer22.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer22.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer22.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer22.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer22.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len2 = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len2;
      };
      Buffer22.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer22.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code22 = val.charCodeAt(0);
            if (encoding === "utf8" && code22 < 128 || encoding === "latin1") {
              val = code22;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i22;
        if (typeof val === "number") {
          for (i22 = start; i22 < end; ++i22) {
            this[i22] = val;
          }
        } else {
          const bytes = Buffer22.isBuffer(val) ? val : Buffer22.from(val, encoding);
          const len2 = bytes.length;
          if (len2 === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i22 = 0; i22 < end - start; ++i22) {
            this[i22 + start] = bytes[i22 % len2];
          }
        }
        return this;
      };
      const errors = {};
      function E(sym, getMessage2, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage2.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range2, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range2}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i22 = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i22 >= start + 4; i22 -= 3) {
          res = `_${val.slice(i22 - 3, i22)}${res}`;
        }
        return `${val.slice(0, i22)}${res}`;
      }
      function checkBounds(buf, offset, byteLength3) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
          boundsError(offset, buf.length - (byteLength3 + 1));
        }
      }
      function checkIntBI(value, min2, max2, buf, offset, byteLength3) {
        if (value > max2 || value < min2) {
          const n2 = typeof min2 === "bigint" ? "n" : "";
          let range2;
          {
            if (min2 === 0 || min2 === BigInt(0)) {
              range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
            } else {
              range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
            }
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
        }
        checkBounds(buf, offset, byteLength3);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          "offset",
          `>= ${0} and <= ${length}`,
          value
        );
      }
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i22 = 0; i22 < length; ++i22) {
          codePoint = string.charCodeAt(i22);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i22 + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i22 = 0; i22 < str.length; ++i22) {
          byteArray.push(str.charCodeAt(i22) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i22 = 0; i22 < str.length; ++i22) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i22);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src2, dst, offset, length) {
        let i22;
        for (i22 = 0; i22 < length; ++i22) {
          if (i22 + offset >= dst.length || i22 >= src2.length) break;
          dst[i22 + offset] = src2[i22];
        }
        return i22;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      const hexSliceLookupTable = (function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i22 = 0; i22 < 16; ++i22) {
          const i16 = i22 * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i22] + alphabet[j];
          }
        }
        return table;
      })();
      function defineBigIntMethod(fn2) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    })(buffer2);
    const Buffer2 = buffer2.Buffer;
    exports$1.Blob = buffer2.Blob;
    exports$1.BlobOptions = buffer2.BlobOptions;
    exports$1.Buffer = buffer2.Buffer;
    exports$1.File = buffer2.File;
    exports$1.FileOptions = buffer2.FileOptions;
    exports$1.INSPECT_MAX_BYTES = buffer2.INSPECT_MAX_BYTES;
    exports$1.SlowBuffer = buffer2.SlowBuffer;
    exports$1.TranscodeEncoding = buffer2.TranscodeEncoding;
    exports$1.atob = buffer2.atob;
    exports$1.btoa = buffer2.btoa;
    exports$1.constants = buffer2.constants;
    exports$1.default = Buffer2;
    exports$1.isAscii = buffer2.isAscii;
    exports$1.isUtf8 = buffer2.isUtf8;
    exports$1.kMaxLength = buffer2.kMaxLength;
    exports$1.kStringMaxLength = buffer2.kStringMaxLength;
    exports$1.resolveObjectURL = buffer2.resolveObjectURL;
    exports$1.transcode = buffer2.transcode;
  })(dist);
  return dist;
}
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module2, exports$1) {
    var buffer2 = requireDist();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports$1);
      exports$1.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var toString3 = {}.toString;
  isarray = Array.isArray || function(arr) {
    return toString3.call(arr) == "[object Array]";
  };
  return isarray;
}
var typedArrayBuffer;
var hasRequiredTypedArrayBuffer;
function requireTypedArrayBuffer() {
  if (hasRequiredTypedArrayBuffer) return typedArrayBuffer;
  hasRequiredTypedArrayBuffer = 1;
  var $TypeError = requireType();
  var callBound2 = requireCallBound();
  var $typedArrayBuffer = callBound2("TypedArray.prototype.buffer", true);
  var isTypedArray2 = requireIsTypedArray();
  typedArrayBuffer = $typedArrayBuffer || function typedArrayBuffer2(x) {
    if (!isTypedArray2(x)) {
      throw new $TypeError("Not a Typed Array");
    }
    return x.buffer;
  };
  return typedArrayBuffer;
}
var toBuffer;
var hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer;
  hasRequiredToBuffer = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isArray2 = requireIsarray();
  var typedArrayBuffer2 = requireTypedArrayBuffer();
  var isView = ArrayBuffer.isView || function isView2(obj) {
    try {
      typedArrayBuffer2(obj);
      return true;
    } catch (e) {
      return false;
    }
  };
  var useUint8Array = typeof Uint8Array !== "undefined";
  var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  var useFromArrayBuffer = useArrayBuffer && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
  toBuffer = function toBuffer2(data, encoding) {
    if (Buffer2.isBuffer(data)) {
      if (data.constructor && !("isBuffer" in data)) {
        return Buffer2.from(data);
      }
      return data;
    }
    if (typeof data === "string") {
      return Buffer2.from(data, encoding);
    }
    if (useArrayBuffer && isView(data)) {
      if (data.byteLength === 0) {
        return Buffer2.alloc(0);
      }
      if (useFromArrayBuffer) {
        var res = Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
        if (res.byteLength === data.byteLength) {
          return res;
        }
      }
      var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
      var result = Buffer2.from(uint8);
      if (result.length === data.byteLength) {
        return result;
      }
    }
    if (useUint8Array && data instanceof Uint8Array) {
      return Buffer2.from(data);
    }
    var isArr = isArray2(data);
    if (isArr) {
      for (var i2 = 0; i2 < data.length; i2 += 1) {
        var x = data[i2];
        if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
          throw new RangeError("Array items must be numbers in the range 0-255.");
        }
      }
    }
    if (isArr || Buffer2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
      return Buffer2.from(data);
    }
    throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
  };
  return toBuffer;
}
var hash;
var hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash;
  hasRequiredHash = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var toBuffer2 = requireToBuffer();
  function Hash(blockSize, finalSize) {
    this._block = Buffer2.alloc(blockSize);
    this._finalSize = finalSize;
    this._blockSize = blockSize;
    this._len = 0;
  }
  Hash.prototype.update = function(data, enc) {
    data = toBuffer2(data, enc || "utf8");
    var block = this._block;
    var blockSize = this._blockSize;
    var length = data.length;
    var accum = this._len;
    for (var offset = 0; offset < length; ) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);
      for (var i2 = 0; i2 < remainder; i2++) {
        block[assigned + i2] = data[offset + i2];
      }
      accum += remainder;
      offset += remainder;
      if (accum % blockSize === 0) {
        this._update(block);
      }
    }
    this._len += length;
    return this;
  };
  Hash.prototype.digest = function(enc) {
    var rem = this._len % this._blockSize;
    this._block[rem] = 128;
    this._block.fill(0, rem + 1);
    if (rem >= this._finalSize) {
      this._update(this._block);
      this._block.fill(0);
    }
    var bits = this._len * 8;
    if (bits <= 4294967295) {
      this._block.writeUInt32BE(bits, this._blockSize - 4);
    } else {
      var lowBits = (bits & 4294967295) >>> 0;
      var highBits = (bits - lowBits) / 4294967296;
      this._block.writeUInt32BE(highBits, this._blockSize - 8);
      this._block.writeUInt32BE(lowBits, this._blockSize - 4);
    }
    this._update(this._block);
    var hash2 = this._hash();
    return enc ? hash2.toString(enc) : hash2;
  };
  Hash.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  hash = Hash;
  return hash;
}
var sha;
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha;
  hasRequiredSha = 1;
  var inherits2 = requireInherits();
  var Hash = requireHash();
  var Buffer2 = requireSafeBuffer().Buffer;
  var K2 = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W2 = new Array(80);
  function Sha() {
    this.init();
    this._w = W2;
    Hash.call(this, 64, 56);
  }
  inherits2(Sha, Hash);
  Sha.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft2(s, b, c, d) {
    if (s === 0) {
      return b & c | ~b & d;
    }
    if (s === 2) {
      return b & c | b & d | c & d;
    }
    return b ^ c ^ d;
  }
  Sha.prototype._update = function(M2) {
    var w2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      w2[i2] = M2.readInt32BE(i2 * 4);
    }
    for (; i2 < 80; ++i2) {
      w2[i2] = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
    }
    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t2 = rotl5(a) + ft2(s, b, c, d) + e + w2[j] + K2[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t2;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };
  Sha.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };
  sha = Sha;
  return sha;
}
var sha12;
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha12;
  hasRequiredSha1 = 1;
  var inherits2 = requireInherits();
  var Hash = requireHash();
  var Buffer2 = requireSafeBuffer().Buffer;
  var K2 = [
    1518500249,
    1859775393,
    2400959708 | 0,
    3395469782 | 0
  ];
  var W2 = new Array(80);
  function Sha1() {
    this.init();
    this._w = W2;
    Hash.call(this, 64, 56);
  }
  inherits2(Sha1, Hash);
  Sha1.prototype.init = function() {
    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
    return this;
  };
  function rotl1(num) {
    return num << 1 | num >>> 31;
  }
  function rotl5(num) {
    return num << 5 | num >>> 27;
  }
  function rotl30(num) {
    return num << 30 | num >>> 2;
  }
  function ft2(s, b, c, d) {
    if (s === 0) {
      return b & c | ~b & d;
    }
    if (s === 2) {
      return b & c | b & d | c & d;
    }
    return b ^ c ^ d;
  }
  Sha1.prototype._update = function(M2) {
    var w2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      w2[i2] = M2.readInt32BE(i2 * 4);
    }
    for (; i2 < 80; ++i2) {
      w2[i2] = rotl1(w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16]);
    }
    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t2 = rotl5(a) + ft2(s, b, c, d) + e + w2[j] + K2[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t2;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
  };
  Sha1.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(20);
    H.writeInt32BE(this._a | 0, 0);
    H.writeInt32BE(this._b | 0, 4);
    H.writeInt32BE(this._c | 0, 8);
    H.writeInt32BE(this._d | 0, 12);
    H.writeInt32BE(this._e | 0, 16);
    return H;
  };
  sha12 = Sha1;
  return sha12;
}
var sha2562;
var hasRequiredSha2562;
function requireSha2562() {
  if (hasRequiredSha2562) return sha2562;
  hasRequiredSha2562 = 1;
  var inherits2 = requireInherits();
  var Hash = requireHash();
  var Buffer2 = requireSafeBuffer().Buffer;
  var K2 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  var W2 = new Array(64);
  function Sha256() {
    this.init();
    this._w = W2;
    Hash.call(this, 64, 56);
  }
  inherits2(Sha256, Hash);
  Sha256.prototype.init = function() {
    this._a = 1779033703;
    this._b = 3144134277;
    this._c = 1013904242;
    this._d = 2773480762;
    this._e = 1359893119;
    this._f = 2600822924;
    this._g = 528734635;
    this._h = 1541459225;
    return this;
  };
  function ch(x, y, z2) {
    return z2 ^ x & (y ^ z2);
  }
  function maj(x, y, z2) {
    return x & y | z2 & (x | y);
  }
  function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }
  function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }
  function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }
  function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }
  Sha256.prototype._update = function(M2) {
    var w2 = this._w;
    var a = this._a | 0;
    var b = this._b | 0;
    var c = this._c | 0;
    var d = this._d | 0;
    var e = this._e | 0;
    var f = this._f | 0;
    var g = this._g | 0;
    var h = this._h | 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      w2[i2] = M2.readInt32BE(i2 * 4);
    }
    for (; i2 < 64; ++i2) {
      w2[i2] = gamma1(w2[i2 - 2]) + w2[i2 - 7] + gamma0(w2[i2 - 15]) + w2[i2 - 16] | 0;
    }
    for (var j = 0; j < 64; ++j) {
      var T1 = h + sigma1(e) + ch(e, f, g) + K2[j] + w2[j] | 0;
      var T2 = sigma0(a) + maj(a, b, c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + T1 | 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 | 0;
    }
    this._a = a + this._a | 0;
    this._b = b + this._b | 0;
    this._c = c + this._c | 0;
    this._d = d + this._d | 0;
    this._e = e + this._e | 0;
    this._f = f + this._f | 0;
    this._g = g + this._g | 0;
    this._h = h + this._h | 0;
  };
  Sha256.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(32);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    H.writeInt32BE(this._h, 28);
    return H;
  };
  sha2562 = Sha256;
  return sha2562;
}
var sha2242;
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha2242;
  hasRequiredSha224 = 1;
  var inherits2 = requireInherits();
  var Sha256 = requireSha2562();
  var Hash = requireHash();
  var Buffer2 = requireSafeBuffer().Buffer;
  var W2 = new Array(64);
  function Sha224() {
    this.init();
    this._w = W2;
    Hash.call(this, 64, 56);
  }
  inherits2(Sha224, Sha256);
  Sha224.prototype.init = function() {
    this._a = 3238371032;
    this._b = 914150663;
    this._c = 812702999;
    this._d = 4144912697;
    this._e = 4290775857;
    this._f = 1750603025;
    this._g = 1694076839;
    this._h = 3204075428;
    return this;
  };
  Sha224.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(28);
    H.writeInt32BE(this._a, 0);
    H.writeInt32BE(this._b, 4);
    H.writeInt32BE(this._c, 8);
    H.writeInt32BE(this._d, 12);
    H.writeInt32BE(this._e, 16);
    H.writeInt32BE(this._f, 20);
    H.writeInt32BE(this._g, 24);
    return H;
  };
  sha2242 = Sha224;
  return sha2242;
}
var sha5122;
var hasRequiredSha5122;
function requireSha5122() {
  if (hasRequiredSha5122) return sha5122;
  hasRequiredSha5122 = 1;
  var inherits2 = requireInherits();
  var Hash = requireHash();
  var Buffer2 = requireSafeBuffer().Buffer;
  var K2 = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  var W2 = new Array(160);
  function Sha512() {
    this.init();
    this._w = W2;
    Hash.call(this, 128, 112);
  }
  inherits2(Sha512, Hash);
  Sha512.prototype.init = function() {
    this._ah = 1779033703;
    this._bh = 3144134277;
    this._ch = 1013904242;
    this._dh = 2773480762;
    this._eh = 1359893119;
    this._fh = 2600822924;
    this._gh = 528734635;
    this._hh = 1541459225;
    this._al = 4089235720;
    this._bl = 2227873595;
    this._cl = 4271175723;
    this._dl = 1595750129;
    this._el = 2917565137;
    this._fl = 725511199;
    this._gl = 4215389547;
    this._hl = 327033209;
    return this;
  };
  function Ch(x, y, z2) {
    return z2 ^ x & (y ^ z2);
  }
  function maj(x, y, z2) {
    return x & y | z2 & (x | y);
  }
  function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
  }
  function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
  }
  function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
  }
  function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
  }
  function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
  }
  function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
  }
  function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
  }
  Sha512.prototype._update = function(M2) {
    var w2 = this._w;
    var ah = this._ah | 0;
    var bh = this._bh | 0;
    var ch = this._ch | 0;
    var dh = this._dh | 0;
    var eh = this._eh | 0;
    var fh = this._fh | 0;
    var gh = this._gh | 0;
    var hh = this._hh | 0;
    var al = this._al | 0;
    var bl = this._bl | 0;
    var cl = this._cl | 0;
    var dl = this._dl | 0;
    var el = this._el | 0;
    var fl = this._fl | 0;
    var gl = this._gl | 0;
    var hl = this._hl | 0;
    for (var i2 = 0; i2 < 32; i2 += 2) {
      w2[i2] = M2.readInt32BE(i2 * 4);
      w2[i2 + 1] = M2.readInt32BE(i2 * 4 + 4);
    }
    for (; i2 < 160; i2 += 2) {
      var xh = w2[i2 - 15 * 2];
      var xl = w2[i2 - 15 * 2 + 1];
      var gamma0 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = w2[i2 - 2 * 2];
      xl = w2[i2 - 2 * 2 + 1];
      var gamma1 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh);
      var Wi7h = w2[i2 - 7 * 2];
      var Wi7l = w2[i2 - 7 * 2 + 1];
      var Wi16h = w2[i2 - 16 * 2];
      var Wi16l = w2[i2 - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      w2[i2] = Wih;
      w2[i2 + 1] = Wil;
    }
    for (var j = 0; j < 160; j += 2) {
      Wih = w2[j];
      Wil = w2[j + 1];
      var majh = maj(ah, bh, ch);
      var majl = maj(al, bl, cl);
      var sigma0h = sigma0(ah, al);
      var sigma0l = sigma0(al, ah);
      var sigma1h = sigma1(eh, el);
      var sigma1l = sigma1(el, eh);
      var Kih = K2[j];
      var Kil = K2[j + 1];
      var chh = Ch(eh, fh, gh);
      var chl = Ch(el, fl, gl);
      var t1l = hl + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = dl + t1l | 0;
      eh = dh + t1h + getCarry(el, dl) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + getCarry(al, t1l) | 0;
    }
    this._al = this._al + al | 0;
    this._bl = this._bl + bl | 0;
    this._cl = this._cl + cl | 0;
    this._dl = this._dl + dl | 0;
    this._el = this._el + el | 0;
    this._fl = this._fl + fl | 0;
    this._gl = this._gl + gl | 0;
    this._hl = this._hl + hl | 0;
    this._ah = this._ah + ah + getCarry(this._al, al) | 0;
    this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
    this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
    this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
    this._eh = this._eh + eh + getCarry(this._el, el) | 0;
    this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
    this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
    this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
  };
  Sha512.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(64);
    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    writeInt64BE(this._gh, this._gl, 48);
    writeInt64BE(this._hh, this._hl, 56);
    return H;
  };
  sha5122 = Sha512;
  return sha5122;
}
var sha3842;
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha3842;
  hasRequiredSha384 = 1;
  var inherits2 = requireInherits();
  var SHA512 = requireSha5122();
  var Hash = requireHash();
  var Buffer2 = requireSafeBuffer().Buffer;
  var W2 = new Array(160);
  function Sha384() {
    this.init();
    this._w = W2;
    Hash.call(this, 128, 112);
  }
  inherits2(Sha384, SHA512);
  Sha384.prototype.init = function() {
    this._ah = 3418070365;
    this._bh = 1654270250;
    this._ch = 2438529370;
    this._dh = 355462360;
    this._eh = 1731405415;
    this._fh = 2394180231;
    this._gh = 3675008525;
    this._hh = 1203062813;
    this._al = 3238371032;
    this._bl = 914150663;
    this._cl = 812702999;
    this._dl = 4144912697;
    this._el = 4290775857;
    this._fl = 1750603025;
    this._gl = 1694076839;
    this._hl = 3204075428;
    return this;
  };
  Sha384.prototype._hash = function() {
    var H = Buffer2.allocUnsafe(48);
    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }
    writeInt64BE(this._ah, this._al, 0);
    writeInt64BE(this._bh, this._bl, 8);
    writeInt64BE(this._ch, this._cl, 16);
    writeInt64BE(this._dh, this._dl, 24);
    writeInt64BE(this._eh, this._el, 32);
    writeInt64BE(this._fh, this._fl, 40);
    return H;
  };
  sha3842 = Sha384;
  return sha3842;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  (function(module2) {
    module2.exports = function SHA(algorithm) {
      var alg = algorithm.toLowerCase();
      var Algorithm = module2.exports[alg];
      if (!Algorithm) {
        throw new Error(alg + " is not supported (we accept pull requests)");
      }
      return new Algorithm();
    };
    module2.exports.sha = requireSha();
    module2.exports.sha1 = requireSha1();
    module2.exports.sha224 = requireSha224();
    module2.exports.sha256 = requireSha2562();
    module2.exports.sha384 = requireSha384();
    module2.exports.sha512 = requireSha5122();
  })(sha_js);
  return sha_js.exports;
}
var sha_jsExports = requireSha_js();
var shajs = getDefaultExportFromCjs$1(sha_jsExports);
var ABIDataTypes;
(function(ABIDataTypes2) {
  ABIDataTypes2["UINT8"] = "UINT8";
  ABIDataTypes2["UINT16"] = "UINT16";
  ABIDataTypes2["UINT32"] = "UINT32";
  ABIDataTypes2["UINT64"] = "UINT64";
  ABIDataTypes2["UINT128"] = "UINT128";
  ABIDataTypes2["UINT256"] = "UINT256";
  ABIDataTypes2["INT8"] = "INT8";
  ABIDataTypes2["INT16"] = "INT16";
  ABIDataTypes2["INT32"] = "INT32";
  ABIDataTypes2["INT64"] = "INT64";
  ABIDataTypes2["INT128"] = "INT128";
  ABIDataTypes2["BOOL"] = "BOOL";
  ABIDataTypes2["ADDRESS"] = "ADDRESS";
  ABIDataTypes2["EXTENDED_ADDRESS"] = "EXTENDED_ADDRESS";
  ABIDataTypes2["STRING"] = "STRING";
  ABIDataTypes2["BYTES4"] = "BYTES4";
  ABIDataTypes2["BYTES32"] = "BYTES32";
  ABIDataTypes2["BYTES"] = "BYTES";
  ABIDataTypes2["ADDRESS_UINT256_TUPLE"] = "ADDRESS_UINT256_TUPLE";
  ABIDataTypes2["EXTENDED_ADDRESS_UINT256_TUPLE"] = "EXTENDED_ADDRESS_UINT256_TUPLE";
  ABIDataTypes2["SCHNORR_SIGNATURE"] = "SCHNORR_SIGNATURE";
  ABIDataTypes2["ARRAY_OF_ADDRESSES"] = "ARRAY_OF_ADDRESSES";
  ABIDataTypes2["ARRAY_OF_EXTENDED_ADDRESSES"] = "ARRAY_OF_EXTENDED_ADDRESSES";
  ABIDataTypes2["ARRAY_OF_UINT256"] = "ARRAY_OF_UINT256";
  ABIDataTypes2["ARRAY_OF_UINT128"] = "ARRAY_OF_UINT128";
  ABIDataTypes2["ARRAY_OF_UINT64"] = "ARRAY_OF_UINT64";
  ABIDataTypes2["ARRAY_OF_UINT32"] = "ARRAY_OF_UINT32";
  ABIDataTypes2["ARRAY_OF_UINT16"] = "ARRAY_OF_UINT16";
  ABIDataTypes2["ARRAY_OF_UINT8"] = "ARRAY_OF_UINT8";
  ABIDataTypes2["ARRAY_OF_STRING"] = "ARRAY_OF_STRING";
  ABIDataTypes2["ARRAY_OF_BYTES"] = "ARRAY_OF_BYTES";
  ABIDataTypes2["ARRAY_OF_BUFFERS"] = "ARRAY_OF_BUFFERS";
})(ABIDataTypes || (ABIDataTypes = {}));
({
  address: ABIDataTypes.ADDRESS,
  extendedAddress: ABIDataTypes.EXTENDED_ADDRESS,
  bool: ABIDataTypes.BOOL,
  bytes: ABIDataTypes.BYTES,
  uint256: ABIDataTypes.UINT256,
  uint128: ABIDataTypes.UINT128,
  uint64: ABIDataTypes.UINT64,
  uint32: ABIDataTypes.UINT32,
  uint16: ABIDataTypes.UINT16,
  uint8: ABIDataTypes.UINT8,
  int128: ABIDataTypes.INT128,
  int64: ABIDataTypes.INT64,
  int32: ABIDataTypes.INT32,
  int16: ABIDataTypes.INT16,
  int8: ABIDataTypes.INT8,
  string: ABIDataTypes.STRING,
  bytes4: ABIDataTypes.BYTES4,
  bytes32: ABIDataTypes.BYTES32,
  schnorrSignature: ABIDataTypes.SCHNORR_SIGNATURE,
  "tuple(address,uint256)[]": ABIDataTypes.ADDRESS_UINT256_TUPLE,
  "tuple(extendedAddress,uint256)[]": ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE,
  "address[]": ABIDataTypes.ARRAY_OF_ADDRESSES,
  "extendedAddress[]": ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES,
  "uint256[]": ABIDataTypes.ARRAY_OF_UINT256,
  "uint128[]": ABIDataTypes.ARRAY_OF_UINT128,
  "uint64[]": ABIDataTypes.ARRAY_OF_UINT64,
  "uint32[]": ABIDataTypes.ARRAY_OF_UINT32,
  "uint16[]": ABIDataTypes.ARRAY_OF_UINT16,
  "uint8[]": ABIDataTypes.ARRAY_OF_UINT8,
  "bytes[]": ABIDataTypes.ARRAY_OF_BYTES,
  "buffer[]": ABIDataTypes.ARRAY_OF_BUFFERS,
  "string[]": ABIDataTypes.ARRAY_OF_STRING,
  boolean: ABIDataTypes.BOOL
});
var AbiTypeToStr = {
  [ABIDataTypes.ADDRESS]: "address",
  [ABIDataTypes.EXTENDED_ADDRESS]: "extendedAddress",
  [ABIDataTypes.BOOL]: "bool",
  [ABIDataTypes.BYTES]: "bytes",
  [ABIDataTypes.BYTES32]: "bytes32",
  [ABIDataTypes.BYTES4]: "bytes4",
  [ABIDataTypes.UINT256]: "uint256",
  [ABIDataTypes.UINT128]: "uint128",
  [ABIDataTypes.UINT64]: "uint64",
  [ABIDataTypes.UINT32]: "uint32",
  [ABIDataTypes.UINT16]: "uint16",
  [ABIDataTypes.UINT8]: "uint8",
  [ABIDataTypes.INT128]: "int128",
  [ABIDataTypes.INT64]: "int64",
  [ABIDataTypes.INT32]: "int32",
  [ABIDataTypes.INT16]: "int16",
  [ABIDataTypes.INT8]: "int8",
  [ABIDataTypes.STRING]: "string",
  [ABIDataTypes.ADDRESS_UINT256_TUPLE]: "tuple(address,uint256)[]",
  [ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE]: "tuple(extendedAddress,uint256)[]",
  [ABIDataTypes.SCHNORR_SIGNATURE]: "schnorrSignature",
  [ABIDataTypes.ARRAY_OF_ADDRESSES]: "address[]",
  [ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES]: "extendedAddress[]",
  [ABIDataTypes.ARRAY_OF_UINT256]: "uint256[]",
  [ABIDataTypes.ARRAY_OF_UINT128]: "uint128[]",
  [ABIDataTypes.ARRAY_OF_UINT64]: "uint64[]",
  [ABIDataTypes.ARRAY_OF_UINT32]: "uint32[]",
  [ABIDataTypes.ARRAY_OF_UINT16]: "uint16[]",
  [ABIDataTypes.ARRAY_OF_UINT8]: "uint8[]",
  [ABIDataTypes.ARRAY_OF_BYTES]: "bytes[]",
  [ABIDataTypes.ARRAY_OF_STRING]: "string[]",
  [ABIDataTypes.ARRAY_OF_BUFFERS]: "buffer[]"
};
function isAbiTuple(type2) {
  return Array.isArray(type2);
}
function isAbiStruct(type2) {
  return typeof type2 === "object" && type2 !== null && !Array.isArray(type2);
}
function isSimpleAbiType(type2) {
  return typeof type2 === "string";
}
function abiTypeToSelectorString(type2) {
  if (isSimpleAbiType(type2)) {
    const str = AbiTypeToStr[type2];
    if (!str) {
      throw new Error(`Unknown ABI type: ${type2}`);
    }
    return str;
  }
  if (isAbiStruct(type2)) {
    const inner2 = Object.values(type2).map((t2) => abiTypeToSelectorString(t2)).join(",");
    return `tuple(${inner2})`;
  }
  const firstType = type2[0];
  if (type2.length === 1 && firstType !== void 0) {
    return `${abiTypeToSelectorString(firstType)}[]`;
  }
  const inner = type2.map((t2) => abiTypeToSelectorString(t2)).join(",");
  return `tuple(${inner})[]`;
}
var ABICoder = class {
  decodeData(data, types2) {
    const byteReader = new BinaryReader(data);
    const result = [];
    for (const type2 of types2) {
      result.push(this.decodeSingleValue(byteReader, type2));
    }
    return result;
  }
  encodeSelector(selectorIdentifier) {
    const hash2 = this.sha256(selectorIdentifier);
    const selector = hash2.subarray(0, 4);
    return Array.from(selector, (b) => b.toString(16).padStart(2, "0")).join("");
  }
  numericSelectorToHex(selector) {
    return selector.toString(16);
  }
  /**
   * Decodes a single value from the reader based on the ABI type.
   * Supports ABIDataTypes enum values, tuple arrays, and struct objects.
   */
  decodeSingleValue(reader, type2) {
    if (isAbiTuple(type2)) {
      const firstType = type2[0];
      if (type2.length === 1 && firstType !== void 0) {
        return this.decodeArray(reader, firstType);
      }
      return this.decodeTuple(reader, type2);
    }
    if (isAbiStruct(type2)) {
      return this.decodeStruct(reader, type2);
    }
    switch (type2) {
      case ABIDataTypes.UINT8:
        return reader.readU8();
      case ABIDataTypes.UINT16:
        return reader.readU16();
      case ABIDataTypes.UINT32:
        return reader.readU32();
      case ABIDataTypes.BYTES4:
        return reader.readBytes(4);
      case ABIDataTypes.BYTES32:
        return reader.readBytes(32);
      case ABIDataTypes.BOOL:
        return reader.readBoolean();
      case ABIDataTypes.ADDRESS:
        return reader.readAddress();
      case ABIDataTypes.STRING:
        return reader.readStringWithLength();
      case ABIDataTypes.UINT128:
        return reader.readU128();
      case ABIDataTypes.UINT256:
        return reader.readU256();
      case ABIDataTypes.INT8:
        return reader.readI8();
      case ABIDataTypes.INT16:
        return reader.readI16();
      case ABIDataTypes.INT32:
        return reader.readI32();
      case ABIDataTypes.INT64:
        return reader.readI64();
      case ABIDataTypes.INT128:
        return reader.readI128();
      case ABIDataTypes.EXTENDED_ADDRESS:
        return reader.readExtendedAddress();
      case ABIDataTypes.ADDRESS_UINT256_TUPLE:
        return reader.readAddressValueTuple();
      case ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE:
        return reader.readExtendedAddressMapU256();
      case ABIDataTypes.SCHNORR_SIGNATURE:
        return reader.readSchnorrSignature();
      case ABIDataTypes.BYTES:
        return reader.readBytesWithLength();
      case ABIDataTypes.UINT64:
        return reader.readU64();
      case ABIDataTypes.ARRAY_OF_ADDRESSES:
        return reader.readAddressArray();
      case ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES:
        return reader.readExtendedAddressArray();
      case ABIDataTypes.ARRAY_OF_UINT256:
        return reader.readU256Array();
      case ABIDataTypes.ARRAY_OF_UINT128:
        return reader.readU128Array();
      case ABIDataTypes.ARRAY_OF_UINT64:
        return reader.readU64Array();
      case ABIDataTypes.ARRAY_OF_UINT32:
        return reader.readU32Array();
      case ABIDataTypes.ARRAY_OF_UINT16:
        return reader.readU16Array();
      case ABIDataTypes.ARRAY_OF_UINT8:
        return reader.readU8Array();
      case ABIDataTypes.ARRAY_OF_STRING:
        return reader.readStringArray();
      case ABIDataTypes.ARRAY_OF_BYTES:
        return reader.readBytesArray();
      case ABIDataTypes.ARRAY_OF_BUFFERS:
        return reader.readArrayOfBuffer();
      default:
        throw new Error(`Unsupported ABI type: ${type2}`);
    }
  }
  /** Decodes a single-element tuple as a flat typed array (u16 count + values). */
  decodeArray(reader, elementType) {
    const count = reader.readU16();
    const result = [];
    for (let i2 = 0; i2 < count; i2++) {
      result.push(this.decodeSingleValue(reader, elementType));
    }
    return result;
  }
  /** Decodes a multi-element tuple as array of tuple entries (u16 count + entries). */
  decodeTuple(reader, types2) {
    const count = reader.readU16();
    const result = [];
    for (let i2 = 0; i2 < count; i2++) {
      const entry = [];
      for (const fieldType of types2) {
        entry.push(this.decodeSingleValue(reader, fieldType));
      }
      result.push(entry);
    }
    return result;
  }
  /** Decodes a struct as a single object with named fields (inline, no count prefix). */
  decodeStruct(reader, struct) {
    const entry = {};
    for (const [name, fieldType] of Object.entries(struct)) {
      entry[name] = this.decodeSingleValue(reader, fieldType);
    }
    return entry;
  }
  sha256(buffer2) {
    return new Uint8Array(new shajs.sha256().update(buffer2).digest());
  }
};
var NetEvent = class {
  constructor(type2, data) {
    __publicField(this, "type");
    __publicField(this, "data");
    this.type = type2;
    this.data = data;
  }
};
var XverseNetwork;
(function(XverseNetwork2) {
  XverseNetwork2["mainnet"] = "mainnet";
  XverseNetwork2["testnet"] = "testnet";
  XverseNetwork2["signet"] = "Signet";
})(XverseNetwork || (XverseNetwork = {}));
var SigningProtocol;
(function(SigningProtocol2) {
  SigningProtocol2["ECDSA"] = "ECDSA";
  SigningProtocol2["BIP322"] = "BIP322";
})(SigningProtocol || (SigningProtocol = {}));
var Node = class {
  constructor(value) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value;
  }
};
var _head, _tail, _size;
var Queue = class {
  constructor() {
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _size);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    if (!__privateGet(this, _head)) {
      __privateSet(this, _tail, void 0);
    }
    return current.value;
  }
  peek() {
    if (!__privateGet(this, _head)) {
      return;
    }
    return __privateGet(this, _head).value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
  *drain() {
    while (__privateGet(this, _head)) {
      yield this.dequeue();
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();
function pLimit(concurrency) {
  let rejectOnClear = false;
  if (typeof concurrency === "object") {
    ({ concurrency, rejectOnClear = false } = concurrency);
  }
  validateConcurrency(concurrency);
  if (typeof rejectOnClear !== "boolean") {
    throw new TypeError("Expected `rejectOnClear` to be a boolean");
  }
  const queue2 = new Queue();
  let activeCount = 0;
  const resumeNext = () => {
    if (activeCount < concurrency && queue2.size > 0) {
      activeCount++;
      queue2.dequeue().run();
    }
  };
  const next = () => {
    activeCount--;
    resumeNext();
  };
  const run = async (function_, resolve, arguments_) => {
    const result = (async () => function_(...arguments_))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (function_, resolve, reject, arguments_) => {
    const queueItem = { reject };
    new Promise((internalResolve) => {
      queueItem.run = internalResolve;
      queue2.enqueue(queueItem);
    }).then(run.bind(void 0, function_, resolve, arguments_));
    if (activeCount < concurrency) {
      resumeNext();
    }
  };
  const generator = (function_, ...arguments_) => new Promise((resolve, reject) => {
    enqueue(function_, resolve, reject, arguments_);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue2.size
    },
    clearQueue: {
      value() {
        if (!rejectOnClear) {
          queue2.clear();
          return;
        }
        const abortError = AbortSignal.abort().reason;
        while (queue2.size > 0) {
          queue2.dequeue().reject(abortError);
        }
      }
    },
    concurrency: {
      get: () => concurrency,
      set(newConcurrency) {
        validateConcurrency(newConcurrency);
        concurrency = newConcurrency;
        queueMicrotask(() => {
          while (activeCount < concurrency && queue2.size > 0) {
            resumeNext();
          }
        });
      }
    },
    map: {
      async value(iterable, function_) {
        const promises = Array.from(iterable, (value, index) => this(function_, value, index));
        return Promise.all(promises);
      }
    }
  });
  return generator;
}
function validateConcurrency(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
}
var wasm = null;
try {
  wasm = new WebAssembly.Instance(
    new WebAssembly.Module(
      new Uint8Array([
        // \0asm
        0,
        97,
        115,
        109,
        // version 1
        1,
        0,
        0,
        0,
        // section "type"
        1,
        13,
        2,
        // 0, () => i32
        96,
        0,
        1,
        127,
        // 1, (i32, i32, i32, i32) => i32
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        // section "function"
        3,
        7,
        6,
        // 0, type 0
        0,
        // 1, type 1
        1,
        // 2, type 1
        1,
        // 3, type 1
        1,
        // 4, type 1
        1,
        // 5, type 1
        1,
        // section "global"
        6,
        6,
        1,
        // 0, "high", mutable i32
        127,
        1,
        65,
        0,
        11,
        // section "export"
        7,
        50,
        6,
        // 0, "mul"
        3,
        109,
        117,
        108,
        0,
        1,
        // 1, "div_s"
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        // 2, "div_u"
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        // 3, "rem_s"
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        // 4, "rem_u"
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        // 5, "get_high"
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        // section "code"
        10,
        191,
        1,
        6,
        // 0, "get_high"
        4,
        0,
        35,
        0,
        11,
        // 1, "mul"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 2, "div_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 3, "div_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 4, "rem_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 5, "rem_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])
    ),
    {}
  ).exports;
} catch {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache) UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache) INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value)) return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0) return UZERO;
    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }
  if (value < 0) return fromNumber(-value, unsigned).neg();
  return fromBits(
    value % TWO_PWR_32_DBL | 0,
    value / TWO_PWR_32_DBL | 0,
    unsigned
  );
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0) throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i2 = 0; i2 < str.length; i2 += 8) {
    var size = Math.min(8, str.length - i2), value = parseInt(str.substring(i2, i2 + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number") return fromNumber(val, unsigned);
  if (typeof val === "string") return fromString(val, unsigned);
  return fromBits(
    val.low,
    val.high,
    typeof unsigned === "boolean" ? unsigned : val.unsigned
  );
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString2(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero()) return digits + result;
    else {
      while (digits.length < 6) digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isSafeInteger = function isSafeInteger() {
  var top11Bits = this.high >> 21;
  if (!top11Bits) return true;
  if (this.unsigned) return false;
  return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
};
LongPrototype.isZero = function isZero2() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven2() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals2(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.eq(other)) return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) return -1;
  if (!thisNeg && otherNeg) return 1;
  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add2(addend) {
  if (!isLong(addend)) addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero()) return this;
  if (!isLong(multiplier)) multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
    else return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (divisor.isZero()) throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE)) return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative()) return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned) divisor = divisor.toUnsigned();
    if (divisor.gt(this)) return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero()) approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or2(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low << numBits,
      this.high << numBits | this.low >>> 32 - numBits,
      this.unsigned
    );
  else return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >> numBits,
      this.unsigned
    );
  else
    return fromBits(
      this.high >> numBits - 32,
      this.high >= 0 ? 0 : -1,
      this.unsigned
    );
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >>> numBits,
      this.unsigned
    );
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(
      this.low << numBits | this.high >>> b,
      this.high << numBits | this.low >>> b,
      this.unsigned
    );
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(
    this.high << numBits | this.low >>> b,
    this.low << numBits | this.high >>> b,
    this.unsigned
  );
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(
      this.high << b | this.low >>> numBits,
      this.low << b | this.high >>> numBits,
      this.unsigned
    );
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(
    this.low << b | this.high >>> numBits,
    this.high << b | this.low >>> numBits,
    this.unsigned
  );
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned) return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned) return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le2) {
  return le2 ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long.fromBytes = function fromBytes(bytes, unsigned, le2) {
  return le2 ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
    bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
    unsigned
  );
};
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
    bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
    unsigned
  );
};
if (typeof BigInt === "function") {
  Long.fromBigInt = function fromBigInt(value, unsigned) {
    var lowBits = Number(BigInt.asIntN(32, value));
    var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
    return fromBits(lowBits, highBits, unsigned);
  };
  Long.fromValue = function fromValueWithBigInt(value, unsigned) {
    if (typeof value === "bigint") return Long.fromBigInt(value, unsigned);
    return fromValue(value, unsigned);
  };
  LongPrototype.toBigInt = function toBigInt() {
    var lowBigInt = BigInt(this.low >>> 0);
    var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
    return highBigInt << BigInt(32) | lowBigInt;
  };
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE2 = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i2, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i2 = v; i2 >= 10; i2 /= 10, e++) ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i2 = str.search(/e/i)) > 0) {
        if (e < 0) e = i2;
        e += +str.slice(i2 + 1);
        str = str.substring(0, i2);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET2.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round2(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET2.slice(0, b);
      e = i2 = 0;
      for (len = str.length; i2 < len; i2++) {
        if (alphabet.indexOf(c = str.charAt(i2)) < 0) {
          if (c == ".") {
            if (i2 > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i2 = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e = str.length;
    }
    for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i2, ++len)) {
      len -= i2;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i2 - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i2 = (e + 1) % LOG_BASE;
        if (e < 0) i2 += LOG_BASE;
        if (i2 < len) {
          if (i2) x.c.push(+str.slice(0, i2));
          for (len -= LOG_BASE; i2 < len; ) {
            x.c.push(+str.slice(i2, i2 += LOG_BASE));
          }
          i2 = LOG_BASE - (str = str.slice(i2)).length;
        } else {
          i2 -= len;
        }
        for (; i2--; str += "0") ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object") FORMAT = v;
          else throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET2 = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET: ALPHABET2
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber2.DEBUG) return true;
    var i2, n2, c = v.c, e = v.e, s = v.s;
    out: if ({}.toString.call(c) == "[object Array]") {
      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }
        i2 = (e + 1) % LOG_BASE;
        if (i2 < 1) i2 += LOG_BASE;
        if (String(c[0]).length == i2) {
          for (i2 = 0; i2 < c.length; i2++) {
            n2 = c[i2];
            if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2)) break out;
          }
          if (n2 !== 0) return true;
        }
      }
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = (function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i2 = 0, c = [], rand = new BigNumber2(ONE2);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i2 < k; ) {
            v = a[i2] * 131072 + (a[i2 + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i2] = b[0];
              a[i2 + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i2 += 2;
            }
          }
          i2 = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i2 < k; ) {
            v = (a[i2] & 31) * 281474976710656 + a[i2 + 1] * 1099511627776 + a[i2 + 2] * 4294967296 + a[i2 + 3] * 16777216 + (a[i2 + 4] << 16) + (a[i2 + 5] << 8) + a[i2 + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i2);
            } else {
              c.push(v % 1e14);
              i2 += 7;
            }
          }
          i2 = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i2 < k; ) {
          v = random53bitInt();
          if (v < 9e15) c[i2++] = v % 1e14;
        }
      }
      k = c[--i2];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i2] = mathfloor(k / v) * v;
      }
      for (; c[i2] === 0; c.pop(), i2--) ;
      if (i2 < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
        for (i2 = 1, v = c[0]; v >= 10; v /= 10, i2++) ;
        if (i2 < LOG_BASE) e -= LOG_BASE - i2;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  })();
  BigNumber2.sum = function() {
    var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ (function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i2 = 0, len = str.length;
      for (; i2 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet.indexOf(str.charAt(i2++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet, d, e, k, r2, x, xc, y, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i2 >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i2);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET2, decimal) : (alphabet = decimal, ALPHABET2));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop()) ;
      if (!xc[0]) return alphabet.charAt(0);
      if (i2 < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign2;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r2 = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i2 = xc[d];
      k = baseOut / 2;
      r2 = r2 || d < 0 || xc[d + 1] != null;
      r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i2 > k || i2 == k && (rm == 4 || r2 || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r2) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; ) ;
        for (i2 = 0, str = ""; i2 <= k; str += alphabet.charAt(xc[i2++])) ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  })();
  div = /* @__PURE__ */ (function() {
    function multiply2(x, k, base2) {
      var m, temp, xlo, xhi, carry = 0, i2 = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i2--; ) {
        xlo = x[i2] % SQRT_BASE;
        xhi = x[i2] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base2 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i2] = temp % base2;
      }
      if (carry) x = [carry].concat(x);
      return x;
    }
    function compare3(a, b, aL, bL) {
      var i2, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i2 = cmp = 0; i2 < aL; i2++) {
          if (a[i2] != b[i2]) {
            cmp = a[i2] > b[i2] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract2(a, b, aL, base2) {
      var i2 = 0;
      for (; aL--; ) {
        a[aL] -= i2;
        i2 = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i2 * base2 + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
    }
    return function(x, y, dp, rm, base2) {
      var cmp, e, i2, more, n2, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base2) {
        base2 = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
      if (yc[i2] > (xc[i2] || 0)) e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i2 = 0;
        s += 2;
        n2 = mathfloor(base2 / (yc[0] + 1));
        if (n2 > 1) {
          yc = multiply2(yc, n2, base2);
          xc = multiply2(xc, n2, base2);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base2 / 2) yc0++;
        do {
          n2 = 0;
          cmp = compare3(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
            n2 = mathfloor(rem0 / yc0);
            if (n2 > 1) {
              if (n2 >= base2) n2 = base2 - 1;
              prod = multiply2(yc, n2, base2);
              prodL = prod.length;
              remL = rem.length;
              while (compare3(prod, rem, prodL, remL) == 1) {
                n2--;
                subtract2(prod, yL < prodL ? yz : yc, prodL, base2);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n2 == 0) {
                cmp = n2 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract2(rem, prod, remL, base2);
            remL = rem.length;
            if (cmp == -1) {
              while (compare3(yc, rem, yL, remL) < 1) {
                n2++;
                subtract2(rem, yL < remL ? yz : yc, remL, base2);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n2++;
            rem = [0];
          }
          qc[i2++] = n2;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base2 == BASE) {
        for (i2 = 1, s = qc[0]; s >= 10; s /= 10, i2++) ;
        round2(q, dp + (q.e = i2 + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  })();
  function format(n2, i2, rm, id2) {
    var c0, e, ne2, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n2.c) return n2.toString();
    c0 = n2.c[0];
    ne2 = n2.e;
    if (i2 == null) {
      str = coeffToString(n2.c);
      str = id2 == 1 || id2 == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
    } else {
      n2 = round2(new BigNumber2(n2), i2, rm);
      e = n2.e;
      str = coeffToString(n2.c);
      len = str.length;
      if (id2 == 1 || id2 == 2 && (i2 <= e || e <= TO_EXP_NEG)) {
        for (; len < i2; str += "0", len++) ;
        str = toExponential(str, e);
      } else {
        i2 -= ne2 + (id2 === 2 && e > ne2);
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i2 > 0) for (str += "."; i2--; str += "0") ;
        } else {
          i2 += e - len;
          if (i2 > 0) {
            if (e + 1 == len) str += ".";
            for (; i2--; str += "0") ;
          }
        }
      }
    }
    return n2.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n2) {
    var k, y, i2 = 1, x = new BigNumber2(args[0]);
    for (; i2 < args.length; i2++) {
      y = new BigNumber2(args[i2]);
      if (!y.s || (k = compare2(x, y)) === n2 || k === 0 && x.s === n2) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n2, c, e) {
    var i2 = 1, j = c.length;
    for (; !c[--j]; c.pop()) ;
    for (j = c[0]; j >= 10; j /= 10, i2++) ;
    if ((e = i2 + e * LOG_BASE - 1) > MAX_EXP) {
      n2.c = n2.e = null;
    } else if (e < MIN_EXP) {
      n2.c = [n2.e = 0];
    } else {
      n2.e = e;
      n2.c = c;
    }
    return n2;
  }
  parseNumeric = /* @__PURE__ */ (function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base2, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base2 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base2 ? p1 : m;
          });
          if (b) {
            base2 = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s) return new BigNumber2(s, base2);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  })();
  function round2(x, sd, rm, r2) {
    var d, i2, j, k, n2, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
        i2 = sd - d;
        if (i2 < 0) {
          i2 += LOG_BASE;
          j = sd;
          n2 = xc[ni = 0];
          rd = mathfloor(n2 / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i2 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r2) {
              for (; xc.length <= ni; xc.push(0)) ;
              n2 = rd = 0;
              d = 1;
              i2 %= LOG_BASE;
              j = i2 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n2 = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++) ;
            i2 %= LOG_BASE;
            j = i2 - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n2 / pows10[d - j - 1] % 10);
          }
        }
        r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n2 : n2 % pows10[d - j - 1]);
        r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i2 > 0 ? j > 0 ? n2 / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r2) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i2 == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i2];
          xc[ni] = j > 0 ? mathfloor(n2 / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r2) {
          for (; ; ) {
            if (ni == 0) {
              for (i2 = 1, j = xc[0]; j >= 10; j /= 10, i2++) ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++) ;
              if (i2 != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n2) {
    var str, e = n2.e;
    if (e === null) return n2.toString();
    str = coeffToString(n2.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n2.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0) x.s = 1;
    return x;
  };
  P2.comparedTo = function(y, b) {
    return compare2(this, new BigNumber2(y, b));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c, n2, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round2(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c)) return null;
    n2 = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n2--) ;
    if (n2 < 0) n2 = 0;
    return n2;
  };
  P2.dividedBy = P2.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n2, m) {
    var half, isModExp, i2, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n2 = new BigNumber2(n2);
    if (n2.c && !n2.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
    }
    if (m != null) m = new BigNumber2(m);
    nIsBig = n2.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n2.c || !n2.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n2.s * (2 - isOdd2(n2)) : +valueOf(n2)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n2.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp) x = x.mod(m);
    } else if (n2.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd2(n2) ? -0 : 0;
      if (x.e > -1) k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg) n2.s = 1;
      nIsOdd = isOdd2(n2);
    } else {
      i2 = Math.abs(+valueOf(n2));
      nIsOdd = i2 % 2;
    }
    y = new BigNumber2(ONE2);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;
        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i2) {
        i2 = mathfloor(i2 / 2);
        if (i2 === 0) break;
        nIsOdd = i2 % 2;
      } else {
        n2 = n2.times(half);
        round2(n2, n2.e + 1, 1);
        if (n2.e > 14) {
          nIsOdd = isOdd2(n2);
        } else {
          i2 = +valueOf(n2);
          if (i2 === 0) break;
          nIsOdd = i2 % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp) return y;
    if (nIsNeg) y = ONE2.div(y);
    return m ? y.mod(m) : k ? round2(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P2.integerValue = function(rm) {
    var n2 = new BigNumber2(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round2(n2, n2.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y, b) {
    return compare2(this, new BigNumber2(y, b)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y, b) {
    return compare2(this, new BigNumber2(y, b)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y, b) {
    return (b = compare2(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y, b) {
    return compare2(this, new BigNumber2(y, b)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y, b) {
    return (b = compare2(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y, b) {
    var i2, j, t2, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe2 = x.e / LOG_BASE, ye2 = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe2 || !ye2) {
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe2 = bitFloor(xe2);
    ye2 = bitFloor(ye2);
    xc = xc.slice();
    if (a = xe2 - ye2) {
      if (xLTy = a < 0) {
        a = -a;
        t2 = xc;
      } else {
        ye2 = xe2;
        t2 = yc;
      }
      t2.reverse();
      for (b = a; b--; t2.push(0)) ;
      t2.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy) {
      t2 = xc;
      xc = yc;
      yc = t2;
      y.s = -y.s;
    }
    b = (j = yc.length) - (i2 = xc.length);
    if (b > 0) for (; b--; xc[i2++] = 0) ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i2 = j; i2 && !xc[--i2]; xc[i2] = b) ;
        --xc[i2];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye2) ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye2);
  };
  P2.modulo = P2.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    return y;
  };
  P2.multipliedBy = P2.times = function(y, b) {
    var c, e, i2, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base2, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i2 = xcL;
      xcL = ycL;
      ycL = i2;
    }
    for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
    base2 = BASE;
    sqrtBase = SQRT_BASE;
    for (i2 = ycL; --i2 >= 0; ) {
      c = 0;
      ylo = yc[i2] % sqrtBase;
      yhi = yc[i2] / sqrtBase | 0;
      for (k = xcL, j = i2 + k; j > i2; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base2 | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base2;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P2.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P2.plus = function(y, b) {
    var t2, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b) return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe2 = x.e / LOG_BASE, ye2 = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe2 || !ye2) {
      if (!xc || !yc) return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe2 = bitFloor(xe2);
    ye2 = bitFloor(ye2);
    xc = xc.slice();
    if (a = xe2 - ye2) {
      if (a > 0) {
        ye2 = xe2;
        t2 = yc;
      } else {
        a = -a;
        t2 = xc;
      }
      t2.reverse();
      for (; a--; t2.push(0)) ;
      t2.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0) {
      t2 = yc;
      yc = xc;
      xc = t2;
      b = a;
    }
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye2;
    }
    return normalise(y, xc, ye2);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c, n2, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round2(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c)) return null;
    v = c.length - 1;
    n2 = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n2--) ;
      for (v = c[0]; v >= 10; v /= 10, n2++) ;
    }
    if (sd && x.e + 1 > n2) n2 = x.e + 1;
    return n2;
  };
  P2.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m, n2, r2, rep, t2, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n2 = coeffToString(c);
      if ((n2.length + e) % 2 == 0) n2 += "0";
      s = Math.sqrt(+n2);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n2 = "5e" + e;
      } else {
        n2 = s.toExponential();
        n2 = n2.slice(0, n2.indexOf("e") + 1) + e;
      }
      r2 = new BigNumber2(n2);
    } else {
      r2 = new BigNumber2(s + "");
    }
    if (r2.c[0]) {
      e = r2.e;
      s = e + dp;
      if (s < 3) s = 0;
      for (; ; ) {
        t2 = r2;
        r2 = half.times(t2.plus(div(x, t2, dp, 1)));
        if (coeffToString(t2.c).slice(0, s) === (n2 = coeffToString(r2.c)).slice(0, s)) {
          if (r2.e < e) --s;
          n2 = n2.slice(s - 3, s + 1);
          if (n2 == "9999" || !rep && n2 == "4999") {
            if (!rep) {
              round2(t2, t2.e + DECIMAL_PLACES + 2, 0);
              if (t2.times(t2).eq(x)) {
                r2 = t2;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
              round2(r2, r2.e + DECIMAL_PLACES + 2, 1);
              m = !r2.times(r2).eq(x);
            }
            break;
          }
        }
      }
    }
    return round2(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i2 = g1;
        g1 = g2;
        g2 = i2;
        len -= i2;
      }
      if (g1 > 0 && len > 0) {
        i2 = len % g1 || g1;
        intPart = intDigits.substr(0, i2);
        for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n2, n0, n1, q, r2, s, x = this, xc = x.c;
    if (md != null) {
      n2 = new BigNumber2(md);
      if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE2)) {
        throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
      }
    }
    if (!xc) return new BigNumber2(x);
    d = new BigNumber2(ONE2);
    n1 = d0 = new BigNumber2(ONE2);
    d1 = n0 = new BigNumber2(ONE2);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n2.comparedTo(d) > 0 ? e > 0 ? d : n1 : n2;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n2 = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n2, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n2.minus(q.times(d2 = d));
      n2 = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r2 = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r2;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b) {
    var str, n2 = this, s = n2.s, e = n2.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e) : toFixedPoint(coeffToString(n2.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n2 = round2(new BigNumber2(n2), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
      } else {
        intCheck(b, 2, ALPHABET2.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n2.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n2.c[0]) str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null) BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n2) {
  var i2 = n2 | 0;
  return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
}
function coeffToString(a) {
  var s, z2, i2 = 1, j = a.length, r2 = a[0] + "";
  for (; i2 < j; ) {
    s = a[i2++] + "";
    z2 = LOG_BASE - s.length;
    for (; z2--; s = "0" + s) ;
    r2 += s;
  }
  for (j = r2.length; r2.charCodeAt(--j) === 48; ) ;
  return r2.slice(0, j + 1 || 1);
}
function compare2(x, y) {
  var a, b, xc = x.c, yc = y.c, i2 = x.s, j = y.s, k = x.e, l = y.e;
  if (!i2 || !j) return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b) return a ? b ? 0 : -j : i2;
  if (i2 != j) return i2;
  a = i2 < 0;
  b = k == l;
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b) return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i2 = 0; i2 < j; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n2, min2, max2, name) {
  if (n2 < min2 || n2 > max2 || n2 !== mathfloor(n2)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min2 || n2 > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
  }
}
function isOdd2(n2) {
  var k = n2.c.length - 1;
  return bitFloor(n2.e / LOG_BASE) == k && n2.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z2) {
  var len, zs;
  if (e < 0) {
    for (zs = z2 + "."; ++e; zs += z2) ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z2, e -= len; --e; zs += z2) ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();

// node_modules/opnet/browser/protobuf.js
var protobuf_min = { exports: {} };
var hasRequiredProtobuf_min;
function requireProtobuf_min() {
  if (hasRequiredProtobuf_min) return protobuf_min.exports;
  hasRequiredProtobuf_min = 1;
  (function(module) {
    !(function(it) {
      !(function(r2, e, t2) {
        var i2 = (function t3(i3) {
          var n2 = e[i3];
          return n2 || r2[i3][0].call(n2 = e[i3] = { exports: {} }, t3, n2, n2.exports), n2.exports;
        })(t2[0]);
        i2.util.global.protobuf = i2, module && module.exports && (module.exports = i2);
      })({ 1: [function(t2, i2, n2) {
        i2.exports = function(t3, i3) {
          var n3 = Array(arguments.length - 1), s = 0, r2 = 2, o = true;
          for (; r2 < arguments.length; ) n3[s++] = arguments[r2++];
          return new Promise(function(r3, e) {
            n3[s] = function(t4) {
              if (o) if (o = false, t4) e(t4);
              else {
                for (var i4 = Array(arguments.length - 1), n4 = 0; n4 < i4.length; ) i4[n4++] = arguments[n4];
                r3.apply(null, i4);
              }
            };
            try {
              t3.apply(i3 || null, n3);
            } catch (t4) {
              o && (o = false, e(t4));
            }
          });
        };
      }, {}], 2: [function(t2, i2, n2) {
        n2.length = function(t3) {
          var i3 = t3.length;
          if (!i3) return 0;
          for (var n3 = 0; 1 < --i3 % 4 && "=" == (t3[0 | i3] || ""); ) ++n3;
          return Math.ceil(3 * t3.length) / 4 - n3;
        };
        for (var h = Array(64), f = Array(123), r2 = 0; r2 < 64; ) f[h[r2] = r2 < 26 ? r2 + 65 : r2 < 52 ? r2 + 71 : r2 < 62 ? r2 - 4 : r2 - 59 | 43] = r2++;
        n2.encode = function(t3, i3, n3) {
          for (var r3, e = null, s = [], o = 0, u = 0; i3 < n3; ) {
            var f2 = t3[i3++];
            switch (u) {
              case 0:
                s[o++] = h[f2 >> 2], r3 = (3 & f2) << 4, u = 1;
                break;
              case 1:
                s[o++] = h[r3 | f2 >> 4], r3 = (15 & f2) << 2, u = 2;
                break;
              case 2:
                s[o++] = h[r3 | f2 >> 6], s[o++] = h[63 & f2], u = 0;
            }
            8191 < o && ((e = e || []).push(String.fromCharCode.apply(String, s)), o = 0);
          }
          return u && (s[o++] = h[r3], s[o++] = 61, 1 === u && (s[o++] = 61)), e ? (o && e.push(String.fromCharCode.apply(String, s.slice(0, o))), e.join("")) : String.fromCharCode.apply(String, s.slice(0, o));
        };
        var a = "invalid encoding";
        n2.decode = function(t3, i3, n3) {
          for (var r3, e = n3, s = 0, o = 0; o < t3.length; ) {
            var u = t3.charCodeAt(o++);
            if (61 == u && 1 < s) break;
            if ((u = f[u]) === it) throw Error(a);
            switch (s) {
              case 0:
                r3 = u, s = 1;
                break;
              case 1:
                i3[n3++] = r3 << 2 | (48 & u) >> 4, r3 = u, s = 2;
                break;
              case 2:
                i3[n3++] = (15 & r3) << 4 | (60 & u) >> 2, r3 = u, s = 3;
                break;
              case 3:
                i3[n3++] = (3 & r3) << 6 | u, s = 0;
            }
          }
          if (1 === s) throw Error(a);
          return n3 - e;
        }, n2.test = function(t3) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t3);
        };
      }, {}], 3: [function(t2, i2, n2) {
        function c(i3, n3) {
          "string" == typeof i3 && (n3 = i3, i3 = it);
          var f = [];
          function h(t3) {
            if ("string" != typeof t3) {
              var i4 = a();
              if (c.verbose && console.log("codegen: " + i4), i4 = "return " + i4, t3) {
                for (var n4 = Object.keys(t3), r2 = Array(n4.length + 1), e = Array(n4.length), s = 0; s < n4.length; ) r2[s] = n4[s], e[s] = t3[n4[s++]];
                return r2[s] = i4, Function.apply(null, r2).apply(null, e);
              }
              return Function(i4)();
            }
            for (var o = Array(arguments.length - 1), u = 0; u < o.length; ) o[u] = arguments[++u];
            if (u = 0, t3 = t3.replace(/%([%dfijs])/g, function(t4, i5) {
              var n5 = o[u++];
              switch (i5) {
                case "d":
                case "f":
                  return "" + +("" + n5);
                case "i":
                  return "" + Math.floor(n5);
                case "j":
                  return JSON.stringify(n5);
                case "s":
                  return "" + n5;
              }
              return "%";
            }), u !== o.length) throw Error("parameter count mismatch");
            return f.push(t3), h;
          }
          function a(t3) {
            return "function " + (t3 || n3 || "") + "(" + (i3 && i3.join(",") || "") + "){\n  " + f.join("\n  ") + "\n}";
          }
          return h.toString = a, h;
        }
        (i2.exports = c).verbose = false;
      }, {}], 4: [function(t2, i2, n2) {
        function r2() {
          this.i = {};
        }
        (i2.exports = r2).prototype.on = function(t3, i3, n3) {
          return (this.i[t3] || (this.i[t3] = [])).push({ fn: i3, ctx: n3 || this }), this;
        }, r2.prototype.off = function(t3, i3) {
          if (t3 === it) this.i = {};
          else if (i3 === it) this.i[t3] = [];
          else for (var n3 = this.i[t3], r3 = 0; r3 < n3.length; ) n3[r3].fn === i3 ? n3.splice(r3, 1) : ++r3;
          return this;
        }, r2.prototype.emit = function(t3) {
          var i3 = this.i[t3];
          if (i3) {
            for (var n3 = [], r3 = 1; r3 < arguments.length; ) n3.push(arguments[r3++]);
            for (r3 = 0; r3 < i3.length; ) i3[r3].fn.apply(i3[r3++].ctx, n3);
          }
          return this;
        };
      }, {}], 5: [function(t2, i2, n2) {
        i2.exports = u;
        var s = t2(1), o = t2(7)("fs");
        function u(n3, r2, e) {
          return r2 = "function" == typeof r2 ? (e = r2, {}) : r2 || {}, e ? !r2.xhr && o && o.readFile ? o.readFile(n3, function(t3, i3) {
            return t3 && "undefined" != typeof XMLHttpRequest ? u.xhr(n3, r2, e) : t3 ? e(t3) : e(null, r2.binary ? i3 : i3.toString("utf8"));
          }) : u.xhr(n3, r2, e) : s(u, this, n3, r2);
        }
        u.xhr = function(t3, n3, r2) {
          var e = new XMLHttpRequest();
          e.onreadystatechange = function() {
            if (4 !== e.readyState) return it;
            if (0 !== e.status && 200 !== e.status) return r2(Error("status " + e.status));
            if (n3.binary) {
              if (!(t4 = e.response)) for (var t4 = [], i3 = 0; i3 < e.responseText.length; ++i3) t4.push(255 & e.responseText.charCodeAt(i3));
              return r2(null, "undefined" != typeof Uint8Array ? new Uint8Array(t4) : t4);
            }
            return r2(null, e.responseText);
          }, n3.binary && ("overrideMimeType" in e && e.overrideMimeType("text/plain; charset=x-user-defined"), e.responseType = "arraybuffer"), e.open("GET", t3), e.send();
        };
      }, { 1: 1, 7: 7 }], 6: [function(t2, i2, n2) {
        function r2(t3) {
          function i3(t4, i4, n4, r4) {
            var e2 = i4 < 0 ? 1 : 0;
            t4(0 === (i4 = e2 ? -i4 : i4) ? 0 < 1 / i4 ? 0 : 2147483648 : isNaN(i4) ? 2143289344 : 34028234663852886e22 < i4 ? (e2 << 31 | 2139095040) >>> 0 : i4 < 11754943508222875e-54 ? (e2 << 31 | Math.round(i4 / 1401298464324817e-60)) >>> 0 : (e2 << 31 | 127 + (t4 = Math.floor(Math.log(i4) / Math.LN2)) << 23 | 8388607 & Math.round(i4 * Math.pow(2, -t4) * 8388608)) >>> 0, n4, r4);
          }
          function n3(t4, i4, n4) {
            t4 = t4(i4, n4), i4 = 2 * (t4 >> 31) + 1, n4 = t4 >>> 23 & 255, t4 &= 8388607;
            return 255 == n4 ? t4 ? NaN : 1 / 0 * i4 : 0 == n4 ? 1401298464324817e-60 * i4 * t4 : i4 * Math.pow(2, n4 - 150) * (8388608 + t4);
          }
          function r3(t4, i4, n4) {
            u[0] = t4, i4[n4] = f[0], i4[n4 + 1] = f[1], i4[n4 + 2] = f[2], i4[n4 + 3] = f[3];
          }
          function e(t4, i4, n4) {
            u[0] = t4, i4[n4] = f[3], i4[n4 + 1] = f[2], i4[n4 + 2] = f[1], i4[n4 + 3] = f[0];
          }
          function s(t4, i4) {
            return f[0] = t4[i4], f[1] = t4[i4 + 1], f[2] = t4[i4 + 2], f[3] = t4[i4 + 3], u[0];
          }
          function o(t4, i4) {
            return f[3] = t4[i4], f[2] = t4[i4 + 1], f[1] = t4[i4 + 2], f[0] = t4[i4 + 3], u[0];
          }
          var u, f, h, a, c;
          function l(t4, i4, n4, r4, e2, s2) {
            var o2, u2 = r4 < 0 ? 1 : 0;
            0 === (r4 = u2 ? -r4 : r4) ? (t4(0, e2, s2 + i4), t4(0 < 1 / r4 ? 0 : 2147483648, e2, s2 + n4)) : isNaN(r4) ? (t4(0, e2, s2 + i4), t4(2146959360, e2, s2 + n4)) : 17976931348623157e292 < r4 ? (t4(0, e2, s2 + i4), t4((u2 << 31 | 2146435072) >>> 0, e2, s2 + n4)) : r4 < 22250738585072014e-324 ? (t4((o2 = r4 / 5e-324) >>> 0, e2, s2 + i4), t4((u2 << 31 | o2 / 4294967296) >>> 0, e2, s2 + n4)) : (t4(4503599627370496 * (o2 = r4 * Math.pow(2, -(r4 = 1024 === (r4 = Math.floor(Math.log(r4) / Math.LN2)) ? 1023 : r4))) >>> 0, e2, s2 + i4), t4((u2 << 31 | r4 + 1023 << 20 | 1048576 * o2 & 1048575) >>> 0, e2, s2 + n4));
          }
          function d(t4, i4, n4, r4, e2) {
            i4 = t4(r4, e2 + i4), t4 = t4(r4, e2 + n4), r4 = 2 * (t4 >> 31) + 1, e2 = t4 >>> 20 & 2047, n4 = 4294967296 * (1048575 & t4) + i4;
            return 2047 == e2 ? n4 ? NaN : 1 / 0 * r4 : 0 == e2 ? 5e-324 * r4 * n4 : r4 * Math.pow(2, e2 - 1075) * (n4 + 4503599627370496);
          }
          function p(t4, i4, n4) {
            h[0] = t4, i4[n4] = a[0], i4[n4 + 1] = a[1], i4[n4 + 2] = a[2], i4[n4 + 3] = a[3], i4[n4 + 4] = a[4], i4[n4 + 5] = a[5], i4[n4 + 6] = a[6], i4[n4 + 7] = a[7];
          }
          function v(t4, i4, n4) {
            h[0] = t4, i4[n4] = a[7], i4[n4 + 1] = a[6], i4[n4 + 2] = a[5], i4[n4 + 3] = a[4], i4[n4 + 4] = a[3], i4[n4 + 5] = a[2], i4[n4 + 6] = a[1], i4[n4 + 7] = a[0];
          }
          function b(t4, i4) {
            return a[0] = t4[i4], a[1] = t4[i4 + 1], a[2] = t4[i4 + 2], a[3] = t4[i4 + 3], a[4] = t4[i4 + 4], a[5] = t4[i4 + 5], a[6] = t4[i4 + 6], a[7] = t4[i4 + 7], h[0];
          }
          function w2(t4, i4) {
            return a[7] = t4[i4], a[6] = t4[i4 + 1], a[5] = t4[i4 + 2], a[4] = t4[i4 + 3], a[3] = t4[i4 + 4], a[2] = t4[i4 + 5], a[1] = t4[i4 + 6], a[0] = t4[i4 + 7], h[0];
          }
          return "undefined" != typeof Float32Array ? (u = new Float32Array([-0]), f = new Uint8Array(u.buffer), c = 128 === f[3], t3.writeFloatLE = c ? r3 : e, t3.writeFloatBE = c ? e : r3, t3.readFloatLE = c ? s : o, t3.readFloatBE = c ? o : s) : (t3.writeFloatLE = i3.bind(null, y), t3.writeFloatBE = i3.bind(null, m), t3.readFloatLE = n3.bind(null, g), t3.readFloatBE = n3.bind(null, j)), "undefined" != typeof Float64Array ? (h = new Float64Array([-0]), a = new Uint8Array(h.buffer), c = 128 === a[7], t3.writeDoubleLE = c ? p : v, t3.writeDoubleBE = c ? v : p, t3.readDoubleLE = c ? b : w2, t3.readDoubleBE = c ? w2 : b) : (t3.writeDoubleLE = l.bind(null, y, 0, 4), t3.writeDoubleBE = l.bind(null, m, 4, 0), t3.readDoubleLE = d.bind(null, g, 0, 4), t3.readDoubleBE = d.bind(null, j, 4, 0)), t3;
        }
        function y(t3, i3, n3) {
          i3[n3] = 255 & t3, i3[n3 + 1] = t3 >>> 8 & 255, i3[n3 + 2] = t3 >>> 16 & 255, i3[n3 + 3] = t3 >>> 24;
        }
        function m(t3, i3, n3) {
          i3[n3] = t3 >>> 24, i3[n3 + 1] = t3 >>> 16 & 255, i3[n3 + 2] = t3 >>> 8 & 255, i3[n3 + 3] = 255 & t3;
        }
        function g(t3, i3) {
          return (t3[i3] | t3[i3 + 1] << 8 | t3[i3 + 2] << 16 | t3[i3 + 3] << 24) >>> 0;
        }
        function j(t3, i3) {
          return (t3[i3] << 24 | t3[i3 + 1] << 16 | t3[i3 + 2] << 8 | t3[i3 + 3]) >>> 0;
        }
        i2.exports = r2(r2);
      }, {}], 7: [function(t, i, n) {
        function r(t) {
          try {
            var i = eval("require")(t);
            if (i && (i.length || Object.keys(i).length)) return i;
          } catch (t2) {
          }
          return null;
        }
        i.exports = r;
      }, {}], 8: [function(t2, i2, n2) {
        var e = n2.isAbsolute = function(t3) {
          return /^(?:\/|\w+:)/.test(t3);
        }, r2 = n2.normalize = function(t3) {
          var i3 = (t3 = t3.replace(/\\/g, "/").replace(/\/{2,}/g, "/")).split("/"), n3 = e(t3), t3 = "";
          n3 && (t3 = i3.shift() + "/");
          for (var r3 = 0; r3 < i3.length; ) ".." === i3[r3] ? 0 < r3 && ".." !== i3[r3 - 1] ? i3.splice(--r3, 2) : n3 ? i3.splice(r3, 1) : ++r3 : "." === i3[r3] ? i3.splice(r3, 1) : ++r3;
          return t3 + i3.join("/");
        };
        n2.resolve = function(t3, i3, n3) {
          return n3 || (i3 = r2(i3)), !e(i3) && (t3 = (t3 = n3 ? t3 : r2(t3)).replace(/(?:\/|^)[^/]+$/, "")).length ? r2(t3 + "/" + i3) : i3;
        };
      }, {}], 9: [function(t2, i2, n2) {
        i2.exports = function(i3, n3, t3) {
          var r2 = t3 || 8192, e = r2 >>> 1, s = null, o = r2;
          return function(t4) {
            if (t4 < 1 || e < t4) return i3(t4);
            r2 < o + t4 && (s = i3(r2), o = 0);
            t4 = n3.call(s, o, o += t4);
            return 7 & o && (o = 1 + (7 | o)), t4;
          };
        };
      }, {}], 10: [function(t2, i2, n2) {
        n2.length = function(t3) {
          for (var i3, n3 = 0, r2 = 0; r2 < t3.length; ++r2) (i3 = t3.charCodeAt(r2)) < 128 ? n3 += 1 : i3 < 2048 ? n3 += 2 : 55296 == (64512 & i3) && 56320 == (64512 & t3.charCodeAt(r2 + 1)) ? (++r2, n3 += 4) : n3 += 3;
          return n3;
        }, n2.read = function(t3, i3, n3) {
          if (n3 - i3 < 1) return "";
          for (var r2, e = null, s = [], o = 0; i3 < n3; ) (r2 = t3[i3++]) < 128 ? s[o++] = r2 : 191 < r2 && r2 < 224 ? s[o++] = (31 & r2) << 6 | 63 & t3[i3++] : 239 < r2 && r2 < 365 ? (r2 = ((7 & r2) << 18 | (63 & t3[i3++]) << 12 | (63 & t3[i3++]) << 6 | 63 & t3[i3++]) - 65536, s[o++] = 55296 + (r2 >> 10), s[o++] = 56320 + (1023 & r2)) : s[o++] = (15 & r2) << 12 | (63 & t3[i3++]) << 6 | 63 & t3[i3++], 8191 < o && ((e = e || []).push(String.fromCharCode.apply(String, s)), o = 0);
          return e ? (o && e.push(String.fromCharCode.apply(String, s.slice(0, o))), e.join("")) : String.fromCharCode.apply(String, s.slice(0, o));
        }, n2.write = function(t3, i3, n3) {
          for (var r2, e, s = n3, o = 0; o < t3.length; ++o) (r2 = t3.charCodeAt(o)) < 128 ? i3[n3++] = r2 : (r2 < 2048 ? i3[n3++] = r2 >> 6 | 192 : (55296 == (64512 & r2) && 56320 == (64512 & (e = t3.charCodeAt(o + 1))) ? (++o, i3[n3++] = (r2 = 65536 + ((1023 & r2) << 10) + (1023 & e)) >> 18 | 240, i3[n3++] = r2 >> 12 & 63 | 128) : i3[n3++] = r2 >> 12 | 224, i3[n3++] = r2 >> 6 & 63 | 128), i3[n3++] = 63 & r2 | 128);
          return n3 - s;
        };
      }, {}], 11: [function(t2, i2, n2) {
        i2.exports = e;
        var r2 = /\/|\./;
        function e(t3, i3) {
          r2.test(t3) || (t3 = "google/protobuf/" + t3 + ".proto", i3 = { nested: { google: { nested: { protobuf: { nested: i3 } } } } }), e[t3] = i3;
        }
        e("any", { Any: { fields: { type_url: { type: "string", id: 1 }, value: { type: "bytes", id: 2 } } } }), e("duration", { Duration: i2 = { fields: { seconds: { type: "int64", id: 1 }, nanos: { type: "int32", id: 2 } } } }), e("timestamp", { Timestamp: i2 }), e("empty", { Empty: { fields: {} } }), e("struct", { Struct: { fields: { fields: { keyType: "string", type: "Value", id: 1 } } }, Value: { oneofs: { kind: { oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"] } }, fields: { nullValue: { type: "NullValue", id: 1 }, numberValue: { type: "double", id: 2 }, stringValue: { type: "string", id: 3 }, boolValue: { type: "bool", id: 4 }, structValue: { type: "Struct", id: 5 }, listValue: { type: "ListValue", id: 6 } } }, NullValue: { values: { NULL_VALUE: 0 } }, ListValue: { fields: { values: { rule: "repeated", type: "Value", id: 1 } } } }), e("wrappers", { DoubleValue: { fields: { value: { type: "double", id: 1 } } }, FloatValue: { fields: { value: { type: "float", id: 1 } } }, Int64Value: { fields: { value: { type: "int64", id: 1 } } }, UInt64Value: { fields: { value: { type: "uint64", id: 1 } } }, Int32Value: { fields: { value: { type: "int32", id: 1 } } }, UInt32Value: { fields: { value: { type: "uint32", id: 1 } } }, BoolValue: { fields: { value: { type: "bool", id: 1 } } }, StringValue: { fields: { value: { type: "string", id: 1 } } }, BytesValue: { fields: { value: { type: "bytes", id: 1 } } } }), e("field_mask", { FieldMask: { fields: { paths: { rule: "repeated", type: "string", id: 1 } } } }), e.get = function(t3) {
          return e[t3] || null;
        };
      }, {}], 12: [function(t2, i2, n2) {
        var l = t2(15), d = t2(37);
        function o(t3, i3, n3, r2) {
          var e = false;
          if (i3.resolvedType) if (i3.resolvedType instanceof l) {
            t3("switch(d%s){", r2);
            for (var s = i3.resolvedType.values, o2 = Object.keys(s), u = 0; u < o2.length; ++u) s[o2[u]] !== i3.typeDefault || e || (t3("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', r2, r2, r2), i3.repeated || t3("break"), e = true), t3("case%j:", o2[u])("case %i:", s[o2[u]])("m%s=%j", r2, s[o2[u]])("break");
            t3("}");
          } else t3('if(typeof d%s!=="object")', r2)("throw TypeError(%j)", i3.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", r2, n3, r2);
          else {
            var f = false;
            switch (i3.type) {
              case "double":
              case "float":
                t3("m%s=Number(d%s)", r2, r2);
                break;
              case "uint32":
              case "fixed32":
                t3("m%s=d%s>>>0", r2, r2);
                break;
              case "int32":
              case "sint32":
              case "sfixed32":
                t3("m%s=d%s|0", r2, r2);
                break;
              case "uint64":
                f = true;
              case "int64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                t3("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", r2, r2, f)('else if(typeof d%s==="string")', r2)("m%s=parseInt(d%s,10)", r2, r2)('else if(typeof d%s==="number")', r2)("m%s=d%s", r2, r2)('else if(typeof d%s==="object")', r2)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", r2, r2, r2, f ? "true" : "");
                break;
              case "bytes":
                t3('if(typeof d%s==="string")', r2)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", r2, r2, r2)("else if(d%s.length >= 0)", r2)("m%s=d%s", r2, r2);
                break;
              case "string":
                t3("m%s=String(d%s)", r2, r2);
                break;
              case "bool":
                t3("m%s=Boolean(d%s)", r2, r2);
            }
          }
          return t3;
        }
        function p(t3, i3, n3, r2) {
          if (i3.resolvedType) i3.resolvedType instanceof l ? t3("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", r2, n3, r2, r2, n3, r2, r2) : t3("d%s=types[%i].toObject(m%s,o)", r2, n3, r2);
          else {
            var e = false;
            switch (i3.type) {
              case "double":
              case "float":
                t3("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", r2, r2, r2, r2);
                break;
              case "uint64":
                e = true;
              case "int64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                t3('if(typeof m%s==="number")', r2)("d%s=o.longs===String?String(m%s):m%s", r2, r2, r2)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", r2, r2, r2, r2, e ? "true" : "", r2);
                break;
              case "bytes":
                t3("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", r2, r2, r2, r2, r2);
                break;
              default:
                t3("d%s=m%s", r2, r2);
            }
          }
          return t3;
        }
        n2.fromObject = function(t3) {
          var i3 = t3.fieldsArray, n3 = d.codegen(["d"], t3.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
          if (!i3.length) return n3("return new this.ctor");
          n3("var m=new this.ctor");
          for (var r2 = 0; r2 < i3.length; ++r2) {
            var e = i3[r2].resolve(), s = d.safeProp(e.name);
            e.map ? (n3("if(d%s){", s)('if(typeof d%s!=="object")', s)("throw TypeError(%j)", e.fullName + ": object expected")("m%s={}", s)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", s), o(n3, e, r2, s + "[ks[i]]")("}")("}")) : e.repeated ? (n3("if(d%s){", s)("if(!Array.isArray(d%s))", s)("throw TypeError(%j)", e.fullName + ": array expected")("m%s=[]", s)("for(var i=0;i<d%s.length;++i){", s), o(n3, e, r2, s + "[i]")("}")("}")) : (e.resolvedType instanceof l || n3("if(d%s!=null){", s), o(n3, e, r2, s), e.resolvedType instanceof l || n3("}"));
          }
          return n3("return m");
        }, n2.toObject = function(t3) {
          var i3 = t3.fieldsArray.slice().sort(d.compareFieldsById);
          if (!i3.length) return d.codegen()("return {}");
          for (var n3 = d.codegen(["m", "o"], t3.name + "$toObject")("if(!o)")("o={}")("var d={}"), r2 = [], e = [], s = [], o2 = 0; o2 < i3.length; ++o2) i3[o2].partOf || (i3[o2].resolve().repeated ? r2 : i3[o2].map ? e : s).push(i3[o2]);
          if (r2.length) {
            for (n3("if(o.arrays||o.defaults){"), o2 = 0; o2 < r2.length; ++o2) n3("d%s=[]", d.safeProp(r2[o2].name));
            n3("}");
          }
          if (e.length) {
            for (n3("if(o.objects||o.defaults){"), o2 = 0; o2 < e.length; ++o2) n3("d%s={}", d.safeProp(e[o2].name));
            n3("}");
          }
          if (s.length) {
            for (n3("if(o.defaults){"), o2 = 0; o2 < s.length; ++o2) {
              var u, f = s[o2], h = d.safeProp(f.name);
              f.resolvedType instanceof l ? n3("d%s=o.enums===String?%j:%j", h, f.resolvedType.valuesById[f.typeDefault], f.typeDefault) : f.long ? n3("if(util.Long){")("var n=new util.Long(%i,%i,%j)", f.typeDefault.low, f.typeDefault.high, f.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", h)("}else")("d%s=o.longs===String?%j:%i", h, f.typeDefault.toString(), f.typeDefault.toNumber()) : f.bytes ? (u = "[" + Array.prototype.slice.call(f.typeDefault).join(",") + "]", n3("if(o.bytes===String)d%s=%j", h, String.fromCharCode.apply(String, f.typeDefault))("else{")("d%s=%s", h, u)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", h, h)("}")) : n3("d%s=%j", h, f.typeDefault);
            }
            n3("}");
          }
          for (var a = false, o2 = 0; o2 < i3.length; ++o2) {
            var f = i3[o2], c = t3.e.indexOf(f), h = d.safeProp(f.name);
            f.map ? (a || (a = true, n3("var ks2")), n3("if(m%s&&(ks2=Object.keys(m%s)).length){", h, h)("d%s={}", h)("for(var j=0;j<ks2.length;++j){"), p(n3, f, c, h + "[ks2[j]]")("}")) : f.repeated ? (n3("if(m%s&&m%s.length){", h, h)("d%s=[]", h)("for(var j=0;j<m%s.length;++j){", h), p(n3, f, c, h + "[j]")("}")) : (n3("if(m%s!=null&&m.hasOwnProperty(%j)){", h, f.name), p(n3, f, c, h), f.partOf && n3("if(o.oneofs)")("d%s=%j", d.safeProp(f.partOf.name), f.name)), n3("}");
          }
          return n3("return d");
        };
      }, { 15: 15, 37: 37 }], 13: [function(t2, i2, n2) {
        i2.exports = function(t3) {
          for (var i3 = h.codegen(["r", "l", "e"], t3.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (t3.fieldsArray.filter(function(t4) {
            return t4.map;
          }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")("switch(t>>>3){"), n3 = 0; n3 < t3.fieldsArray.length; ++n3) {
            var r2 = t3.e[n3].resolve(), e = r2.resolvedType instanceof u ? "int32" : r2.type, s = "m" + h.safeProp(r2.name);
            i3("case %i: {", r2.id), r2.map ? (i3("if(%s===util.emptyObject)", s)("%s={}", s)("var c2 = r.uint32()+r.pos"), f.defaults[r2.keyType] !== it ? i3("k=%j", f.defaults[r2.keyType]) : i3("k=null"), f.defaults[e] !== it ? i3("value=%j", f.defaults[e]) : i3("value=null"), i3("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", r2.keyType)("case 2:"), f.basic[e] === it ? i3("value=types[%i].decode(r,r.uint32())", n3) : i3("value=r.%s()", e), i3("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"), f.long[r2.keyType] !== it ? i3('%s[typeof k==="object"?util.longToHash(k):k]=value', s) : i3("%s[k]=value", s)) : r2.repeated ? (i3("if(!(%s&&%s.length))", s, s)("%s=[]", s), f.packed[e] !== it && i3("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", s, e)("}else"), f.basic[e] === it ? i3(r2.delimited ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))" : "%s.push(types[%i].decode(r,r.uint32()))", s, n3) : i3("%s.push(r.%s())", s, e)) : f.basic[e] === it ? i3(r2.delimited ? "%s=types[%i].decode(r,undefined,((t&~7)|4))" : "%s=types[%i].decode(r,r.uint32())", s, n3) : i3("%s=r.%s()", s, e), i3("break")("}");
          }
          for (i3("default:")("r.skipType(t&7)")("break")("}")("}"), n3 = 0; n3 < t3.e.length; ++n3) {
            var o = t3.e[n3];
            o.required && i3("if(!m.hasOwnProperty(%j))", o.name)("throw util.ProtocolError(%j,{instance:m})", "missing required '" + o.name + "'");
          }
          return i3("return m");
        };
        var u = t2(15), f = t2(36), h = t2(37);
      }, { 15: 15, 36: 36, 37: 37 }], 14: [function(t2, i2, n2) {
        i2.exports = function(t3) {
          for (var i3, n3 = c.codegen(["m", "w"], t3.name + "$encode")("if(!w)")("w=Writer.create()"), r2 = t3.fieldsArray.slice().sort(c.compareFieldsById), e = 0; e < r2.length; ++e) {
            var s = r2[e].resolve(), o = t3.e.indexOf(s), u = s.resolvedType instanceof h ? "int32" : s.type, f = a.basic[u];
            i3 = "m" + c.safeProp(s.name), s.map ? (n3("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", i3, s.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", i3)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (s.id << 3 | 2) >>> 0, 8 | a.mapKey[s.keyType], s.keyType), f === it ? n3("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", o, i3) : n3(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | f, u, i3), n3("}")("}")) : s.repeated ? (n3("if(%s!=null&&%s.length){", i3, i3), s.packed && a.packed[u] !== it ? n3("w.uint32(%i).fork()", (s.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", i3)("w.%s(%s[i])", u, i3)("w.ldelim()") : (n3("for(var i=0;i<%s.length;++i)", i3), f === it ? l(n3, s, o, i3 + "[i]") : n3("w.uint32(%i).%s(%s[i])", (s.id << 3 | f) >>> 0, u, i3)), n3("}")) : (s.optional && n3("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", i3, s.name), f === it ? l(n3, s, o, i3) : n3("w.uint32(%i).%s(%s)", (s.id << 3 | f) >>> 0, u, i3));
          }
          return n3("return w");
        };
        var h = t2(15), a = t2(36), c = t2(37);
        function l(t3, i3, n3, r2) {
          i3.delimited ? t3("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", n3, r2, (i3.id << 3 | 3) >>> 0, (i3.id << 3 | 4) >>> 0) : t3("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", n3, r2, (i3.id << 3 | 2) >>> 0);
        }
      }, { 15: 15, 36: 36, 37: 37 }], 15: [function(t2, i2, n2) {
        i2.exports = s;
        var f = t2(24), r2 = (((s.prototype = Object.create(f.prototype)).constructor = s).className = "Enum", t2(23)), e = t2(37);
        function s(t3, i3, n3, r3, e2, s2) {
          if (f.call(this, t3, n3), i3 && "object" != typeof i3) throw TypeError("values must be an object");
          if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = r3, this.comments = e2 || {}, this.valuesOptions = s2, this.o = {}, this.reserved = it, i3) for (var o = Object.keys(i3), u = 0; u < o.length; ++u) "number" == typeof i3[o[u]] && (this.valuesById[this.values[o[u]] = i3[o[u]]] = o[u]);
        }
        s.prototype.u = function(t3) {
          return t3 = this.f || t3, f.prototype.u.call(this, t3), Object.keys(this.values).forEach((t4) => {
            var i3 = Object.assign({}, this.h);
            this.o[t4] = Object.assign(i3, this.valuesOptions && this.valuesOptions[t4] && this.valuesOptions[t4].features);
          }), this;
        }, s.fromJSON = function(t3, i3) {
          t3 = new s(t3, i3.values, i3.options, i3.comment, i3.comments);
          return t3.reserved = i3.reserved, i3.edition && (t3.f = i3.edition), t3.a = "proto3", t3;
        }, s.prototype.toJSON = function(t3) {
          t3 = !!t3 && !!t3.keepComments;
          return e.toObject(["edition", this.c(), "options", this.options, "valuesOptions", this.valuesOptions, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : it, "comment", t3 ? this.comment : it, "comments", t3 ? this.comments : it]);
        }, s.prototype.add = function(t3, i3, n3, r3) {
          if (!e.isString(t3)) throw TypeError("name must be a string");
          if (!e.isInteger(i3)) throw TypeError("id must be an integer");
          if (this.values[t3] !== it) throw Error("duplicate name '" + t3 + "' in " + this);
          if (this.isReservedId(i3)) throw Error("id " + i3 + " is reserved in " + this);
          if (this.isReservedName(t3)) throw Error("name '" + t3 + "' is reserved in " + this);
          if (this.valuesById[i3] !== it) {
            if (!this.options || !this.options.allow_alias) throw Error("duplicate id " + i3 + " in " + this);
            this.values[t3] = i3;
          } else this.valuesById[this.values[t3] = i3] = t3;
          return r3 && (this.valuesOptions === it && (this.valuesOptions = {}), this.valuesOptions[t3] = r3 || null), this.comments[t3] = n3 || null, this;
        }, s.prototype.remove = function(t3) {
          if (!e.isString(t3)) throw TypeError("name must be a string");
          var i3 = this.values[t3];
          if (null == i3) throw Error("name '" + t3 + "' does not exist in " + this);
          return delete this.valuesById[i3], delete this.values[t3], delete this.comments[t3], this.valuesOptions && delete this.valuesOptions[t3], this;
        }, s.prototype.isReservedId = function(t3) {
          return r2.isReservedId(this.reserved, t3);
        }, s.prototype.isReservedName = function(t3) {
          return r2.isReservedName(this.reserved, t3);
        };
      }, { 23: 23, 24: 24, 37: 37 }], 16: [function(t2, i2, n2) {
        i2.exports = o;
        var r2, u = t2(24), e = (((o.prototype = Object.create(u.prototype)).constructor = o).className = "Field", t2(15)), f = t2(36), h = t2(37), a = /^required|optional|repeated$/;
        function o(t3, i3, n3, r3, e2, s, o2) {
          if (h.isObject(r3) ? (o2 = e2, s = r3, r3 = e2 = it) : h.isObject(e2) && (o2 = s, s = e2, e2 = it), u.call(this, t3, s), !h.isInteger(i3) || i3 < 0) throw TypeError("id must be a non-negative integer");
          if (!h.isString(n3)) throw TypeError("type must be a string");
          if (r3 !== it && !a.test(r3 = r3.toString().toLowerCase())) throw TypeError("rule must be a string rule");
          if (e2 !== it && !h.isString(e2)) throw TypeError("extend must be a string");
          this.rule = (r3 = "proto3_optional" === r3 ? "optional" : r3) && "optional" !== r3 ? r3 : it, this.type = n3, this.id = i3, this.extend = e2 || it, this.repeated = "repeated" === r3, this.map = false, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = !!h.Long && f.long[n3] !== it, this.bytes = "bytes" === n3, this.resolvedType = null, this.extensionField = null, this.declaringField = null, this.comment = o2;
        }
        o.fromJSON = function(t3, i3) {
          t3 = new o(t3, i3.id, i3.type, i3.rule, i3.extend, i3.options, i3.comment);
          return i3.edition && (t3.f = i3.edition), t3.a = "proto3", t3;
        }, Object.defineProperty(o.prototype, "required", { get: function() {
          return "LEGACY_REQUIRED" === this.h.field_presence;
        } }), Object.defineProperty(o.prototype, "optional", { get: function() {
          return !this.required;
        } }), Object.defineProperty(o.prototype, "delimited", { get: function() {
          return this.resolvedType instanceof r2 && "DELIMITED" === this.h.message_encoding;
        } }), Object.defineProperty(o.prototype, "packed", { get: function() {
          return "PACKED" === this.h.repeated_field_encoding;
        } }), Object.defineProperty(o.prototype, "hasPresence", { get: function() {
          return !this.repeated && !this.map && (this.partOf || this.declaringField || this.extensionField || "IMPLICIT" !== this.h.field_presence);
        } }), o.prototype.setOption = function(t3, i3, n3) {
          return u.prototype.setOption.call(this, t3, i3, n3);
        }, o.prototype.toJSON = function(t3) {
          t3 = !!t3 && !!t3.keepComments;
          return h.toObject(["edition", this.c(), "rule", "optional" !== this.rule && this.rule || it, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t3 ? this.comment : it]);
        }, o.prototype.resolve = function() {
          var t3;
          return this.resolved ? this : ((this.typeDefault = f.defaults[this.type]) === it ? (this.resolvedType = (this.declaringField || this).parent.lookupTypeOrEnum(this.type), this.resolvedType instanceof r2 ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]) : this.options && this.options.proto3_optional && (this.typeDefault = null), this.options && null != this.options.default && (this.typeDefault = this.options.default, this.resolvedType instanceof e && "string" == typeof this.typeDefault && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (this.options.packed === it || !this.resolvedType || this.resolvedType instanceof e || delete this.options.packed, Object.keys(this.options).length || (this.options = it)), this.long ? (this.typeDefault = h.Long.fromNumber(this.typeDefault, "u" == (this.type[0] || "")), Object.freeze && Object.freeze(this.typeDefault)) : this.bytes && "string" == typeof this.typeDefault && (h.base64.test(this.typeDefault) ? h.base64.decode(this.typeDefault, t3 = h.newBuffer(h.base64.length(this.typeDefault)), 0) : h.utf8.write(this.typeDefault, t3 = h.newBuffer(h.utf8.length(this.typeDefault)), 0), this.typeDefault = t3), this.map ? this.defaultValue = h.emptyObject : this.repeated ? this.defaultValue = h.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof r2 && (this.parent.ctor.prototype[this.name] = this.defaultValue), u.prototype.resolve.call(this));
        }, o.prototype.l = function(t3) {
          var i3;
          return "proto2" !== t3 && "proto3" !== t3 ? {} : (t3 = {}, "required" === this.rule && (t3.field_presence = "LEGACY_REQUIRED"), this.parent && f.defaults[this.type] === it && (i3 = this.parent.get(this.type.split(".").pop())) && i3 instanceof r2 && i3.group && (t3.message_encoding = "DELIMITED"), true === this.getOption("packed") ? t3.repeated_field_encoding = "PACKED" : false === this.getOption("packed") && (t3.repeated_field_encoding = "EXPANDED"), t3);
        }, o.prototype.u = function(t3) {
          return u.prototype.u.call(this, this.f || t3);
        }, o.d = function(n3, r3, e2, s) {
          return "function" == typeof r3 ? r3 = h.decorateType(r3).name : r3 && "object" == typeof r3 && (r3 = h.decorateEnum(r3).name), function(t3, i3) {
            h.decorateType(t3.constructor).add(new o(i3, n3, r3, e2, { default: s }));
          };
        }, o.p = function(t3) {
          r2 = t3;
        };
      }, { 15: 15, 24: 24, 36: 36, 37: 37 }], 17: [function(t2, i2, n2) {
        var r2 = i2.exports = t2(18);
        r2.build = "light", r2.load = function(t3, i3, n3) {
          return (i3 = "function" == typeof i3 ? (n3 = i3, new r2.Root()) : i3 || new r2.Root()).load(t3, n3);
        }, r2.loadSync = function(t3, i3) {
          return (i3 = i3 || new r2.Root()).loadSync(t3);
        }, r2.encoder = t2(14), r2.decoder = t2(13), r2.verifier = t2(40), r2.converter = t2(12), r2.ReflectionObject = t2(24), r2.Namespace = t2(23), r2.Root = t2(29), r2.Enum = t2(15), r2.Type = t2(35), r2.Field = t2(16), r2.OneOf = t2(25), r2.MapField = t2(20), r2.Service = t2(33), r2.Method = t2(22), r2.Message = t2(21), r2.wrappers = t2(41), r2.types = t2(36), r2.util = t2(37), r2.ReflectionObject.p(r2.Root), r2.Namespace.p(r2.Type, r2.Service, r2.Enum), r2.Root.p(r2.Type), r2.Field.p(r2.Type);
      }, { 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 18: 18, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 29: 29, 33: 33, 35: 35, 36: 36, 37: 37, 40: 40, 41: 41 }], 18: [function(t2, i2, n2) {
        var r2 = n2;
        function e() {
          r2.util.p(), r2.Writer.p(r2.BufferWriter), r2.Reader.p(r2.BufferReader);
        }
        r2.build = "minimal", r2.Writer = t2(42), r2.BufferWriter = t2(43), r2.Reader = t2(27), r2.BufferReader = t2(28), r2.util = t2(39), r2.rpc = t2(31), r2.roots = t2(30), r2.configure = e, e();
      }, { 27: 27, 28: 28, 30: 30, 31: 31, 39: 39, 42: 42, 43: 43 }], 19: [function(t2, i2, n2) {
        i2 = i2.exports = t2(17);
        i2.build = "full", i2.tokenize = t2(34), i2.parse = t2(26), i2.common = t2(11), i2.Root.p(i2.Type, i2.parse, i2.common);
      }, { 11: 11, 17: 17, 26: 26, 34: 34 }], 20: [function(t2, i2, n2) {
        i2.exports = s;
        var o = t2(16), r2 = (((s.prototype = Object.create(o.prototype)).constructor = s).className = "MapField", t2(36)), u = t2(37);
        function s(t3, i3, n3, r3, e, s2) {
          if (o.call(this, t3, i3, r3, it, it, e, s2), !u.isString(n3)) throw TypeError("keyType must be a string");
          this.keyType = n3, this.resolvedKeyType = null, this.map = true;
        }
        s.fromJSON = function(t3, i3) {
          return new s(t3, i3.id, i3.keyType, i3.type, i3.options, i3.comment);
        }, s.prototype.toJSON = function(t3) {
          t3 = !!t3 && !!t3.keepComments;
          return u.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t3 ? this.comment : it]);
        }, s.prototype.resolve = function() {
          if (this.resolved) return this;
          if (r2.mapKey[this.keyType] === it) throw Error("invalid key type: " + this.keyType);
          return o.prototype.resolve.call(this);
        }, s.d = function(n3, r3, e) {
          return "function" == typeof e ? e = u.decorateType(e).name : e && "object" == typeof e && (e = u.decorateEnum(e).name), function(t3, i3) {
            u.decorateType(t3.constructor).add(new s(i3, n3, r3, e));
          };
        };
      }, { 16: 16, 36: 36, 37: 37 }], 21: [function(t2, i2, n2) {
        i2.exports = e;
        var r2 = t2(39);
        function e(t3) {
          if (t3) for (var i3 = Object.keys(t3), n3 = 0; n3 < i3.length; ++n3) this[i3[n3]] = t3[i3[n3]];
        }
        e.create = function(t3) {
          return this.$type.create(t3);
        }, e.encode = function(t3, i3) {
          return this.$type.encode(t3, i3);
        }, e.encodeDelimited = function(t3, i3) {
          return this.$type.encodeDelimited(t3, i3);
        }, e.decode = function(t3) {
          return this.$type.decode(t3);
        }, e.decodeDelimited = function(t3) {
          return this.$type.decodeDelimited(t3);
        }, e.verify = function(t3) {
          return this.$type.verify(t3);
        }, e.fromObject = function(t3) {
          return this.$type.fromObject(t3);
        }, e.toObject = function(t3, i3) {
          return this.$type.toObject(t3, i3);
        }, e.prototype.toJSON = function() {
          return this.$type.toObject(this, r2.toJSONOptions);
        };
      }, { 39: 39 }], 22: [function(t2, i2, n2) {
        i2.exports = r2;
        var h = t2(24), a = (((r2.prototype = Object.create(h.prototype)).constructor = r2).className = "Method", t2(37));
        function r2(t3, i3, n3, r3, e, s, o, u, f) {
          if (a.isObject(e) ? (o = e, e = s = it) : a.isObject(s) && (o = s, s = it), i3 !== it && !a.isString(i3)) throw TypeError("type must be a string");
          if (!a.isString(n3)) throw TypeError("requestType must be a string");
          if (!a.isString(r3)) throw TypeError("responseType must be a string");
          h.call(this, t3, o), this.type = i3 || "rpc", this.requestType = n3, this.requestStream = !!e || it, this.responseType = r3, this.responseStream = !!s || it, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = u, this.parsedOptions = f;
        }
        r2.fromJSON = function(t3, i3) {
          return new r2(t3, i3.type, i3.requestType, i3.responseType, i3.requestStream, i3.responseStream, i3.options, i3.comment, i3.parsedOptions);
        }, r2.prototype.toJSON = function(t3) {
          t3 = !!t3 && !!t3.keepComments;
          return a.toObject(["type", "rpc" !== this.type && this.type || it, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options, "comment", t3 ? this.comment : it, "parsedOptions", this.parsedOptions]);
        }, r2.prototype.resolve = function() {
          return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), h.prototype.resolve.call(this));
        };
      }, { 24: 24, 37: 37 }], 23: [function(t2, i2, n2) {
        i2.exports = c;
        var s, o, u, r2 = t2(24), f = (((c.prototype = Object.create(r2.prototype)).constructor = c).className = "Namespace", t2(16)), h = t2(37), a = t2(25);
        function e(t3, i3) {
          if (!t3 || !t3.length) return it;
          for (var n3 = {}, r3 = 0; r3 < t3.length; ++r3) n3[t3[r3].name] = t3[r3].toJSON(i3);
          return n3;
        }
        function c(t3, i3) {
          r2.call(this, t3, i3), this.nested = it, this.v = null, this.b = {}, this.w = true, this.y = true;
        }
        function l(t3) {
          t3.v = null, t3.b = {};
          for (var i3 = t3; i3 = i3.parent; ) i3.b = {};
          return t3;
        }
        c.fromJSON = function(t3, i3) {
          return new c(t3, i3.options).addJSON(i3.nested);
        }, c.arrayToJSON = e, c.isReservedId = function(t3, i3) {
          if (t3) {
            for (var n3 = 0; n3 < t3.length; ++n3) if ("string" != typeof t3[n3] && t3[n3][0] <= i3 && t3[n3][1] > i3) return true;
          }
          return false;
        }, c.isReservedName = function(t3, i3) {
          if (t3) {
            for (var n3 = 0; n3 < t3.length; ++n3) if (t3[n3] === i3) return true;
          }
          return false;
        }, Object.defineProperty(c.prototype, "nestedArray", { get: function() {
          return this.v || (this.v = h.toArray(this.nested));
        } }), c.prototype.toJSON = function(t3) {
          return h.toObject(["options", this.options, "nested", e(this.nestedArray, t3)]);
        }, c.prototype.addJSON = function(t3) {
          if (t3) for (var i3, n3 = Object.keys(t3), r3 = 0; r3 < n3.length; ++r3) i3 = t3[n3[r3]], this.add((i3.fields !== it ? s : i3.values !== it ? u : i3.methods !== it ? o : i3.id !== it ? f : c).fromJSON(n3[r3], i3));
          return this;
        }, c.prototype.get = function(t3) {
          return this.nested && this.nested[t3] || null;
        }, c.prototype.getEnum = function(t3) {
          if (this.nested && this.nested[t3] instanceof u) return this.nested[t3].values;
          throw Error("no such enum: " + t3);
        }, c.prototype.add = function(t3) {
          if (!(t3 instanceof f && t3.extend !== it || t3 instanceof s || t3 instanceof a || t3 instanceof u || t3 instanceof o || t3 instanceof c)) throw TypeError("object must be a valid nested object");
          if (this.nested) {
            var i3 = this.get(t3.name);
            if (i3) {
              if (!(i3 instanceof c && t3 instanceof c) || i3 instanceof s || i3 instanceof o) throw Error("duplicate name '" + t3.name + "' in " + this);
              for (var n3 = i3.nestedArray, r3 = 0; r3 < n3.length; ++r3) t3.add(n3[r3]);
              this.remove(i3), this.nested || (this.nested = {}), t3.setOptions(i3.options, true);
            }
          } else this.nested = {};
          this.nested[t3.name] = t3, this instanceof s || this instanceof o || this instanceof u || this instanceof f || t3.f || (t3.f = t3.a), this.w = true, this.y = true;
          for (var e2 = this; e2 = e2.parent; ) e2.w = true, e2.y = true;
          return t3.onAdd(this), l(this);
        }, c.prototype.remove = function(t3) {
          if (!(t3 instanceof r2)) throw TypeError("object must be a ReflectionObject");
          if (t3.parent !== this) throw Error(t3 + " is not a member of " + this);
          return delete this.nested[t3.name], Object.keys(this.nested).length || (this.nested = it), t3.onRemove(this), l(this);
        }, c.prototype.define = function(t3, i3) {
          if (h.isString(t3)) t3 = t3.split(".");
          else if (!Array.isArray(t3)) throw TypeError("illegal path");
          if (t3 && t3.length && "" === t3[0]) throw Error("path must be relative");
          for (var n3 = this; 0 < t3.length; ) {
            var r3 = t3.shift();
            if (n3.nested && n3.nested[r3]) {
              if (!((n3 = n3.nested[r3]) instanceof c)) throw Error("path conflicts with non-namespace objects");
            } else n3.add(n3 = new c(r3));
          }
          return i3 && n3.addJSON(i3), n3;
        }, c.prototype.resolveAll = function() {
          if (this.y) {
            this.g(this.f);
            var t3 = this.nestedArray, i3 = 0;
            for (this.resolve(); i3 < t3.length; ) t3[i3] instanceof c ? t3[i3++].resolveAll() : t3[i3++].resolve();
            this.y = false;
          }
          return this;
        }, c.prototype.g = function(i3) {
          return this.w && (this.w = false, i3 = this.f || i3, r2.prototype.g.call(this, i3), this.nestedArray.forEach((t3) => {
            t3.g(i3);
          })), this;
        }, c.prototype.lookup = function(t3, i3, n3) {
          if ("boolean" == typeof i3 ? (n3 = i3, i3 = it) : i3 && !Array.isArray(i3) && (i3 = [i3]), h.isString(t3) && t3.length) {
            if ("." === t3) return this.root;
            t3 = t3.split(".");
          } else if (!t3.length) return this;
          var r3 = t3.join(".");
          if ("" === t3[0]) return this.root.lookup(t3.slice(1), i3);
          var e2 = this.root.j && this.root.j["." + r3];
          if (e2 && (!i3 || ~i3.indexOf(e2.constructor))) return e2;
          if ((e2 = this.k(t3, r3)) && (!i3 || ~i3.indexOf(e2.constructor))) return e2;
          if (!n3) for (var s2 = this; s2.parent; ) {
            if ((e2 = s2.parent.k(t3, r3)) && (!i3 || ~i3.indexOf(e2.constructor))) return e2;
            s2 = s2.parent;
          }
          return null;
        }, c.prototype.k = function(t3, i3) {
          if (Object.prototype.hasOwnProperty.call(this.b, i3)) return this.b[i3];
          var n3 = this.get(t3[0]), r3 = null;
          if (n3) 1 === t3.length ? r3 = n3 : n3 instanceof c && (t3 = t3.slice(1), r3 = n3.k(t3, t3.join(".")));
          else for (var e2 = 0; e2 < this.nestedArray.length; ++e2) this.v[e2] instanceof c && (n3 = this.v[e2].k(t3, i3)) && (r3 = n3);
          return this.b[i3] = r3;
        }, c.prototype.lookupType = function(t3) {
          var i3 = this.lookup(t3, [s]);
          if (i3) return i3;
          throw Error("no such type: " + t3);
        }, c.prototype.lookupEnum = function(t3) {
          var i3 = this.lookup(t3, [u]);
          if (i3) return i3;
          throw Error("no such Enum '" + t3 + "' in " + this);
        }, c.prototype.lookupTypeOrEnum = function(t3) {
          var i3 = this.lookup(t3, [s, u]);
          if (i3) return i3;
          throw Error("no such Type or Enum '" + t3 + "' in " + this);
        }, c.prototype.lookupService = function(t3) {
          var i3 = this.lookup(t3, [o]);
          if (i3) return i3;
          throw Error("no such Service '" + t3 + "' in " + this);
        }, c.p = function(t3, i3, n3) {
          s = t3, o = i3, u = n3;
        };
      }, { 16: 16, 24: 24, 25: 25, 37: 37 }], 24: [function(t2, i2, n2) {
        (i2.exports = a).className = "ReflectionObject";
        const r2 = t2(25);
        var e, o = t2(37), s = { enum_type: "OPEN", field_presence: "EXPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY", enforce_naming_style: "STYLE2024", default_symbol_visibility: "EXPORT_TOP_LEVEL" }, u = { enum_type: "OPEN", field_presence: "EXPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY", enforce_naming_style: "STYLE_LEGACY", default_symbol_visibility: "EXPORT_ALL" }, f = { enum_type: "CLOSED", field_presence: "EXPLICIT", json_format: "LEGACY_BEST_EFFORT", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "EXPANDED", utf8_validation: "NONE", enforce_naming_style: "STYLE_LEGACY", default_symbol_visibility: "EXPORT_ALL" }, h = { enum_type: "OPEN", field_presence: "IMPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY", enforce_naming_style: "STYLE_LEGACY", default_symbol_visibility: "EXPORT_ALL" };
        function a(t3, i3) {
          if (!o.isString(t3)) throw TypeError("name must be a string");
          if (i3 && !o.isObject(i3)) throw TypeError("options must be an object");
          this.options = i3, this.parsedOptions = null, this.name = t3, this.f = null, this.a = "proto2", this.h = {}, this.O = false, this.parent = null, this.resolved = false, this.comment = null, this.filename = null;
        }
        Object.defineProperties(a.prototype, { root: { get: function() {
          for (var t3 = this; null !== t3.parent; ) t3 = t3.parent;
          return t3;
        } }, fullName: { get: function() {
          for (var t3 = [this.name], i3 = this.parent; i3; ) t3.unshift(i3.name), i3 = i3.parent;
          return t3.join(".");
        } } }), a.prototype.toJSON = function() {
          throw Error();
        }, a.prototype.onAdd = function(t3) {
          this.parent && this.parent !== t3 && this.parent.remove(this), this.parent = t3, this.resolved = false;
          t3 = t3.root;
          t3 instanceof e && t3._(this);
        }, a.prototype.onRemove = function(t3) {
          t3 = t3.root;
          t3 instanceof e && t3.A(this), this.parent = null, this.resolved = false;
        }, a.prototype.resolve = function() {
          return this.resolved || this.root instanceof e && (this.resolved = true), this;
        }, a.prototype.g = function(t3) {
          return this.u(this.f || t3);
        }, a.prototype.u = function(t3) {
          if (!this.O) {
            var i3 = {};
            if (!t3) throw Error("Unknown edition for " + this.fullName);
            var n3 = Object.assign(this.options ? Object.assign({}, this.options.features) : {}, this.l(t3));
            if (this.f) {
              if ("proto2" === t3) i3 = Object.assign({}, f);
              else if ("proto3" === t3) i3 = Object.assign({}, h);
              else if ("2023" === t3) i3 = Object.assign({}, u);
              else {
                if ("2024" !== t3) throw Error("Unknown edition: " + t3);
                i3 = Object.assign({}, s);
              }
              this.h = Object.assign(i3, n3 || {});
            } else {
              if (this.partOf instanceof r2) {
                t3 = Object.assign({}, this.partOf.h);
                this.h = Object.assign(t3, n3 || {});
              } else if (!this.declaringField) {
                if (!this.parent) throw Error("Unable to find a parent for " + this.fullName);
                i3 = Object.assign({}, this.parent.h);
                this.h = Object.assign(i3, n3 || {});
              }
              this.extensionField && (this.extensionField.h = this.h);
            }
            this.O = true;
          }
        }, a.prototype.l = function() {
          return {};
        }, a.prototype.getOption = function(t3) {
          return this.options ? this.options[t3] : it;
        }, a.prototype.setOption = function(t3, i3, n3) {
          return this.options || (this.options = {}), /^features\./.test(t3) ? o.setProperty(this.options, t3, i3, n3) : n3 && this.options[t3] !== it || (this.getOption(t3) !== i3 && (this.resolved = false), this.options[t3] = i3), this;
        }, a.prototype.setParsedOption = function(i3, t3, n3) {
          this.parsedOptions || (this.parsedOptions = []);
          var r3, e2, s2 = this.parsedOptions;
          return n3 ? (r3 = s2.find(function(t4) {
            return Object.prototype.hasOwnProperty.call(t4, i3);
          })) ? (e2 = r3[i3], o.setProperty(e2, n3, t3)) : ((r3 = {})[i3] = o.setProperty({}, n3, t3), s2.push(r3)) : ((e2 = {})[i3] = t3, s2.push(e2)), this;
        }, a.prototype.setOptions = function(t3, i3) {
          if (t3) for (var n3 = Object.keys(t3), r3 = 0; r3 < n3.length; ++r3) this.setOption(n3[r3], t3[n3[r3]], i3);
          return this;
        }, a.prototype.toString = function() {
          var t3 = this.constructor.className, i3 = this.fullName;
          return i3.length ? t3 + " " + i3 : t3;
        }, a.prototype.c = function() {
          return this.f && "proto3" !== this.f ? this.f : it;
        }, a.p = function(t3) {
          e = t3;
        };
      }, { 25: 25, 37: 37 }], 25: [function(t2, i2, n2) {
        i2.exports = o;
        var e = t2(24), r2 = (((o.prototype = Object.create(e.prototype)).constructor = o).className = "OneOf", t2(16)), s = t2(37);
        function o(t3, i3, n3, r3) {
          if (Array.isArray(i3) || (n3 = i3, i3 = it), e.call(this, t3, n3), i3 !== it && !Array.isArray(i3)) throw TypeError("fieldNames must be an Array");
          this.oneof = i3 || [], this.fieldsArray = [], this.comment = r3;
        }
        function u(t3) {
          if (t3.parent) for (var i3 = 0; i3 < t3.fieldsArray.length; ++i3) t3.fieldsArray[i3].parent || t3.parent.add(t3.fieldsArray[i3]);
        }
        o.fromJSON = function(t3, i3) {
          return new o(t3, i3.oneof, i3.options, i3.comment);
        }, o.prototype.toJSON = function(t3) {
          t3 = !!t3 && !!t3.keepComments;
          return s.toObject(["options", this.options, "oneof", this.oneof, "comment", t3 ? this.comment : it]);
        }, o.prototype.add = function(t3) {
          if (t3 instanceof r2) return t3.parent && t3.parent !== this.parent && t3.parent.remove(t3), this.oneof.push(t3.name), this.fieldsArray.push(t3), u(t3.partOf = this), this;
          throw TypeError("field must be a Field");
        }, o.prototype.remove = function(t3) {
          if (!(t3 instanceof r2)) throw TypeError("field must be a Field");
          var i3 = this.fieldsArray.indexOf(t3);
          if (i3 < 0) throw Error(t3 + " is not a member of " + this);
          return this.fieldsArray.splice(i3, 1), -1 < (i3 = this.oneof.indexOf(t3.name)) && this.oneof.splice(i3, 1), t3.partOf = null, this;
        }, o.prototype.onAdd = function(t3) {
          e.prototype.onAdd.call(this, t3);
          for (var i3 = 0; i3 < this.oneof.length; ++i3) {
            var n3 = t3.get(this.oneof[i3]);
            n3 && !n3.partOf && (n3.partOf = this).fieldsArray.push(n3);
          }
          u(this);
        }, o.prototype.onRemove = function(t3) {
          for (var i3, n3 = 0; n3 < this.fieldsArray.length; ++n3) (i3 = this.fieldsArray[n3]).parent && i3.parent.remove(i3);
          e.prototype.onRemove.call(this, t3);
        }, Object.defineProperty(o.prototype, "isProto3Optional", { get: function() {
          var t3;
          return null != this.fieldsArray && 1 === this.fieldsArray.length && (null != (t3 = this.fieldsArray[0]).options && true === t3.options.proto3_optional);
        } }), o.d = function() {
          for (var n3 = Array(arguments.length), t3 = 0; t3 < arguments.length; ) n3[t3] = arguments[t3++];
          return function(t4, i3) {
            s.decorateType(t4.constructor).add(new o(i3, n3)), Object.defineProperty(t4, i3, { get: s.oneOfGetter(n3), set: s.oneOfSetter(n3) });
          };
        };
      }, { 16: 16, 24: 24, 37: 37 }], 26: [function(t2, i2, n2) {
        (i2.exports = tt).filename = null, tt.defaults = { keepCase: false };
        var P2 = t2(34), V = t2(29), M2 = t2(35), R = t2(16), F2 = t2(20), $ = t2(25), D2 = t2(15), U = t2(33), C2 = t2(22), q = t2(24), X2 = t2(36), Y2 = t2(37), G2 = /^[1-9][0-9]*$/, z2 = /^-?[1-9][0-9]*$/, Z = /^0[x][0-9a-fA-F]+$/, B = /^-?0[x][0-9a-fA-F]+$/, H = /^0[0-7]+$/, K2 = /^-?0[0-7]+$/, W2 = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/, J2 = /^[a-zA-Z_][a-zA-Z_0-9]*$/, Q2 = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
        function tt(t3, i3, n3) {
          i3 instanceof V || (n3 = i3, i3 = new V());
          var r2, e, s, h, o = (n3 = n3 || tt.defaults).preferTrailingComment || false, u = P2(t3, n3.alternateCommentMode || false), c = u.next, f = u.push, l = u.peek, d = u.skip, a = u.cmnt, p = true, v = "proto2", b = i3, w2 = [], y = {}, m = n3.keepCase ? function(t4) {
            return t4;
          } : Y2.camelCase;
          function g(t4, i4, n4) {
            var r3 = tt.filename;
            return n4 || (tt.filename = null), Error("illegal " + (i4 || "token") + " '" + t4 + "' (" + (r3 ? r3 + ", " : "") + "line " + u.line + ")");
          }
          function j() {
            var t4, i4 = [];
            do {
              if ('"' !== (t4 = c()) && "'" !== t4) throw g(t4);
            } while (i4.push(c()), d(t4), '"' === (t4 = l()) || "'" === t4);
            return i4.join("");
          }
          function E(i4) {
            var n4 = c();
            switch (n4) {
              case "'":
              case '"':
                return f(n4), j();
              case "true":
              case "TRUE":
                return true;
              case "false":
              case "FALSE":
                return false;
            }
            try {
              var t4 = n4, r3 = true, e2 = 1;
              switch ("-" == (t4[0] || "") && (e2 = -1, t4 = t4.substring(1)), t4) {
                case "inf":
                case "INF":
                case "Inf":
                  return e2 * (1 / 0);
                case "nan":
                case "NAN":
                case "Nan":
                case "NaN":
                  return NaN;
                case "0":
                  return 0;
              }
              if (G2.test(t4)) return e2 * parseInt(t4, 10);
              if (Z.test(t4)) return e2 * parseInt(t4, 16);
              if (H.test(t4)) return e2 * parseInt(t4, 8);
              if (W2.test(t4)) return e2 * parseFloat(t4);
              throw g(t4, "number", r3);
            } catch (t5) {
              if (Q2.test(n4)) return n4;
              throw g(n4, "value");
            }
          }
          function k(i4, n4) {
            var t4;
            do {
              if (!n4 || '"' !== (r3 = l()) && "'" !== r3) try {
                i4.push([t4 = O(c()), d("to", true) ? O(c()) : t4]);
              } catch (t5) {
                if (!(n4 && Q2.test(r3) && 2023 <= v)) throw t5;
                i4.push(r3);
              }
              else {
                var r3 = j();
                if (i4.push(r3), 2023 <= v) throw g(r3, "id");
              }
            } while (d(",", true));
            var e2 = { options: it, setOption: function(t5, i5) {
              this.options === it && (this.options = {}), this.options[t5] = i5;
            } };
            A(e2, function(t5) {
              if ("option" !== t5) throw g(t5);
              S2(e2, t5), d(";");
            }, function() {
              N2(e2);
            });
          }
          function O(t4, i4) {
            switch (t4) {
              case "max":
              case "MAX":
              case "Max":
                return 536870911;
              case "0":
                return 0;
            }
            if (i4 || "-" != (t4[0] || "")) {
              if (z2.test(t4)) return parseInt(t4, 10);
              if (B.test(t4)) return parseInt(t4, 16);
              if (K2.test(t4)) return parseInt(t4, 8);
            }
            throw g(t4, "id");
          }
          function _2(t4, i4) {
            switch (i4) {
              case "option":
                return S2(t4, i4), d(";"), true;
              case "message":
                return T(t4), true;
              case "enum":
                return L3(t4), true;
              case "export":
              case "local":
                return v < "2024" ? false : "export" !== (i4 = c()) && "local" !== i4 && (("message" === i4 || "enum" === i4) && _2(t4, i4));
              case "service":
                var h2, n4 = t4, r3 = i4;
                if (J2.test(r3 = c())) return A(h2 = new U(r3), function(t5) {
                  if (!_2(h2, t5)) {
                    if ("rpc" !== t5) throw g(t5);
                    var i5 = h2, n5 = a(), r4 = t5;
                    if (!J2.test(t5 = c())) throw g(t5, "name");
                    var e3, s3, o2, u2 = t5;
                    if (d("("), d("stream", true) && (s3 = true), !Q2.test(t5 = c())) throw g(t5);
                    if (e3 = t5, d(")"), d("returns"), d("("), d("stream", true) && (o2 = true), !Q2.test(t5 = c())) throw g(t5);
                    t5 = t5, d(")");
                    var f2 = new C2(u2, r4, e3, t5, s3, o2);
                    f2.comment = n5, A(f2, function(t6) {
                      if ("option" !== t6) throw g(t6);
                      S2(f2, t6), d(";");
                    }), i5.add(f2);
                  }
                }), n4.add(h2), n4 === b && w2.push(h2), true;
                throw g(r3, "service name");
              case "extend":
                var e2, s2 = t4, n4 = i4;
                if (Q2.test(n4 = c())) return e2 = n4, A(null, function(t5) {
                  switch (t5) {
                    case "required":
                    case "repeated":
                      x(s2, t5, e2);
                      break;
                    case "optional":
                      x(s2, "proto3" === v ? "proto3_optional" : "optional", e2);
                      break;
                    default:
                      if ("proto2" === v || !Q2.test(t5)) throw g(t5);
                      f(t5), x(s2, "optional", e2);
                  }
                }), true;
                throw g(n4, "reference");
            }
            return false;
          }
          function A(t4, i4, n4) {
            var r3, e2 = u.line;
            if (t4 && ("string" != typeof t4.comment && (t4.comment = a()), t4.filename = tt.filename), d("{", true)) {
              for (; "}" !== (r3 = c()); ) i4(r3);
              d(";", true);
            } else n4 && n4(), d(";"), t4 && ("string" != typeof t4.comment || o) && (t4.comment = a(e2) || t4.comment);
          }
          function T(t4, i4) {
            if (!J2.test(i4 = c())) throw g(i4, "type name");
            var u2 = new M2(i4);
            A(u2, function(t5) {
              if (!_2(u2, t5)) switch (t5) {
                case "map":
                  var i5 = u2, n4 = (d("<"), c());
                  if (X2.mapKey[n4] === it) throw g(n4, "type");
                  d(",");
                  var r3 = c();
                  if (!Q2.test(r3)) throw g(r3, "type");
                  d(">");
                  var e2 = c();
                  if (!J2.test(e2)) throw g(e2, "name");
                  d("=");
                  var s2 = new F2(m(e2), O(c()), n4, r3);
                  A(s2, function(t6) {
                    if ("option" !== t6) throw g(t6);
                    S2(s2, t6), d(";");
                  }, function() {
                    N2(s2);
                  }), i5.add(s2);
                  break;
                case "required":
                  if ("proto2" !== v) throw g(t5);
                case "repeated":
                  x(u2, t5);
                  break;
                case "optional":
                  if ("proto3" === v) x(u2, "proto3_optional");
                  else {
                    if ("proto2" !== v) throw g(t5);
                    x(u2, "optional");
                  }
                  break;
                case "oneof":
                  e2 = u2, n4 = t5;
                  if (!J2.test(n4 = c())) throw g(n4, "name");
                  var o2 = new $(m(n4));
                  A(o2, function(t6) {
                    "option" === t6 ? (S2(o2, t6), d(";")) : (f(t6), x(o2, "optional"));
                  }), e2.add(o2);
                  break;
                case "extensions":
                  k(u2.extensions || (u2.extensions = []));
                  break;
                case "reserved":
                  k(u2.reserved || (u2.reserved = []), true);
                  break;
                default:
                  if ("proto2" === v || !Q2.test(t5)) throw g(t5);
                  f(t5), x(u2, "optional");
              }
            }), t4.add(u2), t4 === b && w2.push(u2);
          }
          function x(t4, i4, n4) {
            var r3 = c();
            if ("group" === r3) {
              var e2 = t4, s2 = i4;
              if (2023 <= v) throw g("group");
              var o2, u2, f2 = c();
              if (J2.test(f2)) return u2 = Y2.lcFirst(f2), f2 === u2 && (f2 = Y2.ucFirst(f2)), d("="), h2 = O(c()), (o2 = new M2(f2)).group = true, (u2 = new R(u2, h2, f2, s2)).filename = tt.filename, A(o2, function(t5) {
                switch (t5) {
                  case "option":
                    S2(o2, t5), d(";");
                    break;
                  case "required":
                  case "repeated":
                    x(o2, t5);
                    break;
                  case "optional":
                    x(o2, "proto3" === v ? "proto3_optional" : "optional");
                    break;
                  case "message":
                    T(o2);
                    break;
                  case "enum":
                    L3(o2);
                    break;
                  case "reserved":
                    k(o2.reserved || (o2.reserved = []), true);
                    break;
                  case "export":
                  case "local":
                    if (v < "2024") throw g(t5);
                    switch (t5 = c()) {
                      case "message":
                      case "enum":
                        T(o2);
                        break;
                      default:
                        throw g(t5);
                    }
                    break;
                  default:
                    throw g(t5);
                }
              }), void e2.add(o2).add(u2);
              throw g(f2, "name");
            }
            for (; r3.endsWith(".") || l().startsWith("."); ) r3 += c();
            if (!Q2.test(r3)) throw g(r3, "type");
            var h2 = c();
            if (!J2.test(h2)) throw g(h2, "name");
            h2 = m(h2), d("=");
            var a2 = new R(h2, O(c()), r3, i4, n4);
            A(a2, function(t5) {
              if ("option" !== t5) throw g(t5);
              S2(a2, t5), d(";");
            }, function() {
              N2(a2);
            }), "proto3_optional" === i4 ? (s2 = new $("_" + h2), a2.setOption("proto3_optional", true), s2.add(a2), t4.add(s2)) : t4.add(a2), t4 === b && w2.push(a2);
          }
          function L3(t4, i4) {
            if (!J2.test(i4 = c())) throw g(i4, "name");
            var s2 = new D2(i4);
            A(s2, function(t5) {
              switch (t5) {
                case "option":
                  S2(s2, t5), d(";");
                  break;
                case "reserved":
                  k(s2.reserved || (s2.reserved = []), true), s2.reserved === it && (s2.reserved = []);
                  break;
                default:
                  var i5 = s2, n4 = t5;
                  if (!J2.test(n4)) throw g(n4, "name");
                  d("=");
                  var r3 = O(c(), true), e2 = { options: it, getOption: function(t6) {
                    return this.options[t6];
                  }, setOption: function(t6, i6) {
                    q.prototype.setOption.call(e2, t6, i6);
                  }, setParsedOption: function() {
                    return it;
                  } };
                  return A(e2, function(t6) {
                    if ("option" !== t6) throw g(t6);
                    S2(e2, t6), d(";");
                  }, function() {
                    N2(e2);
                  }), void i5.add(n4, r3, e2.comment, e2.parsedOptions || e2.options);
              }
            }), t4.add(s2), t4 === b && w2.push(s2);
          }
          function S2(t4, i4) {
            var n4 = true;
            for ("option" === i4 && (i4 = c()); "=" !== i4; ) {
              if ("(" === i4 && (r3 = c(), d(")"), i4 = "(" + r3 + ")"), n4) {
                if (n4 = false, i4.includes(".") && !i4.includes("(")) {
                  var r3 = i4.split("."), e2 = r3[0] + ".";
                  i4 = r3[1];
                  continue;
                }
                e2 = i4;
              } else f2 = f2 ? f2 + i4 : i4;
              i4 = c();
            }
            var s2, o2, u2 = f2 ? e2.concat(f2) : e2, u2 = (function t5(i5, n5) {
              if (d("{", true)) {
                for (var r4 = {}; !d("}", true); ) {
                  if (!J2.test(h = c())) throw g(h, "name");
                  if (null === h) throw g(h, "end of input");
                  var e3, s3, o3 = h;
                  if (d(":", true), "{" === l()) e3 = t5(i5, n5 + "." + h);
                  else if ("[" === l()) {
                    if (e3 = [], d("[", true)) {
                      for (; s3 = E(), e3.push(s3), d(",", true); ) ;
                      d("]"), void 0 !== s3 && I2(i5, n5 + "." + h, s3);
                    }
                  } else e3 = E(), I2(i5, n5 + "." + h, e3);
                  var u3 = r4[o3];
                  u3 && (e3 = [].concat(u3).concat(e3)), r4[o3] = e3, d(",", true), d(";", true);
                }
                return r4;
              }
              var f3 = E();
              I2(i5, n5, f3);
              return f3;
            })(t4, u2), f2 = f2 && "." === f2[0] ? f2.slice(1) : f2;
            e2 = e2 && "." === e2[e2.length - 1] ? e2.slice(0, -1) : e2, s2 = e2, u2 = u2, o2 = f2, (t4 = t4).setParsedOption && t4.setParsedOption(s2, u2, o2);
          }
          function I2(t4, i4, n4) {
            b === t4 && /^features\./.test(i4) ? y[i4] = n4 : t4.setOption && t4.setOption(i4, n4);
          }
          function N2(t4) {
            if (d("[", true)) {
              for (; S2(t4, "option"), d(",", true); ) ;
              d("]");
            }
          }
          for (; null !== (h = c()); ) switch (h) {
            case "package":
              if (!p) throw g(h);
              if (r2 !== it) throw g("package");
              if (r2 = c(), !Q2.test(r2)) throw g(r2, "name");
              b = b.define(r2), d(";");
              break;
            case "import":
              if (!p) throw g(h);
              !(function() {
                var t4, i4;
                switch (l()) {
                  case "option":
                    if (v < "2024") throw g("option");
                    return c(), j(), d(";");
                  case "weak":
                    i4 = s = s || [], c();
                    break;
                  case "public":
                    c();
                  default:
                    i4 = e = e || [];
                }
                t4 = j(), d(";"), i4.push(t4);
              })();
              break;
            case "syntax":
              if (!p) throw g(h);
              if (d("="), (v = j()) < 2023) throw g(v, "syntax");
              d(";");
              break;
            case "edition":
              if (!p) throw g(h);
              if (d("="), v = j(), !["2023", "2024"].includes(v)) throw g(v, "edition");
              d(";");
              break;
            case "option":
              S2(b, h), d(";", true);
              break;
            default:
              if (_2(b, h)) {
                p = false;
                continue;
              }
              throw g(h);
          }
          return w2.forEach((i4) => {
            i4.f = v, Object.keys(y).forEach((t4) => {
              i4.getOption(t4) === it && i4.setOption(t4, y[t4], true);
            });
          }), tt.filename = null, { package: r2, imports: e, weakImports: s, root: i3 };
        }
      }, { 15: 15, 16: 16, 20: 20, 22: 22, 24: 24, 25: 25, 29: 29, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37 }], 27: [function(t2, i2, n2) {
        i2.exports = f;
        var r2, e = t2(39), s = e.LongBits, o = e.utf8;
        function u(t3, i3) {
          return RangeError("index out of range: " + t3.pos + " + " + (i3 || 1) + " > " + t3.len);
        }
        function f(t3) {
          this.buf = t3, this.pos = 0, this.len = t3.length;
        }
        function h() {
          return e.Buffer ? function(t3) {
            return (f.create = function(t4) {
              return e.Buffer.isBuffer(t4) ? new r2(t4) : c(t4);
            })(t3);
          } : c;
        }
        var a, c = "undefined" != typeof Uint8Array ? function(t3) {
          if (t3 instanceof Uint8Array || Array.isArray(t3)) return new f(t3);
          throw Error("illegal buffer");
        } : function(t3) {
          if (Array.isArray(t3)) return new f(t3);
          throw Error("illegal buffer");
        };
        function l() {
          var t3 = new s(0, 0), i3 = 0;
          if (!(4 < this.len - this.pos)) {
            for (; i3 < 3; ++i3) {
              if (this.pos >= this.len) throw u(this);
              if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 7 * i3) >>> 0, this.buf[this.pos++] < 128) return t3;
            }
            return t3.lo = (t3.lo | (127 & this.buf[this.pos++]) << 7 * i3) >>> 0, t3;
          }
          for (; i3 < 4; ++i3) if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 7 * i3) >>> 0, this.buf[this.pos++] < 128) return t3;
          if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t3.hi = (t3.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return t3;
          if (i3 = 0, 4 < this.len - this.pos) {
            for (; i3 < 5; ++i3) if (t3.hi = (t3.hi | (127 & this.buf[this.pos]) << 7 * i3 + 3) >>> 0, this.buf[this.pos++] < 128) return t3;
          } else for (; i3 < 5; ++i3) {
            if (this.pos >= this.len) throw u(this);
            if (t3.hi = (t3.hi | (127 & this.buf[this.pos]) << 7 * i3 + 3) >>> 0, this.buf[this.pos++] < 128) return t3;
          }
          throw Error("invalid varint encoding");
        }
        function d(t3, i3) {
          return (t3[i3 - 4] | t3[i3 - 3] << 8 | t3[i3 - 2] << 16 | t3[i3 - 1] << 24) >>> 0;
        }
        function p() {
          if (this.pos + 8 > this.len) throw u(this, 8);
          return new s(d(this.buf, this.pos += 4), d(this.buf, this.pos += 4));
        }
        f.create = h(), f.prototype.T = e.Array.prototype.subarray || e.Array.prototype.slice, f.prototype.uint32 = (a = 4294967295, function() {
          if (a = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128 || (a = (a | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128 || (a = (a | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128 || (a = (a | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128 || (a = (a | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128 || !((this.pos += 5) > this.len)))))) return a;
          throw this.pos = this.len, u(this, 10);
        }), f.prototype.int32 = function() {
          return 0 | this.uint32();
        }, f.prototype.sint32 = function() {
          var t3 = this.uint32();
          return t3 >>> 1 ^ -(1 & t3) | 0;
        }, f.prototype.bool = function() {
          return 0 !== this.uint32();
        }, f.prototype.fixed32 = function() {
          if (this.pos + 4 > this.len) throw u(this, 4);
          return d(this.buf, this.pos += 4);
        }, f.prototype.sfixed32 = function() {
          if (this.pos + 4 > this.len) throw u(this, 4);
          return 0 | d(this.buf, this.pos += 4);
        }, f.prototype.float = function() {
          if (this.pos + 4 > this.len) throw u(this, 4);
          var t3 = e.float.readFloatLE(this.buf, this.pos);
          return this.pos += 4, t3;
        }, f.prototype.double = function() {
          if (this.pos + 8 > this.len) throw u(this, 4);
          var t3 = e.float.readDoubleLE(this.buf, this.pos);
          return this.pos += 8, t3;
        }, f.prototype.bytes = function() {
          var t3 = this.uint32(), i3 = this.pos, n3 = this.pos + t3;
          if (n3 > this.len) throw u(this, t3);
          return this.pos += t3, Array.isArray(this.buf) ? this.buf.slice(i3, n3) : i3 === n3 ? (t3 = e.Buffer) ? t3.alloc(0) : new this.buf.constructor(0) : this.T.call(this.buf, i3, n3);
        }, f.prototype.string = function() {
          var t3 = this.bytes();
          return o.read(t3, 0, t3.length);
        }, f.prototype.skip = function(t3) {
          if ("number" == typeof t3) {
            if (this.pos + t3 > this.len) throw u(this, t3);
            this.pos += t3;
          } else do {
            if (this.pos >= this.len) throw u(this);
          } while (128 & this.buf[this.pos++]);
          return this;
        }, f.prototype.skipType = function(t3) {
          switch (t3) {
            case 0:
              this.skip();
              break;
            case 1:
              this.skip(8);
              break;
            case 2:
              this.skip(this.uint32());
              break;
            case 3:
              for (; 4 != (t3 = 7 & this.uint32()); ) this.skipType(t3);
              break;
            case 5:
              this.skip(4);
              break;
            default:
              throw Error("invalid wire type " + t3 + " at offset " + this.pos);
          }
          return this;
        }, f.p = function(t3) {
          r2 = t3, f.create = h(), r2.p();
          var i3 = e.Long ? "toLong" : "toNumber";
          e.merge(f.prototype, { int64: function() {
            return l.call(this)[i3](false);
          }, uint64: function() {
            return l.call(this)[i3](true);
          }, sint64: function() {
            return l.call(this).zzDecode()[i3](false);
          }, fixed64: function() {
            return p.call(this)[i3](true);
          }, sfixed64: function() {
            return p.call(this)[i3](false);
          } });
        };
      }, { 39: 39 }], 28: [function(t2, i2, n2) {
        i2.exports = s;
        var r2 = t2(27), e = ((s.prototype = Object.create(r2.prototype)).constructor = s, t2(39));
        function s(t3) {
          r2.call(this, t3);
        }
        s.p = function() {
          e.Buffer && (s.prototype.T = e.Buffer.prototype.slice);
        }, s.prototype.string = function() {
          var t3 = this.uint32();
          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t3, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t3, this.len));
        }, s.p();
      }, { 27: 27, 39: 39 }], 29: [function(t2, i2, n2) {
        i2.exports = f;
        var r2, d, p, e = t2(23), s = (((f.prototype = Object.create(e.prototype)).constructor = f).className = "Root", t2(16)), o = t2(15), u = t2(25), v = t2(37);
        function f(t3) {
          e.call(this, "", t3), this.deferred = [], this.files = [], this.f = "proto2", this.j = {};
        }
        function b() {
        }
        f.fromJSON = function(t3, i3) {
          return i3 = i3 || new f(), t3.options && i3.setOptions(t3.options), i3.addJSON(t3.nested).resolveAll();
        }, f.prototype.resolvePath = v.path.resolve, f.prototype.fetch = v.fetch, f.prototype.load = function t3(i3, s2, e2) {
          "function" == typeof s2 && (e2 = s2, s2 = it);
          var o2 = this;
          if (!e2) return v.asPromise(t3, o2, i3, s2);
          var u2 = e2 === b;
          function f2(t4, i4) {
            if (e2) {
              if (u2) throw t4;
              i4 && i4.resolveAll();
              var n4 = e2;
              e2 = null, n4(t4, i4);
            }
          }
          function h2(t4) {
            var i4 = t4.lastIndexOf("google/protobuf/");
            if (-1 < i4) {
              t4 = t4.substring(i4);
              if (t4 in p) return t4;
            }
            return null;
          }
          function a2(t4, i4) {
            try {
              if (v.isString(i4) && "{" == (i4[0] || "") && (i4 = JSON.parse(i4)), v.isString(i4)) {
                d.filename = t4;
                var n4, r4 = d(i4, o2, s2), e3 = 0;
                if (r4.imports) for (; e3 < r4.imports.length; ++e3) (n4 = h2(r4.imports[e3]) || o2.resolvePath(t4, r4.imports[e3])) && c(n4);
                if (r4.weakImports) for (e3 = 0; e3 < r4.weakImports.length; ++e3) (n4 = h2(r4.weakImports[e3]) || o2.resolvePath(t4, r4.weakImports[e3])) && c(n4, true);
              } else o2.setOptions(i4.options).addJSON(i4.nested);
            } catch (t5) {
              f2(t5);
            }
            u2 || l || f2(null, o2);
          }
          function c(n4, r4) {
            if (n4 = h2(n4) || n4, !~o2.files.indexOf(n4)) if (o2.files.push(n4), n4 in p) u2 ? a2(n4, p[n4]) : (++l, setTimeout(function() {
              --l, a2(n4, p[n4]);
            }));
            else if (u2) {
              var t4;
              try {
                t4 = v.fs.readFileSync(n4).toString("utf8");
              } catch (t5) {
                return void (r4 || f2(t5));
              }
              a2(n4, t4);
            } else ++l, o2.fetch(n4, function(t5, i4) {
              --l, e2 && (t5 ? r4 ? l || f2(null, o2) : f2(t5) : a2(n4, i4));
            });
          }
          var l = 0;
          v.isString(i3) && (i3 = [i3]);
          for (var n3, r3 = 0; r3 < i3.length; ++r3) (n3 = o2.resolvePath("", i3[r3])) && c(n3);
          return u2 ? o2.resolveAll() : l || f2(null, o2), o2;
        }, f.prototype.loadSync = function(t3, i3) {
          if (v.isNode) return this.load(t3, i3, b);
          throw Error("not supported");
        }, f.prototype.resolveAll = function() {
          if (!this.y) return this;
          if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function(t3) {
            return "'extend " + t3.extend + "' in " + t3.parent.fullName;
          }).join(", "));
          return e.prototype.resolveAll.call(this);
        };
        var h = /^[A-Z]/;
        function a(t3, i3) {
          var n3, r3 = i3.parent.lookup(i3.extend);
          if (r3) return n3 = new s(i3.fullName, i3.id, i3.type, i3.rule, it, i3.options), r3.get(n3.name) || ((n3.declaringField = i3).extensionField = n3, r3.add(n3)), 1;
        }
        f.prototype._ = function(t3) {
          if (t3 instanceof s) t3.extend === it || t3.extensionField || a(0, t3) || this.deferred.push(t3);
          else if (t3 instanceof o) h.test(t3.name) && (t3.parent[t3.name] = t3.values);
          else if (!(t3 instanceof u)) {
            if (t3 instanceof r2) for (var i3 = 0; i3 < this.deferred.length; ) a(0, this.deferred[i3]) ? this.deferred.splice(i3, 1) : ++i3;
            for (var n3 = 0; n3 < t3.nestedArray.length; ++n3) this._(t3.v[n3]);
            h.test(t3.name) && (t3.parent[t3.name] = t3);
          }
          (t3 instanceof r2 || t3 instanceof o || t3 instanceof s) && (this.j[t3.fullName] = t3);
        }, f.prototype.A = function(t3) {
          var i3;
          if (t3 instanceof s) t3.extend !== it && (t3.extensionField ? (t3.extensionField.parent.remove(t3.extensionField), t3.extensionField = null) : -1 < (i3 = this.deferred.indexOf(t3)) && this.deferred.splice(i3, 1));
          else if (t3 instanceof o) h.test(t3.name) && delete t3.parent[t3.name];
          else if (t3 instanceof e) {
            for (var n3 = 0; n3 < t3.nestedArray.length; ++n3) this.A(t3.v[n3]);
            h.test(t3.name) && delete t3.parent[t3.name];
          }
          delete this.j[t3.fullName];
        }, f.p = function(t3, i3, n3) {
          r2 = t3, d = i3, p = n3;
        };
      }, { 15: 15, 16: 16, 23: 23, 25: 25, 37: 37 }], 30: [function(t2, i2, n2) {
        i2.exports = {};
      }, {}], 31: [function(t2, i2, n2) {
        n2.Service = t2(32);
      }, { 32: 32 }], 32: [function(t2, i2, n2) {
        i2.exports = r2;
        var u = t2(39);
        function r2(t3, i3, n3) {
          if ("function" != typeof t3) throw TypeError("rpcImpl must be a function");
          u.EventEmitter.call(this), this.rpcImpl = t3, this.requestDelimited = !!i3, this.responseDelimited = !!n3;
        }
        ((r2.prototype = Object.create(u.EventEmitter.prototype)).constructor = r2).prototype.rpcCall = function t3(n3, i3, r3, e, s) {
          if (!e) throw TypeError("request must be specified");
          var o = this;
          if (!s) return u.asPromise(t3, o, n3, i3, r3, e);
          if (!o.rpcImpl) return setTimeout(function() {
            s(Error("already ended"));
          }, 0), it;
          try {
            return o.rpcImpl(n3, i3[o.requestDelimited ? "encodeDelimited" : "encode"](e).finish(), function(t4, i4) {
              if (t4) return o.emit("error", t4, n3), s(t4);
              if (null === i4) return o.end(true), it;
              if (!(i4 instanceof r3)) try {
                i4 = r3[o.responseDelimited ? "decodeDelimited" : "decode"](i4);
              } catch (t5) {
                return o.emit("error", t5, n3), s(t5);
              }
              return o.emit("data", i4, n3), s(null, i4);
            });
          } catch (t4) {
            return o.emit("error", t4, n3), setTimeout(function() {
              s(t4);
            }, 0), it;
          }
        }, r2.prototype.end = function(t3) {
          return this.rpcImpl && (t3 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
        };
      }, { 39: 39 }], 33: [function(t2, i2, n2) {
        i2.exports = o;
        var r2 = t2(23), s = (((o.prototype = Object.create(r2.prototype)).constructor = o).className = "Service", t2(22)), u = t2(37), f = t2(31);
        function o(t3, i3) {
          r2.call(this, t3, i3), this.methods = {}, this.x = null;
        }
        function e(t3) {
          return t3.x = null, t3;
        }
        o.fromJSON = function(t3, i3) {
          var n3 = new o(t3, i3.options);
          if (i3.methods) for (var r3 = Object.keys(i3.methods), e2 = 0; e2 < r3.length; ++e2) n3.add(s.fromJSON(r3[e2], i3.methods[r3[e2]]));
          return i3.nested && n3.addJSON(i3.nested), i3.edition && (n3.f = i3.edition), n3.comment = i3.comment, n3.a = "proto3", n3;
        }, o.prototype.toJSON = function(t3) {
          var i3 = r2.prototype.toJSON.call(this, t3), n3 = !!t3 && !!t3.keepComments;
          return u.toObject(["edition", this.c(), "options", i3 && i3.options || it, "methods", r2.arrayToJSON(this.methodsArray, t3) || {}, "nested", i3 && i3.nested || it, "comment", n3 ? this.comment : it]);
        }, Object.defineProperty(o.prototype, "methodsArray", { get: function() {
          return this.x || (this.x = u.toArray(this.methods));
        } }), o.prototype.get = function(t3) {
          return this.methods[t3] || r2.prototype.get.call(this, t3);
        }, o.prototype.resolveAll = function() {
          if (this.y) {
            r2.prototype.resolve.call(this);
            for (var t3 = this.methodsArray, i3 = 0; i3 < t3.length; ++i3) t3[i3].resolve();
          }
          return this;
        }, o.prototype.g = function(i3) {
          return this.w && (i3 = this.f || i3, r2.prototype.g.call(this, i3), this.methodsArray.forEach((t3) => {
            t3.g(i3);
          })), this;
        }, o.prototype.add = function(t3) {
          if (this.get(t3.name)) throw Error("duplicate name '" + t3.name + "' in " + this);
          return t3 instanceof s ? e((this.methods[t3.name] = t3).parent = this) : r2.prototype.add.call(this, t3);
        }, o.prototype.remove = function(t3) {
          if (t3 instanceof s) {
            if (this.methods[t3.name] !== t3) throw Error(t3 + " is not a member of " + this);
            return delete this.methods[t3.name], t3.parent = null, e(this);
          }
          return r2.prototype.remove.call(this, t3);
        }, o.prototype.create = function(t3, i3, n3) {
          for (var r3, e2 = new f.Service(t3, i3, n3), s2 = 0; s2 < this.methodsArray.length; ++s2) {
            var o2 = u.lcFirst((r3 = this.x[s2]).resolve().name).replace(/[^$\w_]/g, "");
            e2[o2] = u.codegen(["r", "c"], u.isReserved(o2) ? o2 + "_" : o2)("return this.rpcCall(m,q,s,r,c)")({ m: r3, q: r3.resolvedRequestType.ctor, s: r3.resolvedResponseType.ctor });
          }
          return e2;
        };
      }, { 22: 22, 23: 23, 31: 31, 37: 37 }], 34: [function(t2, i2, n2) {
        i2.exports = s;
        var k = /[\s{}=;:[\],'"()<>]/g, O = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g, _2 = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g, A = /^ *[*/]+ */, T = /^\s*\*?\/*/, x = /\n/g, L3 = /\s/, r2 = /\\(.?)/g, e = { 0: "\0", r: "\r", n: "\n", t: "	" };
        function S2(t3) {
          return t3.replace(r2, function(t4, i3) {
            switch (i3) {
              case "\\":
              case "":
                return i3;
              default:
                return e[i3] || "";
            }
          });
        }
        function s(h, a) {
          h = h.toString();
          var c = 0, l = h.length, d = 1, f = 0, p = {}, v = [], b = null;
          function w2(t3) {
            return Error("illegal " + t3 + " (line " + d + ")");
          }
          function y(t3) {
            return h[0 | t3] || "";
          }
          function m(t3, i3, n3) {
            var r4, e3 = { type: h[0 | t3++] || "", lineEmpty: false, leading: n3 }, n3 = a ? 2 : 3, s2 = t3 - n3;
            do {
              if (--s2 < 0 || "\n" == (r4 = h[0 | s2] || "")) {
                e3.lineEmpty = true;
                break;
              }
            } while (" " === r4 || "	" === r4);
            for (var o = h.substring(t3, i3).split(x), u = 0; u < o.length; ++u) o[u] = o[u].replace(a ? T : A, "").trim();
            e3.text = o.join("\n").trim(), p[d] = e3, f = d;
          }
          function g(t3) {
            var i3 = j(t3), t3 = h.substring(t3, i3);
            return /^\s*\/\//.test(t3);
          }
          function j(t3) {
            for (var i3 = t3; i3 < l && "\n" !== y(i3); ) i3++;
            return i3;
          }
          function r3() {
            if (0 < v.length) return v.shift();
            if (b) {
              var t3 = "'" === b ? _2 : O, i3 = (t3.lastIndex = c - 1, t3.exec(h));
              if (i3) return c = t3.lastIndex, E(b), b = null, S2(i3[1]);
              throw w2("string");
            }
            var n3, r4, e3, s2, o, u = 0 === c;
            do {
              if (c === l) return null;
              for (n3 = false; L3.test(e3 = y(c)); ) if ("\n" === e3 && (u = true, ++d), ++c === l) return null;
              if ("/" === y(c)) {
                if (++c === l) throw w2("comment");
                if ("/" === y(c)) if (a) {
                  if (o = false, g((s2 = c) - 1)) for (o = true; (c = j(c)) !== l && (c++, u && g(c)); ) ;
                  else c = Math.min(l, j(c) + 1);
                  o && (m(s2, c, u), u = true), d++;
                } else {
                  for (o = "/" === y(s2 = c + 1); "\n" !== y(++c); ) if (c === l) return null;
                  ++c, o && (m(s2, c - 1, u), u = true), ++d;
                }
                else {
                  if ("*" !== (e3 = y(c))) return "/";
                  s2 = c + 1, o = a || "*" === y(s2);
                  do {
                    if ("\n" === e3 && ++d, ++c === l) throw w2("comment");
                  } while (r4 = e3, e3 = y(c), "*" !== r4 || "/" !== e3);
                  ++c, o && (m(s2, c - 2, u), u = true);
                }
                n3 = true;
              }
            } while (n3);
            var f2 = c;
            if (k.lastIndex = 0, !k.test(y(f2++))) for (; f2 < l && !k.test(y(f2)); ) ++f2;
            t3 = h.substring(c, c = f2);
            return '"' != t3 && "'" != t3 || (b = t3), t3;
          }
          function E(t3) {
            v.push(t3);
          }
          function e2() {
            if (!v.length) {
              var t3 = r3();
              if (null === t3) return null;
              E(t3);
            }
            return v[0];
          }
          return Object.defineProperty({ next: r3, peek: e2, push: E, skip: function(t3, i3) {
            var n3 = e2();
            if (n3 === t3) return r3(), true;
            if (i3) return false;
            throw w2("token '" + n3 + "', '" + t3 + "' expected");
          }, cmnt: function(t3) {
            var i3, n3 = null;
            return t3 === it ? (i3 = p[d - 1], delete p[d - 1], i3 && (a || "*" === i3.type || i3.lineEmpty) && (n3 = i3.leading ? i3.text : null)) : (f < t3 && e2(), i3 = p[t3], delete p[t3], !i3 || i3.lineEmpty || !a && "/" !== i3.type || (n3 = i3.leading ? null : i3.text)), n3;
          } }, "line", { get: function() {
            return d;
          } });
        }
        s.unescape = S2;
      }, {}], 35: [function(t2, i2, n2) {
        i2.exports = m;
        var o = t2(23), u = (((m.prototype = Object.create(o.prototype)).constructor = m).className = "Type", t2(15)), f = t2(25), h = t2(16), a = t2(20), c = t2(33), e = t2(21), s = t2(27), l = t2(42), d = t2(37), p = t2(14), v = t2(13), b = t2(40), w2 = t2(12), y = t2(41);
        function m(t3, i3) {
          o.call(this, t3, i3), this.fields = {}, this.oneofs = it, this.extensions = it, this.reserved = it, this.group = it, this.L = null, this.e = null, this.S = null, this.I = null;
        }
        function r2(t3) {
          return t3.L = t3.e = t3.S = null, delete t3.encode, delete t3.decode, delete t3.verify, t3;
        }
        Object.defineProperties(m.prototype, { fieldsById: { get: function() {
          if (!this.L) {
            this.L = {};
            for (var t3 = Object.keys(this.fields), i3 = 0; i3 < t3.length; ++i3) {
              var n3 = this.fields[t3[i3]], r3 = n3.id;
              if (this.L[r3]) throw Error("duplicate id " + r3 + " in " + this);
              this.L[r3] = n3;
            }
          }
          return this.L;
        } }, fieldsArray: { get: function() {
          return this.e || (this.e = d.toArray(this.fields));
        } }, oneofsArray: { get: function() {
          return this.S || (this.S = d.toArray(this.oneofs));
        } }, ctor: { get: function() {
          return this.I || (this.ctor = m.generateConstructor(this)());
        }, set: function(t3) {
          for (var i3 = t3.prototype, n3 = (i3 instanceof e || ((t3.prototype = new e()).constructor = t3, d.merge(t3.prototype, i3)), t3.$type = t3.prototype.$type = this, d.merge(t3, e, true), this.I = t3, 0); n3 < this.fieldsArray.length; ++n3) this.e[n3].resolve();
          for (var r3 = {}, n3 = 0; n3 < this.oneofsArray.length; ++n3) r3[this.S[n3].resolve().name] = { get: d.oneOfGetter(this.S[n3].oneof), set: d.oneOfSetter(this.S[n3].oneof) };
          n3 && Object.defineProperties(t3.prototype, r3);
        } } }), m.generateConstructor = function(t3) {
          for (var i3, n3 = d.codegen(["p"], t3.name), r3 = 0; r3 < t3.fieldsArray.length; ++r3) (i3 = t3.e[r3]).map ? n3("this%s={}", d.safeProp(i3.name)) : i3.repeated && n3("this%s=[]", d.safeProp(i3.name));
          return n3("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
        }, m.fromJSON = function(t3, i3) {
          for (var n3 = new m(t3, i3.options), r3 = (n3.extensions = i3.extensions, n3.reserved = i3.reserved, Object.keys(i3.fields)), e2 = 0; e2 < r3.length; ++e2) n3.add((void 0 !== i3.fields[r3[e2]].keyType ? a : h).fromJSON(r3[e2], i3.fields[r3[e2]]));
          if (i3.oneofs) for (r3 = Object.keys(i3.oneofs), e2 = 0; e2 < r3.length; ++e2) n3.add(f.fromJSON(r3[e2], i3.oneofs[r3[e2]]));
          if (i3.nested) for (r3 = Object.keys(i3.nested), e2 = 0; e2 < r3.length; ++e2) {
            var s2 = i3.nested[r3[e2]];
            n3.add((s2.id !== it ? h : s2.fields !== it ? m : s2.values !== it ? u : s2.methods !== it ? c : o).fromJSON(r3[e2], s2));
          }
          return i3.extensions && i3.extensions.length && (n3.extensions = i3.extensions), i3.reserved && i3.reserved.length && (n3.reserved = i3.reserved), i3.group && (n3.group = true), i3.comment && (n3.comment = i3.comment), i3.edition && (n3.f = i3.edition), n3.a = "proto3", n3;
        }, m.prototype.toJSON = function(t3) {
          var i3 = o.prototype.toJSON.call(this, t3), n3 = !!t3 && !!t3.keepComments;
          return d.toObject(["edition", this.c(), "options", i3 && i3.options || it, "oneofs", o.arrayToJSON(this.oneofsArray, t3), "fields", o.arrayToJSON(this.fieldsArray.filter(function(t4) {
            return !t4.declaringField;
          }), t3) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : it, "reserved", this.reserved && this.reserved.length ? this.reserved : it, "group", this.group || it, "nested", i3 && i3.nested || it, "comment", n3 ? this.comment : it]);
        }, m.prototype.resolveAll = function() {
          if (this.y) {
            o.prototype.resolveAll.call(this);
            for (var t3 = this.oneofsArray, i3 = 0; i3 < t3.length; ) t3[i3++].resolve();
            for (var n3 = this.fieldsArray, i3 = 0; i3 < n3.length; ) n3[i3++].resolve();
          }
          return this;
        }, m.prototype.g = function(i3) {
          return this.w && (i3 = this.f || i3, o.prototype.g.call(this, i3), this.oneofsArray.forEach((t3) => {
            t3.u(i3);
          }), this.fieldsArray.forEach((t3) => {
            t3.u(i3);
          })), this;
        }, m.prototype.get = function(t3) {
          return this.fields[t3] || this.oneofs && this.oneofs[t3] || this.nested && this.nested[t3] || null;
        }, m.prototype.add = function(t3) {
          if (this.get(t3.name)) throw Error("duplicate name '" + t3.name + "' in " + this);
          if (t3 instanceof h && t3.extend === it) {
            if ((this.L || this.fieldsById)[t3.id]) throw Error("duplicate id " + t3.id + " in " + this);
            if (this.isReservedId(t3.id)) throw Error("id " + t3.id + " is reserved in " + this);
            if (this.isReservedName(t3.name)) throw Error("name '" + t3.name + "' is reserved in " + this);
            return t3.parent && t3.parent.remove(t3), (this.fields[t3.name] = t3).message = this, t3.onAdd(this), r2(this);
          }
          return t3 instanceof f ? (this.oneofs || (this.oneofs = {}), (this.oneofs[t3.name] = t3).onAdd(this), r2(this)) : o.prototype.add.call(this, t3);
        }, m.prototype.remove = function(t3) {
          if (t3 instanceof h && t3.extend === it) {
            if (this.fields && this.fields[t3.name] === t3) return delete this.fields[t3.name], t3.parent = null, t3.onRemove(this), r2(this);
            throw Error(t3 + " is not a member of " + this);
          }
          if (t3 instanceof f) {
            if (this.oneofs && this.oneofs[t3.name] === t3) return delete this.oneofs[t3.name], t3.parent = null, t3.onRemove(this), r2(this);
            throw Error(t3 + " is not a member of " + this);
          }
          return o.prototype.remove.call(this, t3);
        }, m.prototype.isReservedId = function(t3) {
          return o.isReservedId(this.reserved, t3);
        }, m.prototype.isReservedName = function(t3) {
          return o.isReservedName(this.reserved, t3);
        }, m.prototype.create = function(t3) {
          return new this.ctor(t3);
        }, m.prototype.setup = function() {
          for (var t3 = this.fullName, i3 = [], n3 = 0; n3 < this.fieldsArray.length; ++n3) i3.push(this.e[n3].resolve().resolvedType);
          this.encode = p(this)({ Writer: l, types: i3, util: d }), this.decode = v(this)({ Reader: s, types: i3, util: d }), this.verify = b(this)({ types: i3, util: d }), this.fromObject = w2.fromObject(this)({ types: i3, util: d }), this.toObject = w2.toObject(this)({ types: i3, util: d });
          var r3, t3 = y[t3];
          return t3 && ((r3 = Object.create(this)).fromObject = this.fromObject, this.fromObject = t3.fromObject.bind(r3), r3.toObject = this.toObject, this.toObject = t3.toObject.bind(r3)), this;
        }, m.prototype.encode = function(t3, i3) {
          return this.setup().encode(t3, i3);
        }, m.prototype.encodeDelimited = function(t3, i3) {
          return this.encode(t3, i3 && i3.len ? i3.fork() : i3).ldelim();
        }, m.prototype.decode = function(t3, i3) {
          return this.setup().decode(t3, i3);
        }, m.prototype.decodeDelimited = function(t3) {
          return t3 instanceof s || (t3 = s.create(t3)), this.decode(t3, t3.uint32());
        }, m.prototype.verify = function(t3) {
          return this.setup().verify(t3);
        }, m.prototype.fromObject = function(t3) {
          return this.setup().fromObject(t3);
        }, m.prototype.toObject = function(t3, i3) {
          return this.setup().toObject(t3, i3);
        }, m.d = function(i3) {
          return function(t3) {
            d.decorateType(t3, i3);
          };
        };
      }, { 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 20: 20, 21: 21, 23: 23, 25: 25, 27: 27, 33: 33, 37: 37, 40: 40, 41: 41, 42: 42 }], 36: [function(t2, i2, n2) {
        var t2 = t2(37), e = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64", "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"];
        function r2(t3, i3) {
          var n3 = 0, r3 = {};
          for (i3 |= 0; n3 < t3.length; ) r3[e[n3 + i3]] = t3[n3++];
          return r3;
        }
        n2.basic = r2([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), n2.defaults = r2([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, "", t2.emptyArray, null]), n2.long = r2([0, 0, 0, 1, 1], 7), n2.mapKey = r2([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), n2.packed = r2([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);
      }, { 37: 37 }], 37: [function(n2, t2, i2) {
        var r2, e, s = t2.exports = n2(39), o = n2(30), u = (s.codegen = n2(3), s.fetch = n2(5), s.path = n2(8), s.fs = s.inquire("fs"), s.toArray = function(t3) {
          if (t3) {
            for (var i3 = Object.keys(t3), n3 = Array(i3.length), r3 = 0; r3 < i3.length; ) n3[r3] = t3[i3[r3++]];
            return n3;
          }
          return [];
        }, s.toObject = function(t3) {
          for (var i3 = {}, n3 = 0; n3 < t3.length; ) {
            var r3 = t3[n3++], e2 = t3[n3++];
            e2 !== it && (i3[r3] = e2);
          }
          return i3;
        }, /\\/g), f = /"/g, h = (s.isReserved = function(t3) {
          return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(t3);
        }, s.safeProp = function(t3) {
          return !/^[$\w_]+$/.test(t3) || s.isReserved(t3) ? '["' + t3.replace(u, "\\\\").replace(f, '\\"') + '"]' : "." + t3;
        }, s.ucFirst = function(t3) {
          return (t3[0] || "").toUpperCase() + t3.substring(1);
        }, /_([a-z])/g), a = (s.camelCase = function(t3) {
          return t3.substring(0, 1) + t3.substring(1).replace(h, function(t4, i3) {
            return i3.toUpperCase();
          });
        }, s.compareFieldsById = function(t3, i3) {
          return t3.id - i3.id;
        }, s.decorateType = function(t3, i3) {
          return t3.$type ? (i3 && t3.$type.name !== i3 && (s.decorateRoot.remove(t3.$type), t3.$type.name = i3, s.decorateRoot.add(t3.$type)), t3.$type) : (i3 = new (r2 = r2 || n2(35))(i3 || t3.name), s.decorateRoot.add(i3), i3.ctor = t3, Object.defineProperty(t3, "$type", { value: i3, enumerable: false }), Object.defineProperty(t3.prototype, "$type", { value: i3, enumerable: false }), i3);
        }, 0);
        s.decorateEnum = function(t3) {
          var i3;
          return t3.$type || (i3 = new (e = e || n2(15))("Enum" + a++, t3), s.decorateRoot.add(i3), Object.defineProperty(t3, "$type", { value: i3, enumerable: false }), i3);
        }, s.setProperty = function(t3, i3, n3, s2) {
          if ("object" != typeof t3) throw TypeError("dst must be an object");
          if (i3) return (function t4(i4, n4, r3) {
            var e2 = n4.shift();
            if ("__proto__" !== e2 && "prototype" !== e2) if (0 < n4.length) i4[e2] = t4(i4[e2] || {}, n4, r3);
            else {
              if ((n4 = i4[e2]) && s2) return i4;
              n4 && (r3 = [].concat(n4).concat(r3)), i4[e2] = r3;
            }
            return i4;
          })(t3, i3 = i3.split("."), n3);
          throw TypeError("path must be specified");
        }, Object.defineProperty(s, "decorateRoot", { get: function() {
          return o.decorated || (o.decorated = new (n2(29))());
        } });
      }, { 15: 15, 29: 29, 3: 3, 30: 30, 35: 35, 39: 39, 5: 5, 8: 8 }], 38: [function(t2, i2, n2) {
        i2.exports = e;
        var r2 = t2(39);
        function e(t3, i3) {
          this.lo = t3 >>> 0, this.hi = i3 >>> 0;
        }
        var s = e.zero = new e(0, 0), o = (s.toNumber = function() {
          return 0;
        }, s.zzEncode = s.zzDecode = function() {
          return this;
        }, s.length = function() {
          return 1;
        }, e.zeroHash = "\0\0\0\0\0\0\0\0", e.fromNumber = function(t3) {
          var i3, n3;
          return 0 === t3 ? s : (n3 = (t3 = (i3 = t3 < 0) ? -t3 : t3) >>> 0, t3 = (t3 - n3) / 4294967296 >>> 0, i3 && (t3 = ~t3 >>> 0, n3 = ~n3 >>> 0, 4294967295 < ++n3 && (n3 = 0, 4294967295 < ++t3 && (t3 = 0))), new e(n3, t3));
        }, e.from = function(t3) {
          if ("number" == typeof t3) return e.fromNumber(t3);
          if (r2.isString(t3)) {
            if (!r2.Long) return e.fromNumber(parseInt(t3, 10));
            t3 = r2.Long.fromString(t3);
          }
          return t3.low || t3.high ? new e(t3.low >>> 0, t3.high >>> 0) : s;
        }, e.prototype.toNumber = function(t3) {
          var i3;
          return !t3 && this.hi >>> 31 ? (t3 = 1 + ~this.lo >>> 0, i3 = ~this.hi >>> 0, -(t3 + 4294967296 * (i3 = t3 ? i3 : i3 + 1 >>> 0))) : this.lo + 4294967296 * this.hi;
        }, e.prototype.toLong = function(t3) {
          return r2.Long ? new r2.Long(0 | this.lo, 0 | this.hi, !!t3) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: !!t3 };
        }, String.prototype.charCodeAt);
        e.fromHash = function(t3) {
          return "\0\0\0\0\0\0\0\0" === t3 ? s : new e((o.call(t3, 0) | o.call(t3, 1) << 8 | o.call(t3, 2) << 16 | o.call(t3, 3) << 24) >>> 0, (o.call(t3, 4) | o.call(t3, 5) << 8 | o.call(t3, 6) << 16 | o.call(t3, 7) << 24) >>> 0);
        }, e.prototype.toHash = function() {
          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
        }, e.prototype.zzEncode = function() {
          var t3 = this.hi >> 31;
          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t3) >>> 0, this.lo = (this.lo << 1 ^ t3) >>> 0, this;
        }, e.prototype.zzDecode = function() {
          var t3 = -(1 & this.lo);
          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t3) >>> 0, this.hi = (this.hi >>> 1 ^ t3) >>> 0, this;
        }, e.prototype.length = function() {
          var t3 = this.lo, i3 = (this.lo >>> 28 | this.hi << 4) >>> 0, n3 = this.hi >>> 24;
          return 0 == n3 ? 0 == i3 ? t3 < 16384 ? t3 < 128 ? 1 : 2 : t3 < 2097152 ? 3 : 4 : i3 < 16384 ? i3 < 128 ? 5 : 6 : i3 < 2097152 ? 7 : 8 : n3 < 128 ? 9 : 10;
        };
      }, { 39: 39 }], 39: [function(t2, i2, n2) {
        var r2 = n2;
        function e(t3, i3, n3) {
          for (var r3 = Object.keys(i3), e2 = 0; e2 < r3.length; ++e2) t3[r3[e2]] !== it && n3 || (t3[r3[e2]] = i3[r3[e2]]);
          return t3;
        }
        function s(t3) {
          function n3(t4, i3) {
            if (!(this instanceof n3)) return new n3(t4, i3);
            Object.defineProperty(this, "message", { get: function() {
              return t4;
            } }), Error.captureStackTrace ? Error.captureStackTrace(this, n3) : Object.defineProperty(this, "stack", { value: Error().stack || "" }), i3 && e(this, i3);
          }
          return n3.prototype = Object.create(Error.prototype, { constructor: { value: n3, writable: true, enumerable: false, configurable: true }, name: { get: function() {
            return t3;
          }, set: it, enumerable: false, configurable: true }, toString: { value: function() {
            return this.name + ": " + this.message;
          }, writable: true, enumerable: false, configurable: true } }), n3;
        }
        r2.asPromise = t2(1), r2.base64 = t2(2), r2.EventEmitter = t2(4), r2.float = t2(6), r2.inquire = t2(7), r2.utf8 = t2(10), r2.pool = t2(9), r2.LongBits = t2(38), r2.isNode = !!("undefined" != typeof globalThis && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node), r2.global = r2.isNode && globalThis || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r2.emptyArray = Object.freeze ? Object.freeze([]) : [], r2.emptyObject = Object.freeze ? Object.freeze({}) : {}, r2.isInteger = Number.isInteger || function(t3) {
          return "number" == typeof t3 && isFinite(t3) && Math.floor(t3) === t3;
        }, r2.isString = function(t3) {
          return "string" == typeof t3 || t3 instanceof String;
        }, r2.isObject = function(t3) {
          return t3 && "object" == typeof t3;
        }, r2.isset = r2.isSet = function(t3, i3) {
          var n3 = t3[i3];
          return null != n3 && t3.hasOwnProperty(i3) && ("object" != typeof n3 || 0 < (Array.isArray(n3) ? n3 : Object.keys(n3)).length);
        }, r2.Buffer = (function() {
          try {
            var t3 = r2.inquire("buffer").Buffer;
            return t3.prototype.utf8Write ? t3 : null;
          } catch (t4) {
            return null;
          }
        })(), r2.N = null, r2.P = null, r2.newBuffer = function(t3) {
          return "number" == typeof t3 ? r2.Buffer ? r2.P(t3) : new r2.Array(t3) : r2.Buffer ? r2.N(t3) : "undefined" == typeof Uint8Array ? t3 : new Uint8Array(t3);
        }, r2.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r2.Long = r2.global.dcodeIO && r2.global.dcodeIO.Long || r2.global.Long || r2.inquire("long"), r2.key2Re = /^true|false|0|1$/, r2.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r2.longToHash = function(t3) {
          return t3 ? r2.LongBits.from(t3).toHash() : r2.LongBits.zeroHash;
        }, r2.longFromHash = function(t3, i3) {
          t3 = r2.LongBits.fromHash(t3);
          return r2.Long ? r2.Long.fromBits(t3.lo, t3.hi, i3) : t3.toNumber(!!i3);
        }, r2.merge = e, r2.lcFirst = function(t3) {
          return (t3[0] || "").toLowerCase() + t3.substring(1);
        }, r2.newError = s, r2.ProtocolError = s("ProtocolError"), r2.oneOfGetter = function(t3) {
          for (var n3 = {}, i3 = 0; i3 < t3.length; ++i3) n3[t3[i3]] = 1;
          return function() {
            for (var t4 = Object.keys(this), i4 = t4.length - 1; -1 < i4; --i4) if (1 === n3[t4[i4]] && this[t4[i4]] !== it && null !== this[t4[i4]]) return t4[i4];
          };
        }, r2.oneOfSetter = function(n3) {
          return function(t3) {
            for (var i3 = 0; i3 < n3.length; ++i3) n3[i3] !== t3 && delete this[n3[i3]];
          };
        }, r2.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r2.p = function() {
          var n3 = r2.Buffer;
          n3 ? (r2.N = n3.from !== Uint8Array.from && n3.from || function(t3, i3) {
            return new n3(t3, i3);
          }, r2.P = n3.allocUnsafe || function(t3) {
            return new n3(t3);
          }) : r2.N = r2.P = null;
        };
      }, { 1: 1, 10: 10, 2: 2, 38: 38, 4: 4, 6: 6, 7: 7, 9: 9 }], 40: [function(t2, i2, n2) {
        i2.exports = function(t3) {
          var i3 = f.codegen(["m"], t3.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"), n3 = t3.oneofsArray, r2 = {};
          n3.length && i3("var p={}");
          for (var e = 0; e < t3.fieldsArray.length; ++e) {
            var s, o2 = t3.e[e].resolve(), u = "m" + f.safeProp(o2.name);
            o2.optional && i3("if(%s!=null&&m.hasOwnProperty(%j)){", u, o2.name), o2.map ? (i3("if(!util.isObject(%s))", u)("return%j", h(o2, "object"))("var k=Object.keys(%s)", u)("for(var i=0;i<k.length;++i){"), (function(t4, i4, n4) {
              switch (i4.keyType) {
                case "int32":
                case "uint32":
                case "sint32":
                case "fixed32":
                case "sfixed32":
                  t4("if(!util.key32Re.test(%s))", n4)("return%j", h(i4, "integer key"));
                  break;
                case "int64":
                case "uint64":
                case "sint64":
                case "fixed64":
                case "sfixed64":
                  t4("if(!util.key64Re.test(%s))", n4)("return%j", h(i4, "integer|Long key"));
                  break;
                case "bool":
                  t4("if(!util.key2Re.test(%s))", n4)("return%j", h(i4, "boolean key"));
              }
            })(i3, o2, "k[i]"), a(i3, o2, e, u + "[k[i]]")("}")) : o2.repeated ? (i3("if(!Array.isArray(%s))", u)("return%j", h(o2, "array"))("for(var i=0;i<%s.length;++i){", u), a(i3, o2, e, u + "[i]")("}")) : (o2.partOf && (s = f.safeProp(o2.partOf.name), 1 === r2[o2.partOf.name] && i3("if(p%s===1)", s)("return%j", o2.partOf.name + ": multiple values"), r2[o2.partOf.name] = 1, i3("p%s=1", s)), a(i3, o2, e, u)), o2.optional && i3("}");
          }
          return i3("return null");
        };
        var o = t2(15), f = t2(37);
        function h(t3, i3) {
          return t3.name + ": " + i3 + (t3.repeated && "array" !== i3 ? "[]" : t3.map && "object" !== i3 ? "{k:" + t3.keyType + "}" : "") + " expected";
        }
        function a(t3, i3, n3, r2) {
          if (i3.resolvedType) if (i3.resolvedType instanceof o) {
            t3("switch(%s){", r2)("default:")("return%j", h(i3, "enum value"));
            for (var e = Object.keys(i3.resolvedType.values), s = 0; s < e.length; ++s) t3("case %i:", i3.resolvedType.values[e[s]]);
            t3("break")("}");
          } else t3("{")("var e=types[%i].verify(%s);", n3, r2)("if(e)")("return%j+e", i3.name + ".")("}");
          else switch (i3.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32":
              t3("if(!util.isInteger(%s))", r2)("return%j", h(i3, "integer"));
              break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              t3("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", r2, r2, r2, r2)("return%j", h(i3, "integer|Long"));
              break;
            case "float":
            case "double":
              t3('if(typeof %s!=="number")', r2)("return%j", h(i3, "number"));
              break;
            case "bool":
              t3('if(typeof %s!=="boolean")', r2)("return%j", h(i3, "boolean"));
              break;
            case "string":
              t3("if(!util.isString(%s))", r2)("return%j", h(i3, "string"));
              break;
            case "bytes":
              t3('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', r2, r2, r2)("return%j", h(i3, "buffer"));
          }
          return t3;
        }
      }, { 15: 15, 37: 37 }], 41: [function(t2, i2, n2) {
        var o = t2(21);
        n2[".google.protobuf.Any"] = { fromObject: function(t3) {
          if (t3 && t3["@type"]) {
            var i3, n3 = t3["@type"].substring(1 + t3["@type"].lastIndexOf("/")), n3 = this.lookup(n3);
            if (n3) return ~(i3 = "." == (t3["@type"][0] || "") ? t3["@type"].slice(1) : t3["@type"]).indexOf("/") || (i3 = "/" + i3), this.create({ type_url: i3, value: n3.encode(n3.fromObject(t3)).finish() });
          }
          return this.fromObject(t3);
        }, toObject: function(t3, i3) {
          var n3, r2, e = "", s = "";
          return i3 && i3.json && t3.type_url && t3.value && (s = t3.type_url.substring(1 + t3.type_url.lastIndexOf("/")), e = t3.type_url.substring(0, 1 + t3.type_url.lastIndexOf("/")), (n3 = this.lookup(s)) && (t3 = n3.decode(t3.value))), !(t3 instanceof this.ctor) && t3 instanceof o ? (n3 = t3.$type.toObject(t3, i3), r2 = "." === t3.$type.fullName[0] ? t3.$type.fullName.slice(1) : t3.$type.fullName, n3["@type"] = s = (e = "" === e ? "type.googleapis.com/" : e) + r2, n3) : this.toObject(t3, i3);
        } };
      }, { 21: 21 }], 42: [function(t2, i2, n2) {
        i2.exports = c;
        var r2, e = t2(39), s = e.LongBits, o = e.base64, u = e.utf8;
        function f(t3, i3, n3) {
          this.fn = t3, this.len = i3, this.next = it, this.val = n3;
        }
        function h() {
        }
        function a(t3) {
          this.head = t3.head, this.tail = t3.tail, this.len = t3.len, this.next = t3.states;
        }
        function c() {
          this.len = 0, this.head = new f(h, 0, 0), this.tail = this.head, this.states = null;
        }
        function l() {
          return e.Buffer ? function() {
            return (c.create = function() {
              return new r2();
            })();
          } : function() {
            return new c();
          };
        }
        function d(t3, i3, n3) {
          i3[n3] = 255 & t3;
        }
        function p(t3, i3) {
          this.len = t3, this.next = it, this.val = i3;
        }
        function v(t3, i3, n3) {
          for (; t3.hi; ) i3[n3++] = 127 & t3.lo | 128, t3.lo = (t3.lo >>> 7 | t3.hi << 25) >>> 0, t3.hi >>>= 7;
          for (; 127 < t3.lo; ) i3[n3++] = 127 & t3.lo | 128, t3.lo = t3.lo >>> 7;
          i3[n3++] = t3.lo;
        }
        function b(t3, i3, n3) {
          i3[n3] = 255 & t3, i3[n3 + 1] = t3 >>> 8 & 255, i3[n3 + 2] = t3 >>> 16 & 255, i3[n3 + 3] = t3 >>> 24;
        }
        c.create = l(), c.alloc = function(t3) {
          return new e.Array(t3);
        }, e.Array !== Array && (c.alloc = e.pool(c.alloc, e.Array.prototype.subarray)), c.prototype.V = function(t3, i3, n3) {
          return this.tail = this.tail.next = new f(t3, i3, n3), this.len += i3, this;
        }, (p.prototype = Object.create(f.prototype)).fn = function(t3, i3, n3) {
          for (; 127 < t3; ) i3[n3++] = 127 & t3 | 128, t3 >>>= 7;
          i3[n3] = t3;
        }, c.prototype.uint32 = function(t3) {
          return this.len += (this.tail = this.tail.next = new p((t3 >>>= 0) < 128 ? 1 : t3 < 16384 ? 2 : t3 < 2097152 ? 3 : t3 < 268435456 ? 4 : 5, t3)).len, this;
        }, c.prototype.int32 = function(t3) {
          return t3 < 0 ? this.V(v, 10, s.fromNumber(t3)) : this.uint32(t3);
        }, c.prototype.sint32 = function(t3) {
          return this.uint32((t3 << 1 ^ t3 >> 31) >>> 0);
        }, c.prototype.int64 = c.prototype.uint64 = function(t3) {
          t3 = s.from(t3);
          return this.V(v, t3.length(), t3);
        }, c.prototype.sint64 = function(t3) {
          t3 = s.from(t3).zzEncode();
          return this.V(v, t3.length(), t3);
        }, c.prototype.bool = function(t3) {
          return this.V(d, 1, t3 ? 1 : 0);
        }, c.prototype.sfixed32 = c.prototype.fixed32 = function(t3) {
          return this.V(b, 4, t3 >>> 0);
        }, c.prototype.sfixed64 = c.prototype.fixed64 = function(t3) {
          t3 = s.from(t3);
          return this.V(b, 4, t3.lo).V(b, 4, t3.hi);
        }, c.prototype.float = function(t3) {
          return this.V(e.float.writeFloatLE, 4, t3);
        }, c.prototype.double = function(t3) {
          return this.V(e.float.writeDoubleLE, 8, t3);
        };
        var w2 = e.Array.prototype.set ? function(t3, i3, n3) {
          i3.set(t3, n3);
        } : function(t3, i3, n3) {
          for (var r3 = 0; r3 < t3.length; ++r3) i3[n3 + r3] = t3[r3];
        };
        c.prototype.bytes = function(t3) {
          var i3, n3 = t3.length >>> 0;
          return n3 ? (e.isString(t3) && (i3 = c.alloc(n3 = o.length(t3)), o.decode(t3, i3, 0), t3 = i3), this.uint32(n3).V(w2, n3, t3)) : this.V(d, 1, 0);
        }, c.prototype.string = function(t3) {
          var i3 = u.length(t3);
          return i3 ? this.uint32(i3).V(u.write, i3, t3) : this.V(d, 1, 0);
        }, c.prototype.fork = function() {
          return this.states = new a(this), this.head = this.tail = new f(h, 0, 0), this.len = 0, this;
        }, c.prototype.reset = function() {
          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new f(h, 0, 0), this.len = 0), this;
        }, c.prototype.ldelim = function() {
          var t3 = this.head, i3 = this.tail, n3 = this.len;
          return this.reset().uint32(n3), n3 && (this.tail.next = t3.next, this.tail = i3, this.len += n3), this;
        }, c.prototype.finish = function() {
          for (var t3 = this.head.next, i3 = this.constructor.alloc(this.len), n3 = 0; t3; ) t3.fn(t3.val, i3, n3), n3 += t3.len, t3 = t3.next;
          return i3;
        }, c.p = function(t3) {
          r2 = t3, c.create = l(), r2.p();
        };
      }, { 39: 39 }], 43: [function(t2, i2, n2) {
        i2.exports = s;
        var r2 = t2(42), e = ((s.prototype = Object.create(r2.prototype)).constructor = s, t2(39));
        function s() {
          r2.call(this);
        }
        function o(t3, i3, n3) {
          t3.length < 40 ? e.utf8.write(t3, i3, n3) : i3.utf8Write ? i3.utf8Write(t3, n3) : i3.write(t3, n3);
        }
        s.p = function() {
          s.alloc = e.P, s.writeBytesBuffer = e.Buffer && e.Buffer.prototype instanceof Uint8Array && "set" === e.Buffer.prototype.set.name ? function(t3, i3, n3) {
            i3.set(t3, n3);
          } : function(t3, i3, n3) {
            if (t3.copy) t3.copy(i3, n3, 0, t3.length);
            else for (var r3 = 0; r3 < t3.length; ) i3[n3++] = t3[r3++];
          };
        }, s.prototype.bytes = function(t3) {
          var i3 = (t3 = e.isString(t3) ? e.N(t3, "base64") : t3).length >>> 0;
          return this.uint32(i3), i3 && this.V(s.writeBytesBuffer, i3, t3), this;
        }, s.prototype.string = function(t3) {
          var i3 = e.Buffer.byteLength(t3);
          return this.uint32(i3), i3 && this.V(o, i3, t3), this;
        }, s.p();
      }, { 39: 39, 42: 42 }] }, {}, [19]);
    })();
  })(protobuf_min);
  return protobuf_min.exports;
}
var protobuf_minExports = requireProtobuf_min();
var protobuf = getDefaultExportFromCjs$1(protobuf_minExports);

// node_modules/opnet/browser/index.js
var version = "1.8.1-rc.15";
var OPNetTransactionTypes = ((OPNetTransactionTypes2) => {
  OPNetTransactionTypes2["Generic"] = "Generic";
  OPNetTransactionTypes2["Deployment"] = "Deployment";
  OPNetTransactionTypes2["Interaction"] = "Interaction";
  return OPNetTransactionTypes2;
})(OPNetTransactionTypes || {});
var TransactionInput = class {
  constructor(data) {
    __publicField(this, "originalTransactionId");
    __publicField(this, "outputTransactionIndex");
    __publicField(this, "scriptSignature");
    __publicField(this, "sequenceId");
    __publicField(this, "transactionInWitness", []);
    this.originalTransactionId = data.originalTransactionId;
    this.outputTransactionIndex = data.outputTransactionIndex;
    this.scriptSignature = data.scriptSignature;
    this.sequenceId = data.sequenceId;
    this.transactionInWitness = data.transactionInWitness || [];
  }
};
var TransactionOutput = class {
  constructor(data) {
    __publicField(this, "value");
    __publicField(this, "index");
    __publicField(this, "scriptPubKey");
    __publicField(this, "script");
    this.value = this.convertValue(data.value);
    this.index = data.index;
    this.scriptPubKey = data.scriptPubKey;
    this.script = decompile(fromHex$1(this.scriptPubKey.hex));
  }
  convertValue(value) {
    return BigInt(value);
  }
};
var LRUCache = class {
  constructor(maxSize) {
    __publicField(this, "cache");
    __publicField(this, "maxSize");
    this.cache = /* @__PURE__ */ new Map();
    this.maxSize = maxSize;
  }
  get(key) {
    const value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== void 0) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }
};
var P2OP_CACHE_MAX_SIZE = 5e3;
var p2opCache = new LRUCache(P2OP_CACHE_MAX_SIZE);
var addressCache = new LRUCache(P2OP_CACHE_MAX_SIZE);
var getP2op = (rawAddress, network) => {
  const cacheKey = `${network.bip32}:${network.pubKeyHash}:${network.bech32}:${rawAddress}`;
  let cached = p2opCache.get(cacheKey);
  if (cached === void 0) {
    let addr = addressCache.get(rawAddress);
    if (addr === void 0) {
      addr = Address.fromString(rawAddress);
      addressCache.set(rawAddress, addr);
    }
    cached = addr.p2op(network);
    p2opCache.set(cacheKey, cached);
  }
  return cached;
};
var ERROR_SELECTOR_BYTES = Uint8Array.from([99, 115, 157, 92]);
function areBytesEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i2 = 0; i2 < a.length; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
function startsWithErrorSelector(revertDataBytes) {
  return revertDataBytes.length >= 4 && areBytesEqual(revertDataBytes.subarray(0, 4), ERROR_SELECTOR_BYTES);
}
function bytesToHexString(byteArray) {
  return Array.from(byteArray, function(byte) {
    return ("0" + (byte & 255).toString(16)).slice(-2);
  }).join("");
}
function decodeRevertData(revertDataBytes) {
  if (startsWithErrorSelector(revertDataBytes)) {
    const decoder = new TextDecoder();
    const buf = revertDataBytes.subarray(8);
    return decoder.decode(buf);
  } else {
    return `Unknown Revert: 0x${bytesToHexString(revertDataBytes)}`;
  }
}
var TransactionReceipt = class {
  constructor(receipt, network) {
    /**
     * @description The receipt of the transaction.
     */
    __publicField(this, "receipt");
    /**
     * @description The receipt proofs of the transaction.
     */
    __publicField(this, "receiptProofs");
    /**
     * @description The events of the transaction.
     */
    __publicField(this, "events");
    __publicField(this, "rawEvents", {});
    /**
     * @description If the transaction was reverted, this field will contain the revert message.
     */
    __publicField(this, "rawRevert");
    __publicField(this, "revert");
    /**
     * @description Whether the transaction failed (reverted) or not.
     */
    __publicField(this, "failed", false);
    __publicField(this, "gasUsed");
    __publicField(this, "specialGasUsed");
    this.receipt = receipt.receipt ? fromBase64$1(receipt.receipt) : void 0;
    this.receiptProofs = receipt.receiptProofs || [];
    this.events = receipt.events ? this.parseEvents(receipt.events, network) : {};
    this.rawRevert = receipt.revert ? fromBase64$1(receipt.revert) : void 0;
    this.revert = this.rawRevert ? decodeRevertData(this.rawRevert) : void 0;
    this.failed = receipt.revert !== void 0 && receipt.revert !== null;
    this.gasUsed = BigInt(receipt.gasUsed || "0x00") || 0n;
    this.specialGasUsed = BigInt(receipt.specialGasUsed || "0x00") || 0n;
  }
  /**
   * @description Parse transaction events.
   * @param events - The events to parse.
   * @param network - The network to use.
   * @private
   */
  parseEvents(events, network) {
    const parsedEvents = {};
    if (!Array.isArray(events)) {
      for (const [key, value] of Object.entries(events)) {
        const caP2op = getP2op(key, network);
        const v = value.map((event) => {
          return this.decodeEvent(event);
        });
        parsedEvents[caP2op] = v;
        this.rawEvents[key] = v;
      }
    } else {
      for (const event of events) {
        const parsedEvent = this.decodeEvent(event);
        const contractAddress = event.contractAddress;
        const caP2op = getP2op(contractAddress, network);
        if (!parsedEvents[caP2op]) {
          parsedEvents[caP2op] = [];
        }
        parsedEvents[caP2op].push(parsedEvent);
        if (!this.rawEvents[contractAddress]) {
          this.rawEvents[contractAddress] = [];
        }
        this.rawEvents[contractAddress].push(parsedEvent);
      }
    }
    return parsedEvents;
  }
  decodeEvent(event) {
    let eventData;
    if (typeof event.data === "string") {
      eventData = fromBase64$1(event.data);
    } else {
      eventData = event.data;
    }
    return new NetEvent(event.type, eventData);
  }
};
var TransactionBase = class extends TransactionReceipt {
  constructor(transaction, network) {
    var _a5;
    super(
      {
        receipt: transaction.receipt,
        receiptProofs: transaction.receiptProofs,
        events: transaction.events,
        revert: transaction.revert,
        gasUsed: transaction.gasUsed,
        specialGasUsed: transaction.specialGasUsed
      },
      network
    );
    /**
     * @description The transaction ID (hash).
     */
    __publicField(this, "id");
    /**
     * @description The transaction "hash".
     */
    __publicField(this, "hash");
    /**
     * @description The index of the transaction in the block.
     */
    __publicField(this, "index");
    /**
     * @description Returns the amount of satoshi that were burned in the transaction.
     */
    __publicField(this, "burnedBitcoin");
    /**
     * @description The priority fee of the transaction.
     */
    __publicField(this, "priorityFee");
    /**
     * @description The maximum amount of gas that can be spent by the transaction.
     */
    __publicField(this, "maxGasSat");
    /**
     * @description The inputs of the transaction.
     */
    __publicField(this, "inputs");
    /**
     * @description The outputs of the transaction.
     */
    __publicField(this, "outputs");
    /**
     * @description The type of the transaction.
     */
    __publicField(this, "OPNetType");
    /**
     * @description The amount of gas used by the transaction.
     */
    __publicField(this, "gasUsed");
    /**
     * @description Special gas used by the transaction.
     */
    __publicField(this, "specialGasUsed");
    /**
     * @description The proof of work challenge.
     */
    __publicField(this, "pow");
    /**
     * @description The block number in which the transaction was included.
     */
    __publicField(this, "blockNumber");
    this.id = transaction.id;
    this.hash = transaction.hash;
    this.index = transaction.index;
    if (transaction.blockNumber) this.blockNumber = BigInt(transaction.blockNumber);
    this.burnedBitcoin = BigInt(transaction.burnedBitcoin) || 0n;
    this.priorityFee = BigInt(transaction.priorityFee) || 0n;
    this.inputs = transaction.inputs.map((input) => new TransactionInput(input));
    this.outputs = transaction.outputs.map(
      (output) => new TransactionOutput(output)
    );
    this.OPNetType = transaction.OPNetType;
    this.gasUsed = BigInt(transaction.gasUsed || "0x00") || 0n;
    this.specialGasUsed = BigInt(transaction.specialGasUsed || "0x00") || 0n;
    if (transaction.pow) {
      this.pow = this.decodeProofOfWorkChallenge(transaction.pow);
    }
    this.maxGasSat = this.burnedBitcoin + (((_a5 = this.pow) == null ? void 0 : _a5.reward) || 0n) - this.priorityFee;
  }
  decodeProofOfWorkChallenge(challenge) {
    return {
      preimage: fromBase64$1(challenge.preimage),
      reward: BigInt(challenge.reward) || 0n,
      difficulty: BigInt(challenge.difficulty || "0"),
      version: challenge.version || 0
    };
  }
};
var DeploymentTransaction2 = class extends TransactionBase {
  constructor(transaction, network) {
    super(transaction, network);
    __publicField(this, "contractAddress");
    __publicField(this, "contractPublicKey");
    __publicField(this, "bytecode");
    __publicField(this, "wasCompressed");
    __publicField(this, "deployerPubKey");
    __publicField(this, "deployerHashedPublicKey");
    __publicField(this, "deployerAddress");
    __publicField(this, "contractSeed");
    __publicField(this, "contractSaltHash");
    __publicField(this, "from");
    if (!transaction.deployerAddress && (transaction.revert === null || transaction.revert === void 0)) {
      throw new Error("Deployer address is missing");
    }
    try {
      this.from = new Address(
        fromBase64$1(transaction.from),
        fromBase64$1(transaction.fromLegacy)
      );
      this.contractAddress = transaction.contractAddress;
      this.contractPublicKey = new Address(
        fromBase64$1(transaction.contractPublicKey)
      );
      this.bytecode = fromBase64$1(transaction.bytecode);
      this.wasCompressed = transaction.wasCompressed;
      if (transaction.deployerPubKey) {
        this.deployerPubKey = fromBase64$1(transaction.deployerPubKey);
      }
      if (transaction.deployerAddress) {
        const deployerAddr = transaction.deployerAddress;
        this.deployerHashedPublicKey = fromHex$1(
          deployerAddr.startsWith("0x") ? deployerAddr.slice(2) : deployerAddr
        );
      }
      if (this.deployerHashedPublicKey && this.deployerPubKey) {
        this.deployerAddress = new Address(
          this.deployerHashedPublicKey,
          this.deployerPubKey
        );
      }
      this.contractSeed = fromBase64$1(transaction.contractSeed);
      this.contractSaltHash = fromBase64$1(transaction.contractSaltHash);
    } catch {
    }
  }
};
var GenericTransaction = class extends TransactionBase {
  constructor(transaction, network) {
    super(transaction, network);
  }
};
var InteractionTransaction2 = class extends TransactionBase {
  constructor(transaction, network) {
    super(transaction, network);
    /**
     * @description The calldata of the transaction.
     */
    __publicField(this, "calldata");
    /**
     * @description The sender's public key hash.
     */
    __publicField(this, "senderPubKeyHash");
    /**
     * @description The contract secret.
     */
    __publicField(this, "contractSecret");
    /**
     * @description The interaction public key.
     */
    __publicField(this, "interactionPubKey");
    /**
     * @description Whether the transaction data was compressed.
     */
    __publicField(this, "wasCompressed");
    /**
     * @description The from address of the transaction. (ALWAYS TAPROOT. *This address is generated from the P2TR of the pubkey of the deployer.*)
     */
    __publicField(this, "from");
    /**
     * @description The contract address where the transaction was sent. (AKA "to").
     */
    __publicField(this, "contractAddress");
    /**
     * @description The contract tweaked public key.
     */
    __publicField(this, "contractPublicKey");
    this.contractPublicKey = new Address(fromBase64$1(transaction.contractPublicKey));
    if (transaction.calldata) {
      this.calldata = fromBase64$1(transaction.calldata);
    }
    this.senderPubKeyHash = fromBase64$1(transaction.senderPubKeyHash);
    this.contractSecret = fromBase64$1(transaction.contractSecret);
    this.interactionPubKey = fromBase64$1(transaction.interactionPubKey);
    this.wasCompressed = transaction.wasCompressed || false;
    this.contractAddress = transaction.contractAddress;
    try {
      if (transaction.from) {
        this.from = new Address(
          fromBase64$1(transaction.from),
          fromBase64$1(transaction.fromLegacy)
        );
      }
    } catch {
    }
  }
};
BigInt.prototype.toJSON = function() {
  return this.toString();
};
var TransactionParser = class {
  static parseTransactions(transactions, network) {
    if (!transactions) {
      return [];
    }
    const transactionArray = [];
    for (const transaction of transactions) {
      if (!transaction) throw new Error(`Something went wrong while parsing transactions`);
      transactionArray.push(this.parseTransaction(transaction, network));
    }
    return transactionArray;
  }
  static parseTransaction(transaction, network) {
    if (!transaction) throw new Error("Transaction is required");
    const opnetType = transaction.OPNetType;
    switch (opnetType) {
      case OPNetTransactionTypes.Generic:
        return new GenericTransaction(transaction, network);
      case OPNetTransactionTypes.Interaction:
        return new InteractionTransaction2(transaction, network);
      case OPNetTransactionTypes.Deployment:
        return new DeploymentTransaction2(transaction, network);
      default:
        throw new Error("Unknown transaction type");
    }
  }
};
var Block = class {
  constructor(block, network) {
    __publicField(this, "height");
    __publicField(this, "hash");
    __publicField(this, "previousBlockHash");
    __publicField(this, "previousBlockChecksum");
    __publicField(this, "bits");
    __publicField(this, "nonce");
    __publicField(this, "version");
    __publicField(this, "size");
    __publicField(this, "txCount");
    __publicField(this, "weight");
    __publicField(this, "strippedSize");
    __publicField(this, "time");
    __publicField(this, "medianTime");
    __publicField(this, "checksumRoot");
    __publicField(this, "merkleRoot");
    __publicField(this, "storageRoot");
    __publicField(this, "receiptRoot");
    __publicField(this, "ema");
    __publicField(this, "baseGas");
    __publicField(this, "gasUsed");
    __publicField(this, "checksumProofs");
    __publicField(this, "_rawBlock");
    __publicField(this, "_network");
    __publicField(this, "_transactions");
    __publicField(this, "_deployments");
    if (!block) throw new Error("Invalid block.");
    this._rawBlock = block;
    this._network = network;
    this.height = BigInt(block.height.toString());
    this.hash = block.hash;
    this.previousBlockHash = block.previousBlockHash;
    this.previousBlockChecksum = block.previousBlockChecksum;
    this.bits = block.bits;
    this.nonce = block.nonce;
    this.version = block.version;
    this.size = block.size;
    this.txCount = block.txCount;
    this.ema = BigInt(block.ema);
    this.baseGas = BigInt(block.baseGas);
    this.gasUsed = BigInt(block.gasUsed);
    this.weight = block.weight;
    this.strippedSize = block.strippedSize;
    this.time = block.time;
    this.medianTime = block.medianTime;
    this.checksumRoot = block.checksumRoot;
    this.merkleRoot = block.merkleRoot;
    this.storageRoot = block.storageRoot;
    this.receiptRoot = block.receiptRoot;
    this.checksumProofs = block.checksumProofs;
  }
  get transactions() {
    if (!this._transactions) {
      this._transactions = TransactionParser.parseTransactions(
        this._rawBlock.transactions,
        this._network
      );
    }
    return this._transactions;
  }
  get deployments() {
    if (!this._deployments) {
      this._deployments = this._rawBlock.deployments ? this._rawBlock.deployments.map((address) => Address.fromString(address)) : [];
    }
    return this._deployments;
  }
  // For cases where you need raw without parsing
  get rawTransactions() {
    return this._rawBlock.transactions;
  }
};
var BlockGasParameters = class {
  constructor(data) {
    __publicField(this, "blockNumber");
    __publicField(this, "gasUsed");
    __publicField(this, "targetGasLimit");
    __publicField(this, "ema");
    __publicField(this, "baseGas");
    __publicField(this, "gasPerSat");
    __publicField(this, "bitcoin");
    this.blockNumber = BigInt(data.blockNumber);
    this.gasUsed = BigInt(data.gasUsed);
    this.targetGasLimit = BigInt(data.targetGasLimit);
    this.ema = BigInt(data.ema);
    this.baseGas = BigInt(data.baseGas);
    this.gasPerSat = BigInt(data.gasPerSat);
    this.bitcoin = {
      conservative: Number(data.bitcoin.conservative),
      recommended: {
        low: Number(data.bitcoin.recommended.low),
        medium: Number(data.bitcoin.recommended.medium),
        high: Number(data.bitcoin.recommended.high)
      }
    };
  }
};
function stringToBuffer2(str) {
  return fromHex$1(str.startsWith("0x") ? str.slice(2) : str);
}
function stringBase64ToBuffer(str) {
  return fromBase64$1(str);
}
var BlockWitnessAPI = class {
  constructor(data) {
    __publicField(this, "trusted");
    __publicField(this, "signature");
    __publicField(this, "timestamp");
    __publicField(this, "proofs");
    __publicField(this, "identity");
    __publicField(this, "publicKey");
    this.trusted = data.trusted;
    this.signature = stringBase64ToBuffer(data.signature);
    this.timestamp = data.timestamp;
    this.proofs = Object.freeze(data.proofs.map((proof) => stringBase64ToBuffer(proof)));
    this.identity = data.identity ? stringBase64ToBuffer(data.identity) : void 0;
    this.publicKey = data.publicKey ? Address.fromString(data.publicKey) : void 0;
  }
};
var BlockWitness = class {
  constructor(data) {
    __publicField(this, "blockNumber");
    __publicField(this, "witnesses");
    this.blockNumber = typeof data.blockNumber === "string" ? BigInt(data.blockNumber) : data.blockNumber;
    this.witnesses = Object.freeze(
      data.witnesses.map((witness) => new BlockWitnessAPI(witness))
    );
  }
};
function parseBlockWitnesses(rawWitnesses) {
  return Object.freeze(rawWitnesses.map((rawWitness) => new BlockWitness(rawWitness)));
}
var NetworkName = ((NetworkName2) => {
  NetworkName2["Mainnet"] = "mainnet";
  NetworkName2["Testnet"] = "testnet";
  NetworkName2["OpnetTestnet"] = "opnetTestnet";
  NetworkName2["Regtest"] = "regtest";
  return NetworkName2;
})(NetworkName || {});
var SERIALIZATION_VERSION = 1;
var CallResultSerializer = class {
  /**
   * Serializes offline data to a Uint8Array.
   * @param {OfflineCallResultData} data - The data to serialize.
   * @returns {Uint8Array} The serialized binary data.
   */
  static serialize(data) {
    const writer = new BinaryWriter();
    writer.writeU8(SERIALIZATION_VERSION);
    writer.writeU8(this.networkNameToU8(data.network));
    writer.writeBytesWithLength(data.calldata);
    writer.writeStringWithLength(data.to);
    writer.writeStringWithLength(data.contractAddress);
    writer.writeU256(data.estimatedSatGas);
    writer.writeU256(data.estimatedRefundedGasInSat);
    writer.writeU256(data.estimatedGas ?? 0n);
    writer.writeU256(data.refundedGas ?? 0n);
    if (data.revert !== void 0) {
      writer.writeBoolean(true);
      writer.writeStringWithLength(data.revert);
    } else {
      writer.writeBoolean(false);
    }
    writer.writeBytesWithLength(data.result);
    this.writeAccessList(writer, data.accessList);
    if (data.bitcoinFees) {
      writer.writeBoolean(true);
      this.writeBitcoinFees(writer, data.bitcoinFees);
    } else {
      writer.writeBoolean(false);
    }
    this.writeChallenge(writer, data.challenge);
    writer.writeBytesWithLength(data.challengeOriginalPublicKey);
    this.writeUTXOs(writer, data.utxos);
    if (data.csvAddress) {
      writer.writeBoolean(true);
      writer.writeStringWithLength(data.csvAddress.address);
      writer.writeBytesWithLength(data.csvAddress.witnessScript);
    } else {
      writer.writeBoolean(false);
    }
    return writer.getBuffer();
  }
  /**
   * Deserializes a Uint8Array to offline data.
   * @param {Uint8Array} buffer - The serialized data.
   * @returns {OfflineCallResultData} The deserialized data.
   */
  static deserialize(buffer2) {
    const reader = new BinaryReader(buffer2);
    const version2 = reader.readU8();
    if (version2 !== SERIALIZATION_VERSION) {
      throw new Error(
        `Unsupported serialization version: ${version2}. Expected: ${SERIALIZATION_VERSION}`
      );
    }
    const network = this.u8ToNetworkName(reader.readU8());
    const calldata = reader.readBytesWithLength();
    const to = reader.readStringWithLength();
    const contractAddress = reader.readStringWithLength();
    const estimatedSatGas = reader.readU256();
    const estimatedRefundedGasInSat = reader.readU256();
    const estimatedGasRaw = reader.readU256();
    const refundedGasRaw = reader.readU256();
    const estimatedGas = estimatedGasRaw > 0n ? estimatedGasRaw : void 0;
    const refundedGas = refundedGasRaw > 0n ? refundedGasRaw : void 0;
    const hasRevert = reader.readBoolean();
    const revert = hasRevert ? reader.readStringWithLength() : void 0;
    const result = reader.readBytesWithLength();
    const accessList = this.readAccessList(reader);
    const hasBitcoinFees = reader.readBoolean();
    const bitcoinFees = hasBitcoinFees ? this.readBitcoinFees(reader) : void 0;
    const challenge = this.readChallenge(reader);
    const challengeOriginalPublicKey = reader.readBytesWithLength();
    const utxos = this.readUTXOs(reader);
    const hasCsvAddress = reader.readBoolean();
    const csvAddress = hasCsvAddress ? {
      address: reader.readStringWithLength(),
      witnessScript: reader.readBytesWithLength()
    } : void 0;
    return {
      calldata,
      to,
      contractAddress,
      estimatedSatGas,
      estimatedRefundedGasInSat,
      estimatedGas,
      refundedGas,
      revert,
      result,
      accessList,
      bitcoinFees,
      network,
      challenge,
      challengeOriginalPublicKey,
      utxos,
      csvAddress
    };
  }
  static networkNameToU8(network) {
    switch (network) {
      case "mainnet":
        return 0;
      case "testnet":
        return 1;
      case "regtest":
        return 2;
      case "opnetTestnet":
        return 3;
      default:
        return 2;
    }
  }
  static u8ToNetworkName(value) {
    switch (value) {
      case 0:
        return "mainnet";
      case 1:
        return "testnet";
      case 2:
        return "regtest";
      case 3:
        return "opnetTestnet";
      default:
        return "regtest";
    }
  }
  static writeAccessList(writer, accessList) {
    const contracts = Object.keys(accessList);
    writer.writeU16(contracts.length);
    for (const contract of contracts) {
      writer.writeStringWithLength(contract);
      const slots = accessList[contract];
      const slotKeys = Object.keys(slots);
      writer.writeU16(slotKeys.length);
      for (const key of slotKeys) {
        writer.writeStringWithLength(key);
        writer.writeStringWithLength(slots[key]);
      }
    }
  }
  static readAccessList(reader) {
    const accessList = {};
    const contractCount = reader.readU16();
    for (let i2 = 0; i2 < contractCount; i2++) {
      const contract = reader.readStringWithLength();
      const slotCount = reader.readU16();
      accessList[contract] = {};
      for (let j = 0; j < slotCount; j++) {
        const key = reader.readStringWithLength();
        const value = reader.readStringWithLength();
        accessList[contract][key] = value;
      }
    }
    return accessList;
  }
  static writeBitcoinFees(writer, fees) {
    writer.writeU64(BigInt(Math.round(fees.conservative * this.FEE_PRECISION)));
    writer.writeU64(BigInt(Math.round(fees.recommended.low * this.FEE_PRECISION)));
    writer.writeU64(BigInt(Math.round(fees.recommended.medium * this.FEE_PRECISION)));
    writer.writeU64(BigInt(Math.round(fees.recommended.high * this.FEE_PRECISION)));
  }
  static readBitcoinFees(reader) {
    return {
      conservative: Number(reader.readU64()) / this.FEE_PRECISION,
      recommended: {
        low: Number(reader.readU64()) / this.FEE_PRECISION,
        medium: Number(reader.readU64()) / this.FEE_PRECISION,
        high: Number(reader.readU64()) / this.FEE_PRECISION
      }
    };
  }
  static writeChallenge(writer, challenge) {
    writer.writeStringWithLength(challenge.epochNumber);
    writer.writeStringWithLength(challenge.mldsaPublicKey);
    writer.writeStringWithLength(challenge.legacyPublicKey);
    writer.writeStringWithLength(challenge.solution);
    writer.writeStringWithLength(challenge.salt);
    writer.writeStringWithLength(challenge.graffiti);
    writer.writeU256(BigInt(challenge.difficulty));
    writer.writeStringWithLength(challenge.verification.epochHash);
    writer.writeStringWithLength(challenge.verification.epochRoot);
    writer.writeStringWithLength(challenge.verification.targetHash);
    writer.writeStringWithLength(challenge.verification.targetChecksum);
    writer.writeStringWithLength(challenge.verification.startBlock);
    writer.writeStringWithLength(challenge.verification.endBlock);
    writer.writeU16(challenge.verification.proofs.length);
    for (const proof of challenge.verification.proofs) {
      writer.writeStringWithLength(proof);
    }
    if (challenge.submission) {
      writer.writeBoolean(true);
      writer.writeStringWithLength(challenge.submission.mldsaPublicKey);
      writer.writeStringWithLength(challenge.submission.legacyPublicKey);
      writer.writeStringWithLength(challenge.submission.solution);
      writer.writeStringWithLength(challenge.submission.graffiti || "");
      writer.writeStringWithLength(challenge.submission.signature);
    } else {
      writer.writeBoolean(false);
    }
  }
  static readChallenge(reader) {
    const epochNumber = reader.readStringWithLength();
    const mldsaPublicKey = reader.readStringWithLength();
    const legacyPublicKey = reader.readStringWithLength();
    const solution = reader.readStringWithLength();
    const salt = reader.readStringWithLength();
    const graffiti = reader.readStringWithLength();
    const difficulty = Number(reader.readU256());
    const epochHash = reader.readStringWithLength();
    const epochRoot = reader.readStringWithLength();
    const targetHash = reader.readStringWithLength();
    const targetChecksum = reader.readStringWithLength();
    const startBlock = reader.readStringWithLength();
    const endBlock = reader.readStringWithLength();
    const proofCount = reader.readU16();
    const proofs = [];
    for (let i2 = 0; i2 < proofCount; i2++) {
      proofs.push(reader.readStringWithLength());
    }
    const hasSubmission = reader.readBoolean();
    const submission = hasSubmission ? {
      mldsaPublicKey: reader.readStringWithLength(),
      legacyPublicKey: reader.readStringWithLength(),
      solution: reader.readStringWithLength(),
      graffiti: reader.readStringWithLength() || void 0,
      signature: reader.readStringWithLength()
    } : void 0;
    return {
      epochNumber,
      mldsaPublicKey,
      legacyPublicKey,
      solution,
      salt,
      graffiti,
      difficulty,
      verification: {
        epochHash,
        epochRoot,
        targetHash,
        targetChecksum,
        startBlock,
        endBlock,
        proofs
      },
      submission
    };
  }
  static writeUTXOs(writer, utxos) {
    writer.writeU16(utxos.length);
    for (const utxo of utxos) {
      writer.writeStringWithLength(utxo.transactionId);
      writer.writeU32(utxo.outputIndex);
      writer.writeU64(utxo.value);
      writer.writeStringWithLength(utxo.scriptPubKey.hex);
      writer.writeStringWithLength(utxo.scriptPubKey.address || "");
      writer.writeBoolean(!!utxo.isCSV);
      if (utxo.witnessScript) {
        writer.writeBoolean(true);
        const witnessScriptBytes = typeof utxo.witnessScript === "string" ? fromHex$1(utxo.witnessScript) : utxo.witnessScript;
        writer.writeBytesWithLength(witnessScriptBytes);
      } else {
        writer.writeBoolean(false);
      }
      if (utxo.redeemScript) {
        writer.writeBoolean(true);
        const redeemScriptBytes = typeof utxo.redeemScript === "string" ? fromHex$1(utxo.redeemScript) : utxo.redeemScript;
        writer.writeBytesWithLength(redeemScriptBytes);
      } else {
        writer.writeBoolean(false);
      }
    }
  }
  static readUTXOs(reader) {
    const count = reader.readU16();
    const utxos = [];
    for (let i2 = 0; i2 < count; i2++) {
      const transactionId = reader.readStringWithLength();
      const outputIndex = reader.readU32();
      const value = reader.readU64();
      const hex = reader.readStringWithLength();
      const addressStr = reader.readStringWithLength();
      const isCSV = reader.readBoolean();
      const hasWitnessScript = reader.readBoolean();
      const witnessScript = hasWitnessScript ? reader.readBytesWithLength() : void 0;
      const hasRedeemScript = reader.readBoolean();
      const redeemScript = hasRedeemScript ? reader.readBytesWithLength() : void 0;
      utxos.push({
        transactionId,
        outputIndex,
        value,
        scriptPubKey: {
          hex,
          address: addressStr || void 0
        },
        isCSV,
        witnessScript,
        redeemScript
      });
    }
    return utxos;
  }
};
__publicField(CallResultSerializer, "FEE_PRECISION", 1e6);
var TransactionHelper = class {
  static estimateMiningCost(utxos, extraOutputs, opReturnLen, network, feeRate) {
    const vBytes = this.estimateVBytes(utxos, extraOutputs, opReturnLen, network);
    return BigInt(Math.ceil(vBytes * feeRate));
  }
  static varIntLen(n2) {
    return n2 < 253 ? 1 : n2 <= 65535 ? 3 : n2 <= 4294967295 ? 5 : 9;
  }
  static estimateVBytes(utxos, extraOutputs, scriptLength, network) {
    var _a5;
    const INPUT_WU = {
      [AddressTypes.P2PKH]: 148 * 4,
      [AddressTypes.P2SH_OR_P2SH_P2WPKH]: 91 * 4 + 107,
      [AddressTypes.P2WPKH]: 41 * 4 + 107,
      [AddressTypes.P2TR]: 41 * 4 + 65,
      [AddressTypes.P2MR]: 41 * 4 + 33,
      [AddressTypes.P2PK]: 148 * 4,
      [AddressTypes.P2WSH]: 41 * 4 + (1 + 73 + 1 + 33),
      [AddressTypes.P2OP]: 41 * 4 + 107,
      [AddressTypes.P2WDA]: 41 * 4 + 253
    };
    const OUTPUT_BYTES = {
      [AddressTypes.P2PKH]: 34,
      [AddressTypes.P2SH_OR_P2SH_P2WPKH]: 32,
      [AddressTypes.P2WPKH]: 31,
      [AddressTypes.P2TR]: 43,
      [AddressTypes.P2MR]: 43,
      [AddressTypes.P2PK]: 34,
      [AddressTypes.P2OP]: 32,
      [AddressTypes.P2WSH]: 43,
      [AddressTypes.P2WDA]: 43
    };
    const ins = utxos.length ? utxos : new Array(3).fill(null);
    let weight = 0;
    weight += 8 * 4;
    const usesWitness = utxos.length === 0 || utxos.some((u) => {
      var _a6;
      const t2 = AddressVerificator.detectAddressType(
        ((_a6 = u == null ? void 0 : u.scriptPubKey) == null ? void 0 : _a6.address) ?? "",
        network
      );
      return t2 === AddressTypes.P2WPKH || t2 === AddressTypes.P2SH_OR_P2SH_P2WPKH || t2 === AddressTypes.P2TR || t2 === AddressTypes.P2MR || t2 === AddressTypes.P2OP || t2 === AddressTypes.P2WSH;
    });
    if (usesWitness) weight += 2 * 4;
    weight += this.varIntLen(ins.length) * 4;
    weight += this.varIntLen(extraOutputs.length) * 4;
    for (const u of ins) {
      const t2 = utxos.length === 0 ? AddressTypes.P2TR : AddressVerificator.detectAddressType(
        ((_a5 = u == null ? void 0 : u.scriptPubKey) == null ? void 0 : _a5.address) ?? "",
        network
      ) ?? AddressTypes.P2PKH;
      weight += INPUT_WU[t2] ?? 110 * 4;
    }
    for (const o of extraOutputs) {
      if ("address" in o) {
        const t2 = AddressVerificator.detectAddressType(o.address, network) ?? AddressTypes.P2PKH;
        weight += (OUTPUT_BYTES[t2] ?? 40) * 4;
      } else if ("script" in o) {
        const scriptLen = o.script.length;
        const bytes = 8 + this.varIntLen(scriptLen) + scriptLen;
        weight += bytes * 4;
      } else {
        weight += 34 * 4;
      }
    }
    const witnessBytes = 1 + 3 * (this.varIntLen(32) + 32);
    weight += witnessBytes;
    const stackItemScript = this.varIntLen(scriptLength) + scriptLength;
    const controlBlock = 1 + 33;
    weight += stackItemScript + controlBlock;
    return Math.ceil(weight / 4);
  }
};
var factory = new TransactionFactory();
var _bitcoinFees, _rawEvents, _provider, _resultBase64, _CallResult_instances, getNetworkName_fn, cloneUTXOWithWitnessScript_fn, processUTXOTracking_fn, fetchUTXOs_fn;
var _CallResult = class _CallResult {
  constructor(callResult, provider) {
    __privateAdd(this, _CallResult_instances);
    __publicField(this, "result");
    __publicField(this, "accessList");
    __publicField(this, "revert");
    __publicField(this, "constant", false);
    __publicField(this, "payable", false);
    __publicField(this, "calldata");
    __publicField(this, "loadedStorage");
    __publicField(this, "estimatedGas");
    __publicField(this, "refundedGas");
    __publicField(this, "properties", {});
    __publicField(this, "estimatedSatGas", 0n);
    __publicField(this, "estimatedRefundedGasInSat", 0n);
    __publicField(this, "events", []);
    __publicField(this, "to");
    __publicField(this, "address");
    __publicField(this, "fromAddress");
    __publicField(this, "csvAddress");
    __privateAdd(this, _bitcoinFees);
    __privateAdd(this, _rawEvents);
    __privateAdd(this, _provider);
    __privateAdd(this, _resultBase64);
    __privateSet(this, _provider, provider);
    __privateSet(this, _rawEvents, this.parseEvents(callResult.events));
    this.accessList = callResult.accessList;
    this.loadedStorage = callResult.loadedStorage;
    if (callResult.estimatedGas) {
      this.estimatedGas = BigInt(callResult.estimatedGas);
    }
    if (callResult.specialGas) {
      this.refundedGas = BigInt(callResult.specialGas);
    }
    const revert = typeof callResult.revert === "string" ? this.base64ToUint8Array(callResult.revert) : callResult.revert;
    if (revert) {
      this.revert = _CallResult.decodeRevertData(revert);
    }
    if (typeof callResult.result === "string") {
      __privateSet(this, _resultBase64, callResult.result);
      this.result = new BinaryReader(this.base64ToUint8Array(callResult.result));
    } else if (callResult.result instanceof Uint8Array) {
      __privateSet(this, _resultBase64, "");
      this.result = new BinaryReader(callResult.result);
    } else {
      __privateSet(this, _resultBase64, "");
      this.result = callResult.result;
    }
  }
  get rawEvents() {
    return __privateGet(this, _rawEvents);
  }
  static decodeRevertData(revertDataBytes) {
    return decodeRevertData(revertDataBytes);
  }
  /**
   * Reconstructs a CallResult from offline serialized buffer.
   * Use this on a device to sign transactions offline.
   * @param {Uint8Array | string} input - The serialized offline data as Uint8Array or hex string.
   * @returns {CallResult} A CallResult instance ready for offline signing.
   *
   * @example
   * ```typescript
   * // Offline device: reconstruct from buffer
   * const buffer = fs.readFileSync('offline-tx.bin');
   * const simulation = CallResult.fromOfflineBuffer(buffer);
   *
   * // Now sign offline
   * const signedTx = await simulation.signTransaction({
   *     signer: wallet.keypair,
   *     // ... other params
   * });
   * ```
   */
  static fromOfflineBuffer(input) {
    var _a5, _b2;
    const buffer2 = typeof input === "string" ? fromHex$1(input) : input;
    const data = CallResultSerializer.deserialize(buffer2);
    const network = _CallResult.resolveNetwork(data.network);
    const challengeWithOriginalKey = {
      ...data.challenge,
      legacyPublicKey: "0x" + toHex$1(data.challengeOriginalPublicKey)
    };
    const challengeSolution = new ChallengeSolution(challengeWithOriginalKey);
    const offlineProvider = {
      network,
      utxoManager: {
        getUTXOsForAmount: () => Promise.resolve(data.utxos),
        spentUTXO: () => {
        },
        clean: () => {
        }
      },
      getChallenge: () => Promise.resolve(challengeSolution),
      sendRawTransaction: () => {
        return Promise.reject(
          new Error(
            "Cannot broadcast from offline CallResult. Export signed transaction and broadcast online."
          )
        );
      },
      getCSV1ForAddress: () => {
        if (!data.csvAddress) {
          throw new Error("CSV address not available in offline data");
        }
        return data.csvAddress;
      }
    };
    const callResultData = {
      result: data.result,
      accessList: data.accessList,
      events: {},
      revert: void 0,
      estimatedGas: (_a5 = data.estimatedGas) == null ? void 0 : _a5.toString(),
      specialGas: (_b2 = data.refundedGas) == null ? void 0 : _b2.toString()
    };
    const callResult = new _CallResult(callResultData, offlineProvider);
    callResult.revert = data.revert;
    callResult.calldata = data.calldata;
    callResult.to = data.to;
    callResult.address = Address.fromString(data.contractAddress);
    callResult.estimatedSatGas = data.estimatedSatGas;
    callResult.estimatedRefundedGasInSat = data.estimatedRefundedGasInSat;
    callResult.csvAddress = data.csvAddress;
    if (data.bitcoinFees) {
      callResult.setBitcoinFee(data.bitcoinFees);
    }
    return callResult;
  }
  /**
   * Resolves a NetworkName enum to a Network object.
   */
  static resolveNetwork(networkName) {
    switch (networkName) {
      case NetworkName.Mainnet:
        return bitcoin$1;
      case NetworkName.Testnet:
        return testnet;
      case NetworkName.OpnetTestnet:
        return opnetTestnet;
      case NetworkName.Regtest:
        return regtest;
      default:
        return regtest;
    }
  }
  setTo(to, address) {
    this.to = to;
    this.address = address;
  }
  setFromAddress(from) {
    this.fromAddress = from;
    this.csvAddress = this.fromAddress && this.fromAddress.originalPublicKey ? __privateGet(this, _provider).getCSV1ForAddress(this.fromAddress) : void 0;
  }
  /**
   * Signs a bitcoin interaction transaction from a simulated contract call without broadcasting.
   * @param {TransactionParameters} interactionParams - The parameters for the transaction.
   * @param {bigint} amountAddition - Additional satoshis to request when acquiring UTXOs.
   * @returns {Promise<SignedInteractionTransactionReceipt>} The signed transaction data and UTXO tracking info.
   */
  async signTransaction(interactionParams, amountAddition = 0n) {
    var _a5, _b2;
    if (!this.address) {
      throw new Error("Contract address not set");
    }
    if (!this.calldata) {
      throw new Error("Calldata not set");
    }
    if (!this.to) {
      throw new Error("To address not set");
    }
    if (this.revert) {
      throw new Error(`Can not send transaction! Simulation reverted: ${this.revert}`);
    }
    if (this.constant) {
      throw new Error(
        "Cannot send a transaction on a constant (view) function. Use the returned CallResult directly."
      );
    }
    if (this.payable) {
      const hasExtraInputs = interactionParams.extraInputs && interactionParams.extraInputs.length > 0;
      const hasExtraOutputs = interactionParams.extraOutputs && interactionParams.extraOutputs.length > 0;
      if (!hasExtraInputs && !hasExtraOutputs) {
        throw new Error(
          "Payable function requires extraInputs or extraOutputs in the transaction parameters."
        );
      }
    }
    let UTXOs = interactionParams.utxos || await this.acquire(interactionParams, amountAddition);
    if (interactionParams.extraInputs) {
      UTXOs = UTXOs.filter((utxo) => {
        var _a6;
        return ((_a6 = interactionParams.extraInputs) == null ? void 0 : _a6.find((input) => {
          return input.outputIndex === utxo.outputIndex && input.transactionId === utxo.transactionId;
        })) === void 0;
      });
    }
    if (!UTXOs || UTXOs.length === 0) {
      throw new Error("No UTXOs found");
    }
    const priorityFee = interactionParams.priorityFee || 0n;
    const challenge = interactionParams.challenge || await __privateGet(this, _provider).getChallenge();
    const sharedParams = {
      contract: this.address.toHex(),
      calldata: this.calldata,
      priorityFee,
      gasSatFee: this.bigintMax(this.estimatedSatGas, interactionParams.minGas || 0n),
      feeRate: interactionParams.feeRate || ((_a5 = __privateGet(this, _bitcoinFees)) == null ? void 0 : _a5.conservative) || 10,
      from: interactionParams.refundTo,
      utxos: UTXOs,
      to: this.to,
      network: interactionParams.network,
      optionalInputs: interactionParams.extraInputs || [],
      optionalOutputs: interactionParams.extraOutputs || [],
      note: interactionParams.note,
      anchor: interactionParams.anchor || false,
      txVersion: interactionParams.txVersion || 2,
      linkMLDSAPublicKeyToAddress: interactionParams.linkMLDSAPublicKeyToAddress ?? true,
      revealMLDSAPublicKey: interactionParams.revealMLDSAPublicKey ?? false,
      subtractExtraUTXOFromAmountRequired: interactionParams.subtractExtraUTXOFromAmountRequired ?? false
    };
    const params = interactionParams.signer !== null ? {
      ...sharedParams,
      signer: interactionParams.signer,
      challenge,
      mldsaSigner: interactionParams.mldsaSigner
    } : sharedParams;
    const transaction = await factory.signInteraction(params);
    const csvUTXOs = UTXOs.filter((u) => u.isCSV === true);
    const p2wdaUTXOs = UTXOs.filter((u) => u.witnessScript && u.isCSV !== true);
    const regularUTXOs = UTXOs.filter((u) => !u.witnessScript && u.isCSV !== true);
    const refundAddress = interactionParams.sender || interactionParams.refundTo;
    const p2wdaAddress = (_b2 = interactionParams.from) == null ? void 0 : _b2.p2wda(__privateGet(this, _provider).network);
    let refundToAddress;
    if (this.csvAddress && refundAddress === this.csvAddress.address) {
      refundToAddress = this.csvAddress.address;
    } else if (p2wdaAddress && refundAddress === p2wdaAddress.address) {
      refundToAddress = p2wdaAddress.address;
    } else {
      refundToAddress = refundAddress;
    }
    const utxoTracking = {
      csvUTXOs,
      p2wdaUTXOs,
      regularUTXOs,
      refundAddress,
      refundToAddress,
      csvAddress: this.csvAddress,
      p2wdaAddress: p2wdaAddress ? { address: p2wdaAddress.address, witnessScript: p2wdaAddress.witnessScript } : void 0,
      isP2WDA: interactionParams.p2wda || false
    };
    return {
      fundingTransactionRaw: transaction.fundingTransaction,
      interactionTransactionRaw: transaction.interactionTransaction,
      nextUTXOs: transaction.nextUTXOs,
      estimatedFees: transaction.estimatedFees,
      challengeSolution: transaction.challenge,
      interactionAddress: transaction.interactionAddress,
      fundingUTXOs: transaction.fundingUTXOs,
      fundingInputUtxos: transaction.fundingInputUtxos,
      compiledTargetScript: transaction.compiledTargetScript,
      utxoTracking
    };
  }
  /**
   * Broadcasts a pre-signed interaction transaction.
   * @param {SignedInteractionTransactionReceipt} signedTx - The signed transaction data.
   * @returns {Promise<InteractionTransactionReceipt>} The transaction receipt with broadcast results.
   */
  async sendPresignedTransaction(signedTx) {
    if (!signedTx.utxoTracking.isP2WDA) {
      if (!signedTx.fundingTransactionRaw) {
        throw new Error("Funding transaction not created");
      }
      const tx1 = await __privateGet(this, _provider).sendRawTransaction(
        signedTx.fundingTransactionRaw,
        false
      );
      if (!tx1 || tx1.error) {
        throw new Error(`Error sending transaction: ${(tx1 == null ? void 0 : tx1.error) || "Unknown error"}`);
      }
      if (!tx1.success) {
        throw new Error(`Error sending transaction: ${tx1.result || "Unknown error"}`);
      }
    }
    const tx2 = await __privateGet(this, _provider).sendRawTransaction(
      signedTx.interactionTransactionRaw,
      false
    );
    if (!tx2 || tx2.error) {
      throw new Error(`Error sending transaction: ${(tx2 == null ? void 0 : tx2.error) || "Unknown error"}`);
    }
    if (!tx2.result) {
      throw new Error("No transaction ID returned");
    }
    if (!tx2.success) {
      throw new Error(`Error sending transaction: ${tx2.result || "Unknown error"}`);
    }
    __privateMethod(this, _CallResult_instances, processUTXOTracking_fn).call(this, signedTx);
    return {
      interactionAddress: signedTx.interactionAddress,
      transactionId: tx2.result,
      peerAcknowledgements: tx2.peers || 0,
      newUTXOs: signedTx.nextUTXOs,
      estimatedFees: signedTx.estimatedFees,
      challengeSolution: signedTx.challengeSolution,
      rawTransaction: signedTx.interactionTransactionRaw,
      fundingUTXOs: signedTx.fundingUTXOs,
      fundingInputUtxos: signedTx.fundingInputUtxos,
      compiledTargetScript: signedTx.compiledTargetScript
    };
  }
  /**
   * Signs and broadcasts a bitcoin interaction transaction from a simulated contract call.
   * @param {TransactionParameters} interactionParams - The parameters for the transaction.
   * @param {bigint} amountAddition - Additional satoshis to request when acquiring UTXOs.
   * @returns {Promise<InteractionTransactionReceipt>} The transaction receipt with broadcast results.
   */
  async sendTransaction(interactionParams, amountAddition = 0n) {
    try {
      const signedTx = await this.signTransaction(interactionParams, amountAddition);
      return await this.sendPresignedTransaction(signedTx);
    } catch (e) {
      const msgStr = e.message;
      if (msgStr.includes("Insufficient funds to pay the fees") && amountAddition === 0n) {
        return await this.sendTransaction(interactionParams, 200000n);
      }
      __privateGet(this, _provider).utxoManager.clean();
      throw e;
    }
  }
  /**
   * Set the gas estimation values.
   * @param {bigint} estimatedGas - The estimated gas in satoshis.
   * @param {bigint} refundedGas - The refunded gas in satoshis.
   */
  setGasEstimation(estimatedGas, refundedGas) {
    this.estimatedSatGas = estimatedGas;
    this.estimatedRefundedGasInSat = refundedGas;
  }
  /**
   * Set the Bitcoin fee rates.
   * @param {BitcoinFees} fees - The Bitcoin fee rates.
   */
  setBitcoinFee(fees) {
    __privateSet(this, _bitcoinFees, fees);
  }
  /**
   * Set the decoded contract output properties.
   * @param {DecodedOutput} decoded - The decoded output.
   */
  setDecoded(decoded) {
    this.properties = Object.freeze(decoded.obj);
  }
  /**
   * Set the contract events.
   * @param {U} events - The contract events.
   */
  setEvents(events) {
    this.events = events;
  }
  /**
   * Set the calldata for the transaction.
   * @param {Uint8Array} calldata - The calldata.
   */
  setCalldata(calldata) {
    this.calldata = calldata;
  }
  /**
   * Serializes this CallResult to a Uint8Array.
   * Call this on an online device after simulation, then transfer the result
   * to an offline device for signing.
   *
   * @param {string} refundAddress - The address to fetch UTXOs from (your p2tr address).
   * @param {bigint} amount - The amount of satoshis needed for the transaction.
   * @returns {Promise<Uint8Array>} Serialized buffer ready for offline signing.
   *
   * @example
   * ```typescript
   * // Online device: prepare for offline signing
   * const simulation = await contract.transfer(recipient, amount);
   * const offlineBuffer = await simulation.toOfflineBuffer(wallet.p2tr, 50000n);
   *
   * // Save to file or encode as base64 for QR code
   * fs.writeFileSync('offline-tx.bin', offlineBuffer);
   * // Or: const qrData = offlineBuffer.toString('base64');
   * ```
   */
  async toOfflineBuffer(refundAddress, amount) {
    if (!this.calldata) {
      throw new Error("Calldata not set");
    }
    if (!this.to) {
      throw new Error("Contract address not set");
    }
    if (!this.address) {
      throw new Error("Contract Address object not set");
    }
    if (this.revert) {
      throw new Error(`Cannot serialize reverted simulation: ${this.revert}`);
    }
    const utxos = await __privateGet(this, _provider).utxoManager.getUTXOsForAmount({
      address: refundAddress,
      amount: amount + this.estimatedSatGas + 10000n,
      // Add buffer for fees
      throwErrors: true
    });
    const challengeSolution = await __privateGet(this, _provider).getChallenge();
    const networkName = __privateMethod(this, _CallResult_instances, getNetworkName_fn).call(this);
    return CallResultSerializer.serialize({
      calldata: this.calldata,
      to: this.to,
      contractAddress: this.address.toHex(),
      estimatedSatGas: this.estimatedSatGas,
      estimatedRefundedGasInSat: this.estimatedRefundedGasInSat,
      revert: this.revert,
      result: fromBase64$1(__privateGet(this, _resultBase64)),
      accessList: this.accessList,
      bitcoinFees: __privateGet(this, _bitcoinFees),
      network: networkName,
      estimatedGas: this.estimatedGas,
      refundedGas: this.refundedGas,
      challenge: challengeSolution.toRaw(),
      challengeOriginalPublicKey: challengeSolution.publicKey.originalPublicKeyBuffer(),
      utxos,
      csvAddress: this.csvAddress
    });
  }
  /**
   * Acquire UTXOs for the transaction.
   * @param {TransactionParameters} interactionParams - The transaction parameters.
   * @param {bigint} amountAddition - Additional amount to request.
   * @returns {Promise<UTXO[]>} The acquired UTXOs.
   */
  async acquire(interactionParams, amountAddition = 0n) {
    if (!this.calldata) {
      throw new Error("Calldata not set");
    }
    if (!interactionParams.feeRate) {
      interactionParams.feeRate = 1.5;
    }
    const feeRate = interactionParams.feeRate;
    const priority = interactionParams.priorityFee ?? 0n;
    const addedOuts = interactionParams.extraOutputs ?? [];
    const totalOuts = addedOuts.reduce((s, o) => s + BigInt(o.value), 0n);
    const gasFee = this.bigintMax(this.estimatedSatGas, interactionParams.minGas ?? 0n);
    const preWant = gasFee + priority + amountAddition + totalOuts + interactionParams.maximumAllowedSatToSpend;
    let utxos = interactionParams.utxos ?? await __privateMethod(this, _CallResult_instances, fetchUTXOs_fn).call(this, preWant, interactionParams);
    let refetched = false;
    while (true) {
      const miningCost = TransactionHelper.estimateMiningCost(
        utxos,
        addedOuts,
        this.calldata.length + 200,
        interactionParams.network,
        feeRate
      );
      const want = gasFee + priority + amountAddition + totalOuts + miningCost + interactionParams.maximumAllowedSatToSpend;
      const have = utxos.reduce((s, u) => s + u.value, 0n);
      if (have >= want) break;
      if (refetched) {
        throw new Error("Not enough sat to complete transaction");
      }
      utxos = await __privateMethod(this, _CallResult_instances, fetchUTXOs_fn).call(this, want, interactionParams);
      refetched = true;
      const haveAfter = utxos.reduce((s, u) => s + u.value, 0n);
      if (haveAfter === have) {
        throw new Error("Not enough sat to complete transaction");
      }
    }
    return utxos;
  }
  /**
   * Return the maximum of two bigints.
   * @param {bigint} a - First value.
   * @param {bigint} b - Second value.
   * @returns {bigint} The maximum value.
   */
  bigintMax(a, b) {
    return a > b ? a : b;
  }
  /**
   * Get storage keys from access list.
   * @returns {LoadedStorage} The loaded storage map.
   */
  getValuesFromAccessList() {
    const storage = {};
    for (const contract in this.accessList) {
      const contractData = this.accessList[contract];
      storage[contract] = Object.keys(contractData);
    }
    return storage;
  }
  /**
   * Convert contract address to p2op string.
   * @param {string} contract - The contract address hex.
   * @returns {string} The p2op address string.
   */
  contractToString(contract) {
    const addressCa = Address.fromString(contract);
    return addressCa.p2op(__privateGet(this, _provider).network);
  }
  /**
   * Parse raw events into EventList format.
   * @param {RawEventList} events - The raw events.
   * @returns {EventList} The parsed events.
   */
  parseEvents(events) {
    const eventsList = {};
    for (const [contract, value] of Object.entries(events)) {
      const events2 = [];
      for (const event of value) {
        const eventData = new NetEvent(event.type, fromBase64$1(event.data));
        events2.push(eventData);
      }
      eventsList[this.contractToString(contract)] = events2;
    }
    return eventsList;
  }
  /**
   * Convert base64 string to Uint8Array.
   * @param {string} base64 - The base64 encoded string.
   * @returns {Uint8Array} The decoded bytes.
   */
  base64ToUint8Array(base64) {
    return fromBase64$1(base64);
  }
};
_bitcoinFees = new WeakMap();
_rawEvents = new WeakMap();
_provider = new WeakMap();
_resultBase64 = new WeakMap();
_CallResult_instances = new WeakSet();
/**
 * Gets the NetworkName enum from the provider's network.
 * @returns {NetworkName} The network name enum value.
 */
getNetworkName_fn = function() {
  const network = __privateGet(this, _provider).network;
  if (network === bitcoin$1) return NetworkName.Mainnet;
  if (network === testnet) return NetworkName.Testnet;
  if (network === opnetTestnet) return NetworkName.OpnetTestnet;
  if (network === regtest) return NetworkName.Regtest;
  return NetworkName.Regtest;
};
/**
 * Clone a UTXO and attach a witness script.
 * @param {UTXO} utxo - The UTXO to clone.
 * @param {Uint8Array} witnessScript - The witness script to attach.
 * @returns {UTXO} The cloned UTXO with witness script.
 */
cloneUTXOWithWitnessScript_fn = function(utxo, witnessScript) {
  const clone2 = Object.assign(
    Object.create(Object.getPrototypeOf(utxo)),
    utxo
  );
  clone2.witnessScript = witnessScript;
  return clone2;
};
/**
 * Process UTXO tracking after transaction broadcast.
 * @param {SignedInteractionTransactionReceipt} signedTx - The signed transaction receipt.
 */
processUTXOTracking_fn = function(signedTx) {
  const {
    csvUTXOs,
    p2wdaUTXOs,
    regularUTXOs,
    refundAddress,
    refundToAddress,
    csvAddress,
    p2wdaAddress
  } = signedTx.utxoTracking;
  if (csvAddress && csvUTXOs.length) {
    const finalUTXOs = signedTx.nextUTXOs.map(
      (u) => __privateMethod(this, _CallResult_instances, cloneUTXOWithWitnessScript_fn).call(this, u, csvAddress.witnessScript)
    );
    __privateGet(this, _provider).utxoManager.spentUTXO(
      csvAddress.address,
      csvUTXOs,
      refundToAddress === csvAddress.address ? finalUTXOs : []
    );
  }
  if (p2wdaAddress && p2wdaUTXOs.length) {
    const finalUTXOs = signedTx.nextUTXOs.map(
      (u) => __privateMethod(this, _CallResult_instances, cloneUTXOWithWitnessScript_fn).call(this, u, p2wdaAddress.witnessScript)
    );
    __privateGet(this, _provider).utxoManager.spentUTXO(
      p2wdaAddress.address,
      p2wdaUTXOs,
      refundToAddress === p2wdaAddress.address ? finalUTXOs : []
    );
  }
  if (regularUTXOs.length) {
    __privateGet(this, _provider).utxoManager.spentUTXO(
      refundAddress,
      regularUTXOs,
      refundToAddress === refundAddress ? signedTx.nextUTXOs : []
    );
  }
  if (csvAddress && refundToAddress === csvAddress.address && !csvUTXOs.length) {
    const finalUTXOs = signedTx.nextUTXOs.map(
      (u) => __privateMethod(this, _CallResult_instances, cloneUTXOWithWitnessScript_fn).call(this, u, csvAddress.witnessScript)
    );
    __privateGet(this, _provider).utxoManager.spentUTXO(csvAddress.address, [], finalUTXOs);
  } else if (p2wdaAddress && refundToAddress === p2wdaAddress.address && !p2wdaUTXOs.length) {
    const finalUTXOs = signedTx.nextUTXOs.map(
      (u) => __privateMethod(this, _CallResult_instances, cloneUTXOWithWitnessScript_fn).call(this, u, p2wdaAddress.witnessScript)
    );
    __privateGet(this, _provider).utxoManager.spentUTXO(p2wdaAddress.address, [], finalUTXOs);
  } else if (refundToAddress === refundAddress && !regularUTXOs.length) {
    const isSpecialAddress = csvAddress && refundToAddress === csvAddress.address || p2wdaAddress && refundToAddress === p2wdaAddress.address;
    if (!isSpecialAddress) {
      __privateGet(this, _provider).utxoManager.spentUTXO(refundAddress, [], signedTx.nextUTXOs);
    }
  }
};
fetchUTXOs_fn = async function(amount, interactionParams) {
  var _a5;
  if (!interactionParams.sender && !interactionParams.refundTo) {
    throw new Error("Refund address not set");
  }
  const utxoSetting = {
    address: interactionParams.sender || interactionParams.refundTo,
    amount,
    throwErrors: true,
    maxUTXOs: interactionParams.maxUTXOs,
    throwIfUTXOsLimitReached: interactionParams.throwIfUTXOsLimitReached,
    csvAddress: !interactionParams.p2wda && !interactionParams.dontUseCSVUtxos ? (_a5 = this.csvAddress) == null ? void 0 : _a5.address : void 0
  };
  let utxos = await __privateGet(this, _provider).utxoManager.getUTXOsForAmount(utxoSetting);
  if (!utxos) {
    throw new Error("No UTXOs found");
  }
  if (interactionParams.extraInputs && interactionParams.extraInputs.length > 0) {
    utxos = utxos.filter((utxo) => {
      if (!interactionParams.extraInputs) {
        throw new Error("extraInputs should be defined here");
      }
      return !interactionParams.extraInputs.some(
        (extra) => extra.transactionId === utxo.transactionId && extra.outputIndex === utxo.outputIndex
      );
    });
  }
  if (this.csvAddress) {
    const csvUtxos = utxos.filter((u) => u.isCSV === true);
    if (csvUtxos.length > 0) {
      for (const utxo of csvUtxos) {
        utxo.witnessScript = this.csvAddress.witnessScript;
      }
    }
  }
  if (interactionParams.p2wda) {
    if (!interactionParams.from) {
      throw new Error("From address not set in interaction parameters");
    }
    const p2wda = interactionParams.from.p2wda(__privateGet(this, _provider).network);
    if (interactionParams.sender ? p2wda.address === interactionParams.sender : p2wda.address === interactionParams.refundTo) {
      utxos.forEach((utxo) => {
        utxo.witnessScript = p2wda.witnessScript;
      });
    }
  }
  return utxos;
};
var CallResult = _CallResult;
var ContractData = class {
  constructor(raw) {
    __publicField(this, "contractAddress");
    __publicField(this, "contractPublicKey");
    __publicField(this, "bytecode");
    __publicField(this, "wasCompressed");
    __publicField(this, "deployedTransactionId");
    __publicField(this, "deployedTransactionHash");
    __publicField(this, "deployerPubKey");
    __publicField(this, "deployerHashedPublicKey");
    __publicField(this, "contractSeed");
    __publicField(this, "contractSaltHash");
    __publicField(this, "deployerAddress");
    this.contractAddress = raw.contractAddress;
    this.contractPublicKey = raw.contractPublicKey instanceof Uint8Array ? new Address(raw.contractPublicKey) : new Address(fromBase64$1(raw.contractPublicKey));
    this.bytecode = raw.bytecode instanceof Uint8Array ? raw.bytecode : fromBase64$1(raw.bytecode);
    this.wasCompressed = raw.wasCompressed;
    this.deployedTransactionId = raw.deployedTransactionId;
    this.deployedTransactionHash = raw.deployedTransactionHash;
    this.deployerPubKey = raw.deployerPubKey instanceof Uint8Array ? raw.deployerPubKey : fromBase64$1(raw.deployerPubKey);
    const deployerAddr = raw.deployerAddress;
    const cleanDeployerAddr = deployerAddr.startsWith("0x") ? deployerAddr.slice(2) : deployerAddr;
    this.deployerHashedPublicKey = raw.deployerAddress instanceof Address ? fromHex$1(cleanDeployerAddr) : fromBase64$1(cleanDeployerAddr);
    this.contractSeed = raw.contractSeed instanceof Uint8Array ? raw.contractSeed : fromBase64$1(raw.contractSeed);
    this.contractSaltHash = raw.contractSaltHash instanceof Uint8Array ? raw.contractSaltHash : fromBase64$1(raw.contractSaltHash);
    if (this.deployerHashedPublicKey && this.deployerPubKey) {
      this.deployerAddress = new Address(this.deployerHashedPublicKey, this.deployerPubKey);
    } else {
      throw new Error("Deployer address or public key is missing");
    }
  }
};
var TransactionInputFlags = ((TransactionInputFlags2) => {
  TransactionInputFlags2[TransactionInputFlags2["hasCoinbase"] = 1] = "hasCoinbase";
  TransactionInputFlags2[TransactionInputFlags2["hasWitness"] = 2] = "hasWitness";
  return TransactionInputFlags2;
})(TransactionInputFlags || {});
var TransactionOutputFlags = ((TransactionOutputFlags2) => {
  TransactionOutputFlags2[TransactionOutputFlags2["hasTo"] = 1] = "hasTo";
  TransactionOutputFlags2[TransactionOutputFlags2["hasScriptPubKey"] = 2] = "hasScriptPubKey";
  TransactionOutputFlags2[TransactionOutputFlags2["OP_RETURN"] = 4] = "OP_RETURN";
  return TransactionOutputFlags2;
})(TransactionOutputFlags || {});
var EpochMiner = class {
  constructor(data) {
    __publicField(this, "solution");
    __publicField(this, "publicKey");
    __publicField(this, "salt");
    __publicField(this, "graffiti");
    this.solution = stringToBuffer2(data.solution);
    this.publicKey = Address.fromString(data.mldsaPublicKey, data.legacyPublicKey);
    this.salt = stringToBuffer2(data.salt);
    this.graffiti = data.graffiti ? stringToBuffer2(data.graffiti) : void 0;
  }
};
var Epoch = class {
  constructor(data) {
    __publicField(this, "epochNumber");
    __publicField(this, "epochHash");
    __publicField(this, "epochRoot");
    __publicField(this, "startBlock");
    __publicField(this, "endBlock");
    __publicField(this, "difficultyScaled");
    __publicField(this, "minDifficulty");
    __publicField(this, "targetHash");
    __publicField(this, "proposer");
    __publicField(this, "proofs");
    this.epochNumber = BigInt(data.epochNumber);
    this.epochHash = stringToBuffer2(data.epochHash);
    this.epochRoot = stringToBuffer2(data.epochRoot);
    this.startBlock = BigInt(data.startBlock);
    this.endBlock = BigInt(data.endBlock);
    this.difficultyScaled = BigInt(data.difficultyScaled);
    this.minDifficulty = data.minDifficulty;
    this.targetHash = stringToBuffer2(data.targetHash);
    this.proposer = new EpochMiner(data.proposer);
    this.proofs = Object.freeze(data.proofs.map((proof) => stringToBuffer2(proof)));
  }
};
var EpochSubmission = class {
  constructor(data) {
    __publicField(this, "submissionTxId");
    __publicField(this, "submissionTxHash");
    __publicField(this, "submissionHash");
    __publicField(this, "confirmedAt");
    __publicField(this, "epochProposed");
    this.submissionTxId = stringToBuffer2(data.submissionTxId);
    this.submissionTxHash = stringToBuffer2(data.submissionTxHash);
    this.submissionHash = stringToBuffer2(data.submissionHash);
    this.confirmedAt = data.confirmedAt;
    this.epochProposed = new EpochMiner(data.epochProposed);
  }
};
var EpochWithSubmissions = class extends Epoch {
  constructor(data) {
    super(data);
    __publicField(this, "submissions");
    if (data.submissions) {
      this.submissions = Object.freeze(
        data.submissions.map((sub) => new EpochSubmission(sub))
      );
    }
  }
};
var EpochTemplate = class {
  constructor(data) {
    __publicField(this, "epochNumber");
    __publicField(this, "epochTarget");
    this.epochNumber = BigInt(data.epochNumber);
    this.epochTarget = stringToBuffer2(data.epochTarget);
  }
};
var SubmittedEpoch = class {
  constructor(data) {
    __publicField(this, "epochNumber");
    __publicField(this, "submissionHash");
    __publicField(this, "difficulty");
    __publicField(this, "timestamp");
    __publicField(this, "status");
    __publicField(this, "message");
    this.epochNumber = BigInt(data.epochNumber);
    this.submissionHash = stringToBuffer2(data.submissionHash);
    this.difficulty = data.difficulty;
    this.timestamp = typeof data.timestamp === "number" ? new Date(data.timestamp) : data.timestamp;
    this.status = data.status;
    this.message = data.message;
  }
};
var StoredValue = class {
  constructor(iStoredValue) {
    __publicField(this, "pointer");
    __publicField(this, "value");
    __publicField(this, "height");
    __publicField(this, "proofs");
    this.pointer = typeof iStoredValue.pointer === "string" ? this.base64ToBigInt(iStoredValue.pointer) : iStoredValue.pointer;
    if (typeof iStoredValue.value !== "string") {
      this.value = iStoredValue.value;
    } else {
      this.value = iStoredValue.value.startsWith("0x") ? fromHex$1(iStoredValue.value.slice(2)) : fromBase64$1(iStoredValue.value);
    }
    this.height = BigInt(iStoredValue.height);
    this.proofs = iStoredValue.proofs || [];
  }
  base64ToBigInt(base64) {
    return BufferHelper.uint8ArrayToPointer(fromBase64$1(base64));
  }
};
var UTXO = class {
  /**
   * Create a UTXO from raw interface data.
   * When raw transaction data is present, a lazy getter is installed on `nonWitnessUtxo`
   * that decodes the base64 data to a `Uint8Array` on first access and caches the result.
   *
   * @param iUTXO - The raw UTXO data from the API
   * @param isCSV - Whether this is a CSV UTXO
   */
  constructor(iUTXO, isCSV) {
    __publicField(this, "transactionId");
    __publicField(this, "outputIndex");
    __publicField(this, "value");
    __publicField(this, "scriptPubKey");
    /**
     * The raw transaction data for this UTXO, encoded as a base64 string.
     */
    __publicField(this, "nonWitnessUtxoBase64");
    /**
     * The non-witness UTXO data as a Uint8Array.
     * Lazily decoded from the base64 raw transaction data when first accessed.
     * Remains `undefined` when no raw data was provided.
     */
    __publicField(this, "nonWitnessUtxo");
    __publicField(this, "witnessScript");
    __publicField(this, "redeemScript");
    __publicField(this, "isCSV");
    this.transactionId = iUTXO.transactionId;
    this.outputIndex = iUTXO.outputIndex;
    this.isCSV = isCSV || false;
    this.value = BigInt(iUTXO.value);
    this.scriptPubKey = iUTXO.scriptPubKey;
    this.nonWitnessUtxoBase64 = iUTXO.raw;
    this.witnessScript = iUTXO.witnessScript;
    if (iUTXO.raw) {
      const raw = iUTXO.raw;
      let cached;
      Object.defineProperty(this, "nonWitnessUtxo", {
        get() {
          if (!cached) {
            cached = fromBase64$1(raw);
          }
          return cached;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
};
var JSONRpcMethods = ((JSONRpcMethods2) => {
  JSONRpcMethods2["BLOCK_BY_NUMBER"] = "btc_blockNumber";
  JSONRpcMethods2["CHAIN_ID"] = "btc_chainId";
  JSONRpcMethods2["REORG"] = "btc_reorg";
  JSONRpcMethods2["GET_BLOCK_BY_HASH"] = "btc_getBlockByHash";
  JSONRpcMethods2["GET_BLOCK_BY_CHECKSUM"] = "btc_getBlockByChecksum";
  JSONRpcMethods2["GET_BLOCK_BY_NUMBER"] = "btc_getBlockByNumber";
  JSONRpcMethods2["GAS"] = "btc_gas";
  JSONRpcMethods2["GET_TRANSACTION_BY_HASH"] = "btc_getTransactionByHash";
  JSONRpcMethods2["BROADCAST_TRANSACTION"] = "btc_sendRawTransaction";
  JSONRpcMethods2["TRANSACTION_PREIMAGE"] = "btc_preimage";
  JSONRpcMethods2["PUBLIC_KEY_INFO"] = "btc_publicKeyInfo";
  JSONRpcMethods2["GET_UTXOS"] = "btc_getUTXOs";
  JSONRpcMethods2["GET_BALANCE"] = "btc_getBalance";
  JSONRpcMethods2["BLOCK_WITNESS"] = "btc_blockWitness";
  JSONRpcMethods2["GET_TRANSACTION_RECEIPT"] = "btc_getTransactionReceipt";
  JSONRpcMethods2["GET_CODE"] = "btc_getCode";
  JSONRpcMethods2["GET_STORAGE_AT"] = "btc_getStorageAt";
  JSONRpcMethods2["LATEST_EPOCH"] = "btc_latestEpoch";
  JSONRpcMethods2["GET_EPOCH_BY_NUMBER"] = "btc_getEpochByNumber";
  JSONRpcMethods2["GET_EPOCH_BY_HASH"] = "btc_getEpochByHash";
  JSONRpcMethods2["GET_EPOCH_TEMPLATE"] = "btc_getEpochTemplate";
  JSONRpcMethods2["SUBMIT_EPOCH"] = "btc_submitEpoch";
  JSONRpcMethods2["CALL"] = "btc_call";
  JSONRpcMethods2["GET_MEMPOOL_INFO"] = "btc_getMempoolInfo";
  JSONRpcMethods2["GET_PENDING_TRANSACTION"] = "btc_getPendingTransaction";
  JSONRpcMethods2["GET_LATEST_PENDING_TRANSACTIONS"] = "btc_getLatestPendingTransactions";
  return JSONRpcMethods2;
})(JSONRpcMethods || {});
var AUTO_PURGE_AFTER = 1e3 * 60;
var FETCH_COOLDOWN = 1e4;
var MEMPOOL_CHAIN_LIMIT = 25;
var UTXOsManager = class {
  constructor(provider) {
    /**
     * Holds all address-specific data so we dont mix up UTXOs between addresses/wallets.
     */
    __publicField(this, "dataByAddress", {});
    this.provider = provider;
  }
  /**
   * Mark UTXOs as spent and track new UTXOs created by the transaction, _per address_.
   *
   * Enforces a mempool chain limit of 25 unconfirmed transaction descendants.
   *
   * @param address - The address these spent/new UTXOs belong to
   * @param {UTXOs} spent - The UTXOs that were spent.
   * @param {UTXOs} newUTXOs - The new UTXOs created by the transaction.
   * @throws {Error} If adding the new unconfirmed outputs would exceed the mempool chain limit.
   */
  spentUTXO(address, spent, newUTXOs) {
    const addressData = this.getAddressData(address);
    const utxoKey = (u) => `${u.transactionId}:${u.outputIndex}`;
    addressData.pendingUTXOs = addressData.pendingUTXOs.filter((utxo) => {
      return !spent.some(
        (spentUtxo) => spentUtxo.transactionId === utxo.transactionId && spentUtxo.outputIndex === utxo.outputIndex
      );
    });
    let maxParentDepth = 0;
    for (const spentUtxo of spent) {
      const key = utxoKey(spentUtxo);
      const parentDepth = addressData.pendingUtxoDepth[key] ?? 0;
      if (parentDepth > maxParentDepth) {
        maxParentDepth = parentDepth;
      }
    }
    for (const spentUtxo of spent) {
      const key = utxoKey(spentUtxo);
      delete addressData.pendingUtxoDepth[key];
    }
    addressData.spentUTXOs.push(...spent);
    const newDepth = maxParentDepth + 1;
    if (newDepth > MEMPOOL_CHAIN_LIMIT) {
      throw new Error(
        `too-long-mempool-chain, too many descendants for tx ... [limit: ${MEMPOOL_CHAIN_LIMIT}]`
      );
    }
    for (const nu of newUTXOs) {
      addressData.pendingUTXOs.push(nu);
      addressData.pendingUtxoDepth[utxoKey(nu)] = newDepth;
    }
  }
  /**
   * Get the pending UTXOs for a specific address.
   * @param address
   */
  getPendingUTXOs(address) {
    const addressData = this.getAddressData(address);
    return addressData.pendingUTXOs;
  }
  /**
   * Clean (reset) the data for a particular address or for all addresses if none is passed.
   */
  clean(address) {
    if (address) {
      const addressData = this.getAddressData(address);
      addressData.spentUTXOs = [];
      addressData.pendingUTXOs = [];
      addressData.pendingUtxoDepth = {};
      addressData.lastCleanup = Date.now();
      addressData.lastFetchTimestamp = 0;
      addressData.lastFetchedData = null;
    } else {
      this.dataByAddress = {};
    }
  }
  /**
   * Get UTXOs with configurable options, specifically for an address.
   *
   * If the last UTXO fetch for that address was <10s ago, returns cached data.
   * Otherwise, fetches fresh data from the provider.
   *
   * @param {object} options - The UTXO fetch options
   * @param {string} options.address - The address to get the UTXOs for
   * @param {boolean} [options.optimize=true] - Whether to optimize the UTXOs
   * @param {boolean} [options.mergePendingUTXOs=true] - Merge locally pending UTXOs
   * @param {boolean} [options.filterSpentUTXOs=true] - Filter out known-spent UTXOs
   * @param {boolean} [options.isCSV=false] - Whether to this UTXO as a CSV UTXO
   * @param {bigint} [options.olderThan] - Only fetch UTXOs older than this value
   * @returns {Promise<UTXOs>} The UTXOs
   * @throws {Error} If something goes wrong
   */
  async getUTXOs({
    address,
    isCSV = false,
    optimize = true,
    mergePendingUTXOs = true,
    filterSpentUTXOs = true,
    olderThan
  }) {
    const addressData = this.getAddressData(address);
    const fetchedData = await this.maybeFetchUTXOs(address, optimize, olderThan, isCSV);
    const utxoKey = (utxo) => `${utxo.transactionId}:${utxo.outputIndex}`;
    const spentRefKey = (ref2) => `${ref2.transactionId}:${ref2.outputIndex}`;
    const pendingUTXOKeys = new Set(addressData.pendingUTXOs.map(utxoKey));
    const spentUTXOKeys = new Set(addressData.spentUTXOs.map(utxoKey));
    const fetchedSpentKeys = new Set(fetchedData.spentTransactions.map(spentRefKey));
    const combinedUTXOs = [];
    const combinedKeysSet = /* @__PURE__ */ new Set();
    for (const utxo of fetchedData.confirmed) {
      const key = utxoKey(utxo);
      if (!combinedKeysSet.has(key)) {
        combinedUTXOs.push(utxo);
        combinedKeysSet.add(key);
      }
    }
    if (mergePendingUTXOs) {
      for (const utxo of addressData.pendingUTXOs) {
        const key = utxoKey(utxo);
        if (!combinedKeysSet.has(key)) {
          combinedUTXOs.push(utxo);
          combinedKeysSet.add(key);
        }
      }
      for (const utxo of fetchedData.pending) {
        const key = utxoKey(utxo);
        if (!pendingUTXOKeys.has(key) && !combinedKeysSet.has(key)) {
          combinedUTXOs.push(utxo);
          combinedKeysSet.add(key);
        }
      }
    }
    let finalUTXOs = combinedUTXOs.filter((utxo) => !spentUTXOKeys.has(utxoKey(utxo)));
    if (filterSpentUTXOs && fetchedSpentKeys.size > 0) {
      finalUTXOs = finalUTXOs.filter((utxo) => !fetchedSpentKeys.has(utxoKey(utxo)));
    }
    return finalUTXOs;
  }
  /**
   * Fetch UTXOs for a specific amount needed, from a single address,
   * merging from pending and confirmed UTXOs.
   *
   * @param {object} options
   * @param {string} options.address The address to fetch UTXOs for
   * @param {bigint} options.amount The needed amount
   * @param {boolean} [options.optimize=true] Optimize the UTXOs
   * @param {boolean} [options.csvAddress] Use CSV UTXOs in priority
   * @param {boolean} [options.mergePendingUTXOs=true] Merge pending
   * @param {boolean} [options.filterSpentUTXOs=true] Filter out spent
   * @param {boolean} [options.throwErrors=false] Throw error if insufficient
   * @param {bigint} [options.olderThan] Only fetch UTXOs older than this value
   * @returns {Promise<UTXOs>}
   */
  async getUTXOsForAmount({
    address,
    amount,
    csvAddress,
    optimize = true,
    mergePendingUTXOs = true,
    filterSpentUTXOs = true,
    throwErrors = false,
    olderThan,
    maxUTXOs = 5e3,
    throwIfUTXOsLimitReached = false
  }) {
    const utxosPromises = [];
    if (csvAddress) {
      utxosPromises.push(
        this.getUTXOs({
          address: csvAddress,
          optimize: true,
          mergePendingUTXOs: false,
          filterSpentUTXOs: true,
          olderThan: 1n,
          isCSV: true
        })
      );
    }
    utxosPromises.push(
      this.getUTXOs({
        address,
        optimize,
        mergePendingUTXOs,
        filterSpentUTXOs,
        olderThan
      })
    );
    const combinedUTXOs = (await Promise.all(utxosPromises)).flat();
    const utxoUntilAmount = [];
    let currentValue = 0n;
    for (const utxo of combinedUTXOs) {
      if (maxUTXOs && utxoUntilAmount.length >= maxUTXOs) {
        if (throwIfUTXOsLimitReached) {
          throw new Error(
            `Woah. You must consolidate your UTXOs (${combinedUTXOs.length})! This transaction is too large.`
          );
        }
        break;
      }
      utxoUntilAmount.push(utxo);
      currentValue += utxo.value;
      if (currentValue >= amount) {
        break;
      }
    }
    if (currentValue < amount && throwErrors) {
      throw new Error(
        `Insufficient UTXOs to cover amount. Available: ${currentValue}, Needed: ${amount}`
      );
    }
    return utxoUntilAmount;
  }
  /**
   * Fetch UTXOs for multiple addresses in a single batch request.
   *
   * This method bypasses caching and directly fetches from the provider
   * for all requested addresses in parallel using batch RPC calls.
   *
   * @param {RequestMultipleUTXOsParams} options - The batch UTXO fetch options
   * @param {BatchUTXORequest[]} options.requests - Array of address-specific fetch parameters
   * @param {boolean} [options.mergePendingUTXOs=true] - Merge locally pending UTXOs
   * @param {boolean} [options.filterSpentUTXOs=true] - Filter out known-spent UTXOs
   * @returns {Promise<Record<string, UTXOs>>} Map of address to UTXOs
   * @throws {Error} If something goes wrong during the batch fetch
   */
  async getMultipleUTXOs({
    requests,
    mergePendingUTXOs = true,
    filterSpentUTXOs = true
  }) {
    if (requests.length === 0) {
      return {};
    }
    const fetchedDataMap = await this.fetchMultipleUTXOs(requests);
    const result = {};
    for (const request of requests) {
      const { address, isCSV = false } = request;
      const addressData = this.getAddressData(address);
      const fetchedData = fetchedDataMap[address];
      if (!fetchedData) {
        result[address] = [];
        continue;
      }
      addressData.lastFetchedData = fetchedData;
      addressData.lastFetchTimestamp = Date.now();
      this.syncPendingDepthWithFetched(address);
      const utxoKey = (utxo) => `${utxo.transactionId}:${utxo.outputIndex}`;
      const spentRefKey = (ref2) => `${ref2.transactionId}:${ref2.outputIndex}`;
      const pendingUTXOKeys = new Set(addressData.pendingUTXOs.map(utxoKey));
      const spentUTXOKeys = new Set(addressData.spentUTXOs.map(utxoKey));
      const fetchedSpentKeys = new Set(fetchedData.spentTransactions.map(spentRefKey));
      const combinedUTXOs = [];
      const combinedKeysSet = /* @__PURE__ */ new Set();
      for (const utxo of fetchedData.confirmed) {
        const key = utxoKey(utxo);
        if (!combinedKeysSet.has(key)) {
          combinedUTXOs.push(utxo);
          combinedKeysSet.add(key);
        }
      }
      if (mergePendingUTXOs) {
        for (const utxo of addressData.pendingUTXOs) {
          const key = utxoKey(utxo);
          if (!combinedKeysSet.has(key)) {
            combinedUTXOs.push(utxo);
            combinedKeysSet.add(key);
          }
        }
        for (const utxo of fetchedData.pending) {
          const key = utxoKey(utxo);
          if (!pendingUTXOKeys.has(key) && !combinedKeysSet.has(key)) {
            combinedUTXOs.push(utxo);
            combinedKeysSet.add(key);
          }
        }
      }
      let finalUTXOs = combinedUTXOs.filter((utxo) => !spentUTXOKeys.has(utxoKey(utxo)));
      if (filterSpentUTXOs && fetchedSpentKeys.size > 0) {
        finalUTXOs = finalUTXOs.filter((utxo) => !fetchedSpentKeys.has(utxoKey(utxo)));
      }
      result[address] = finalUTXOs;
    }
    return result;
  }
  /**
   * Fetch UTXOs for multiple addresses in a single batch RPC call.
   * @private
   */
  async fetchMultipleUTXOs(requests) {
    const payloads = requests.map((request) => {
      const data = [request.address, request.optimize ?? true];
      if (request.olderThan !== void 0) {
        data.push(request.olderThan.toString());
      }
      return this.provider.buildJsonRpcPayload(JSONRpcMethods.GET_UTXOS, data);
    });
    const rawResults = await this.provider.callMultiplePayloads(payloads);
    if ("error" in rawResults) {
      throw new Error(`Error fetching UTXOs: ${rawResults.error}`);
    }
    const result = {};
    for (let i2 = 0; i2 < rawResults.length; i2++) {
      const rawUTXOs = rawResults[i2];
      const request = requests[i2];
      if (!request) {
        throw new Error("Impossible index mismatch");
      }
      if ("error" in rawUTXOs) {
        throw new Error(`Error fetching UTXOs for ${request.address}: ${rawUTXOs.error}`);
      }
      const rawData = rawUTXOs.result || {
        confirmed: [],
        pending: [],
        spentTransactions: [],
        raw: []
      };
      const rawTransactions = rawData.raw || [];
      const isCSV = request.isCSV ?? false;
      result[request.address] = {
        confirmed: rawData.confirmed.map((utxo) => {
          return this.parseUTXO(utxo, isCSV, rawTransactions);
        }),
        pending: rawData.pending.map((utxo) => {
          return this.parseUTXO(utxo, isCSV, rawTransactions);
        }),
        spentTransactions: rawData.spentTransactions.map(
          (spent) => ({
            transactionId: spent.transactionId,
            outputIndex: spent.outputIndex
          })
        )
      };
    }
    return result;
  }
  /**
   * Return the AddressData object for a given address. Initializes it if nonexistent.
   */
  getAddressData(address) {
    if (!this.dataByAddress[address]) {
      this.dataByAddress[address] = {
        spentUTXOs: [],
        pendingUTXOs: [],
        pendingUtxoDepth: {},
        lastCleanup: Date.now(),
        lastFetchTimestamp: 0,
        lastFetchedData: null
      };
    }
    return this.dataByAddress[address];
  }
  /**
   * Checks if we need to fetch fresh UTXOs or can return the cached data (per address).
   */
  async maybeFetchUTXOs(address, optimize, olderThan, isCSV = false) {
    const addressData = this.getAddressData(address);
    const now = Date.now();
    const age = now - addressData.lastFetchTimestamp;
    if (now - addressData.lastCleanup > AUTO_PURGE_AFTER) {
      this.clean(address);
    }
    if (addressData.lastFetchedData && age < FETCH_COOLDOWN) {
      return addressData.lastFetchedData;
    }
    addressData.lastFetchedData = await this.fetchUTXOs(address, optimize, olderThan, isCSV);
    addressData.lastFetchTimestamp = now;
    this.syncPendingDepthWithFetched(address);
    return addressData.lastFetchedData;
  }
  /**
   * Generic method to fetch all UTXOs in one call (confirmed, pending, spent) for a given address.
   */
  async fetchUTXOs(address, optimize = false, olderThan, isCSV = false) {
    const data = [address, optimize];
    if (olderThan !== void 0) {
      data.push(olderThan.toString());
    }
    const payload = this.provider.buildJsonRpcPayload(
      JSONRpcMethods.GET_UTXOS,
      data
    );
    const rawUTXOs = await this.provider.callPayloadSingle(payload);
    if ("error" in rawUTXOs) {
      throw new Error(`Error fetching UTXOs: ${rawUTXOs.error}`);
    }
    const rawResult = rawUTXOs.result;
    const result = rawResult && typeof rawResult === "object" && Array.isArray(rawResult.confirmed) ? rawResult : {
      confirmed: [],
      pending: [],
      spentTransactions: [],
      raw: []
    };
    const rawTransactions = result.raw || [];
    return {
      confirmed: (result.confirmed || []).map((utxo) => {
        return this.parseUTXO(utxo, isCSV, rawTransactions);
      }),
      pending: (result.pending || []).map((utxo) => {
        return this.parseUTXO(utxo, isCSV, rawTransactions);
      }),
      // spentTransactions only contain transactionId and outputIndex (no raw data needed)
      spentTransactions: (result.spentTransactions || []).map(
        (spent) => ({
          transactionId: spent.transactionId,
          outputIndex: spent.outputIndex
        })
      )
    };
  }
  parseUTXO(utxo, isCSV, rawTransactions) {
    if (utxo.raw === void 0 || utxo.raw === null) {
      throw new Error("Missing raw index field in UTXO");
    }
    const rawHex = rawTransactions[utxo.raw];
    if (!rawHex) {
      throw new Error(`Invalid raw index ${utxo.raw} - not found in rawTransactions array`);
    }
    const raw = {
      ...utxo,
      raw: rawTransactions[utxo.raw]
    };
    return new UTXO(raw, isCSV);
  }
  /**
   * After fetching new data for a single address, some pending UTXOs may have confirmed
   * or become known-spent. Remove them from pending state/depth map.
   */
  syncPendingDepthWithFetched(address) {
    const addressData = this.getAddressData(address);
    const fetched = addressData.lastFetchedData;
    if (!fetched) return;
    const confirmedKeys = new Set(
      fetched.confirmed.map((u) => `${u.transactionId}:${u.outputIndex}`)
    );
    const spentKeys = new Set(
      fetched.spentTransactions.map(
        (s) => `${s.transactionId}:${s.outputIndex}`
      )
    );
    addressData.pendingUTXOs = addressData.pendingUTXOs.filter((u) => {
      const key = `${u.transactionId}:${u.outputIndex}`;
      if (confirmedKeys.has(key) || spentKeys.has(key)) {
        delete addressData.pendingUtxoDepth[key];
        return false;
      }
      return true;
    });
  }
};
var MempoolTransactionData = class {
  constructor(data) {
    /** Internal transaction identifier (txid). */
    __publicField(this, "id");
    /** Timestamp of when the transaction was first seen. */
    __publicField(this, "firstSeen");
    /** Block height at which the transaction was observed. */
    __publicField(this, "blockHeight");
    /** The OPNet transaction type. */
    __publicField(this, "transactionType");
    /** Whether the transaction was submitted as a PSBT. */
    __publicField(this, "psbt");
    /** The transaction inputs. */
    __publicField(this, "inputs");
    /** The transaction outputs. */
    __publicField(this, "outputs");
    /** The full raw transaction as a hex string. */
    __publicField(this, "raw");
    this.id = data.id;
    this.firstSeen = new Date(data.firstSeen);
    this.blockHeight = BigInt(data.blockHeight);
    this.transactionType = data.transactionType;
    this.psbt = data.psbt;
    this.inputs = data.inputs;
    this.outputs = data.outputs;
    this.raw = data.raw;
  }
};
var MempoolOPNetTransactionData = class extends MempoolTransactionData {
  constructor(data) {
    super(data);
    /** Theoretical gas limit for OPNet execution. */
    __publicField(this, "theoreticalGasLimit");
    /** Priority fee attached to the transaction. */
    __publicField(this, "priorityFee");
    /** The sender address (p2tr format). */
    __publicField(this, "from");
    /** The target contract address (p2op format). */
    __publicField(this, "contractAddress");
    /** Decoded calldata. */
    __publicField(this, "calldata");
    if (data.theoreticalGasLimit === void 0) {
      throw new Error("Missing theoreticalGasLimit field in OPNet transaction mempool data.");
    }
    if (data.calldata === void 0) {
      throw new Error("Missing calldata field in OPNet transaction mempool data.");
    }
    if (data.from === void 0) {
      throw new Error("Missing from field in OPNet transaction mempool data.");
    }
    if (data.contractAddress === void 0) {
      throw new Error("Missing contractAddress field in OPNet transaction mempool data.");
    }
    this.theoreticalGasLimit = BigInt(data.theoreticalGasLimit);
    this.priorityFee = BigInt(data.priorityFee || "0x00");
    this.from = data.from;
    this.contractAddress = data.contractAddress;
    const calldataHex = data.calldata.startsWith("0x") ? data.calldata.slice(2) : data.calldata;
    this.calldata = fromHex$1(calldataHex);
  }
};
var MempoolDeploymentTransactionData = class extends MempoolOPNetTransactionData {
  constructor(data) {
    super(data);
    /** Decoded contract bytecode. */
    __publicField(this, "bytecode");
    if (data.bytecode === void 0) {
      throw new Error("Bytecode is required for deployment transactions.");
    }
    const bytecodeHex = data.bytecode.startsWith("0x") ? data.bytecode.slice(2) : data.bytecode;
    this.bytecode = fromHex$1(bytecodeHex);
  }
};
var MempoolGenericTransactionData = class extends MempoolTransactionData {
  constructor(data) {
    super(data);
  }
};
var MempoolInteractionTransactionData = class extends MempoolOPNetTransactionData {
  constructor(data) {
    super(data);
  }
};
var MempoolTransactionParser = class {
  static parseTransactions(transactions) {
    if (!transactions) {
      return [];
    }
    const result = [];
    for (const tx of transactions) {
      if (!tx) throw new Error("Something went wrong while parsing mempool transactions");
      result.push(this.parseTransaction(tx));
    }
    return result;
  }
  static parseTransaction(data) {
    if (!data) throw new Error("Mempool transaction data is required");
    switch (data.transactionType) {
      case OPNetTransactionTypes.Generic:
        return new MempoolGenericTransactionData(data);
      case OPNetTransactionTypes.Interaction:
        return new MempoolInteractionTransactionData(
          data
        );
      case OPNetTransactionTypes.Deployment:
        return new MempoolDeploymentTransactionData(
          data
        );
      default:
        throw new Error(`Unknown mempool transaction type: ${data.transactionType}`);
    }
  }
};
var AbstractRpcProvider = class {
  constructor(network) {
    __publicField(this, "nextId", 0);
    __publicField(this, "chainId");
    __publicField(this, "gasCache");
    __publicField(this, "lastFetchedGas", 0);
    __publicField(this, "challengeCache");
    __publicField(this, "csvCache", new AddressMap());
    __publicField(this, "_utxoManager", new UTXOsManager(this));
    this.network = network;
  }
  /**
   * Get the UTXO manager.
   */
  get utxoManager() {
    return this._utxoManager;
  }
  /**
   * Get the CSV1 address for a given address.
   * @description This method is used to get the CSV1 address for a given address.
   * @param {Address} address The address to get the CSV1 address for
   * @returns {IP2WSHAddress} The CSV1 address
   * @example const csv1Address = provider.getCSV1ForAddress(Address.fromString('bcrt1q...'));
   */
  getCSV1ForAddress(address) {
    const cached = this.csvCache.get(address);
    if (cached) return cached;
    const csv = address.toCSV(1, this.network);
    this.csvCache.set(address, csv);
    return csv;
  }
  /**
   * Get the public key information.
   * @description This method is used to get the public key information.
   * @param {string | Address} addressRaw The address or addresses to get the public key information of
   * @param isContract
   * @returns {Promise<Address>} The public keys information
   * @example await getPublicKeyInfo('bcrt1qfqsr3m7vjxheghcvw4ks0fryqxfq8qzjf8fxes');
   * @throws {Error} If the address is invalid
   */
  async getPublicKeyInfo(addressRaw, isContract) {
    const address = addressRaw.toString();
    try {
      const pubKeyInfo = await this.getPublicKeysInfo(address, isContract);
      return pubKeyInfo[address] || pubKeyInfo[address.startsWith("0x") ? address.slice(2) : address];
    } catch (e) {
      if (AddressVerificator.isValidPublicKey(address, this.network)) {
        return Address.fromString(address);
      }
      throw e;
    }
  }
  /**
   * Verify an address.
   * @param {string | Address} addr The address to verify
   * @param {Network} network The network to verify the address against
   * @returns {AddressTypes} The address type, return null if the address is invalid
   */
  validateAddress(addr, network) {
    let validationResult = null;
    if (addr instanceof Address) {
      validationResult = AddressVerificator.detectAddressType(addr.toHex(), network);
    } else if (typeof addr === "string") {
      validationResult = AddressVerificator.detectAddressType(addr, network);
    } else {
      throw new Error(`Invalid type: ${typeof addr} for address: ${addr}`);
    }
    return validationResult;
  }
  /**
   * Get the latest block number.
   * @description This method is used to get the latest block number.
   * @returns {Promise<number>} The latest block number
   * @example await getBlockNumber();
   */
  async getBlockNumber() {
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.BLOCK_BY_NUMBER,
      []
    );
    const rawBlockNumber = await this.callPayloadSingle(payload);
    const result = rawBlockNumber.result;
    return BigInt(result);
  }
  /**
   * Get block by checksum.
   * @param {string} checksum The block checksum
   * @param {boolean} prefetchTxs Whether to prefetch transactions
   * @description This method is used to get a block by its checksum.
   * @returns {Promise<Block>} The requested block
   * @throws {Error} If the block is not found
   * @example await getBlockByChecksum('0xabcdef123456...');
   */
  async getBlockByChecksum(checksum, prefetchTxs = false) {
    var _a5;
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_BLOCK_BY_CHECKSUM,
      [checksum, prefetchTxs]
    );
    const block = await this.callPayloadSingle(payload);
    if ("error" in block) {
      throw new Error(
        `Error fetching block by checksum: ${((_a5 = block.error) == null ? void 0 : _a5.message) || "Unknown error"}`
      );
    }
    const result = block.result;
    return new Block(result, this.network);
  }
  /**
   * Get the latest challenge to use in a transaction.
   * @description This method is used to get the latest challenge along with epoch winner and verification data.
   * @returns {Promise<ChallengeSolution>} The challenge and epoch data
   * @example const challenge = await getChallenge();
   * @throws {Error} If no challenge found or OPNet is not active
   */
  async getChallenge() {
    var _a5;
    if (this.challengeCache && Date.now() < this.challengeCache.expireAt) {
      return this.challengeCache.challenge;
    }
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.TRANSACTION_PREIMAGE,
      []
    );
    const rawChallenge = await this.callPayloadSingle(payload);
    if ("error" in rawChallenge) {
      throw new Error(
        `Error fetching preimage: ${((_a5 = rawChallenge.error) == null ? void 0 : _a5.message) || "Unknown error"}`
      );
    }
    const result = rawChallenge.result;
    if (!result || !result.solution) {
      throw new Error(
        "No challenge found. OPNet is probably not active yet on this blockchain."
      );
    }
    const solutionHex = result.solution.startsWith("0x") ? result.solution.slice(2) : result.solution;
    if (solutionHex === "0".repeat(64)) {
      throw new Error(
        "No valid challenge found. OPNet is probably not active yet on this blockchain."
      );
    }
    const challengeSolution = new ChallengeSolution(result);
    this.challengeCache = {
      challenge: challengeSolution,
      expireAt: Date.now() + 1e4
    };
    return challengeSolution;
  }
  /**
   * Get block by number or hash.
   * @param {BlockTag} blockNumberOrHash The block number or hash
   * @param {boolean} prefetchTxs Whether to prefetch transactions
   * @description This method is used to get a block by its number or hash.
   * @returns {Promise<Block>} The requested block
   * @throws {Error} If the block is not found
   * @example await getBlock(123456);
   */
  async getBlock(blockNumberOrHash, prefetchTxs = false) {
    var _a5;
    const method = typeof blockNumberOrHash === "string" ? JSONRpcMethods.GET_BLOCK_BY_HASH : JSONRpcMethods.GET_BLOCK_BY_NUMBER;
    const payload = this.buildJsonRpcPayload(method, [
      blockNumberOrHash,
      prefetchTxs
    ]);
    const block = await this.callPayloadSingle(payload);
    if ("error" in block) {
      throw new Error(`Error fetching block: ${((_a5 = block.error) == null ? void 0 : _a5.message) || "Unknown error"}`);
    }
    const result = block.result;
    return new Block(result, this.network);
  }
  /**
   * Get multiple blocks by number or hash.
   * @param {BlockTag[]} blockNumbers The block numbers or hashes
   * @param {boolean} prefetchTxs Whether to prefetch transactions
   * @description This method is used to get multiple blocks by their numbers or hashes.
   * @returns {Promise<Block[]>} The requested blocks
   */
  async getBlocks(blockNumbers, prefetchTxs = false) {
    const payloads = blockNumbers.map((blockNumber) => {
      return this.buildJsonRpcPayload(JSONRpcMethods.GET_BLOCK_BY_NUMBER, [
        blockNumber,
        prefetchTxs
      ]);
    });
    const blocks = await this.callMultiplePayloads(payloads);
    if ("error" in blocks) {
      const error = blocks.error;
      throw new Error(`Error fetching block: ${error.message}`);
    }
    return blocks.map((block) => {
      if ("error" in block) {
        throw new Error(`Error fetching block: ${block.error}`);
      }
      const result = block.result;
      return new Block(result, this.network);
    });
  }
  /**
   * Get block by hash. This is the same method as getBlock.
   * @param {string} blockHash The block hash
   * @description This method is used to get a block by its hash. Note that this method is the same as getBlock.
   * @returns {Promise<Block>} The requested block
   * @throws {Error} If the block is not found
   */
  async getBlockByHash(blockHash) {
    return await this.getBlock(blockHash);
  }
  /**
   * Get the bitcoin balance of an address.
   * @param {string} address The address to get the balance of
   * @param {boolean} filterOrdinals Whether to filter ordinals or not
   * @description This method is used to get the balance of a bitcoin address.
   * @returns {Promise<bigint>} The balance of the address
   * @example await getBalance('bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq');
   */
  async getBalance(address, filterOrdinals = true) {
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.GET_BALANCE, [
      address,
      filterOrdinals
    ]);
    const rawBalance = await this.callPayloadSingle(payload);
    const result = rawBalance.result;
    if (!result || result && !result.startsWith("0x")) {
      throw new Error(`Invalid balance returned from provider: ${result}`);
    }
    return BigInt(result);
  }
  /**
   * Get the bitcoin balances of multiple addresses.
   * @param {string[]} addressesLike The addresses to get the balances of
   * @param {boolean} filterOrdinals Whether to filter ordinals or not
   * @description This method is used to get the balance of a bitcoin address.
   * @returns {Record<string, bigint>} The balance of the address
   * @example await getBalances(['bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq']);
   */
  async getBalances(addressesLike, filterOrdinals = true) {
    const payloads = addressesLike.map((address) => {
      return this.buildJsonRpcPayload(JSONRpcMethods.GET_BALANCE, [address, filterOrdinals]);
    });
    const balances = await this.callMultiplePayloads(payloads);
    if ("error" in balances) {
      const error = balances.error;
      throw new Error(`Error fetching block: ${error.message}`);
    }
    const resultBalance = {};
    for (let i2 = 0; i2 < balances.length; i2++) {
      const balance = balances[i2];
      const address = addressesLike[i2];
      if (!address) throw new Error("Impossible index.");
      if ("error" in balance) {
        throw new Error(`Error fetching block: ${balance.error}`);
      }
      const result = balance.result;
      if (!result || result && !result.startsWith("0x")) {
        throw new Error(`Invalid balance returned from provider: ${result}`);
      }
      resultBalance[address] = BigInt(result);
    }
    return resultBalance;
  }
  /**
   * Get a transaction by its hash or hash id.
   * @description This method is used to get a transaction by its hash or hash id.
   * @param {string} txHash The transaction hash
   * @returns {Promise<TransactionBase<OPNetTransactionTypes>>} The requested transaction
   * @example await getTransaction('63e77ba9fa4262b3d4d0d9d97fa8a7359534606c3f3af096284662e3f619f374');
   * @throws {Error} If something went wrong while fetching the transaction
   */
  async getTransaction(txHash) {
    var _a5;
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_TRANSACTION_BY_HASH,
      [txHash]
    );
    const rawTransaction = await this.callPayloadSingle(payload);
    const result = rawTransaction.result;
    if ("error" in rawTransaction) {
      throw new Error(
        `Error fetching transaction: ${((_a5 = rawTransaction.error) == null ? void 0 : _a5.message) || "Unknown error"}`
      );
    }
    return TransactionParser.parseTransaction(result, this.network);
  }
  /**
   * Get a transaction receipt by its hash.
   * @description This method is used to get a transaction receipt by its hash.
   * @param {string} txHash The transaction hash
   * @returns {Promise<TransactionReceipt>} The requested transaction receipt
   * @example await getTransactionReceipt('63e77ba9fa4262b3d4d0d9d97fa8a7359534606c3f3af096284662e3f619f374');
   * @throws {Error} Something went wrong while fetching the transaction receipt
   */
  async getTransactionReceipt(txHash) {
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_TRANSACTION_RECEIPT,
      [txHash]
    );
    const rawTransaction = await this.callPayloadSingle(payload);
    return new TransactionReceipt(rawTransaction.result, this.network);
  }
  /**
   * Get the current connected network type.
   * @description This method is used to get the current connected network type.
   * @returns {Network} The current connected network type
   * @throws {Error} If the chain id is invalid
   */
  getNetwork() {
    return this.network;
  }
  /**
   * Get the chain id.
   * @description This method is used to get the chain id.
   * @returns {Promise<bigint>} The chain id
   * @throws {Error} If something went wrong while fetching the chain id
   */
  async getChainId() {
    if (this.chainId !== void 0) return this.chainId;
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.CHAIN_ID, []);
    const rawChainId = await this.callPayloadSingle(payload);
    if ("error" in rawChainId) {
      throw new Error(`Something went wrong while fetching: ${rawChainId.error}`);
    }
    const chainId = rawChainId.result;
    this.chainId = BigInt(chainId);
    return this.chainId;
  }
  /**
   * Get the contract code of an address.
   * @description This method is used to get the contract code of an address.
   * @param {string | Address} address The address of the contract
   * @param {boolean} [onlyBytecode] Whether to return only the bytecode
   * @returns {Promise<ContractData | Uint8Array>} The contract data or bytecode
   * @example await getCode('tb1pth90usc4f528aqphpjrfkkdm4vy8hxnt5gps6aau2nva6pxeshtqqzlt3a');
   * @throws {Error} If something went wrong while fetching the contract code
   */
  async getCode(address, onlyBytecode = false) {
    const addressStr = address.toString();
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.GET_CODE, [
      addressStr,
      onlyBytecode
    ]);
    const rawCode = await this.callPayloadSingle(payload);
    if (rawCode.error) {
      throw new Error(
        `${rawCode.error.code}: Something went wrong while fetching: ${rawCode.error.message}`
      );
    }
    const result = rawCode.result;
    if ("contractAddress" in result) {
      return new ContractData(result);
    } else {
      return fromBase64$1(result.bytecode);
    }
  }
  /**
   * Get the storage at a specific address and pointer.
   * @description This method is used to get the storage at a specific address and pointer.
   * @param {string | Address} address The address to get the storage from
   * @param {BigNumberish} rawPointer The pointer to get the storage from as base64 or bigint
   * @param {boolean} proofs Whether to send proofs or not
   * @param {BigNumberish} [height] The height to get the storage from
   * @returns {Promise<StoredValue>} The storage value
   * @example await getStorageAt('tb1pth90usc4f528aqphpjrfkkdm4vy8hxnt5gps6aau2nva6pxeshtqqzlt3a', 'EXLK/QhEQMI5d9DrthLvozT+UcDQ7WuSPaz7g8GV3AQ=');
   * @throws {Error} If something went wrong while fetching the storage
   */
  async getStorageAt(address, rawPointer, proofs = true, height) {
    const addressStr = address.toString();
    const pointer = typeof rawPointer === "string" ? rawPointer : this.bigintToBase64(rawPointer);
    const params = [addressStr, pointer, proofs];
    if (height) {
      params.push(height.toString());
    }
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_STORAGE_AT,
      params
    );
    const rawStorage = await this.callPayloadSingle(payload);
    const result = rawStorage.result;
    return new StoredValue(result);
  }
  /**
   * Call a contract function with a given calldata.
   * @description This method is used to call a contract function with a given calldata.
   * @param {string | Address} to The address of the contract
   * @param {Uint8Array | string} data The calldata of the contract function
   * @param {string | Address} [from] The address to call the contract from
   * @param {BigNumberish} [height] The height to call the contract from
   * @param {ParsedSimulatedTransaction} [simulatedTransaction] UTXOs to simulate the transaction
   * @param {IAccessList} [accessList] The access list of previous simulation to use for this call
   * @returns {Promise<CallResult>} The result of the contract function call
   * @example await call('tb1pth90usc4f528aqphpjrfkkdm4vy8hxnt5gps6aau2nva6pxeshtqqzlt3a', fromHex('12345678'));
   * @throws {Error} If something went wrong while calling the contract
   */
  async call(to, data, from, height, simulatedTransaction, accessList) {
    const toStr = to.toString();
    const fromStr = from ? from.toHex() : void 0;
    const fromLegacyStr = from ? from.tweakedToHex() : void 0;
    let dataStr = data instanceof Uint8Array ? toHex$1(data) : data;
    if (dataStr.startsWith("0x")) {
      dataStr = dataStr.slice(2);
    }
    const params = [toStr, dataStr, fromStr, fromLegacyStr];
    if (height) {
      if (typeof height === "object") {
        throw new Error("Height must be a number or bigint");
      }
      params.push(height.toString());
    } else {
      params.push(void 0);
    }
    if (simulatedTransaction) {
      params.push(this.parseSimulatedTransaction(simulatedTransaction));
    } else {
      params.push(void 0);
    }
    if (accessList) {
      params.push(accessList);
    } else {
      params.push(void 0);
    }
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.CALL, params);
    const rawCall = await this.callPayloadSingle(payload);
    const result = rawCall.result || rawCall;
    if (!rawCall.result) {
      return {
        error: result.error.message
      };
    }
    if ("error" in result) {
      return result;
    }
    if (result.revert) {
      let decodedError;
      try {
        decodedError = decodeRevertData(fromBase64$1(result.revert));
      } catch {
        decodedError = result.revert;
      }
      return {
        error: decodedError
      };
    }
    return new CallResult(result, this);
  }
  /**
   * Get the next block gas parameters.
   * @description This method is used to get the next block gas parameters. Such as base gas, gas limit, and gas price.
   * @returns {Promise<BlockGasParameters>} The gas parameters of the next block
   * @example await provider.gasParameters();
   * @throws {Error} If something went wrong while calling the contract
   */
  async gasParameters() {
    if (!this.gasCache || Date.now() - this.lastFetchedGas > 1e4) {
      this.lastFetchedGas = Date.now();
      this.gasCache = await this._gasParameters();
    }
    return this.gasCache;
  }
  /**
   * Send a raw transaction.
   * @description This method is used to send a raw transaction.
   * @param {string} tx The raw transaction to send as hex string
   * @param {boolean} [psbt] Whether the transaction is a PSBT or not
   * @returns {Promise<BroadcastedTransaction>} The result of the transaction
   * @example await sendRawTransaction('02000000000101ad897689f66c98daae5fdc3606235c1ad7a17b9e0a6aaa0ea9e58ecc1198ad2a0100000000ffffffff01a154c39400000000160014482038efcc91af945f0c756d07a46401920380520247304402201c1f8718dec637ddb41b42abc44dcbf35a94c6be6a9de8c1db48c9fa6e456b7e022032a4b3286808372a7ac2c5094d6341b4d61b17663f4ccd1c1d92efa85c7dada80121020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c00000000', false);
   * @throws {Error} If something went wrong while sending the transaction
   */
  async sendRawTransaction(tx, psbt) {
    if (!/^[0-9A-Fa-f]+$/.test(tx)) {
      throw new Error("sendRawTransaction: Invalid hex string");
    }
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.BROADCAST_TRANSACTION,
      [tx, psbt]
    );
    const rawTx = await this.callPayloadSingle(payload);
    return rawTx.result;
  }
  /**
   * Bulk send transactions.
   * @description This method is used to send multiple transactions at the same time.
   * @param {string[]} txs The raw transactions to send as hex string
   * @returns {Promise<BroadcastedTransaction[]>} The result of the transaction
   * @throws {Error} If something went wrong while sending the transaction
   */
  async sendRawTransactions(txs) {
    const payloads = txs.map((tx) => {
      return this.buildJsonRpcPayload(JSONRpcMethods.BROADCAST_TRANSACTION, [tx, false]);
    });
    const rawTxs = await this.callMultiplePayloads(payloads);
    if ("error" in rawTxs) {
      throw new Error(`Error sending transactions: ${rawTxs.error}`);
    }
    return rawTxs.map((rawTx) => {
      return rawTx.result;
    });
  }
  /**
   * Get block witnesses.
   * @description This method is used to get the witnesses of a block. This proves that the actions executed inside a block are valid and confirmed by the network. If the minimum number of witnesses are not met, the block is considered as potentially invalid.
   * @param {BlockTag} height The block number or hash, use -1 for latest block
   * @param {boolean} [trusted] Whether to trust the witnesses or not
   * @param {number} [limit] The maximum number of witnesses to return
   * @param {number} [page] The page number of the witnesses
   * @returns {Promise<BlockWitnesses>} The witnesses of the block
   * @example await getBlockWitness(123456n);
   * @throws {Error} If something went wrong while fetching the witnesses
   */
  async getBlockWitness(height = -1, trusted, limit, page) {
    var _a5;
    const params = [height.toString()];
    if (trusted !== void 0 && trusted !== null) params.push(trusted);
    if (limit !== void 0 && limit !== null) params.push(limit);
    if (page !== void 0 && page !== null) params.push(page);
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.BLOCK_WITNESS,
      params
    );
    const rawWitnesses = await this.callPayloadSingle(payload);
    if ("error" in rawWitnesses) {
      throw new Error(
        `Error fetching block witnesses: ${((_a5 = rawWitnesses.error) == null ? void 0 : _a5.message) || "Unknown error"}`
      );
    }
    const result = rawWitnesses.result;
    return parseBlockWitnesses(result);
  }
  /**
   * Get reorgs that happened between two blocks.
   * @description This method is used to get the reorgs that happened between two blocks.
   * @param {BigNumberish} [fromBlock] The block number to start from
   * @param {BigNumberish} [toBlock] The block number to end at
   * @returns {Promise<ReorgInformation>} The reorg information
   * @example await getReorg(123456n, 123457n);
   * @throws {Error} If something went wrong while fetching the reorg information
   */
  async getReorg(fromBlock, toBlock) {
    const params = [];
    if (fromBlock !== void 0 && fromBlock !== null) params.push(fromBlock.toString());
    if (toBlock !== void 0 && toBlock !== null) params.push(toBlock.toString());
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.REORG, params);
    const rawReorg = await this.callPayloadSingle(payload);
    const result = rawReorg.result;
    if (result.length > 0) {
      for (let i2 = 0; i2 < result.length; i2++) {
        const res = result[i2];
        res.fromBlock = BigInt("0x" + res.fromBlock.toString());
        res.toBlock = BigInt("0x" + res.toBlock.toString());
      }
    }
    return result;
  }
  /**
   * Send a single payload. This method is used to send a single payload.
   * @param {JsonRpcPayload} payload The payload to send
   * @returns {Promise<JsonRpcResult>} The result of the payload
   * @throws {Error} If no data is returned
   * @private
   */
  async callPayloadSingle(payload) {
    const rawData = await this._send(payload);
    if (!rawData.length) {
      throw new Error("No data returned");
    }
    const data = rawData.shift();
    if (!data) {
      throw new Error("Block not found");
    }
    return data;
  }
  /**
   * Send multiple payloads. This method is used to send multiple payloads.
   * @param {JsonRpcPayload[]} payloads The payloads to send
   * @returns {Promise<JsonRpcResult>} The result of the payloads
   */
  async callMultiplePayloads(payloads) {
    const rawData = await this._send(
      payloads
    );
    if ("error" in rawData) {
      throw new Error(`Error fetching block: ${rawData.error}`);
    }
    const data = rawData.shift();
    if (!data) {
      throw new Error("Block not found");
    }
    return data;
  }
  /**
   * Build a JSON RPC payload. This method is used to build a JSON RPC payload.
   * @param {JSONRpcMethods} method The method to call
   * @param {unknown[]} params The parameters to send
   * @returns {JsonRpcPayload} The JSON RPC payload
   */
  buildJsonRpcPayload(method, params) {
    return {
      method,
      params,
      id: this.nextId++,
      jsonrpc: "2.0"
    };
  }
  /**
   * Get the raw public key information from the API.
   * @description Returns the raw API response without transforming to Address objects.
   * @param {string | string[] | Address | Address[]} addresses The address or addresses to get the public key information of
   * @returns {Promise<IPublicKeyInfoResult>} The raw public keys information from the API
   * @example await getPublicKeysInfoRaw(['addressA', 'addressB']);
   * @throws {Error} If the address is invalid or API call fails
   */
  async getPublicKeysInfoRaw(addresses) {
    const addressArray = Array.isArray(addresses) ? addresses : [addresses];
    for (const addr of addressArray) {
      if (this.validateAddress(addr, this.network) === null) {
        throw new Error(`Invalid address: ${addr}`);
      }
    }
    const method = JSONRpcMethods.PUBLIC_KEY_INFO;
    const payload = this.buildJsonRpcPayload(method, [addressArray]);
    const data = await this.callPayloadSingle(payload);
    if (data.error) {
      const errorData = data.error;
      const errorMessage = typeof errorData === "string" ? errorData : errorData.message;
      throw new Error(errorMessage);
    }
    return data.result;
  }
  /**
   * Get the public key information and transform to Address objects.
   * @description Fetches public key information from the API and converts results to Address instances
   * containing both ML-DSA (quantum-resistant) and classical key data when available.
   *
   * The method resolves various address formats (p2tr, p2pkh, p2wpkh, p2op, raw public keys) to their
   * corresponding public key information and constructs Address objects with the appropriate key hierarchy.
   *
   * For addresses with ML-DSA keys registered, the returned Address will have:
   * - Primary content: SHA256 hash of the ML-DSA public key (mldsaHashedPublicKey)
   * - Legacy key: The classical tweaked/original public key for Bitcoin address derivation
   * - Original ML-DSA public key and security level attached to the Address instance
   *
   * For addresses without ML-DSA keys, the Address will use the tweaked x-only public key as primary content.
   *
   * @param {string | string[] | Address | Address[]} addresses The address(es) to look up. Accepts p2tr addresses,
   * p2op addresses, raw public keys (32-byte x-only, 33-byte compressed, or 65-byte uncompressed), or existing Address instances.
   * @param {boolean} [isContract=false] When true, uses tweakedPubkey as the legacy key since contracts
   * don't have original untweaked keys. When false, prefers originalPubKey when available.
   * @param {boolean} [logErrors=false] When true, logs errors to console for addresses that fail lookup
   * instead of silently skipping them.
   * @returns {Promise<AddressesInfo>} Map of input keys to Address instances. Keys that failed lookup are omitted.
   * @example
   * // Single address lookup
   * const info = await provider.getPublicKeysInfo('bc1p...');
   *
   * @example
   * // Multiple addresses with error logging
   * const info = await provider.getPublicKeysInfo(['bc1p...', 'bc1q...'], false, true);
   *
   * @example
   * // Contract address lookup
   * const info = await provider.getPublicKeysInfo(contractAddress, true);
   *
   * @throws {Error} If any provided address fails validation before the API call
   */
  async getPublicKeysInfo(addresses, isContract = false, logErrors = false) {
    const result = await this.getPublicKeysInfoRaw(addresses);
    const response = {};
    for (const pubKey of Object.keys(result)) {
      const info = result[pubKey];
      if ("error" in info) {
        if (logErrors) {
          console.error(`Error fetching public key info for ${pubKey}: ${info.error}`);
        }
        continue;
      }
      const addressContent = isContract ? info.mldsaHashedPublicKey ?? info.tweakedPubkey : info.mldsaHashedPublicKey;
      const legacyKey = isContract ? info.tweakedPubkey : info.originalPubKey ?? info.tweakedPubkey;
      if (!addressContent) {
        throw new Error(
          `No valid address content found for ${pubKey}. Use getPublicKeysInfoRaw instead.`
        );
      }
      const address = Address.fromString(addressContent, legacyKey);
      if (info.mldsaPublicKey) {
        address.originalMDLSAPublicKey = fromHex$1(info.mldsaPublicKey);
        address.mldsaLevel = info.mldsaLevel;
      }
      response[pubKey] = address;
    }
    return response;
  }
  /**
   * Get the latest epoch.
   * @description This method is used to get the latest epoch in the OPNet protocol.
   * @returns {Promise<Epoch>} The latest epoch
   * @example await getLatestEpoch();
   * @throws {Error} If something went wrong while fetching the epoch
   */
  async getLatestEpoch(includeSubmissions) {
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.LATEST_EPOCH, []);
    const rawEpoch = await this.callPayloadSingle(payload);
    const result = rawEpoch.result;
    return new Epoch(result);
  }
  /**
   * Get an epoch by its number.
   * @description This method is used to get an epoch by its number.
   * @param {BigNumberish} epochNumber The epoch number (-1 for latest)
   * @param {boolean} [includeSubmissions] Whether to include submissions in the response
   * @returns {Promise<Epoch | EpochWithSubmissions>} The requested epoch
   * @example await getEpochByNumber(123n);
   * @throws {Error} If something went wrong while fetching the epoch
   */
  async getEpochByNumber(epochNumber, includeSubmissions = false) {
    var _a5;
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_EPOCH_BY_NUMBER,
      [epochNumber.toString(), includeSubmissions]
    );
    const rawEpoch = await this.callPayloadSingle(payload);
    if ("error" in rawEpoch) {
      throw new Error(`Error fetching epoch: ${((_a5 = rawEpoch.error) == null ? void 0 : _a5.message) || "Unknown error"}`);
    }
    const result = rawEpoch.result;
    return includeSubmissions || result.submissions ? new EpochWithSubmissions(result) : new Epoch(result);
  }
  /**
   * Get an epoch by its hash.
   * @description This method is used to get an epoch by its hash.
   * @param {string} epochHash The epoch hash
   * @param {boolean} [includeSubmissions] Whether to include submissions in the response
   * @returns {Promise<Epoch | EpochWithSubmissions>} The requested epoch
   * @example await getEpochByHash('0x1234567890abcdef...');
   * @throws {Error} If something went wrong while fetching the epoch
   */
  async getEpochByHash(epochHash, includeSubmissions = false) {
    var _a5;
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.GET_EPOCH_BY_HASH, [
      epochHash,
      includeSubmissions
    ]);
    const rawEpoch = await this.callPayloadSingle(payload);
    if ("error" in rawEpoch) {
      throw new Error(`Error fetching epoch: ${((_a5 = rawEpoch.error) == null ? void 0 : _a5.message) || "Unknown error"}`);
    }
    const result = rawEpoch.result;
    return includeSubmissions || result.submissions ? new EpochWithSubmissions(result) : new Epoch(result);
  }
  /**
   * Get the current epoch mining template.
   * @description This method is used to get the current epoch mining template with target hash and requirements.
   * @returns {Promise<EpochTemplate>} The epoch template
   * @example await getEpochTemplate();
   * @throws {Error} If something went wrong while fetching the template
   */
  async getEpochTemplate() {
    var _a5;
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_EPOCH_TEMPLATE,
      []
    );
    const rawTemplate = await this.callPayloadSingle(payload);
    if ("error" in rawTemplate) {
      throw new Error(
        `Error fetching epoch template: ${((_a5 = rawTemplate.error) == null ? void 0 : _a5.message) || "Unknown error"}`
      );
    }
    const result = rawTemplate.result;
    return new EpochTemplate(result);
  }
  /**
   * Submit a new epoch solution.
   * @description This method is used to submit a SHA-1 collision solution for epoch mining.
   * @param {EpochSubmissionParams} params The parameters for the epoch submission
   * @returns {Promise<SubmittedEpoch>} The submission result
   * @example await submitEpoch({
   *     epochNumber: 123n,
   *     checksumRoot: fromHex('00000000000000000000000000000000'), // 32 bytes
   *     salt: fromHex('0a0a0a0a0a0a00a0'),
   *     mldsaPublicKey: Address.dead(),
   *     graffiti: new Uint8Array([72, 101, 108, 108, 111]),
   *     signature: fromHex('1234567890abcdef'),
   * });
   * @throws {Error} If something went wrong while submitting the epoch
   */
  async submitEpoch(params) {
    var _a5;
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.SUBMIT_EPOCH, [
      {
        epochNumber: params.epochNumber.toString(),
        checksumRoot: toHex$1(params.checksumRoot),
        salt: toHex$1(params.salt),
        mldsaPublicKey: toHex$1(params.mldsaPublicKey),
        signature: toHex$1(params.signature),
        graffiti: params.graffiti ? toHex$1(params.graffiti) : void 0
      }
    ]);
    const rawSubmission = await this.callPayloadSingle(payload);
    if ("error" in rawSubmission) {
      throw new Error(
        `Error submitting epoch: ${((_a5 = rawSubmission.error) == null ? void 0 : _a5.message) || "Unknown error"}`
      );
    }
    const result = rawSubmission.result;
    return new SubmittedEpoch(result);
  }
  /**
   * @description Get mempool information (transaction count, size, etc.)
   * @returns {Promise<MempoolInfo>} Mempool information
   */
  async getMempoolInfo() {
    var _a5;
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_MEMPOOL_INFO,
      []
    );
    const rawResult = await this.callPayloadSingle(payload);
    if ("error" in rawResult) {
      throw new Error(
        `Error fetching mempool info: ${((_a5 = rawResult.error) == null ? void 0 : _a5.message) || "Unknown error"}`
      );
    }
    return rawResult.result;
  }
  /**
   * @description Get a pending transaction from the mempool by hash
   * @param {string} hash - The transaction txid (64 hex characters)
   * @returns {Promise<MempoolTransactionData | null>} The pending transaction data, or null if not found
   */
  async getPendingTransaction(hash2) {
    var _a5;
    if (!hash2 || !/^[0-9a-fA-F]{64}$/.test(hash2)) {
      throw new Error(
        `getPendingTransaction: expected a 64-character hex txid, got "${hash2}"`
      );
    }
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_PENDING_TRANSACTION,
      [hash2]
    );
    const rawResult = await this.callPayloadSingle(payload);
    if ("error" in rawResult) {
      const msg = ((_a5 = rawResult.error) == null ? void 0 : _a5.message) ?? "Unknown error";
      if (/not found/i.test(msg)) return null;
      throw new Error(`Error fetching pending transaction: ${msg}`);
    }
    const raw = rawResult.result;
    if (raw == null) return null;
    return MempoolTransactionParser.parseTransaction(raw);
  }
  /**
   * @description Get the latest pending transactions from the mempool, optionally filtered by a single address.
   * @param {object} [options]
   * @param {string} [options.address] - Optional address to filter transactions by
   * @param {number} [options.limit] - Optional maximum number of transactions to return (positive integer)
   * @returns {Promise<MempoolTransactionData[]>} Array of pending transactions
   */
  async getLatestPendingTransactions(options) {
    if ((options == null ? void 0 : options.address) !== void 0) {
      if (this.validateAddress(options.address, this.network) === null) {
        throw new Error(
          `getLatestPendingTransactions: invalid address "${options.address}"`
        );
      }
    }
    return this._fetchPendingTransactions((options == null ? void 0 : options.address) ?? null, null, options == null ? void 0 : options.limit);
  }
  /**
   * @description Get the latest pending transactions from the mempool filtered by a list of addresses.
   * @param {object} options
   * @param {string[]} options.addresses - Addresses to filter transactions by
   * @param {number} [options.limit] - Optional maximum number of transactions to return (positive integer)
   * @returns {Promise<MempoolTransactionData[]>} Array of pending transactions
   */
  async getLatestPendingTransactionsByAddresses(options) {
    if (options.addresses.length === 0) {
      throw new Error(
        "getLatestPendingTransactionsByAddresses: addresses array must not be empty"
      );
    }
    for (const addr of options.addresses) {
      if (this.validateAddress(addr, this.network) === null) {
        throw new Error(
          `getLatestPendingTransactionsByAddresses: invalid address "${addr}"`
        );
      }
    }
    return this._fetchPendingTransactions(null, options.addresses, options.limit);
  }
  async _fetchPendingTransactions(address, addresses, limit) {
    if (address !== null && addresses !== null) {
      throw new Error(
        "_fetchPendingTransactions: address and addresses are mutually exclusive"
      );
    }
    if (limit !== void 0 && (!Number.isInteger(limit) || limit < 1)) {
      throw new Error(`limit must be a positive integer, got ${limit}`);
    }
    const params = [address, addresses, limit ?? null];
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_LATEST_PENDING_TRANSACTIONS,
      params
    );
    const rawResult = await this.callPayloadSingle(payload);
    if (rawResult.error != null) {
      throw new Error(
        `Error fetching latest pending transactions: ${rawResult.error.message}`
      );
    }
    const result = rawResult.result;
    if (result == null) {
      return [];
    }
    if (typeof result !== "object" || Array.isArray(result)) {
      throw new Error(
        "Error fetching latest pending transactions: unexpected response shape"
      );
    }
    if (result.transactions == null) {
      return [];
    }
    if (!Array.isArray(result.transactions)) {
      throw new Error(
        "Error fetching latest pending transactions: expected transactions to be an array"
      );
    }
    return MempoolTransactionParser.parseTransactions(result.transactions);
  }
  async _gasParameters() {
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.GAS, []);
    const rawCall = await this.callPayloadSingle(payload);
    if ("error" in rawCall) {
      throw new Error(`Error fetching gas parameters: ${rawCall.error}`);
    }
    const result = rawCall.result;
    return new BlockGasParameters(result);
  }
  parseSimulatedTransaction(transaction) {
    return {
      inputs: transaction.inputs.map((input) => {
        return {
          txId: toBase64$1(input.txId),
          outputIndex: input.outputIndex,
          scriptSig: toBase64$1(input.scriptSig),
          witnesses: input.witnesses.map((w2) => toBase64$1(w2)),
          coinbase: input.coinbase ? toBase64$1(input.coinbase) : void 0,
          flags: input.flags
        };
      }),
      outputs: transaction.outputs.map((output) => {
        return {
          index: output.index,
          to: output.to,
          value: output.value.toString(),
          scriptPubKey: output.scriptPubKey ? toBase64$1(output.scriptPubKey) : void 0,
          flags: output.flags || TransactionOutputFlags.hasTo
        };
      })
    };
  }
  bigintToBase64(bigint) {
    return toBase64$1(BufferHelper.pointerToUint8Array(bigint));
  }
};
var Agent = class {
  async close() {
  }
};
function fetch$1(input, init) {
  const nativeFetch = globalThis.fetch || window.fetch || self.fetch;
  if (!nativeFetch) {
    throw new Error("Fetch API is not available.");
  }
  return nativeFetch(input, init);
}
function getFetcher(configs) {
  const agent = new Agent(configs);
  const limit = pLimit(500);
  async function limitedFetch(input, init) {
    return limit(() => fetch$1(input, { ...init, dispatcher: agent }));
  }
  return {
    fetch: limitedFetch,
    close: async () => {
      await agent.close();
    }
  };
}
var isNode = typeof process$1 !== "undefined" && process$1.versions != null && process$1.versions.node != null;
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
async function createWorker(workerScript) {
  if (isNode) {
    return createNodeWorker(workerScript);
  }
  return createBrowserWorker(workerScript);
}
async function createNodeWorker(workerScript) {
  const { Worker: Worker2 } = await import("./worker_threads-browser-RV3WZRIP.js");
  const worker = new Worker2(workerScript, { eval: true });
  worker.on("error", (err2) => {
    console.error("[WorkerCreator] Worker error:", err2);
  });
  let messageCallback = null;
  worker.on("message", (msg) => {
    if (messageCallback) messageCallback(msg);
  });
  worker.unref();
  return {
    postMessage: (msg, transferables) => {
      if (transferables && transferables.length > 0) {
        worker.postMessage(msg, transferables);
      } else {
        worker.postMessage(msg);
      }
    },
    onMessage: (callback) => {
      messageCallback = callback;
    },
    terminate: async () => {
      await worker.terminate();
    }
  };
}
function createBrowserWorker(workerScript) {
  const blob = new Blob([workerScript], { type: "application/javascript" });
  const url = URL.createObjectURL(blob);
  const worker = new Worker(url);
  worker.onerror = (err2) => {
    console.error("[WorkerCreator] Worker error:", err2);
  };
  return {
    postMessage: (msg, transferables) => {
      if (transferables && transferables.length > 0) {
        worker.postMessage(msg, transferables);
      } else {
        worker.postMessage(msg);
      }
    },
    onMessage: (callback) => {
      worker.onmessage = (e) => callback(e.data);
    },
    terminate: () => {
      worker.terminate();
      URL.revokeObjectURL(url);
    }
  };
}
var BaseThreader = class extends Logger {
  constructor(options = {}) {
    super();
    __publicField(this, "logColor", "#FF5733");
    __publicField(this, "workers", []);
    __publicField(this, "available", []);
    __publicField(this, "pending", /* @__PURE__ */ new Map());
    __publicField(this, "queue", []);
    __publicField(this, "idCounter", 0);
    __publicField(this, "initialized", false);
    __publicField(this, "initializing", null);
    __publicField(this, "tasksProcessed", 0);
    __publicField(this, "tasksFailed", 0);
    __publicField(this, "lastStatsLog", 0);
    __publicField(this, "poolSize");
    __publicField(this, "statsInterval", 3e4);
    __publicField(this, "cleanupBound", false);
    this.poolSize = options.poolSize ?? (isNode ? 6 : Math.max(Math.max(1, Math.ceil(((navigator == null ? void 0 : navigator.hardwareConcurrency) ?? 8) / 2)), 6));
  }
  get stats() {
    return {
      pending: this.pending.size,
      queued: this.queue.length,
      available: this.available.length,
      total: this.workers.length,
      processed: this.tasksProcessed,
      failed: this.tasksFailed
    };
  }
  async terminate() {
    if (!this.initialized && !this.initializing) return;
    const queuedCount = this.queue.length;
    const pendingCount = this.pending.size;
    for (const task of this.queue) {
      task.reject(new Error("Threader terminated"));
    }
    for (const [, handler] of this.pending) {
      handler.reject(new Error("Threader terminated"));
    }
    for (const worker of this.workers) {
      await worker.terminate();
    }
    this.queue = [];
    this.pending.clear();
    this.workers = [];
    this.available = [];
    this.initialized = false;
    this.initializing = null;
    if (queuedCount > 0 || pendingCount > 0) {
      this.info(
        `Terminated. Rejected ${queuedCount} queued and ${pendingCount} pending tasks. Total processed: ${this.tasksProcessed}, failed: ${this.tasksFailed}`
      );
    }
  }
  async drain() {
    if (!this.initialized) return;
    const queuedCount = this.queue.length;
    const pendingCount = this.pending.size;
    this.info(
      `Draining. Rejecting ${queuedCount} queued, waiting for ${pendingCount} pending...`
    );
    for (const task of this.queue) {
      task.reject(new Error("Threader draining"));
    }
    this.queue = [];
    if (this.pending.size > 0) {
      await new Promise((resolve) => {
        const checkDone = () => {
          if (this.pending.size === 0) {
            resolve();
          }
        };
        const originalPending = new Map(this.pending);
        for (const [id2, handler] of originalPending) {
          const origResolve = handler.resolve;
          const origReject = handler.reject;
          handler.resolve = (v) => {
            origResolve(v);
            checkDone();
          };
          handler.reject = (e) => {
            origReject(e);
            checkDone();
          };
          this.pending.set(id2, handler);
        }
        checkDone();
      });
    }
    await this.terminate();
  }
  runWithTransfer(op, data, transferables) {
    return new Promise(async (resolve, reject) => {
      await this.init();
      this.queue.push({ resolve, reject, op, data, transferables });
      this.processQueue();
    });
  }
  run(op, data) {
    return new Promise(async (resolve, reject) => {
      await this.init();
      this.queue.push({ resolve, reject, op, data });
      this.processQueue();
    });
  }
  bindCleanupHandlers() {
    if (this.cleanupBound) return;
    this.cleanupBound = true;
    const cleanup = () => {
      this.terminate().catch(() => {
      });
    };
    if (isNode) {
      process$1.once("beforeExit", cleanup);
      process$1.once("SIGINT", cleanup);
      process$1.once("SIGTERM", cleanup);
    } else if (isReactNative) ;
    else if (typeof window !== "undefined" && typeof window.addEventListener === "function") {
      window.addEventListener("beforeunload", cleanup);
      window.addEventListener("unload", cleanup);
    } else if (typeof self !== "undefined" && typeof self.addEventListener === "function") {
      self.addEventListener("beforeunload", cleanup);
    }
  }
  async init() {
    if (this.initialized) return;
    if (this.initializing) return this.initializing;
    this.bindCleanupHandlers();
    this.initializing = (async () => {
      const workers = await Promise.all(
        Array.from(
          { length: this.poolSize },
          () => createWorker(this.workerScript)
        )
      );
      for (const worker of workers) {
        worker.onMessage((msg) => {
          const handler = this.pending.get(msg.id);
          if (handler) {
            this.pending.delete(msg.id);
            if (msg.error) {
              this.tasksFailed++;
              handler.reject(new Error(msg.error));
            } else {
              this.tasksProcessed++;
              handler.resolve(msg.result);
            }
          }
          this.available.push(worker);
          this.logStatsIfNeeded();
          this.processQueue();
        });
        this.workers.push(worker);
        this.available.push(worker);
      }
      this.initialized = true;
    })();
    return this.initializing;
  }
  logStatsIfNeeded() {
    const now = Date.now();
    if (now - this.lastStatsLog < this.statsInterval) return;
    this.lastStatsLog = now;
  }
  processQueue() {
    if (this.queue.length > 100 && this.available.length === 0) {
      this.warn(`Queue backing up: ${this.queue.length} tasks waiting, no workers available`);
    }
    while (this.queue.length > 0 && this.available.length > 0) {
      const task = this.queue.shift();
      if (!task) break;
      const worker = this.available.pop();
      if (!worker) break;
      const id2 = this.idCounter++;
      this.pending.set(id2, task);
      worker.postMessage({ id: id2, op: task.op, data: task.data }, task.transferables);
    }
  }
};
var jsonWorkerScript = `
    (async () => {
        let parentPort = null;
        let isBrowser = typeof self !== 'undefined' && typeof self.onmessage !== 'undefined';

        if (!isBrowser) {
            const wt = await import('node:worker_threads');
            parentPort = wt.parentPort;
        }

        const send = (msg) => {
            if (isBrowser) {
                postMessage(msg);
            } else if (parentPort) {
                parentPort.postMessage(msg);
            } else {
                console.error('[JsonWorker] No way to send message:', msg);
            }
        };

        const handler = async (e) => {
            // Node: e is the message directly
            // Browser: e is MessageEvent, e.data is the message
            const msg = isBrowser ? e.data : e;

            // Handle raw ArrayBuffer (shouldn't happen but defensive)
            if (msg instanceof ArrayBuffer) {
                console.error('[JsonWorker] Received raw ArrayBuffer instead of message object. Length:', msg.byteLength);
                return;
            }

            const { id, op, data } = msg ?? {};

            if (typeof id !== 'number') {
                console.error('[JsonWorker] Invalid message, missing id. Got:', msg);
                return;
            }

            try {
                let result;
                if (op === 'parse') {
                    if (data === undefined || data === null) {
                        throw new Error('No data provided for parse operation');
                    }
                    const text = data instanceof ArrayBuffer
                        ? new TextDecoder().decode(data)
                        : data;
                    result = JSON.parse(text);
                } else if (op === 'stringify') {
                    result = JSON.stringify(data);
                } else if (op === 'fetch') {
                    const { url, payload, timeout, headers } = data;
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout || 20000);

                    try {
                        const resp = await fetch(url, {
                            method: 'POST',
                            headers: headers || {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json',
                            },
                            body: JSON.stringify(payload),
                            signal: controller.signal,
                        });

                        clearTimeout(timeoutId);

                        if (!resp.ok) {
                            throw new Error('HTTP ' + resp.status + ': ' + resp.statusText);
                        }

                        const text = await resp.text();
                        result = JSON.parse(text);
                    } catch (err) {
                        clearTimeout(timeoutId);
                        if (err.name === 'AbortError') {
                            throw new Error('Request timed out after ' + (timeout || 20000) + 'ms');
                        }
                        throw err;
                    }
                } else {
                    throw new Error('Unknown operation: ' + op);
                }
                send({ id, result });
            } catch (err) {
                const error = err instanceof Error ? err.message : String(err);
                console.error('[JsonWorker] Error processing task ' + id + ':', error);
                send({ id, error });
            }
        };

        if (isBrowser) {
            self.onmessage = handler;
            self.onerror = (err) => {
                console.error('[JsonWorker] Uncaught error:', err);
            };
        } else if (parentPort) {
            parentPort.on('message', handler);
            parentPort.on('error', (err) => {
                console.error('[JsonWorker] Uncaught error:', err);
            });
        } else {
            console.error('[JsonWorker] No parentPort and not browser - worker cannot receive messages');
        }
    })();
`;
var _isServiceWorker = null;
function checkIsServiceWorker() {
  if (_isServiceWorker !== null) return _isServiceWorker;
  if (typeof __IS_SERVICE_WORKER__ !== "undefined" && __IS_SERVICE_WORKER__) {
    _isServiceWorker = true;
    return true;
  }
  if (typeof ServiceWorkerGlobalScope !== "undefined" && self instanceof ServiceWorkerGlobalScope) {
    _isServiceWorker = true;
    return true;
  }
  _isServiceWorker = false;
  return false;
}
var isServiceWorker = checkIsServiceWorker();
var JsonThreader = class extends BaseThreader {
  constructor(options = {}) {
    super(options);
    __publicField(this, "workerScript", jsonWorkerScript);
    __publicField(this, "threadingThreshold");
    this.threadingThreshold = options.threadingThreshold ?? 16384;
  }
  async parse(json) {
    if (isServiceWorker || json.length < this.threadingThreshold) {
      return JSON.parse(json);
    }
    const result = await this.run("parse", json);
    return result;
  }
  async parseBuffer(buffer2) {
    if (isServiceWorker || buffer2.byteLength <= this.threadingThreshold) {
      const text = new TextDecoder().decode(buffer2);
      return JSON.parse(text);
    }
    const result = await this.runWithTransfer("parse", buffer2, [buffer2]);
    return result;
  }
  async stringify(data) {
    const result = JSON.stringify(data);
    if (isServiceWorker || result.length < this.threadingThreshold) {
      return result;
    }
    return await this.run("stringify", data);
  }
  async fetch(request) {
    if (isServiceWorker) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), request.timeout || 2e4);
      try {
        const resp = await fetch(request.url, {
          method: "POST",
          headers: request.headers || {
            "Content-Type": "application/json",
            Accept: "application/json"
          },
          body: JSON.stringify(request.payload),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
        }
        return await resp.json();
      } catch (err2) {
        clearTimeout(timeoutId);
        if (err2.name === "AbortError") {
          throw new Error(`Request timed out after ${request.timeout || 2e4}ms`, {
            cause: err2
          });
        }
        throw err2;
      }
    }
    const result = await this.run("fetch", request);
    return result;
  }
};
var GLOBAL_KEY = Symbol.for("opnet.jsonThreader");
var globalObj = typeof globalThis !== "undefined" ? globalThis : globalThis;
if (!(GLOBAL_KEY in globalObj)) {
  globalObj[GLOBAL_KEY] = new JsonThreader();
}
var jsonThreader = globalObj[GLOBAL_KEY];
var JSONRpcProvider = class extends AbstractRpcProvider {
  constructor(config2) {
    super(config2.network);
    __publicField(this, "url");
    __publicField(this, "timeout");
    __publicField(this, "fetcherConfigurations");
    //private useRESTAPI: boolean;
    __publicField(this, "useThreadedParsing");
    __publicField(this, "useThreadedHttp");
    __publicField(this, "_fetcherWithCleanup");
    this.timeout = config2.timeout ?? 2e4;
    this.fetcherConfigurations = config2.fetcherConfigurations ?? {
      keepAliveTimeout: 3e4,
      keepAliveTimeoutThreshold: 3e4,
      connections: 128,
      pipelining: 2
    };
    this.useThreadedParsing = config2.useThreadedParsing ?? false;
    this.useThreadedHttp = config2.useThreadedHttp ?? false;
    this.url = this.providerUrl(config2.url);
  }
  get fetcher() {
    if (!this._fetcherWithCleanup) {
      this._fetcherWithCleanup = getFetcher(this.fetcherConfigurations);
    }
    return this._fetcherWithCleanup.fetch;
  }
  async close() {
    if (this._fetcherWithCleanup) {
      await this._fetcherWithCleanup.close();
      this._fetcherWithCleanup = void 0;
    }
  }
  /**
   * @description Sets the fetch mode to use REST API or not.
   * @param {boolean} useRESTAPI - Whether to use REST API or not
   * @returns {void}
   */
  /*public setFetchMode(useRESTAPI: boolean) {
      this.useRESTAPI = useRESTAPI;
  }*/
  /**
   * @description Sends a JSON RPC payload to the provider.
   * @param {JsonRpcPayload | JsonRpcPayload[]} payload - The payload to send
   * @returns {Promise<JsonRpcCallResult>} - The result of the call
   */
  async _send(payload) {
    if (this.useThreadedHttp) {
      const fetchedData = await jsonThreader.fetch({
        url: this.url,
        payload,
        timeout: this.timeout,
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "OPNET/1.0",
          Accept: "application/json",
          "Accept-Charset": "utf-8",
          "Accept-Language": "en-US"
        }
      });
      if (!fetchedData) {
        throw new Error("No data fetched");
      }
      return [fetchedData];
    }
    const controller = new AbortController();
    const { signal } = controller;
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    const params = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "OPNET/1.0",
        Accept: "application/json",
        "Accept-Charset": "utf-8",
        "Accept-Language": "en-US",
        Connection: "Keep-Alive"
      },
      body: JSON.stringify(payload),
      timeout: this.timeout,
      signal
    };
    try {
      const resp = await this.fetcher(this.url, params);
      if (!resp.ok) {
        throw new Error(`Failed to fetch: ${resp.statusText}`);
      }
      const fetchedData = await this.parseResponse(resp);
      if (!fetchedData) {
        throw new Error("No data fetched");
      }
      return [fetchedData];
    } catch (e) {
      const error = e;
      if (error.name === "AbortError") {
        throw new Error(`Request timed out after ${this.timeout}ms`, { cause: e });
      }
      throw e;
    } finally {
      clearTimeout(timeoutId);
    }
  }
  providerUrl(url) {
    url = url.trim();
    if (url.endsWith("/")) {
      return url.slice(0, -1);
    }
    if (url.includes("api/v1/json-rpc")) {
      return url;
    } else {
      return `${url}/api/v1/json-rpc`;
    }
  }
  async parseResponse(resp) {
    if (this.useThreadedParsing) {
      const buffer2 = await resp.arrayBuffer();
      return jsonThreader.parseBuffer(buffer2);
    }
    return await resp.json();
  }
};
var WebSocketRequestOpcode = ((WebSocketRequestOpcode2) => {
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["PING"] = 0] = "PING";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["HANDSHAKE"] = 1] = "HANDSHAKE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_NUMBER"] = 16] = "GET_BLOCK_NUMBER";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_BY_NUMBER"] = 17] = "GET_BLOCK_BY_NUMBER";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_BY_HASH"] = 18] = "GET_BLOCK_BY_HASH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_BY_CHECKSUM"] = 19] = "GET_BLOCK_BY_CHECKSUM";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_WITNESS"] = 20] = "GET_BLOCK_WITNESS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_GAS"] = 21] = "GET_GAS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_TRANSACTION_BY_HASH"] = 32] = "GET_TRANSACTION_BY_HASH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_TRANSACTION_RECEIPT"] = 33] = "GET_TRANSACTION_RECEIPT";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["BROADCAST_TRANSACTION"] = 34] = "BROADCAST_TRANSACTION";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_PREIMAGE"] = 35] = "GET_PREIMAGE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_MEMPOOL_INFO"] = 36] = "GET_MEMPOOL_INFO";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_PENDING_TRANSACTION"] = 37] = "GET_PENDING_TRANSACTION";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_LATEST_PENDING_TRANSACTIONS"] = 38] = "GET_LATEST_PENDING_TRANSACTIONS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BALANCE"] = 48] = "GET_BALANCE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_UTXOS"] = 49] = "GET_UTXOS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_PUBLIC_KEY_INFO"] = 50] = "GET_PUBLIC_KEY_INFO";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_CHAIN_ID"] = 64] = "GET_CHAIN_ID";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_REORG"] = 65] = "GET_REORG";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_CODE"] = 80] = "GET_CODE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_STORAGE_AT"] = 81] = "GET_STORAGE_AT";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["CALL"] = 82] = "CALL";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_LATEST_EPOCH"] = 96] = "GET_LATEST_EPOCH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_EPOCH_BY_NUMBER"] = 97] = "GET_EPOCH_BY_NUMBER";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_EPOCH_BY_HASH"] = 98] = "GET_EPOCH_BY_HASH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_EPOCH_TEMPLATE"] = 99] = "GET_EPOCH_TEMPLATE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["SUBMIT_EPOCH"] = 100] = "SUBMIT_EPOCH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["SUBSCRIBE_BLOCKS"] = 112] = "SUBSCRIBE_BLOCKS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["SUBSCRIBE_EPOCHS"] = 113] = "SUBSCRIBE_EPOCHS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["SUBSCRIBE_MEMPOOL"] = 114] = "SUBSCRIBE_MEMPOOL";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["UNSUBSCRIBE"] = 127] = "UNSUBSCRIBE";
  return WebSocketRequestOpcode2;
})(WebSocketRequestOpcode || {});
var WebSocketResponseOpcode = ((WebSocketResponseOpcode2) => {
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["ERROR"] = 128] = "ERROR";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["PONG"] = 129] = "PONG";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["HANDSHAKE_ACK"] = 130] = "HANDSHAKE_ACK";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BLOCK_NUMBER"] = 144] = "BLOCK_NUMBER";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BLOCK"] = 145] = "BLOCK";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BLOCK_WITNESS"] = 146] = "BLOCK_WITNESS";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["GAS"] = 147] = "GAS";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["TRANSACTION"] = 160] = "TRANSACTION";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["TRANSACTION_RECEIPT"] = 161] = "TRANSACTION_RECEIPT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BROADCAST_RESULT"] = 162] = "BROADCAST_RESULT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["PREIMAGE"] = 163] = "PREIMAGE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["MEMPOOL_INFO"] = 164] = "MEMPOOL_INFO";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["PENDING_TRANSACTION"] = 165] = "PENDING_TRANSACTION";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["LATEST_PENDING_TRANSACTIONS"] = 166] = "LATEST_PENDING_TRANSACTIONS";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BALANCE"] = 176] = "BALANCE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["UTXOS"] = 177] = "UTXOS";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["PUBLIC_KEY_INFO"] = 178] = "PUBLIC_KEY_INFO";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["CHAIN_ID"] = 192] = "CHAIN_ID";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["REORG"] = 193] = "REORG";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["CODE"] = 208] = "CODE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["STORAGE"] = 209] = "STORAGE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["CALL_RESULT"] = 210] = "CALL_RESULT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["EPOCH"] = 224] = "EPOCH";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["EPOCH_TEMPLATE"] = 225] = "EPOCH_TEMPLATE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["EPOCH_SUBMIT_RESULT"] = 226] = "EPOCH_SUBMIT_RESULT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["SUBSCRIPTION_CREATED"] = 240] = "SUBSCRIPTION_CREATED";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["UNSUBSCRIBE_RESULT"] = 241] = "UNSUBSCRIBE_RESULT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["NEW_BLOCK_NOTIFICATION"] = 248] = "NEW_BLOCK_NOTIFICATION";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["NEW_EPOCH_NOTIFICATION"] = 249] = "NEW_EPOCH_NOTIFICATION";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["NEW_MEMPOOL_TX_NOTIFICATION"] = 250] = "NEW_MEMPOOL_TX_NOTIFICATION";
  return WebSocketResponseOpcode2;
})(WebSocketResponseOpcode || {});
var METHOD_MAPPINGS = {
  [JSONRpcMethods.BLOCK_BY_NUMBER]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_NUMBER,
    responseOpcode: WebSocketResponseOpcode.BLOCK_NUMBER,
    requestType: "GetBlockNumberRequest",
    responseType: "GetBlockNumberResponse"
  },
  [JSONRpcMethods.GET_BLOCK_BY_NUMBER]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_BY_NUMBER,
    responseOpcode: WebSocketResponseOpcode.BLOCK,
    requestType: "GetBlockByNumberRequest",
    responseType: "BlockResponse"
  },
  [JSONRpcMethods.GET_BLOCK_BY_HASH]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_BY_HASH,
    responseOpcode: WebSocketResponseOpcode.BLOCK,
    requestType: "GetBlockByHashRequest",
    responseType: "BlockResponse"
  },
  [JSONRpcMethods.GET_BLOCK_BY_CHECKSUM]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_BY_CHECKSUM,
    responseOpcode: WebSocketResponseOpcode.BLOCK,
    requestType: "GetBlockByChecksumRequest",
    responseType: "BlockResponse"
  },
  [JSONRpcMethods.BLOCK_WITNESS]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_WITNESS,
    responseOpcode: WebSocketResponseOpcode.BLOCK_WITNESS,
    requestType: "GetBlockWitnessRequest",
    responseType: "BlockWitnessResponse"
  },
  [JSONRpcMethods.GAS]: {
    requestOpcode: WebSocketRequestOpcode.GET_GAS,
    responseOpcode: WebSocketResponseOpcode.GAS,
    requestType: "GetGasRequest",
    responseType: "GasResponse"
  },
  [JSONRpcMethods.GET_TRANSACTION_BY_HASH]: {
    requestOpcode: WebSocketRequestOpcode.GET_TRANSACTION_BY_HASH,
    responseOpcode: WebSocketResponseOpcode.TRANSACTION,
    requestType: "GetTransactionByHashRequest",
    responseType: "TransactionResponse"
  },
  [JSONRpcMethods.GET_TRANSACTION_RECEIPT]: {
    requestOpcode: WebSocketRequestOpcode.GET_TRANSACTION_RECEIPT,
    responseOpcode: WebSocketResponseOpcode.TRANSACTION_RECEIPT,
    requestType: "GetTransactionReceiptRequest",
    responseType: "TransactionReceiptResponse"
  },
  [JSONRpcMethods.BROADCAST_TRANSACTION]: {
    requestOpcode: WebSocketRequestOpcode.BROADCAST_TRANSACTION,
    responseOpcode: WebSocketResponseOpcode.BROADCAST_RESULT,
    requestType: "BroadcastTransactionRequest",
    responseType: "BroadcastTransactionResponse"
  },
  [JSONRpcMethods.TRANSACTION_PREIMAGE]: {
    requestOpcode: WebSocketRequestOpcode.GET_PREIMAGE,
    responseOpcode: WebSocketResponseOpcode.PREIMAGE,
    requestType: "GetPreimageRequest",
    responseType: "PreimageResponse"
  },
  [JSONRpcMethods.GET_BALANCE]: {
    requestOpcode: WebSocketRequestOpcode.GET_BALANCE,
    responseOpcode: WebSocketResponseOpcode.BALANCE,
    requestType: "GetBalanceRequest",
    responseType: "BalanceResponse"
  },
  [JSONRpcMethods.GET_UTXOS]: {
    requestOpcode: WebSocketRequestOpcode.GET_UTXOS,
    responseOpcode: WebSocketResponseOpcode.UTXOS,
    requestType: "GetUTXOsRequest",
    responseType: "UTXOsResponse"
  },
  [JSONRpcMethods.PUBLIC_KEY_INFO]: {
    requestOpcode: WebSocketRequestOpcode.GET_PUBLIC_KEY_INFO,
    responseOpcode: WebSocketResponseOpcode.PUBLIC_KEY_INFO,
    requestType: "GetPublicKeyInfoRequest",
    responseType: "PublicKeyInfoResponse"
  },
  [JSONRpcMethods.CHAIN_ID]: {
    requestOpcode: WebSocketRequestOpcode.GET_CHAIN_ID,
    responseOpcode: WebSocketResponseOpcode.CHAIN_ID,
    requestType: "GetChainIdRequest",
    responseType: "ChainIdResponse"
  },
  [JSONRpcMethods.REORG]: {
    requestOpcode: WebSocketRequestOpcode.GET_REORG,
    responseOpcode: WebSocketResponseOpcode.REORG,
    requestType: "GetReorgRequest",
    responseType: "ReorgResponse"
  },
  [JSONRpcMethods.GET_CODE]: {
    requestOpcode: WebSocketRequestOpcode.GET_CODE,
    responseOpcode: WebSocketResponseOpcode.CODE,
    requestType: "GetCodeRequest",
    responseType: "CodeResponse"
  },
  [JSONRpcMethods.GET_STORAGE_AT]: {
    requestOpcode: WebSocketRequestOpcode.GET_STORAGE_AT,
    responseOpcode: WebSocketResponseOpcode.STORAGE,
    requestType: "GetStorageAtRequest",
    responseType: "StorageResponse"
  },
  [JSONRpcMethods.CALL]: {
    requestOpcode: WebSocketRequestOpcode.CALL,
    responseOpcode: WebSocketResponseOpcode.CALL_RESULT,
    requestType: "CallRequest",
    responseType: "CallResponse"
  },
  [JSONRpcMethods.LATEST_EPOCH]: {
    requestOpcode: WebSocketRequestOpcode.GET_LATEST_EPOCH,
    responseOpcode: WebSocketResponseOpcode.EPOCH,
    requestType: "GetLatestEpochRequest",
    responseType: "EpochResponse"
  },
  [JSONRpcMethods.GET_EPOCH_BY_NUMBER]: {
    requestOpcode: WebSocketRequestOpcode.GET_EPOCH_BY_NUMBER,
    responseOpcode: WebSocketResponseOpcode.EPOCH,
    requestType: "GetEpochByNumberRequest",
    responseType: "EpochResponse"
  },
  [JSONRpcMethods.GET_EPOCH_BY_HASH]: {
    requestOpcode: WebSocketRequestOpcode.GET_EPOCH_BY_HASH,
    responseOpcode: WebSocketResponseOpcode.EPOCH,
    requestType: "GetEpochByHashRequest",
    responseType: "EpochResponse"
  },
  [JSONRpcMethods.GET_EPOCH_TEMPLATE]: {
    requestOpcode: WebSocketRequestOpcode.GET_EPOCH_TEMPLATE,
    responseOpcode: WebSocketResponseOpcode.EPOCH_TEMPLATE,
    requestType: "GetEpochTemplateRequest",
    responseType: "EpochTemplateResponse"
  },
  [JSONRpcMethods.SUBMIT_EPOCH]: {
    requestOpcode: WebSocketRequestOpcode.SUBMIT_EPOCH,
    responseOpcode: WebSocketResponseOpcode.EPOCH_SUBMIT_RESULT,
    requestType: "SubmitEpochRequest",
    responseType: "SubmitEpochResponse"
  },
  [JSONRpcMethods.GET_MEMPOOL_INFO]: {
    requestOpcode: WebSocketRequestOpcode.GET_MEMPOOL_INFO,
    responseOpcode: WebSocketResponseOpcode.MEMPOOL_INFO,
    requestType: "GetMempoolInfoRequest",
    responseType: "GetMempoolInfoResponse"
  },
  [JSONRpcMethods.GET_PENDING_TRANSACTION]: {
    requestOpcode: WebSocketRequestOpcode.GET_PENDING_TRANSACTION,
    responseOpcode: WebSocketResponseOpcode.PENDING_TRANSACTION,
    requestType: "GetPendingTransactionRequest",
    responseType: "PendingTransactionResponse"
  },
  [JSONRpcMethods.GET_LATEST_PENDING_TRANSACTIONS]: {
    requestOpcode: WebSocketRequestOpcode.GET_LATEST_PENDING_TRANSACTIONS,
    responseOpcode: WebSocketResponseOpcode.LATEST_PENDING_TRANSACTIONS,
    requestType: "GetLatestPendingTransactionsRequest",
    responseType: "LatestPendingTransactionsResponse"
  }
};
var ProtocolError = ((ProtocolError2) => {
  ProtocolError2[ProtocolError2["MALFORMED_MESSAGE"] = 1] = "MALFORMED_MESSAGE";
  ProtocolError2[ProtocolError2["UNKNOWN_OPCODE"] = 2] = "UNKNOWN_OPCODE";
  ProtocolError2[ProtocolError2["HANDSHAKE_REQUIRED"] = 3] = "HANDSHAKE_REQUIRED";
  ProtocolError2[ProtocolError2["HANDSHAKE_ALREADY_COMPLETED"] = 4] = "HANDSHAKE_ALREADY_COMPLETED";
  ProtocolError2[ProtocolError2["UNSUPPORTED_PROTOCOL_VERSION"] = 5] = "UNSUPPORTED_PROTOCOL_VERSION";
  ProtocolError2[ProtocolError2["PAYLOAD_TOO_LARGE"] = 6] = "PAYLOAD_TOO_LARGE";
  ProtocolError2[ProtocolError2["INVALID_REQUEST_ID"] = 7] = "INVALID_REQUEST_ID";
  ProtocolError2[ProtocolError2["CONNECTION_CLOSING"] = 8] = "CONNECTION_CLOSING";
  ProtocolError2[ProtocolError2["RATE_LIMIT_EXCEEDED"] = 9] = "RATE_LIMIT_EXCEEDED";
  ProtocolError2[ProtocolError2["TOO_MANY_PENDING_REQUESTS"] = 10] = "TOO_MANY_PENDING_REQUESTS";
  ProtocolError2[ProtocolError2["REQUEST_TIMEOUT"] = 11] = "REQUEST_TIMEOUT";
  ProtocolError2[ProtocolError2["INVALID_MESSAGE_FORMAT"] = 12] = "INVALID_MESSAGE_FORMAT";
  return ProtocolError2;
})(ProtocolError || {});
var AuthError = ((AuthError2) => {
  AuthError2[AuthError2["AUTHENTICATION_REQUIRED"] = 1e3] = "AUTHENTICATION_REQUIRED";
  AuthError2[AuthError2["INVALID_CREDENTIALS"] = 1001] = "INVALID_CREDENTIALS";
  AuthError2[AuthError2["SESSION_EXPIRED"] = 1002] = "SESSION_EXPIRED";
  AuthError2[AuthError2["PERMISSION_DENIED"] = 1003] = "PERMISSION_DENIED";
  AuthError2[AuthError2["INVALID_CLIENT_INFO"] = 1004] = "INVALID_CLIENT_INFO";
  return AuthError2;
})(AuthError || {});
var ResourceError = ((ResourceError2) => {
  ResourceError2[ResourceError2["NOT_FOUND"] = 2e3] = "NOT_FOUND";
  ResourceError2[ResourceError2["BLOCK_NOT_FOUND"] = 2001] = "BLOCK_NOT_FOUND";
  ResourceError2[ResourceError2["TRANSACTION_NOT_FOUND"] = 2002] = "TRANSACTION_NOT_FOUND";
  ResourceError2[ResourceError2["ADDRESS_NOT_FOUND"] = 2003] = "ADDRESS_NOT_FOUND";
  ResourceError2[ResourceError2["CONTRACT_NOT_FOUND"] = 2004] = "CONTRACT_NOT_FOUND";
  ResourceError2[ResourceError2["EPOCH_NOT_FOUND"] = 2005] = "EPOCH_NOT_FOUND";
  ResourceError2[ResourceError2["SUBSCRIPTION_NOT_FOUND"] = 2006] = "SUBSCRIPTION_NOT_FOUND";
  ResourceError2[ResourceError2["ALREADY_EXISTS"] = 2100] = "ALREADY_EXISTS";
  ResourceError2[ResourceError2["SUBSCRIPTION_ALREADY_EXISTS"] = 2101] = "SUBSCRIPTION_ALREADY_EXISTS";
  ResourceError2[ResourceError2["MAX_SUBSCRIPTIONS_REACHED"] = 2102] = "MAX_SUBSCRIPTIONS_REACHED";
  return ResourceError2;
})(ResourceError || {});
var ValidationError = ((ValidationError2) => {
  ValidationError2[ValidationError2["INVALID_PARAMS"] = 3e3] = "INVALID_PARAMS";
  ValidationError2[ValidationError2["MISSING_REQUIRED_FIELD"] = 3001] = "MISSING_REQUIRED_FIELD";
  ValidationError2[ValidationError2["VALUE_OUT_OF_RANGE"] = 3002] = "VALUE_OUT_OF_RANGE";
  ValidationError2[ValidationError2["INVALID_ADDRESS"] = 3003] = "INVALID_ADDRESS";
  ValidationError2[ValidationError2["INVALID_HASH"] = 3004] = "INVALID_HASH";
  ValidationError2[ValidationError2["INVALID_BLOCK_IDENTIFIER"] = 3005] = "INVALID_BLOCK_IDENTIFIER";
  ValidationError2[ValidationError2["INVALID_TRANSACTION_DATA"] = 3006] = "INVALID_TRANSACTION_DATA";
  ValidationError2[ValidationError2["INVALID_SIGNATURE"] = 3007] = "INVALID_SIGNATURE";
  ValidationError2[ValidationError2["INVALID_CALLDATA"] = 3008] = "INVALID_CALLDATA";
  ValidationError2[ValidationError2["INVALID_BLOCK_HEIGHT"] = 3009] = "INVALID_BLOCK_HEIGHT";
  ValidationError2[ValidationError2["INVALID_EPOCH_NUMBER"] = 3010] = "INVALID_EPOCH_NUMBER";
  ValidationError2[ValidationError2["INVALID_POINTER"] = 3011] = "INVALID_POINTER";
  ValidationError2[ValidationError2["INVALID_PUBLIC_KEY"] = 3012] = "INVALID_PUBLIC_KEY";
  return ValidationError2;
})(ValidationError || {});
var InternalError = ((InternalError2) => {
  InternalError2[InternalError2["INTERNAL_ERROR"] = 4e3] = "INTERNAL_ERROR";
  InternalError2[InternalError2["DATABASE_ERROR"] = 4001] = "DATABASE_ERROR";
  InternalError2[InternalError2["STORAGE_ERROR"] = 4002] = "STORAGE_ERROR";
  InternalError2[InternalError2["SERIALIZATION_ERROR"] = 4003] = "SERIALIZATION_ERROR";
  InternalError2[InternalError2["DESERIALIZATION_ERROR"] = 4004] = "DESERIALIZATION_ERROR";
  InternalError2[InternalError2["VM_ERROR"] = 4005] = "VM_ERROR";
  InternalError2[InternalError2["NETWORK_ERROR"] = 4006] = "NETWORK_ERROR";
  InternalError2[InternalError2["SERVICE_UNAVAILABLE"] = 4007] = "SERVICE_UNAVAILABLE";
  InternalError2[InternalError2["NOT_IMPLEMENTED"] = 4008] = "NOT_IMPLEMENTED";
  InternalError2[InternalError2["TIMEOUT"] = 4009] = "TIMEOUT";
  return InternalError2;
})(InternalError || {});
var ErrorMessages = {
  // Protocol errors
  [
    1
    /* MALFORMED_MESSAGE */
  ]: "Malformed message",
  [
    2
    /* UNKNOWN_OPCODE */
  ]: "Unknown opcode",
  [
    3
    /* HANDSHAKE_REQUIRED */
  ]: "Handshake required before making requests",
  [
    4
    /* HANDSHAKE_ALREADY_COMPLETED */
  ]: "Handshake has already been completed",
  [
    5
    /* UNSUPPORTED_PROTOCOL_VERSION */
  ]: "Unsupported protocol version",
  [
    6
    /* PAYLOAD_TOO_LARGE */
  ]: "Message payload too large",
  [
    7
    /* INVALID_REQUEST_ID */
  ]: "Invalid or missing request ID",
  [
    8
    /* CONNECTION_CLOSING */
  ]: "Connection is closing",
  [
    9
    /* RATE_LIMIT_EXCEEDED */
  ]: "Rate limit exceeded",
  [
    10
    /* TOO_MANY_PENDING_REQUESTS */
  ]: "Too many pending requests",
  [
    11
    /* REQUEST_TIMEOUT */
  ]: "Request timed out",
  [
    12
    /* INVALID_MESSAGE_FORMAT */
  ]: "Invalid message format",
  // Auth errors
  [
    1e3
    /* AUTHENTICATION_REQUIRED */
  ]: "Authentication required",
  [
    1001
    /* INVALID_CREDENTIALS */
  ]: "Invalid credentials",
  [
    1002
    /* SESSION_EXPIRED */
  ]: "Session has expired",
  [
    1003
    /* PERMISSION_DENIED */
  ]: "Permission denied",
  [
    1004
    /* INVALID_CLIENT_INFO */
  ]: "Invalid client information",
  // Resource errors
  [
    2e3
    /* NOT_FOUND */
  ]: "Resource not found",
  [
    2001
    /* BLOCK_NOT_FOUND */
  ]: "Block not found",
  [
    2002
    /* TRANSACTION_NOT_FOUND */
  ]: "Transaction not found",
  [
    2003
    /* ADDRESS_NOT_FOUND */
  ]: "Address not found",
  [
    2004
    /* CONTRACT_NOT_FOUND */
  ]: "Contract not found",
  [
    2005
    /* EPOCH_NOT_FOUND */
  ]: "Epoch not found",
  [
    2006
    /* SUBSCRIPTION_NOT_FOUND */
  ]: "Subscription not found",
  [
    2100
    /* ALREADY_EXISTS */
  ]: "Resource already exists",
  [
    2101
    /* SUBSCRIPTION_ALREADY_EXISTS */
  ]: "Subscription already exists",
  [
    2102
    /* MAX_SUBSCRIPTIONS_REACHED */
  ]: "Maximum subscriptions reached",
  // Validation errors
  [
    3e3
    /* INVALID_PARAMS */
  ]: "Invalid parameters",
  [
    3001
    /* MISSING_REQUIRED_FIELD */
  ]: "Missing required field",
  [
    3002
    /* VALUE_OUT_OF_RANGE */
  ]: "Value out of valid range",
  [
    3003
    /* INVALID_ADDRESS */
  ]: "Invalid address format",
  [
    3004
    /* INVALID_HASH */
  ]: "Invalid hash format",
  [
    3005
    /* INVALID_BLOCK_IDENTIFIER */
  ]: "Invalid block identifier",
  [
    3006
    /* INVALID_TRANSACTION_DATA */
  ]: "Invalid transaction data",
  [
    3007
    /* INVALID_SIGNATURE */
  ]: "Invalid signature",
  [
    3008
    /* INVALID_CALLDATA */
  ]: "Invalid calldata",
  [
    3009
    /* INVALID_BLOCK_HEIGHT */
  ]: "Invalid block height",
  [
    3010
    /* INVALID_EPOCH_NUMBER */
  ]: "Invalid epoch number",
  [
    3011
    /* INVALID_POINTER */
  ]: "Invalid pointer format",
  [
    3012
    /* INVALID_PUBLIC_KEY */
  ]: "Invalid public key",
  // Internal errors
  [
    4e3
    /* INTERNAL_ERROR */
  ]: "Internal server error",
  [
    4001
    /* DATABASE_ERROR */
  ]: "Database error",
  [
    4002
    /* STORAGE_ERROR */
  ]: "Storage error",
  [
    4003
    /* SERIALIZATION_ERROR */
  ]: "Serialization error",
  [
    4004
    /* DESERIALIZATION_ERROR */
  ]: "Deserialization error",
  [
    4005
    /* VM_ERROR */
  ]: "VM execution error",
  [
    4006
    /* NETWORK_ERROR */
  ]: "Network error",
  [
    4007
    /* SERVICE_UNAVAILABLE */
  ]: "Service temporarily unavailable",
  [
    4008
    /* NOT_IMPLEMENTED */
  ]: "Method not implemented",
  [
    4009
    /* TIMEOUT */
  ]: "Operation timed out"
};
function getErrorMessage(code2) {
  return ErrorMessages[code2] ?? "Unknown error";
}
var OPNetError = class extends Error {
  constructor(code2, message, data) {
    super(message ?? getErrorMessage(code2));
    __publicField(this, "code");
    __publicField(this, "data");
    this.name = "OPNetError";
    this.code = code2;
    this.data = data;
  }
};
protobuf.Reader;
protobuf.Writer;
protobuf.util;
protobuf.roots;
protobuf.configure;
protobuf.rpc;
var cachedRoot = null;
async function loadProtobufSchema(baseUrl) {
  if (cachedRoot) {
    return cachedRoot;
  }
  let url = baseUrl.trim();
  if (url.endsWith("/")) {
    url = url.slice(0, -1);
  }
  const schemaUrl = `${url}/api/v1/protobuf/api-schema`;
  const response = await fetch(schemaUrl);
  if (!response.ok) {
    throw new Error(
      `Failed to fetch protobuf schema: ${response.status} ${response.statusText}`
    );
  }
  const protoContent = await response.text();
  cachedRoot = protobuf.parse(protoContent, { keepCase: true }).root;
  return cachedRoot;
}
function getProtobufType(root, typeName) {
  const fullPath = `OPNetAPIProtocol.${typeName}`;
  return root.lookupType(fullPath);
}
function clearProtobufCache() {
  cachedRoot = null;
}
var ConnectionState = ((ConnectionState2) => {
  ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
  ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
  ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
  ConnectionState2[ConnectionState2["HANDSHAKING"] = 3] = "HANDSHAKING";
  ConnectionState2[ConnectionState2["READY"] = 4] = "READY";
  ConnectionState2[ConnectionState2["RECONNECTING"] = 5] = "RECONNECTING";
  ConnectionState2[ConnectionState2["CLOSING"] = 6] = "CLOSING";
  return ConnectionState2;
})(ConnectionState || {});
function getConnectionStateName(state) {
  switch (state) {
    case 0:
      return "DISCONNECTED";
    case 1:
      return "CONNECTING";
    case 2:
      return "CONNECTED";
    case 3:
      return "HANDSHAKING";
    case 4:
      return "READY";
    case 5:
      return "RECONNECTING";
    case 6:
      return "CLOSING";
    default:
      return "UNKNOWN";
  }
}
var SubscriptionType = ((SubscriptionType2) => {
  SubscriptionType2[SubscriptionType2["BLOCKS"] = 0] = "BLOCKS";
  SubscriptionType2[SubscriptionType2["EPOCHS"] = 1] = "EPOCHS";
  SubscriptionType2[SubscriptionType2["MEMPOOL"] = 2] = "MEMPOOL";
  return SubscriptionType2;
})(SubscriptionType || {});
function getSubscriptionTypeName(type2) {
  switch (type2) {
    case 0:
      return "BLOCKS";
    case 1:
      return "EPOCHS";
    case 2:
      return "MEMPOOL";
    default:
      return "UNKNOWN";
  }
}
var DEFAULT_CONFIG2 = {
  connectTimeout: 1e4,
  requestTimeout: 3e4,
  handshakeTimeout: 1e4,
  pingInterval: 3e4,
  autoReconnect: true,
  maxReconnectAttempts: 10,
  reconnectBaseDelay: 1e3,
  reconnectMaxDelay: 3e4,
  maxPendingRequests: 1e3
};
var WebSocketClientEvent = ((WebSocketClientEvent2) => {
  WebSocketClientEvent2["CONNECTED"] = "connected";
  WebSocketClientEvent2["DISCONNECTED"] = "disconnected";
  WebSocketClientEvent2["ERROR"] = "error";
  WebSocketClientEvent2["BLOCK"] = "block";
  WebSocketClientEvent2["EPOCH"] = "epoch";
  WebSocketClientEvent2["MEMPOOL"] = "mempool";
  return WebSocketClientEvent2;
})(WebSocketClientEvent || {});
var WebSocketRpcProvider = class extends AbstractRpcProvider {
  constructor(providerConfig) {
    super(providerConfig.network);
    __publicField(this, "config");
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "subscriptions", /* @__PURE__ */ new Map());
    __publicField(this, "eventHandlers", /* @__PURE__ */ new Map());
    __publicField(this, "socket", null);
    __publicField(this, "state", ConnectionState.DISCONNECTED);
    __publicField(this, "requestId", 0);
    __publicField(this, "reconnectAttempt", 0);
    __publicField(this, "pingTimeout", null);
    __publicField(this, "sessionId", null);
    __publicField(this, "userRequestedDisconnect", false);
    __publicField(this, "protoRoot", null);
    __publicField(this, "protoTypes", /* @__PURE__ */ new Map());
    if (!providerConfig.url) {
      throw new Error("WebSocketRpcProvider requires a URL in the configuration");
    }
    if (!providerConfig.url.startsWith("ws://") && !providerConfig.url.startsWith("wss://")) {
      throw new Error("WebSocketRpcProvider URL must start with ws:// or wss://");
    }
    this.config = {
      ...DEFAULT_CONFIG2,
      url: providerConfig.url,
      ...providerConfig.websocketConfig
    };
  }
  /**
   * Get the current connection state
   */
  getState() {
    return this.state;
  }
  /**
   * Check if the provider is ready to send requests
   */
  isReady() {
    return this.state === ConnectionState.READY;
  }
  /**
   * Connect to the WebSocket server
   */
  async connect() {
    if (this.state !== ConnectionState.DISCONNECTED) {
      throw new Error(
        `Cannot connect: current state is ${getConnectionStateName(this.state)}`
      );
    }
    this.state = ConnectionState.CONNECTING;
    this.userRequestedDisconnect = false;
    try {
      const httpUrl = this.config.url.replace(/^ws/, "http");
      this.protoRoot = await loadProtobufSchema(httpUrl);
      this.protoTypes.clear();
      await this.connectWebSocket();
      await this.performHandshake();
      this.schedulePing();
      this.reconnectAttempt = 0;
      this.emit(WebSocketClientEvent.CONNECTED, void 0);
    } catch (error) {
      this.state = ConnectionState.DISCONNECTED;
      throw error;
    }
  }
  /**
   * Disconnect from the WebSocket server
   */
  disconnect() {
    if (this.state === ConnectionState.DISCONNECTED) {
      return;
    }
    this.userRequestedDisconnect = true;
    this.state = ConnectionState.CLOSING;
    this.cancelPing();
    this.cleanupPendingRequests(new Error("Connection closed"));
    if (this.socket) {
      this.socket.close(1e3, "Client disconnect");
      this.socket = null;
    }
    this.state = ConnectionState.DISCONNECTED;
    this.emit(WebSocketClientEvent.DISCONNECTED, void 0);
  }
  /**
   * Register an event handler
   */
  on(event, handler) {
    let handlers = this.eventHandlers.get(event);
    if (!handlers) {
      handlers = /* @__PURE__ */ new Set();
      this.eventHandlers.set(event, handlers);
    }
    handlers.add(handler);
  }
  /**
   * Remove an event handler
   */
  off(event, handler) {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }
  /**
   * Subscribe to new blocks
   */
  async subscribeBlocks(handler) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("Not connected");
    }
    const type2 = this.getType("SubscribeBlocksRequest");
    const message = type2.create({});
    const encodedPayload = type2.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.SUBSCRIBE_BLOCKS,
      requestId,
      encodedPayload
    );
    await this.sendRequest(requestId, fullMessage);
    this.subscriptions.set(SubscriptionType.BLOCKS, handler);
  }
  /**
   * Subscribe to new epochs
   */
  async subscribeEpochs(handler) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("Not connected");
    }
    const type2 = this.getType("SubscribeEpochsRequest");
    const message = type2.create({});
    const encodedPayload = type2.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.SUBSCRIBE_EPOCHS,
      requestId,
      encodedPayload
    );
    await this.sendRequest(requestId, fullMessage);
    this.subscriptions.set(SubscriptionType.EPOCHS, handler);
  }
  /**
   * Subscribe to new mempool transactions
   */
  async subscribeMempool(handler) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("Not connected");
    }
    const type2 = this.getType("SubscribeMempoolRequest");
    const message = type2.create({});
    const encodedPayload = type2.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.SUBSCRIBE_MEMPOOL,
      requestId,
      encodedPayload
    );
    await this.sendRequest(requestId, fullMessage);
    this.subscriptions.set(SubscriptionType.MEMPOOL, handler);
  }
  /**
   * Unsubscribe from a subscription
   */
  async unsubscribe(subscriptionType) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("Not connected");
    }
    const type2 = this.getType("UnsubscribeRequest");
    const messageData = this.buildMessageByFieldId(type2, {
      2: subscriptionType
      // subscriptionId field (id=2)
    });
    const message = type2.create(messageData);
    const encodedPayload = type2.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.UNSUBSCRIBE,
      requestId,
      encodedPayload
    );
    await this.sendRequest(requestId, fullMessage);
    this.subscriptions.delete(subscriptionType);
  }
  /**
   * Clear the protobuf cache (useful when reconnecting to a different server)
   */
  clearCache() {
    clearProtobufCache();
    this.protoTypes.clear();
    this.protoRoot = null;
  }
  /**
   * Implements the abstract _send method from AbstractRpcProvider.
   * Translates JSON-RPC payloads to WebSocket binary protocol.
   *
   * Note: To match JSONRpcProvider behavior for callMultiplePayloads:
   * - Single payload returns [result]
   * - Array of payloads returns [[result1, result2, ...]] (wrapped in outer array)
   * This is because callMultiplePayloads expects the batch results to be wrapped.
   */
  async _send(payload) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("WebSocket not connected. Call connect() first.");
    }
    const isArray2 = Array.isArray(payload);
    const payloads = isArray2 ? payload : [payload];
    const results = [];
    for (const p of payloads) {
      const result = await this.sendJsonRpcRequest(p);
      results.push(result);
    }
    return isArray2 ? [results] : results;
  }
  providerUrl(url) {
    url = url.trim();
    if (url.endsWith("/")) {
      url = url.slice(0, -1);
    }
    if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
      url = url.replace(/^http/, "ws");
    }
    return url;
  }
  /**
   * Translate a JSON-RPC payload to a WebSocket request and send it
   */
  async sendJsonRpcRequest(payload) {
    const mapping = METHOD_MAPPINGS[payload.method];
    if (!mapping) {
      throw new Error(`Unsupported method: ${payload.method}`);
    }
    const requestType = this.getType(mapping.requestType);
    const params = Array.isArray(payload.params) ? payload.params : [];
    const fieldIdMap = this.translateJsonRpcParamsToFieldIds(payload.method, params);
    const protoPayload = this.buildMessageByFieldId(requestType, fieldIdMap);
    const message = requestType.create(protoPayload);
    const encodedPayload = requestType.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(mapping.requestOpcode, requestId, encodedPayload);
    const responseData = await this.sendRequest(requestId, fullMessage);
    const responseType = this.getType(mapping.responseType);
    const decoded = responseType.decode(responseData);
    const responseObj = responseType.toObject(decoded, {
      longs: String,
      bytes: String,
      defaults: true
    });
    const result = this.translateProtoResponse(payload.method, responseObj, responseType);
    return {
      jsonrpc: "2.0",
      id: payload.id ?? null,
      result
    };
  }
  /**
   * Translate JSON-RPC params to protobuf field IDs.
   * Uses proto field numbers (stable) instead of field names (may change).
   * Field numbers are defined in the .proto file and are part of the wire format.
   */
  translateJsonRpcParamsToFieldIds(method, params) {
    switch (method) {
      case JSONRpcMethods.BLOCK_BY_NUMBER:
        return {};
      case JSONRpcMethods.GET_BLOCK_BY_NUMBER:
        return {
          2: { 1: Long.fromString(String(params[0])) },
          // identifier.height
          3: params[1] ?? false
        };
      case JSONRpcMethods.GET_BLOCK_BY_HASH:
        return {
          2: { 2: params[0] },
          // identifier.hash
          3: params[1] ?? false
        };
      case JSONRpcMethods.GET_BLOCK_BY_CHECKSUM:
        return {
          2: { 3: params[0] },
          // identifier.checksum
          3: params[1] ?? false
        };
      case JSONRpcMethods.BLOCK_WITNESS:
        return {
          2: Long.fromString(String(params[0] ?? -1)),
          3: params[1],
          4: params[2],
          5: params[3]
        };
      case JSONRpcMethods.GAS:
        return {};
      case JSONRpcMethods.GET_TRANSACTION_BY_HASH:
        return { 2: params[0] };
      case JSONRpcMethods.GET_TRANSACTION_RECEIPT:
        return { 2: params[0] };
      case JSONRpcMethods.BROADCAST_TRANSACTION:
        return {
          2: params[0],
          3: params[1] ?? false
        };
      case JSONRpcMethods.TRANSACTION_PREIMAGE:
        return {};
      case JSONRpcMethods.GET_BALANCE:
        return {
          2: String(params[0]),
          3: params[1] ?? true
        };
      case JSONRpcMethods.GET_UTXOS:
        return {
          2: String(params[0]),
          3: params[1] ?? true
        };
      case JSONRpcMethods.PUBLIC_KEY_INFO:
        return { 2: params[0] };
      case JSONRpcMethods.CHAIN_ID:
        return {};
      case JSONRpcMethods.REORG:
        return {
          2: params[0]
        };
      case JSONRpcMethods.GET_CODE:
        return {
          2: String(params[0]),
          3: params[1] ?? false
        };
      case JSONRpcMethods.GET_STORAGE_AT:
        return {
          2: String(params[0]),
          3: params[1],
          4: params[2] ?? true
        };
      case JSONRpcMethods.CALL:
        return {
          2: String(params[0]),
          3: params[1],
          4: params[2],
          5: params[3]
        };
      case JSONRpcMethods.LATEST_EPOCH:
        return {};
      case JSONRpcMethods.GET_EPOCH_BY_NUMBER:
        return {
          2: Long.fromString(String(params[0]))
        };
      case JSONRpcMethods.GET_EPOCH_BY_HASH:
        return {
          2: params[0]
        };
      case JSONRpcMethods.GET_EPOCH_TEMPLATE:
        return {};
      case JSONRpcMethods.SUBMIT_EPOCH: {
        const submitParams = params[0];
        return {
          2: submitParams.epochNumber,
          3: submitParams.targetHash,
          4: submitParams.salt,
          5: submitParams.mldsaPublicKey,
          6: submitParams.graffiti,
          7: submitParams.signature
        };
      }
      case JSONRpcMethods.GET_MEMPOOL_INFO:
        return {};
      case JSONRpcMethods.GET_PENDING_TRANSACTION:
        return { 2: params[0] };
      case JSONRpcMethods.GET_LATEST_PENDING_TRANSACTIONS:
        return {
          ...params[0] != null ? { 2: params[0] } : {},
          ...params[1] != null ? { 3: params[1] } : {},
          ...params[2] != null ? { 4: params[2] } : {}
        };
      default:
        return {};
    }
  }
  /**
   * Convert OPNetType proto enum value to OPNetTransactionTypes string enum.
   * Proto enum: GENERIC=0, DEPLOYMENT=1, INTERACTION=2
   */
  convertOPNetTypeToString(value) {
    switch (value) {
      case 1:
        return OPNetTransactionTypes.Deployment;
      case 2:
        return OPNetTransactionTypes.Interaction;
      case 0:
      default:
        return OPNetTransactionTypes.Generic;
    }
  }
  /**
   * Convert transaction object:
   * 1. Converts OPNetType from integer to string enum
   * 2. Flattens nested type-specific data (interaction/deployment) to top level
   *
   * Proto uses oneof for type-specific data:
   * - field 20: interaction (InteractionTransactionData)
   * - field 21: deployment (DeploymentTransactionData)
   */
  convertTransaction(tx) {
    var _a5;
    const txType = (_a5 = this.protoRoot) == null ? void 0 : _a5.lookupType("TransactionForAPI");
    if (!txType) {
      return tx;
    }
    const opnetTypeField = this.getFieldById(txType, 19);
    if (opnetTypeField && tx[opnetTypeField.name] !== void 0) {
      tx[opnetTypeField.name] = this.convertOPNetTypeToString(
        tx[opnetTypeField.name]
      );
    }
    const interactionField = this.getFieldById(txType, 20);
    if (interactionField && tx[interactionField.name]) {
      const interactionData = tx[interactionField.name];
      Object.assign(tx, interactionData);
      delete tx[interactionField.name];
    }
    const deploymentField = this.getFieldById(txType, 21);
    if (deploymentField && tx[deploymentField.name]) {
      const deploymentData = tx[deploymentField.name];
      Object.assign(tx, deploymentData);
      delete tx[deploymentField.name];
    }
    return tx;
  }
  /**
   * Convert block response, converting OPNetType in all transactions.
   */
  convertBlockResponse(block) {
    var _a5;
    const blockType = (_a5 = this.protoRoot) == null ? void 0 : _a5.lookupType("BlockResponse");
    if (!blockType) {
      return block;
    }
    const txField = this.getFieldById(blockType, 22);
    if (txField && Array.isArray(block[txField.name])) {
      block[txField.name] = block[txField.name].map(
        (tx) => this.convertTransaction(tx)
      );
    }
    return block;
  }
  /**
   * Translate protobuf response to JSON-RPC result format.
   * Uses field IDs to extract values (not hardcoded field names).
   */
  translateProtoResponse(method, response, responseType) {
    var _a5;
    switch (method) {
      case JSONRpcMethods.BLOCK_BY_NUMBER: {
        const fieldName = this.getFieldNameById(responseType, 1);
        return fieldName ? response[fieldName] : void 0;
      }
      case JSONRpcMethods.CHAIN_ID: {
        const fieldName = this.getFieldNameById(responseType, 1);
        return fieldName ? response[fieldName] : void 0;
      }
      case JSONRpcMethods.GET_BALANCE: {
        const fieldName = this.getFieldNameById(responseType, 1);
        return fieldName ? response[fieldName] : void 0;
      }
      case JSONRpcMethods.GET_BLOCK_BY_NUMBER:
      case JSONRpcMethods.GET_BLOCK_BY_HASH:
      case JSONRpcMethods.GET_BLOCK_BY_CHECKSUM: {
        return this.convertBlockResponse(response);
      }
      case JSONRpcMethods.GET_TRANSACTION_BY_HASH: {
        const txResponseType = (_a5 = this.protoRoot) == null ? void 0 : _a5.lookupType("TransactionResponse");
        if (txResponseType) {
          const txField = this.getFieldById(txResponseType, 1);
          if (txField && response[txField.name]) {
            response[txField.name] = this.convertTransaction(
              response[txField.name]
            );
          }
        }
        return response;
      }
      default:
        return response;
    }
  }
  connectWebSocket() {
    return new Promise((resolve, reject) => {
      const url = this.buildWebSocketUrl();
      const timeout = setTimeout(() => {
        reject(new Error(`Connection timeout after ${this.config.connectTimeout}ms`));
      }, this.config.connectTimeout);
      try {
        this.socket = new WebSocket(url);
        this.socket.binaryType = "arraybuffer";
        this.socket.onopen = () => {
          clearTimeout(timeout);
          this.state = ConnectionState.CONNECTED;
          resolve();
        };
        this.socket.onerror = (event) => {
          clearTimeout(timeout);
          reject(new Error(`WebSocket error: ${event}`));
        };
        this.socket.onclose = (event) => {
          this.handleClose(event);
        };
        this.socket.onmessage = (event) => {
          this.handleMessage(event.data);
        };
      } catch (error) {
        clearTimeout(timeout);
        reject(error instanceof Error ? error : new Error(String(error)));
      }
    });
  }
  buildWebSocketUrl() {
    let url = this.config.url.trim();
    if (url.endsWith("/")) {
      url = url.slice(0, -1);
    }
    if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
      url = url.replace(/^http/, "ws");
    }
    if (!url.includes("/api/v1/ws")) {
      url = `${url}/api/v1/ws`;
    }
    return url;
  }
  async performHandshake() {
    this.state = ConnectionState.HANDSHAKING;
    const type2 = this.getType("HandshakeRequest");
    const messageData = this.buildMessageByFieldId(type2, {
      1: 1,
      // protocolVersion field (id=1)
      2: "opnet-js",
      // clientName field (id=2)
      3: "1.0.0"
      // clientVersion field (id=3)
    });
    const message = type2.create(messageData);
    const encodedPayload = type2.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.HANDSHAKE,
      requestId,
      encodedPayload
    );
    const responseData = await this.sendRequest(
      requestId,
      fullMessage,
      this.config.handshakeTimeout
    );
    const responseType = this.getType("HandshakeResponse");
    const decoded = responseType.decode(responseData);
    const response = responseType.toObject(decoded, {
      longs: String,
      bytes: Uint8Array,
      defaults: true
    });
    const sessionIdFieldName = this.getFieldNameById(responseType, 2);
    if (sessionIdFieldName && response[sessionIdFieldName]) {
      this.sessionId = response[sessionIdFieldName];
    }
    this.state = ConnectionState.READY;
  }
  /**
   * Build a message object using proto field IDs instead of hardcoded field names.
   * This ensures we use whatever field names the server's proto schema defines.
   * Handles nested messages recursively.
   */
  buildMessageByFieldId(type2, valuesByFieldId) {
    const result = {};
    for (const [fieldIdStr, value] of Object.entries(valuesByFieldId)) {
      const fieldId = parseInt(fieldIdStr, 10);
      const field = this.getFieldById(type2, fieldId);
      if (field) {
        if (value !== null && typeof value === "object" && !Array.isArray(value) && !(value instanceof Long)) {
          const keys = Object.keys(value);
          const isFieldIdMap = keys.length > 0 && keys.every((k) => /^\d+$/.test(k));
          if (isFieldIdMap) {
            const nestedType = this.getNestedType(field.type);
            if (nestedType) {
              result[field.name] = this.buildMessageByFieldId(
                nestedType,
                value
              );
            } else {
              result[field.name] = value;
            }
          } else {
            result[field.name] = value;
          }
        } else {
          result[field.name] = value;
        }
      }
    }
    return result;
  }
  /**
   * Get field from proto Type by field ID number
   */
  getFieldById(type2, fieldId) {
    for (const field of type2.fieldsArray) {
      if (field.id === fieldId) {
        return { name: field.name, type: field.type };
      }
    }
    return void 0;
  }
  /**
   * Get field name from proto Type by field ID number
   */
  getFieldNameById(type2, fieldId) {
    const field = this.getFieldById(type2, fieldId);
    return field == null ? void 0 : field.name;
  }
  /**
   * Get nested message Type by type name
   */
  getNestedType(typeName) {
    if (!this.protoRoot) return void 0;
    try {
      return getProtobufType(this.protoRoot, typeName);
    } catch {
      return void 0;
    }
  }
  getType(typeName) {
    let type2 = this.protoTypes.get(typeName);
    if (!type2) {
      if (!this.protoRoot) {
        throw new Error("Protobuf schema not loaded");
      }
      type2 = getProtobufType(this.protoRoot, typeName);
      this.protoTypes.set(typeName, type2);
    }
    return type2;
  }
  nextRequestId() {
    this.requestId = this.requestId + 1 & 4294967295;
    return this.requestId;
  }
  buildMessage(opcode, requestId, payload) {
    const message = new Uint8Array(1 + 4 + payload.length);
    message[0] = opcode;
    message[1] = requestId & 255;
    message[2] = requestId >> 8 & 255;
    message[3] = requestId >> 16 & 255;
    message[4] = requestId >> 24 & 255;
    message.set(payload, 5);
    return message;
  }
  sendRequest(requestId, message, timeout = this.config.requestTimeout) {
    return new Promise((resolve, reject) => {
      if (this.pendingRequests.size >= this.config.maxPendingRequests) {
        reject(new Error("Too many pending requests"));
        return;
      }
      const timeoutHandle = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error(`Request timeout after ${timeout}ms`));
      }, timeout);
      this.pendingRequests.set(requestId, {
        resolve,
        reject,
        timeout: timeoutHandle
      });
      this.send(message);
    });
  }
  send(data) {
    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("WebSocket not connected");
    }
    this.socket.send(data);
  }
  handleMessage(data) {
    const buffer2 = new Uint8Array(data);
    if (buffer2.length < 5) {
      console.error("Invalid message: too short");
      return;
    }
    const opcode = buffer2[0];
    if (opcode === WebSocketResponseOpcode.NEW_BLOCK_NOTIFICATION) {
      this.handleBlockNotification(buffer2.slice(1));
      return;
    }
    if (opcode === WebSocketResponseOpcode.NEW_EPOCH_NOTIFICATION) {
      this.handleEpochNotification(buffer2.slice(1));
      return;
    }
    if (opcode === WebSocketResponseOpcode.NEW_MEMPOOL_TX_NOTIFICATION) {
      this.handleMempoolNotification(buffer2.slice(1));
      return;
    }
    const requestId = buffer2[1] | buffer2[2] << 8 | buffer2[3] << 16 | buffer2[4] << 24;
    const payload = buffer2.slice(5);
    if (opcode === WebSocketResponseOpcode.ERROR) {
      this.handleErrorResponse(requestId, payload);
      return;
    }
    const pending = this.pendingRequests.get(requestId);
    if (pending) {
      clearTimeout(pending.timeout);
      this.pendingRequests.delete(requestId);
      pending.resolve(payload);
    }
  }
  handleErrorResponse(requestId, payload) {
    const pending = this.pendingRequests.get(requestId);
    if (!pending) return;
    clearTimeout(pending.timeout);
    this.pendingRequests.delete(requestId);
    try {
      const type2 = this.getType("ErrorResponse");
      const decoded = type2.decode(payload);
      const error = type2.toObject(decoded, {
        longs: Number,
        bytes: Uint8Array,
        defaults: true
      });
      pending.reject(
        new OPNetError(
          error.code ?? InternalError.INTERNAL_ERROR,
          error.message,
          error.data
        )
      );
    } catch (e) {
      pending.reject(new Error("Failed to parse error response"));
    }
  }
  handleBlockNotification(payload) {
    const handler = this.subscriptions.get(SubscriptionType.BLOCKS);
    if (!handler) return;
    try {
      const type2 = this.getType("NewBlockNotification");
      const decoded = type2.decode(payload);
      const block = type2.toObject(decoded, {
        longs: String,
        defaults: true
      });
      const notification = {
        blockNumber: BigInt(block.block_number || block.blockNumber || "0"),
        blockHash: block.block_hash || block.blockHash || "",
        timestamp: BigInt(block.timestamp || "0"),
        txCount: block.tx_count ?? block.txCount ?? 0
      };
      handler(notification);
      this.emit(WebSocketClientEvent.BLOCK, notification);
    } catch (e) {
      console.error("Failed to parse block notification:", e);
    }
  }
  handleEpochNotification(payload) {
    const handler = this.subscriptions.get(SubscriptionType.EPOCHS);
    if (!handler) return;
    try {
      const type2 = this.getType("NewEpochNotification");
      const decoded = type2.decode(payload);
      const epoch = type2.toObject(decoded, {
        longs: String,
        defaults: true
      });
      const notification = {
        epochNumber: BigInt(epoch.epoch_number || epoch.epochNumber || "0"),
        epochHash: epoch.epoch_hash || epoch.epochHash || ""
      };
      handler(notification);
      this.emit(WebSocketClientEvent.EPOCH, notification);
    } catch (e) {
      console.error("Failed to parse epoch notification:", e);
    }
  }
  handleMempoolNotification(payload) {
    const handler = this.subscriptions.get(SubscriptionType.MEMPOOL);
    if (!handler) return;
    try {
      const type2 = this.getType("NewMempoolTransactionNotification");
      const decoded = type2.decode(payload);
      const mempool = type2.toObject(decoded, {
        longs: String,
        defaults: true
      });
      const notification = {
        txId: mempool.tx_id || mempool.txId || "",
        transactionType: mempool.transaction_type || mempool.transactionType || "Generic",
        timestamp: BigInt(mempool.timestamp || "0")
      };
      handler(notification);
      this.emit(WebSocketClientEvent.MEMPOOL, notification);
    } catch (e) {
      console.error("Failed to parse mempool notification:", e);
    }
  }
  handleClose(event) {
    const wasReady = this.state === ConnectionState.READY;
    this.state = ConnectionState.DISCONNECTED;
    this.cancelPing();
    if (wasReady && this.config.autoReconnect && !this.userRequestedDisconnect) {
      void this.reconnect();
    } else {
      this.cleanupPendingRequests(
        new Error(`Connection closed: ${event.code} ${event.reason}`)
      );
      this.emit(WebSocketClientEvent.DISCONNECTED, {
        code: event.code,
        reason: event.reason
      });
    }
  }
  async reconnect() {
    if (this.reconnectAttempt >= this.config.maxReconnectAttempts) {
      this.emit(WebSocketClientEvent.ERROR, new Error("Max reconnection attempts exceeded"));
      return;
    }
    this.state = ConnectionState.RECONNECTING;
    this.reconnectAttempt++;
    this.clearCache();
    const delay = Math.min(
      this.config.reconnectBaseDelay * Math.pow(2, this.reconnectAttempt - 1),
      this.config.reconnectMaxDelay
    );
    const jitter = Math.random() * 0.3 * delay;
    await this.sleep(delay + jitter);
    try {
      this.state = ConnectionState.DISCONNECTED;
      await this.connect();
      await this.resubscribe();
    } catch (e) {
      console.warn(`Reconnect attempt ${this.reconnectAttempt} failed:`, e);
      void this.reconnect();
    }
  }
  async resubscribe() {
    const handlers = new Map(this.subscriptions);
    this.subscriptions.clear();
    for (const [type2, handler] of handlers) {
      try {
        if (type2 === SubscriptionType.BLOCKS) {
          await this.subscribeBlocks(handler);
        } else if (type2 === SubscriptionType.EPOCHS) {
          await this.subscribeEpochs(handler);
        } else if (type2 === SubscriptionType.MEMPOOL) {
          await this.subscribeMempool(
            handler
          );
        }
      } catch (e) {
        console.error(`Failed to resubscribe to ${type2}:`, e);
      }
    }
  }
  cleanupPendingRequests(error) {
    for (const [_id, pending] of this.pendingRequests) {
      clearTimeout(pending.timeout);
      pending.reject(error);
    }
    this.pendingRequests.clear();
  }
  schedulePing() {
    this.cancelPing();
    this.pingTimeout = setTimeout(() => {
      if (this.state === ConnectionState.READY) {
        try {
          this.ping();
        } catch (e) {
          console.warn("Ping failed:", e);
        }
        this.schedulePing();
      }
    }, this.config.pingInterval);
  }
  cancelPing() {
    if (this.pingTimeout) {
      clearTimeout(this.pingTimeout);
      this.pingTimeout = null;
    }
  }
  ping() {
    const type2 = this.getType("PingRequest");
    const message = type2.create({ timestamp: Long.fromNumber(Date.now()) });
    const encodedPayload = type2.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.PING,
      requestId,
      encodedPayload
    );
    this.send(fullMessage);
  }
  emit(event, data) {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      for (const handler of handlers) {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in event handler for ${event}:`, e);
        }
      }
    }
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};
var SubmissionStatus = ((SubmissionStatus2) => {
  SubmissionStatus2["ACCEPTED"] = "accepted";
  SubmissionStatus2["REJECTED"] = "rejected";
  return SubmissionStatus2;
})(SubmissionStatus || {});
var EpochDifficultyConverter = class {
  /**
   * Convert matching bits to actual difficulty value
   * Difficulty = 2^bits
   *
   * This ensures that:
   * - 20 bits = difficulty of 1,048,576
   * - 30 bits = difficulty of 1,073,741,824
   * - 40 bits = difficulty of 1,099,511,627,776
   *
   * So a 40-bit share is worth 1,048,576x more than a 20-bit share,
   * not just 2x more
   */
  static bitsToScaledDifficulty(bits) {
    return 2n ** BigInt(Math.max(0, bits));
  }
  /**
   * Format difficulty for display
   */
  static formatDifficulty(difficulty) {
    if (difficulty < 1000n) {
      return difficulty.toString();
    } else if (difficulty < BigInt(1e6)) {
      return (difficulty / BigInt(1e3)).toString() + "K";
    } else if (difficulty < BigInt(1e9)) {
      return (difficulty / BigInt(1e6)).toString() + "M";
    } else if (difficulty < BigInt(1e12)) {
      return (difficulty / BigInt(1e9)).toString() + "G";
    } else if (difficulty < BigInt(1e15)) {
      return (difficulty / BigInt(1e12)).toString() + "T";
    } else {
      return (difficulty / BigInt(1e15)).toString() + "P";
    }
  }
};
var BitcoinAbiTypes = ((BitcoinAbiTypes2) => {
  BitcoinAbiTypes2["Function"] = "function";
  BitcoinAbiTypes2["Event"] = "event";
  return BitcoinAbiTypes2;
})(BitcoinAbiTypes || {});
var BitcoinInterface = class _BitcoinInterface {
  constructor(abi) {
    __publicField(this, "abi");
    this.verifyAbi(abi);
    this.abi = abi;
  }
  static from(abi) {
    if (abi instanceof _BitcoinInterface) {
      return abi;
    }
    return new _BitcoinInterface(abi);
  }
  hasFunction(name) {
    return this.abi.some(
      (element) => element.name === name && element.type === BitcoinAbiTypes.Function
    );
  }
  hasEvent(name) {
    return this.abi.some(
      (element) => element.name === name && element.type === BitcoinAbiTypes.Event
    );
  }
  verifyAbi(abi) {
    var _a5, _b2, _c;
    if (abi.length === 0) {
      throw new Error("The ABI provided is empty.");
    }
    for (let i2 = 0; i2 < abi.length; i2++) {
      const element = abi[i2];
      if (!element.name) {
        throw new Error("The ABI provided is missing a name.");
      }
      if (!element.type) {
        throw new Error("The ABI provided is missing a type.");
      }
      if (element.type === BitcoinAbiTypes.Function) {
        if (element.inputs && ((_a5 = element.inputs) == null ? void 0 : _a5.length)) this.verifyAbiValues(element.inputs);
        if (element.outputs && ((_b2 = element.outputs) == null ? void 0 : _b2.length)) {
          this.verifyAbiValues(element.outputs);
        }
      } else if (element.type === BitcoinAbiTypes.Event) {
        if (element.values && ((_c = element.values) == null ? void 0 : _c.length)) this.verifyAbiValues(element.values);
      }
    }
  }
  verifyAbiValues(inputs2) {
    for (let j = 0; j < inputs2.length; j++) {
      const input = inputs2[j];
      if (!input.name) {
        throw new Error("The ABI provided is missing an input name.");
      }
      if (!input.type) {
        throw new Error("The ABI provided is missing an input type.");
      }
    }
  }
};
var OPNetEvent = class extends NetEvent {
  constructor(type2, data) {
    super(type2, data);
    __publicField(this, "properties", {});
    __publicField(this, "values", []);
    this.type = type2;
    this.data = data;
  }
  setDecoded(decoded) {
    this.properties = Object.freeze(decoded.obj);
    this.values.push(...decoded.values);
  }
};
var internal = Symbol.for("_btc_internal");
var bitcoinAbiCoder = new ABICoder();
var _a4;
_a4 = internal;
var IBaseContract = class {
  constructor(address, abi, provider, network, from) {
    /**
     * The address of the contract.
     */
    __publicField(this, "address");
    /**
     * The address of the contract.
     */
    __publicField(this, "network");
    /**
     * The interface of the contract.
     */
    __publicField(this, "interface");
    /**
     * A generic provider for the contract.
     */
    __publicField(this, "provider");
    /**
     * Who is sending the transaction.
     */
    __publicField(this, "from");
    /**
     * The internal functions of the contract.
     * @protected
     */
    __publicField(this, _a4);
    __publicField(this, "events", /* @__PURE__ */ new Map());
    __publicField(this, "gasParameters");
    __publicField(this, "fetchGasParametersAfter", 1e3 * 10);
    __publicField(this, "currentTxDetails");
    __publicField(this, "simulatedHeight");
    __publicField(this, "accessList");
    __publicField(this, "_rlAddress");
    if (typeof address === "string") {
      const type2 = AddressVerificator.detectAddressType(address, network);
      if (type2 !== AddressTypes.P2OP && type2 !== AddressTypes.P2PK) {
        throw new Error(
          `Oops! The address provided is not a valid P2OP or P2PK address ${address}.`
        );
      }
    }
    this.address = address;
    this.provider = provider;
    this.interface = BitcoinInterface.from(abi);
    this.network = network;
    this.from = from;
    Object.defineProperty(this, internal, { value: {} });
    this.defineInternalFunctions();
  }
  /**
   * The P2OP address of the contract.
   * @returns {string} The P2OP address of the contract.
   */
  get p2op() {
    if (typeof this.address !== "string") {
      return this.address.p2op(this.network);
    }
    return this.address;
  }
  /**
   * Gets the contract address as an Address object.
   * @return {Promise<Address>} The contract address as an Address object.
   */
  get contractAddress() {
    if (typeof this.address === "string") {
      if (!this._rlAddress) {
        this._rlAddress = this.provider.getPublicKeyInfo(this.address, true);
      }
      return this._rlAddress;
    }
    return Promise.resolve(this.address);
  }
  /**
   * Sets the sender of the transaction.
   * @param {Address} sender The sender of the transaction.
   */
  setSender(sender) {
    this.from = sender;
  }
  /**
   * Decodes the events from the contract.
   * @param {NetEvent[] | ContractEvents} events The events to decode.
   * @returns {OPNetEvent[]} The decoded events.
   */
  decodeEvents(events) {
    const decodedEvents = [];
    if (!Array.isArray(events)) {
      const tempEvents = events;
      events = tempEvents[this.p2op];
      if (!Array.isArray(events) && typeof this.address === "string" && this.address.startsWith("0x")) {
        const addy = Address.fromString(this.address);
        const p2op2 = addy.p2op(this.network);
        events = tempEvents[p2op2];
      }
      if (!Array.isArray(events)) {
        return [];
      }
    }
    for (const event of events) {
      decodedEvents.push(this.decodeEvent(event));
    }
    return decodedEvents;
  }
  /**
   * Decodes a single event.
   * @param {NetEvent} event The event to decode.
   * @returns {OPNetEvent} The decoded event.
   */
  decodeEvent(event) {
    const eventData = this.events.get(event.type);
    if (!eventData || eventData.values.length === 0) {
      return new OPNetEvent(event.type, event.data);
    }
    const binaryReader = new BinaryReader(event.data);
    const out = this.decodeOutput(eventData.values, binaryReader);
    const decodedEvent = new OPNetEvent(event.type, event.data);
    decodedEvent.setDecoded(out);
    return decodedEvent;
  }
  /**
   * Encodes the calldata for a function.
   * @param {string} functionName The name of the function.
   * @param {unknown[]} args The arguments for the function.
   * @returns {Uint8Array} The encoded calldata.
   */
  encodeCalldata(functionName, args) {
    for (const element of this.interface.abi) {
      if (element.name === functionName) {
        const data = this.encodeFunctionData(element, args);
        return data.getBuffer();
      }
    }
    throw new Error(`Function not found: ${functionName}`);
  }
  async currentGasParameters() {
    if (this.gasParameters && this.gasParameters.cachedAt + this.fetchGasParametersAfter > Date.now()) {
      return this.gasParameters.params;
    }
    this.gasParameters = {
      cachedAt: Date.now(),
      params: this.provider.gasParameters()
    };
    return await this.gasParameters.params;
  }
  setTransactionDetails(tx) {
    for (let i2 = 0; i2 < tx.outputs.length; i2++) {
      const input = tx.outputs[i2];
      if (input.index === 0) {
        throw new Error(`Outputs 0 is reserved for the contract internal use.`);
      }
    }
    this.currentTxDetails = tx;
  }
  setAccessList(accessList) {
    this.accessList = accessList;
  }
  setSimulatedHeight(height) {
    this.simulatedHeight = height;
  }
  getFunction(name) {
    const key = name;
    return this[key];
  }
  /**
   * Defines the internal functions of the contract. These functions are generated for the ABI provided.
   * @private
   */
  defineInternalFunctions() {
    for (const element of this.interface.abi) {
      switch (element.type) {
        case BitcoinAbiTypes.Function: {
          if (this.getFunction(element.name)) {
            continue;
          }
          Object.defineProperty(this, element.name, {
            value: this.callFunction(element).bind(this)
          });
          break;
        }
        case BitcoinAbiTypes.Event: {
          if (this.events.has(element.name)) {
            throw new Error(`Duplicate event found in the ABI: ${element.name}.`);
          }
          this.events.set(element.name, element);
          break;
        }
        default:
          throw new Error(`Unsupported type.`);
      }
    }
  }
  getSelector(element) {
    let name = element.name;
    name += "(";
    if (element.inputs && element.inputs.length) {
      for (let i2 = 0; i2 < element.inputs.length; i2++) {
        const input = element.inputs[i2];
        if (i2 > 0) name += ",";
        name += abiTypeToSelectorString(input.type);
      }
    }
    name += ")";
    return name;
  }
  encodeFunctionData(element, args) {
    var _a5;
    const writer = new BinaryWriter();
    const selectorStr = this.getSelector(element);
    let str = bitcoinAbiCoder.encodeSelector(selectorStr);
    if (str.includes(",")) {
      const array = str.split(",").map((s) => Number(s));
      str = array.map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    const selector = Number("0x" + str);
    writer.writeSelector(selector);
    if (args.length !== (((_a5 = element.inputs) == null ? void 0 : _a5.length) ?? 0)) {
      throw new Error("Invalid number of arguments provided");
    }
    if (!element.inputs || element.inputs && element.inputs.length === 0) {
      return writer;
    }
    for (let i2 = 0; i2 < element.inputs.length; i2++) {
      this.encodeInput(writer, element.inputs[i2], args[i2]);
    }
    return writer;
  }
  /** Encodes a single-element tuple as a flat typed array (u16 count + values). */
  encodeArray(writer, elementType, value, name) {
    if (!(value instanceof Array)) {
      throw new Error(`Expected array for ${name}`);
    }
    writer.writeU16(value.length);
    for (const item of value) {
      this.encodeInput(writer, { name: `${name}[]`, type: elementType }, item);
    }
  }
  /** Encodes a multi-element tuple as array of entries (u16 count + entries). */
  encodeTuple(writer, types2, value, name) {
    if (!(value instanceof Array)) {
      throw new Error(`Expected array of tuples for ${name}`);
    }
    const entries = value;
    writer.writeU16(entries.length);
    for (const entry of entries) {
      if (!(entry instanceof Array) || entry.length !== types2.length) {
        throw new Error(
          `Each tuple entry must be an array of ${types2.length} elements (${name})`
        );
      }
      for (let j = 0; j < types2.length; j++) {
        this.encodeInput(writer, { name: `${name}[${j}]`, type: types2[j] }, entry[j]);
      }
    }
  }
  /** Encodes a struct as a single inline object (no count prefix). */
  encodeStruct(writer, struct, value, name) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new Error(`Expected object for struct ${name}`);
    }
    const obj = value;
    for (const [fieldName, fieldType] of Object.entries(struct)) {
      this.encodeInput(
        writer,
        { name: `${name}.${fieldName}`, type: fieldType },
        obj[fieldName]
      );
    }
  }
  encodeInput(writer, abi, value) {
    const type2 = abi.type;
    const name = abi.name;
    if (isAbiTuple(type2)) {
      const firstType = type2[0];
      if (type2.length === 1 && firstType !== void 0) {
        this.encodeArray(writer, firstType, value, name);
        return;
      }
      this.encodeTuple(writer, type2, value, name);
      return;
    }
    if (isAbiStruct(type2)) {
      this.encodeStruct(writer, type2, value, name);
      return;
    }
    switch (type2) {
      case ABIDataTypes.INT128: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeI128(value);
        break;
      }
      case ABIDataTypes.UINT256: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeU256(value);
        break;
      }
      case ABIDataTypes.BOOL: {
        if (typeof value !== "boolean") {
          throw new Error(`Expected value to be of type boolean (${name})`);
        }
        writer.writeBoolean(value);
        break;
      }
      case ABIDataTypes.STRING: {
        if (typeof value !== "string") {
          throw new Error(`Expected value to be of type string (${name})`);
        }
        writer.writeStringWithLength(value);
        break;
      }
      case ABIDataTypes.ADDRESS: {
        if (!value) throw new Error(`Expected value to be of type Address (${name})`);
        if (!("equals" in value)) {
          throw new Error(
            `Expected value to be of type Address (${name}) was ${typeof value}`
          );
        }
        writer.writeAddress(value);
        break;
      }
      case ABIDataTypes.UINT8: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeU8(value);
        break;
      }
      case ABIDataTypes.UINT16: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeU16(value);
        break;
      }
      case ABIDataTypes.UINT32: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeU32(value);
        break;
      }
      case ABIDataTypes.BYTES32: {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`Expected value to be of type Uint8Array (${name})`);
        }
        writer.writeBytes(value);
        break;
      }
      case ABIDataTypes.BYTES4: {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`Expected value to be of type Uint8Array (${name})`);
        }
        writer.writeBytes(value);
        break;
      }
      case ABIDataTypes.ADDRESS_UINT256_TUPLE: {
        writer.writeAddressValueTuple(value);
        break;
      }
      case ABIDataTypes.BYTES: {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`Expected value to be of type Uint8Array (${name})`);
        }
        writer.writeBytesWithLength(value);
        break;
      }
      case ABIDataTypes.UINT64: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeU64(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_ADDRESSES: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeAddressArray(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT256: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU256Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT32: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU32Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_STRING: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeStringArray(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_BYTES: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeBytesArray(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT64: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU64Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT8: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU8Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT16: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU16Array(value);
        break;
      }
      case ABIDataTypes.UINT128: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeU128(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT128: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU128Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_BUFFERS: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeArrayOfBuffer(value);
        break;
      }
      case ABIDataTypes.EXTENDED_ADDRESS: {
        if (!value) throw new Error(`Expected value to be of type Address (${name})`);
        if (!("equals" in value)) {
          throw new Error(
            `Expected value to be of type Address (${name}) was ${typeof value}`
          );
        }
        writer.writeExtendedAddress(value);
        break;
      }
      case ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE: {
        writer.writeExtendedAddressMapU256(value);
        break;
      }
      case ABIDataTypes.SCHNORR_SIGNATURE: {
        const sig = value;
        if (!sig.address || !sig.signature) {
          throw new Error(
            `Expected value to be of type SchnorrSignature with address and signature (${name})`
          );
        }
        writer.writeSchnorrSignature(sig.address, sig.signature);
        break;
      }
      case ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeExtendedAddressArray(value);
        break;
      }
      case ABIDataTypes.INT8: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeI8(value);
        break;
      }
      case ABIDataTypes.INT16: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeI16(value);
        break;
      }
      case ABIDataTypes.INT32: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeI32(value);
        break;
      }
      case ABIDataTypes.INT64: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeI64(value);
        break;
      }
      default: {
        throw new Error(`Unsupported type: ${type2} (${name})`);
      }
    }
  }
  decodeOutput(abi, reader) {
    const result = [];
    const obj = {};
    for (let i2 = 0; i2 < abi.length; i2++) {
      const type2 = abi[i2].type;
      const name = abi[i2].name;
      let decodedResult;
      if (isAbiTuple(type2) || isAbiStruct(type2)) {
        decodedResult = bitcoinAbiCoder.decodeSingleValue(
          reader,
          type2
        );
        result.push(decodedResult);
        obj[name] = decodedResult;
        continue;
      }
      switch (type2) {
        case ABIDataTypes.INT128:
          decodedResult = reader.readI128();
          break;
        case ABIDataTypes.UINT256:
          decodedResult = reader.readU256();
          break;
        case ABIDataTypes.BOOL:
          decodedResult = reader.readBoolean();
          break;
        case ABIDataTypes.STRING:
          decodedResult = reader.readStringWithLength();
          break;
        case ABIDataTypes.ADDRESS:
          decodedResult = reader.readAddress();
          break;
        case ABIDataTypes.UINT8:
          decodedResult = reader.readU8();
          break;
        case ABIDataTypes.UINT16:
          decodedResult = reader.readU16();
          break;
        case ABIDataTypes.UINT32:
          decodedResult = reader.readU32();
          break;
        case ABIDataTypes.BYTES32:
          decodedResult = reader.readBytes(32);
          break;
        case ABIDataTypes.BYTES4:
          decodedResult = reader.readBytes(4);
          break;
        case ABIDataTypes.ADDRESS_UINT256_TUPLE:
          decodedResult = reader.readAddressValueTuple();
          break;
        case ABIDataTypes.BYTES: {
          decodedResult = reader.readBytesWithLength();
          break;
        }
        case ABIDataTypes.UINT64: {
          decodedResult = reader.readU64();
          break;
        }
        case ABIDataTypes.ARRAY_OF_ADDRESSES: {
          decodedResult = reader.readAddressArray();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT256: {
          decodedResult = reader.readU256Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT32: {
          decodedResult = reader.readU32Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_STRING: {
          decodedResult = reader.readStringArray();
          break;
        }
        case ABIDataTypes.ARRAY_OF_BYTES: {
          decodedResult = reader.readBytesArray();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT64: {
          decodedResult = reader.readU64Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT8: {
          decodedResult = reader.readU8Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT16: {
          decodedResult = reader.readU16Array();
          break;
        }
        case ABIDataTypes.UINT128: {
          decodedResult = reader.readU128();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT128: {
          decodedResult = reader.readU128Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_BUFFERS: {
          decodedResult = reader.readArrayOfBuffer();
          break;
        }
        case ABIDataTypes.EXTENDED_ADDRESS: {
          decodedResult = reader.readExtendedAddress();
          break;
        }
        case ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE: {
          decodedResult = reader.readExtendedAddressMapU256();
          break;
        }
        case ABIDataTypes.SCHNORR_SIGNATURE: {
          decodedResult = reader.readSchnorrSignature();
          break;
        }
        case ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES: {
          decodedResult = reader.readExtendedAddressArray();
          break;
        }
        case ABIDataTypes.INT8: {
          decodedResult = reader.readI8();
          break;
        }
        case ABIDataTypes.INT16: {
          decodedResult = reader.readI16();
          break;
        }
        case ABIDataTypes.INT32: {
          decodedResult = reader.readI32();
          break;
        }
        case ABIDataTypes.INT64: {
          decodedResult = reader.readI64();
          break;
        }
        default: {
          throw new Error(`Unsupported type: ${type2} (${name})`);
        }
      }
      result.push(decodedResult);
      obj[name] = decodedResult;
    }
    return {
      values: result,
      obj
    };
  }
  estimateGas(gas, gasParameters) {
    const gasPerSat = gasParameters.gasPerSat;
    const exactGas = gas * gasPerSat / 1000000000000n;
    const finalGas = exactGas * 100n / (100n - 15n);
    return this.max(finalGas, 297n);
  }
  max(a, b) {
    return a > b ? a : b;
  }
  callFunction(element) {
    return async (...args) => {
      const address = await this.contractAddress;
      const txDetails = this.currentTxDetails;
      const accessList = this.accessList;
      this.currentTxDetails = void 0;
      this.accessList = void 0;
      if (element.payable && !txDetails) {
        throw new Error(
          "Payable function requires setTransactionDetails() to be called before invoking the contract method."
        );
      }
      const data = this.encodeFunctionData(element, args);
      const buffer2 = data.getBuffer();
      const response = await this.provider.call(
        this.address,
        buffer2,
        this.from,
        this.simulatedHeight,
        txDetails,
        accessList
      );
      if ("error" in response) {
        throw new Error(`Error in calling function: ${response.error}`);
      }
      if (response.revert) {
        throw new Error(`Execution Reverted: ${response.revert}`);
      }
      const decoded = element.outputs ? this.decodeOutput(element.outputs, response.result) : { values: [], obj: {} };
      response.setTo(this.p2op, address);
      response.setFromAddress(this.from);
      response.setDecoded(decoded);
      response.setCalldata(buffer2);
      response.constant = element.constant ?? false;
      response.payable = element.payable ?? false;
      const gasParameters = await this.currentGasParameters();
      const gas = this.estimateGas(response.estimatedGas || 0n, gasParameters);
      const gasRefunded = this.estimateGas(response.refundedGas || 0n, gasParameters);
      response.setBitcoinFee(gasParameters.bitcoin);
      response.setGasEstimation(gas, gasRefunded);
      response.setEvents(this.decodeEvents(response.rawEvents));
      return response;
    };
  }
};
var BaseContract = class extends IBaseContract {
  constructor(address, abi, provider, network, sender) {
    super(address, abi, provider, network, sender);
    return this.proxify();
  }
  /**
   * Proxifies the contract to allow for type checking.
   * @private
   */
  proxify() {
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target) {
          return Reflect.get(target, prop, receiver);
        }
        try {
          return this.getFunction(prop);
        } catch (error) {
          if (!(error instanceof Error)) {
            throw new Error(
              `Something went wrong when trying to get the function: ${error}`,
              { cause: error }
            );
          } else {
            throw error;
          }
        }
      },
      has: (target, prop) => {
        if (typeof prop === "symbol" || prop in target) {
          return Reflect.has(target, prop);
        }
        return target.interface.hasFunction(prop);
      }
    });
  }
};
function contractBase() {
  return BaseContract;
}
function getContract(address, abi, provider, network, sender) {
  const base2 = contractBase();
  return new base2(address, abi, provider, network, sender);
}
var AbiTypeToStr2 = {
  // Basic address types
  [ABIDataTypes.ADDRESS]: "address",
  [ABIDataTypes.EXTENDED_ADDRESS]: "extendedAddress",
  // Boolean
  [ABIDataTypes.BOOL]: "bool",
  // Bytes types
  [ABIDataTypes.BYTES]: "bytes",
  [ABIDataTypes.BYTES32]: "bytes32",
  [ABIDataTypes.BYTES4]: "bytes4",
  // Unsigned integers
  [ABIDataTypes.UINT256]: "uint256",
  [ABIDataTypes.UINT128]: "uint128",
  [ABIDataTypes.UINT64]: "uint64",
  [ABIDataTypes.UINT32]: "uint32",
  [ABIDataTypes.UINT16]: "uint16",
  [ABIDataTypes.UINT8]: "uint8",
  // Signed integers
  [ABIDataTypes.INT128]: "int128",
  [ABIDataTypes.INT64]: "int64",
  [ABIDataTypes.INT32]: "int32",
  [ABIDataTypes.INT16]: "int16",
  [ABIDataTypes.INT8]: "int8",
  // String
  [ABIDataTypes.STRING]: "string",
  // Tuples/Maps
  [ABIDataTypes.ADDRESS_UINT256_TUPLE]: "tuple(address,uint256)[]",
  [ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE]: "tuple(extendedAddress,uint256)[]",
  // Signatures
  [ABIDataTypes.SCHNORR_SIGNATURE]: "schnorrSignature",
  // Arrays
  [ABIDataTypes.ARRAY_OF_ADDRESSES]: "address[]",
  [ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES]: "extendedAddress[]",
  [ABIDataTypes.ARRAY_OF_UINT256]: "uint256[]",
  [ABIDataTypes.ARRAY_OF_UINT128]: "uint128[]",
  [ABIDataTypes.ARRAY_OF_UINT64]: "uint64[]",
  [ABIDataTypes.ARRAY_OF_UINT32]: "uint32[]",
  [ABIDataTypes.ARRAY_OF_UINT16]: "uint16[]",
  [ABIDataTypes.ARRAY_OF_UINT8]: "uint8[]",
  [ABIDataTypes.ARRAY_OF_BYTES]: "bytes[]",
  [ABIDataTypes.ARRAY_OF_STRING]: "string[]",
  [ABIDataTypes.ARRAY_OF_BUFFERS]: "buffer[]"
};
BigNumber.config({
  EXPONENTIAL_AT: 1e9,
  DECIMAL_PLACES: 18
});
var BitcoinUtils2 = class {
  /**
   * Get Satoshis or any other unit, bitcoin by default.
   * @description This function is used to format a value in satoshis to Bitcoin.
   * @param value Value in satoshis or any other unit
   * @param decimals Default is 8
   */
  static formatUnits(value, decimals = 8) {
    const bn2 = new BigNumber(value.toString());
    return bn2.dividedBy(new BigNumber(10).pow(decimals)).toString();
  }
  /**
   * Convert number or string to BigInt
   * @param {number | string} n
   * @param {number | string} decimals
   * @returns {bigint}
   */
  static expandToDecimals(n2, decimals) {
    const amount = new BigNumber(n2).multipliedBy(new BigNumber(10).pow(decimals)).decimalPlaces(0);
    return BigInt(amount.toString());
  }
};
var JSONRPCErrorCode = ((JSONRPCErrorCode2) => {
  JSONRPCErrorCode2[JSONRPCErrorCode2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  JSONRPCErrorCode2[JSONRPCErrorCode2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  JSONRPCErrorCode2[JSONRPCErrorCode2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  JSONRPCErrorCode2[JSONRPCErrorCode2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["SERVER_ERROR"] = -32e3] = "SERVER_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["APPLICATION_ERROR"] = -32099] = "APPLICATION_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["SYSTEM_ERROR"] = -32098] = "SYSTEM_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["TRANSPORT_ERROR"] = -32097] = "TRANSPORT_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["GENERIC_ERROR"] = -32096] = "GENERIC_ERROR";
  return JSONRPCErrorCode2;
})(JSONRPCErrorCode || {});
var JSONRPCErrorHttpCodes = ((JSONRPCErrorHttpCodes2) => {
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["PARSE_ERROR"] = 500] = "PARSE_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["INVALID_REQUEST"] = 400] = "INVALID_REQUEST";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["METHOD_NOT_FOUND"] = 404] = "METHOD_NOT_FOUND";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["INVALID_PARAMS"] = 400] = "INVALID_PARAMS";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["INTERNAL_ERROR"] = 500] = "INTERNAL_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["SERVER_ERROR"] = 500] = "SERVER_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["APPLICATION_ERROR"] = 500] = "APPLICATION_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["SYSTEM_ERROR"] = 500] = "SYSTEM_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["TRANSPORT_ERROR"] = 500] = "TRANSPORT_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["GENERIC_ERROR"] = 500] = "GENERIC_ERROR";
  return JSONRPCErrorHttpCodes2;
})(JSONRPCErrorHttpCodes || {});
var P2MR_WITNESS_VERSION2 = 2;
var P2MR_DATA_LENGTH = 32;
function isP2MRAddress(addr, network) {
  try {
    const decoded = fromBech32(addr);
    return decoded.prefix === network.bech32 && decoded.version === P2MR_WITNESS_VERSION2 && decoded.data.length === P2MR_DATA_LENGTH;
  } catch {
    return false;
  }
}
var StackingEvents = [
  {
    name: "Stake",
    values: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Unstake",
    values: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Claim",
    values: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var STAKING_ABI = [
  {
    name: "stake",
    inputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "unstake",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "stakedAmount",
    constant: true,
    inputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "stakedReward",
    constant: true,
    inputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "claim",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "rewardPool",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "reward",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "totalStaked",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "total",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  // EVENTS
  ...StackingEvents
];
var OP_NET_ABI = [
  {
    name: "address",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "deployer",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "deployer",
        type: ABIDataTypes.ADDRESS
      }
    ]
  }
];
var OP20Events = [
  {
    name: "Transferred",
    values: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "from",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Approved",
    values: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "spender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Burned",
    values: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Minted",
    values: [
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var OP_20_ABI = [
  // Properties
  {
    name: "name",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "name",
        type: ABIDataTypes.STRING
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "symbol",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "symbol",
        type: ABIDataTypes.STRING
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "icon",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "icon",
        type: ABIDataTypes.STRING
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "decimals",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "decimals",
        type: ABIDataTypes.UINT8
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "totalSupply",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "totalSupply",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "maximumSupply",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "maximumSupply",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "domainSeparator",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "domainSeparator",
        type: ABIDataTypes.BYTES32
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "balanceOf",
    constant: true,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "balance",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "nonceOf",
    constant: true,
    inputs: [{ name: "owner", type: ABIDataTypes.ADDRESS }],
    outputs: [
      {
        name: "nonce",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "allowance",
    constant: true,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "spender",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "remaining",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transfer",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transferFrom",
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "safeTransfer",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 },
      { name: "data", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "safeTransferFrom",
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 },
      { name: "data", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "increaseAllowance",
    inputs: [
      { name: "spender", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "decreaseAllowance",
    inputs: [
      { name: "spender", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "increaseAllowanceBySignature",
    inputs: [
      { name: "owner", type: ABIDataTypes.BYTES32 },
      { name: "ownerTweakedPublicKey", type: ABIDataTypes.BYTES32 },
      { name: "spender", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 },
      { name: "deadline", type: ABIDataTypes.UINT64 },
      { name: "signature", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "decreaseAllowanceBySignature",
    inputs: [
      { name: "owner", type: ABIDataTypes.BYTES32 },
      { name: "ownerTweakedPublicKey", type: ABIDataTypes.BYTES32 },
      { name: "spender", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 },
      { name: "deadline", type: ABIDataTypes.UINT64 },
      { name: "signature", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "burn",
    inputs: [{ name: "amount", type: ABIDataTypes.UINT256 }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "metadata",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "name",
        type: ABIDataTypes.STRING
      },
      {
        name: "symbol",
        type: ABIDataTypes.STRING
      },
      {
        name: "icon",
        type: ABIDataTypes.STRING
      },
      {
        name: "decimals",
        type: ABIDataTypes.UINT8
      },
      {
        name: "totalSupply",
        type: ABIDataTypes.UINT256
      },
      {
        name: "domainSeparator",
        type: ABIDataTypes.BYTES32
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "mint",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "airdrop",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "addressAndAmount",
        type: ABIDataTypes.ADDRESS_UINT256_TUPLE
      }
    ],
    outputs: []
  },
  // Events
  ...OP20Events,
  // OP_NET
  ...OP_NET_ABI
];
var MOTO_ABI = [
  {
    name: "admin",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "adminAddress",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "changeAdmin",
    type: BitcoinAbiTypes.Function,
    inputs: [{ name: "to", type: ABIDataTypes.ADDRESS }],
    outputs: []
  },
  {
    name: "adminMint",
    type: BitcoinAbiTypes.Function,
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: []
  },
  {
    name: "adminBurn",
    type: BitcoinAbiTypes.Function,
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: []
  },
  // OP_20
  ...OP_20_ABI
];
var OwnableEvents = [
  {
    name: "OwnershipTransferred",
    values: [
      {
        name: "previousOwner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "newOwner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var OWNABLE_ABI = [
  {
    name: "owner",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "renounceOwnership",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "transferOwnership",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "newOwner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  }
];
var MotoChefEvents = [
  {
    name: "PoolAdded",
    values: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT256
      },
      {
        name: "lpToken",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Initialized",
    values: [],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PoolUpdated",
    values: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "lastRewardBlock",
        type: ABIDataTypes.UINT64
      },
      {
        name: "lpSupply",
        type: ABIDataTypes.UINT256
      },
      {
        name: "accMotoPerShare",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "BTCStaked",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "netAmount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "stakeTxId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "stakeIndex",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "BTCUnstaked",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "pendingMoto",
        type: ABIDataTypes.UINT256
      },
      {
        name: "storedTxId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "storedIndex",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "BTCStakeRemoved",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "storedTxId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "storedIndex",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PoolSet",
    values: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Deposited",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Withdrawn",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Harvested",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "EmergencyWithdrawn",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var MOTOCHEF_ABI = [
  {
    name: "initialize",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "motoAddress",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "premineAmount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "devAddress",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "motoPerBlock",
        type: ABIDataTypes.UINT256
      },
      {
        name: "bonusEndBlock",
        type: ABIDataTypes.UINT256
      },
      {
        name: "bonusMultiplier",
        type: ABIDataTypes.UINT256
      },
      {
        name: "treasuryAddress",
        type: ABIDataTypes.STRING
      },
      {
        name: "BTCAllocPoint",
        type: ABIDataTypes.UINT256
      },
      {
        name: "MOTOAllocPoint",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "totalAllocPoint",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "totalAllocPoint",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "devAddress",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "devAddress",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "getMotoPerBlock",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "motoPerBlock",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getBonusEndBlock",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "bonusEndBlock",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getBonusMultiplier",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "bonusMultiplier",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getLpTokens",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "lpTokens",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      }
    ]
  },
  {
    name: "getPoolsLength",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "poolsLength",
        type: ABIDataTypes.UINT32
      }
    ]
  },
  {
    name: "getLpToken",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      }
    ],
    outputs: [
      {
        name: "lpToken",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "getPoolInfo",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      }
    ],
    outputs: [
      {
        name: "accMotoPerShare",
        type: ABIDataTypes.UINT256
      },
      {
        name: "lastRewardBlock",
        type: ABIDataTypes.UINT64
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT64
      }
    ]
  },
  {
    name: "getUserInfo",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "rewardDebt",
        type: ABIDataTypes.INT128
      }
    ]
  },
  {
    name: "getMultiplier",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "from",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "multiplier",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "pendingMoto",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "pendingMoto",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "treasuryAddress",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "treasuryAddress",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "getStakingTxId",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "stakingTxId",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getStakingIndex",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "stakingIndex",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "totalBTCStaked",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "totalBTCStaked",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "stakeBTC",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "unstakeBTC",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "removeBTCStake",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "add",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT256
      },
      {
        name: "lpToken",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "set",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "updatePool",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      }
    ],
    outputs: [
      {
        name: "accMotoPerShare",
        type: ABIDataTypes.UINT256
      },
      {
        name: "lastRewardBlock",
        type: ABIDataTypes.UINT64
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT64
      }
    ]
  },
  {
    name: "massUpdatePools",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "length",
        type: ABIDataTypes.UINT16
      },
      {
        name: "poolIds",
        type: ABIDataTypes.ARRAY_OF_UINT32
      }
    ],
    outputs: []
  },
  {
    name: "deposit",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "withdraw",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "harvest",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "withdrawAndHarvest",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "emergencyWithdraw",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "onOP20Received",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "from",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "data",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: [
      {
        name: "selector",
        type: ABIDataTypes.BYTES4
      }
    ]
  },
  {
    name: "setMotoPerBlock",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "motoPerBlock",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "setBonusEndBlock",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "bonusEndBlock",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "setBonusMultiplier",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "bonusMultiplier",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "setDev",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "devAddress",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  // Ownable
  ...OwnableEvents,
  ...OWNABLE_ABI,
  // Events
  ...MotoChefEvents,
  // OP_NET
  ...OP_NET_ABI
];
var MotoSwapFactoryEvents = [
  {
    name: "PoolCreated",
    values: [
      {
        name: "token0",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "token1",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "pool",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var MotoSwapFactoryAbi = [
  {
    name: "createPool",
    inputs: [
      {
        name: "tokenA",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenB",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getPool",
    constant: true,
    inputs: [
      {
        name: "tokenA",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenB",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "pool",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "setStakingContractAddress",
    inputs: [
      {
        name: "stakingContractAddress",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getStakingContractAddress",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "stakingContractAddress",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  ...MotoSwapFactoryEvents,
  // OP_NET
  ...OP_NET_ABI
];
var MotoSwapPoolEvents = [
  {
    name: "LiquidityRemoved",
    values: [
      {
        name: "sender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1",
        type: ABIDataTypes.UINT256
      },
      { name: "to", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "LiquidityAdded",
    values: [
      {
        name: "sender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Swapped",
    values: [
      {
        name: "sender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount0In",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1In",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount0Out",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1Out",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Synced",
    values: [
      {
        name: "reserve0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserve1",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var MotoswapPoolAbi = [
  {
    name: "initialize",
    inputs: [
      {
        name: "token0",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "token1",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "swap",
    inputs: [
      {
        name: "amount0Out",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1Out",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "data",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "skim",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getReserves",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "reserve0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserve1",
        type: ABIDataTypes.UINT256
      },
      {
        name: "blockTimestampLast",
        type: ABIDataTypes.UINT64
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "token0",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "token0",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "token1",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "token1",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "price0CumulativeLast",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "price0CumulativeLast",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "price1CumulativeLast",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "price1CumulativeLast",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "kLast",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "kLast",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "blockTimestampLast",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "blockTimestampLast",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "sync",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "MINIMUM_LIQUIDITY",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "MINIMUM_LIQUIDITY",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  // Overwrites
  {
    name: "mint",
    inputs: [],
    outputs: [
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "burn",
    inputs: [
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "amount0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  // OP_20
  ...OP_20_ABI,
  // EVENTS
  ...MotoSwapPoolEvents
];
var MOTOSWAP_ROUTER_ABI = [
  /** Liquidity functions */
  {
    name: "addLiquidity",
    inputs: [
      {
        name: "tokenA",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenB",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amountADesired",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountBDesired",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountAMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountBMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      }
    ],
    outputs: [
      {
        name: "amountA",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountB",
        type: ABIDataTypes.UINT256
      },
      {
        name: "liquidity",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "removeLiquidity",
    inputs: [
      {
        name: "tokenA",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenB",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "liquidity",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountAMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountBMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      }
    ],
    outputs: [
      {
        name: "amountA",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountB",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  /** Common functions */
  {
    name: "quote",
    constant: true,
    inputs: [
      {
        name: "amountA",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveA",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveB",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "quote",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getAmountOut",
    constant: true,
    inputs: [
      {
        name: "amountIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveOut",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "amountOut",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getAmountIn",
    constant: true,
    inputs: [
      {
        name: "amountOut",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveOut",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "amountIn",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getAmountsOut",
    constant: true,
    inputs: [
      {
        name: "amountIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "path",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      }
    ],
    outputs: [
      {
        name: "amountsOut",
        type: ABIDataTypes.ARRAY_OF_UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getAmountsIn",
    constant: true,
    inputs: [
      {
        name: "amountOut",
        type: ABIDataTypes.UINT256
      },
      {
        name: "path",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      }
    ],
    outputs: [
      {
        name: "amountsIn",
        type: ABIDataTypes.ARRAY_OF_UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  /** Swap Functions */
  {
    name: "swapExactTokensForTokensSupportingFeeOnTransferTokens",
    inputs: [
      {
        name: "amountIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountOutMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "path",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  /** Views */
  {
    name: "factory",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "factory",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  /** Events */
  ...MotoSwapFactoryEvents,
  ...OP20Events,
  ...MotoSwapPoolEvents,
  // OP_NET
  ...OP_NET_ABI
];
var NativeSwapEvents = [
  {
    name: "LiquidityAdded",
    values: [
      { name: "totalTokensContributed", type: ABIDataTypes.UINT256 },
      { name: "virtualTokenExchanged", type: ABIDataTypes.UINT256 },
      { name: "totalSatoshisSpent", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "LiquidityListed",
    values: [
      { name: "totalLiquidity", type: ABIDataTypes.UINT128 },
      { name: "provider", type: ABIDataTypes.STRING }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "LiquidityRemoved",
    values: [
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "satoshisOwed", type: ABIDataTypes.UINT64 },
      { name: "tokenAmount", type: ABIDataTypes.UINT128 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "LiquidityReserved",
    values: [
      { name: "depositAddress", type: ABIDataTypes.STRING },
      { name: "satoshisAmount", type: ABIDataTypes.UINT64 },
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "tokenAmount", type: ABIDataTypes.UINT128 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ListingCanceled",
    values: [
      { name: "amount", type: ABIDataTypes.UINT128 },
      { name: "penalty", type: ABIDataTypes.UINT128 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ProviderActivated",
    values: [
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "listingAmount", type: ABIDataTypes.UINT128 },
      { name: "btcToRemove", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ProviderConsumed",
    values: [
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "amountUsed", type: ABIDataTypes.UINT128 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ProviderFulfilled",
    values: [
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "removalCompleted", type: ABIDataTypes.BOOL },
      { name: "stakedAmount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationFallback",
    values: [
      { name: "reservationId", type: ABIDataTypes.UINT128 },
      { name: "expirationBlock", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationCreated",
    values: [
      { name: "expectedAmountOut", type: ABIDataTypes.UINT256 },
      { name: "totalSatoshis", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationPurged",
    values: [
      { name: "reservationId", type: ABIDataTypes.UINT128 },
      { name: "currentBlock", type: ABIDataTypes.UINT64 },
      { name: "purgingBlock", type: ABIDataTypes.UINT64 },
      { name: "purgeIndex", type: ABIDataTypes.UINT32 },
      { name: "providerCount", type: ABIDataTypes.UINT32 },
      { name: "purgedAmount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "SwapExecuted",
    values: [
      { name: "buyer", type: ABIDataTypes.ADDRESS },
      { name: "amountIn", type: ABIDataTypes.UINT64 },
      { name: "amountOut", type: ABIDataTypes.UINT256 },
      { name: "totalFees", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "WithdrawListing",
    values: [
      { name: "amount", type: ABIDataTypes.UINT128 },
      { name: "tokenAddress", type: ABIDataTypes.ADDRESS },
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "sender", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var NativeSwapAbi = [
  //=================================================
  // RESERVE
  //=================================================
  {
    name: "reserve",
    inputs: [
      { name: "token", type: ABIDataTypes.ADDRESS },
      { name: "maximumAmountIn", type: ABIDataTypes.UINT64 },
      { name: "minimumAmountOut", type: ABIDataTypes.UINT256 },
      { name: "activationDelay", type: ABIDataTypes.UINT8 },
      { name: "sender", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // SWAP
  //=================================================
  {
    name: "swap",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // UPDATE
  //=================================================
  {
    name: "update",
    inputs: [
      { name: "address", type: ABIDataTypes.ADDRESS },
      { name: "calldata", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // LIST LIQUIDITY
  //=================================================
  {
    name: "listLiquidity",
    inputs: [
      { name: "token", type: ABIDataTypes.ADDRESS },
      { name: "receiver", type: ABIDataTypes.BYTES },
      { name: "receiverStr", type: ABIDataTypes.STRING },
      { name: "amountIn", type: ABIDataTypes.UINT128 },
      { name: "priority", type: ABIDataTypes.BOOL }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // CANCEL LISTING
  //=================================================
  {
    name: "cancelListing",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // WITHDRAW LISTING
  //=================================================
  {
    name: "withdrawListing",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // CREATE POOL
  //=================================================
  {
    name: "createPool",
    inputs: [
      { name: "token", type: ABIDataTypes.ADDRESS },
      { name: "floorPrice", type: ABIDataTypes.UINT256 },
      { name: "initialLiquidity", type: ABIDataTypes.UINT128 },
      { name: "receiver", type: ABIDataTypes.BYTES },
      { name: "receiverStr", type: ABIDataTypes.STRING },
      { name: "antiBotEnabledFor", type: ABIDataTypes.UINT16 },
      { name: "antiBotMaximumTokensPerReservation", type: ABIDataTypes.UINT256 },
      { name: "maxReservesIn5BlocksPercent", type: ABIDataTypes.UINT16 },
      { name: "poolType", type: ABIDataTypes.UINT8 },
      { name: "amplification", type: ABIDataTypes.UINT64 },
      { name: "pegStalenessThreshold", type: ABIDataTypes.UINT64 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // SET FEES
  //=================================================
  {
    name: "setFees",
    inputs: [
      { name: "reservationBaseFee", type: ABIDataTypes.UINT64 },
      { name: "priorityQueueBaseFee", type: ABIDataTypes.UINT64 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // SET STAKING CONTRACT ADDRESS
  //=================================================
  {
    name: "setStakingContractAddress",
    inputs: [{ name: "address", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // SET FEES ADDRESS
  //=================================================
  {
    name: "setFeesAddress",
    inputs: [{ name: "address", type: ABIDataTypes.STRING }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // PAUSE
  //=================================================
  {
    name: "pause",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // UNPAUSE
  //=================================================
  {
    name: "unpause",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // ACTIVATE WITHDRAW MODE
  //=================================================
  {
    name: "activateWithdrawMode",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // VIEW FUNCTIONS - READ ONLY
  //=================================================
  //=================================================
  // IS PAUSED
  //=================================================
  {
    name: "isPaused",
    constant: true,
    inputs: [],
    outputs: [{ name: "paused", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // IS WITHDRAW MODE ACTIVE
  //=================================================
  {
    name: "isWithdrawModeActive",
    constant: true,
    inputs: [],
    outputs: [{ name: "active", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET RESERVE
  //=================================================
  {
    name: "getReserve",
    constant: true,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "liquidity", type: ABIDataTypes.UINT256 },
      { name: "reservedLiquidity", type: ABIDataTypes.UINT256 },
      { name: "virtualBTCReserve", type: ABIDataTypes.UINT64 },
      { name: "virtualTokenReserve", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET QUOTE
  //=================================================
  {
    name: "getQuote",
    constant: true,
    inputs: [
      { name: "token", type: ABIDataTypes.ADDRESS },
      { name: "satoshisIn", type: ABIDataTypes.UINT64 }
    ],
    outputs: [
      { name: "tokensOut", type: ABIDataTypes.UINT256 },
      { name: "requiredSatoshis", type: ABIDataTypes.UINT64 },
      { name: "price", type: ABIDataTypes.UINT256 },
      { name: "scale", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET PROVIDER DETAILS
  //=================================================
  {
    name: "getProviderDetails",
    constant: true,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "id", type: ABIDataTypes.UINT256 },
      { name: "liquidity", type: ABIDataTypes.UINT128 },
      { name: "reserved", type: ABIDataTypes.UINT128 },
      { name: "btcReceiver", type: ABIDataTypes.STRING },
      { name: "indexedAt", type: ABIDataTypes.UINT32 },
      { name: "isPriority", type: ABIDataTypes.BOOL },
      { name: "purgeIndex", type: ABIDataTypes.UINT32 },
      { name: "isActive", type: ABIDataTypes.BOOL },
      { name: "lastListedTokensAtBlock", type: ABIDataTypes.UINT64 },
      { name: "isPurged", type: ABIDataTypes.BOOL },
      { name: "isLiquidityProvisionAllowed", type: ABIDataTypes.BOOL },
      { name: "toReset", type: ABIDataTypes.BOOL }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET PROVIDER DETAILS BY ID
  //=================================================
  {
    name: "getProviderDetailsById",
    constant: true,
    inputs: [{ name: "providerId", type: ABIDataTypes.UINT256 }],
    outputs: [
      { name: "id", type: ABIDataTypes.UINT256 },
      { name: "liquidity", type: ABIDataTypes.UINT128 },
      { name: "reserved", type: ABIDataTypes.UINT128 },
      { name: "btcReceiver", type: ABIDataTypes.STRING },
      { name: "indexedAt", type: ABIDataTypes.UINT32 },
      { name: "isPriority", type: ABIDataTypes.BOOL },
      { name: "purgeIndex", type: ABIDataTypes.UINT32 },
      { name: "isActive", type: ABIDataTypes.BOOL },
      { name: "lastListedTokensAtBlock", type: ABIDataTypes.UINT64 },
      { name: "isPurged", type: ABIDataTypes.BOOL },
      { name: "isLiquidityProvisionAllowed", type: ABIDataTypes.BOOL },
      { name: "toReset", type: ABIDataTypes.BOOL }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET QUEUE DETAILS
  //=================================================
  {
    name: "getQueueDetails",
    constant: true,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "lastPurgedBlock", type: ABIDataTypes.UINT64 },
      { name: "blockWithReservationsLength", type: ABIDataTypes.UINT32 },
      { name: "priorityQueueLength", type: ABIDataTypes.UINT32 },
      { name: "priorityQueueStartingIndex", type: ABIDataTypes.UINT32 },
      { name: "standardQueueLength", type: ABIDataTypes.UINT32 },
      { name: "standardQueueStartingIndex", type: ABIDataTypes.UINT32 },
      { name: "priorityPurgeQueueLength", type: ABIDataTypes.UINT32 },
      { name: "standardPurgeQueueLength", type: ABIDataTypes.UINT32 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET PRIORITY QUEUE COST
  //=================================================
  {
    name: "getPriorityQueueCost",
    constant: true,
    inputs: [],
    outputs: [{ name: "cost", type: ABIDataTypes.UINT64 }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET FEES
  //=================================================
  {
    name: "getFees",
    constant: true,
    inputs: [],
    outputs: [
      { name: "reservationBaseFee", type: ABIDataTypes.UINT64 },
      { name: "priorityQueueBaseFee", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET ANTIBOT SETTINGS
  //=================================================
  {
    name: "getAntibotSettings",
    constant: true,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "antiBotExpirationBlock", type: ABIDataTypes.UINT64 },
      { name: "maxTokensPerReservation", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET STAKING CONTRACT ADDRESS
  //=================================================
  {
    name: "getStakingContractAddress",
    constant: true,
    inputs: [],
    outputs: [{ name: "stakingAddress", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET FEES ADDRESS
  //=================================================
  {
    name: "getFeesAddress",
    constant: true,
    inputs: [],
    outputs: [{ name: "feesAddress", type: ABIDataTypes.STRING }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET POOL INFO
  //=================================================
  {
    name: "getPoolInfo",
    constant: true,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "poolType", type: ABIDataTypes.UINT8 },
      { name: "amplification", type: ABIDataTypes.UINT64 },
      { name: "pegStalenessThreshold", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // All Event Definitions
  //=================================================
  ...NativeSwapEvents,
  //=================================================
  // OP_NET Base ABI
  //=================================================
  ...OP_NET_ABI
];
var OP20SEvents = [
  {
    name: "PegRateUpdated",
    values: [
      { name: "oldRate", type: ABIDataTypes.UINT256 },
      { name: "newRate", type: ABIDataTypes.UINT256 },
      { name: "updatedAt", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "MaxStalenessUpdated",
    values: [
      { name: "oldStaleness", type: ABIDataTypes.UINT64 },
      { name: "newStaleness", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PegAuthorityTransferStarted",
    values: [
      { name: "currentAuthority", type: ABIDataTypes.ADDRESS },
      { name: "pendingAuthority", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PegAuthorityTransferred",
    values: [
      { name: "previousAuthority", type: ABIDataTypes.ADDRESS },
      { name: "newAuthority", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PegAuthorityRenounced",
    values: [{ name: "previousAuthority", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Event
  }
];
var OP_20S_ABI = [
  {
    name: "pegRate",
    constant: true,
    inputs: [],
    outputs: [{ name: "rate", type: ABIDataTypes.UINT256 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pegAuthority",
    constant: true,
    inputs: [],
    outputs: [{ name: "authority", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pegUpdatedAt",
    constant: true,
    inputs: [],
    outputs: [{ name: "updatedAt", type: ABIDataTypes.UINT64 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "maxStaleness",
    constant: true,
    inputs: [],
    outputs: [{ name: "staleness", type: ABIDataTypes.UINT64 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "isStale",
    constant: true,
    inputs: [],
    outputs: [{ name: "stale", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "updatePegRate",
    inputs: [{ name: "newRate", type: ABIDataTypes.UINT256 }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "updateMaxStaleness",
    inputs: [{ name: "newStaleness", type: ABIDataTypes.UINT64 }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transferPegAuthority",
    inputs: [{ name: "newAuthority", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "acceptPegAuthority",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "renouncePegAuthority",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  ...OP20SEvents,
  ...OP_20_ABI
];
var MOTOSWAP_OWNABLE_REENTRANCY_GUARD_ABI = [
  // Ownable
  {
    name: "admin",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "adminAddress",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "changeAdmin",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [
      {
        name: "newAdmin",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  // Reentrancy guard
  {
    name: "status",
    inputs: [],
    outputs: [
      {
        name: "status",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  }
];
var MotoswapStakingEvents = [
  {
    name: "RewardTokenAdded",
    type: BitcoinAbiTypes.Event,
    values: [
      {
        name: "token",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "RewardTokenRemoved",
    type: BitcoinAbiTypes.Event,
    values: [
      {
        name: "token",
        type: ABIDataTypes.ADDRESS
      }
    ]
  }
];
var MOTOSWAP_STAKING_ABI = [
  {
    name: "balanceOf",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [{ name: "address", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "balance", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "motoAddress",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [{ name: "motoAddress", type: ABIDataTypes.ADDRESS }]
  },
  {
    name: "totalSupply",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [{ name: "totalSupply", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "lastInteractedBlock",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [{ name: "address", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "lastInteractedBlock", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "rewardDebt",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      { name: "user", type: ABIDataTypes.ADDRESS },
      { name: "rewardToken", type: ABIDataTypes.ADDRESS }
    ],
    outputs: [{ name: "rewardDebt", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "rewardBalance",
    type: BitcoinAbiTypes.Function,
    constant: false,
    inputs: [
      { name: "user", type: ABIDataTypes.ADDRESS },
      { name: "rewardToken", type: ABIDataTypes.ADDRESS }
    ],
    outputs: [{ name: "rewardBalance", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "pendingReward",
    type: BitcoinAbiTypes.Function,
    constant: true,
    payable: false,
    inputs: [
      { name: "user", type: ABIDataTypes.ADDRESS },
      { name: "rewardToken", type: ABIDataTypes.ADDRESS }
    ],
    outputs: [{ name: "pendingReward", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "calculateSlashingFee",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      { name: "user", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [{ name: "rewardDebt", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "enabledRewardTokens",
    type: BitcoinAbiTypes.Function,
    constant: false,
    inputs: [],
    outputs: [{ name: "enabledRewardTokens", type: ABIDataTypes.ARRAY_OF_ADDRESSES }]
  },
  {
    name: "stake",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [{ name: "amount", type: ABIDataTypes.UINT256 }],
    outputs: []
  },
  {
    name: "unstake",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [],
    outputs: []
  },
  {
    name: "claimRewards",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [],
    outputs: []
  },
  {
    name: "adminAddRewardToken",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: []
  },
  {
    name: "adminRemoveRewardToken",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: []
  },
  {
    name: "adminChangeMotoAddress",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: []
  },
  {
    name: "adminChangeLockupParameters",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [
      { name: "newLockupDuration", type: ABIDataTypes.UINT256 },
      { name: "newMaxSlashingFeePercent", type: ABIDataTypes.UINT256 },
      { name: "newBlocksPerOnePercentSlashingFeeReduction", type: ABIDataTypes.UINT256 }
    ],
    outputs: []
  },
  {
    name: "adminEnableEmergencyWithdrawals",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [],
    outputs: []
  },
  // Ownable Reentrancy Guard
  ...MOTOSWAP_OWNABLE_REENTRANCY_GUARD_ABI,
  // Events
  ...MotoswapStakingEvents,
  // OP_NET
  ...OP_NET_ABI
];
var OP721Events = [
  {
    name: "Transferred",
    values: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "from",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Approved",
    values: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "spender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ApprovedForAll",
    values: [
      {
        name: "account",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "approved",
        type: ABIDataTypes.BOOL
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "URI",
    values: [
      {
        name: "value",
        type: ABIDataTypes.STRING
      },
      {
        name: "id",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var OP_721_ABI = [
  {
    name: "name",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "name",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "symbol",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "symbol",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "maxSupply",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "maxSupply",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "collectionInfo",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "icon",
        type: ABIDataTypes.STRING
      },
      {
        name: "banner",
        type: ABIDataTypes.STRING
      },
      {
        name: "description",
        type: ABIDataTypes.STRING
      },
      {
        name: "website",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "tokenURI",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "uri",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "changeMetadata",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "totalSupply",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "totalSupply",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "balanceOf",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "balance",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "ownerOf",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "safeTransfer",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "data",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: []
  },
  {
    name: "safeTransferFrom",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "from",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "data",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: []
  },
  {
    name: "approve",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "getApproved",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "setApprovalForAll",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "approved",
        type: ABIDataTypes.BOOL
      }
    ],
    outputs: []
  },
  {
    name: "isApprovedForAll",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "approved",
        type: ABIDataTypes.BOOL
      }
    ]
  },
  {
    name: "approveBySignature",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.BYTES32
      },
      {
        name: "ownerTweakedPublicKey",
        type: ABIDataTypes.BYTES32
      },
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      },
      {
        name: "signature",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: []
  },
  {
    name: "setApprovalForAllBySignature",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.BYTES32
      },
      {
        name: "ownerTweakedPublicKey",
        type: ABIDataTypes.BYTES32
      },
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "approved",
        type: ABIDataTypes.BOOL
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      },
      {
        name: "signature",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: []
  },
  {
    name: "burn",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "domainSeparator",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "domainSeparator",
        type: ABIDataTypes.BYTES32
      }
    ]
  },
  {
    name: "tokenOfOwnerByIndex",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "index",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getApproveNonce",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "nonce",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "setBaseURI",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "baseURI",
        type: ABIDataTypes.STRING
      }
    ],
    outputs: []
  },
  {
    name: "metadata",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "name",
        type: ABIDataTypes.STRING
      },
      {
        name: "symbol",
        type: ABIDataTypes.STRING
      },
      {
        name: "icon",
        type: ABIDataTypes.STRING
      },
      {
        name: "banner",
        type: ABIDataTypes.STRING
      },
      {
        name: "description",
        type: ABIDataTypes.STRING
      },
      {
        name: "website",
        type: ABIDataTypes.STRING
      },
      {
        name: "totalSupply",
        type: ABIDataTypes.UINT256
      },
      {
        name: "domainSeparator",
        type: ABIDataTypes.BYTES32
      }
    ]
  },
  ...OP721Events,
  // OP_NET
  ...OP_NET_ABI
];
var EXTENDED_OP721_EVENTS = [
  {
    name: "MintStatusChanged",
    values: [
      {
        name: "enabled",
        type: ABIDataTypes.BOOL
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationCreated",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "block",
        type: ABIDataTypes.UINT64
      },
      {
        name: "feePaid",
        type: ABIDataTypes.UINT64
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationClaimed",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "firstTokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationExpired",
    values: [
      {
        name: "block",
        type: ABIDataTypes.UINT64
      },
      {
        name: "amountRecovered",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var EXTENDED_OP721_ABI = [
  {
    name: "setMintEnabled",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "enabled",
        type: ABIDataTypes.BOOL
      }
    ],
    outputs: []
  },
  {
    name: "isMintEnabled",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "enabled",
        type: ABIDataTypes.BOOL
      }
    ]
  },
  {
    name: "reserve",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "quantity",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "remainingPayment",
        type: ABIDataTypes.UINT64
      },
      {
        name: "reservationBlock",
        type: ABIDataTypes.UINT64
      }
    ]
  },
  {
    name: "claim",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "purgeExpired",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "getStatus",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "minted",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserved",
        type: ABIDataTypes.UINT256
      },
      {
        name: "available",
        type: ABIDataTypes.UINT256
      },
      {
        name: "maxSupply",
        type: ABIDataTypes.UINT256
      },
      {
        name: "blocksWithReservations",
        type: ABIDataTypes.UINT32
      },
      {
        name: "pricePerToken",
        type: ABIDataTypes.UINT64
      },
      {
        name: "reservationFeePercent",
        type: ABIDataTypes.UINT64
      },
      {
        name: "minReservationFee",
        type: ABIDataTypes.UINT64
      }
    ]
  },
  {
    name: "airdrop",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "addresses",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      },
      {
        name: "amounts",
        type: ABIDataTypes.ARRAY_OF_UINT8
      }
    ],
    outputs: []
  },
  {
    name: "setTokenURI",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "uri",
        type: ABIDataTypes.STRING
      }
    ],
    outputs: []
  },
  ...EXTENDED_OP721_EVENTS,
  ...OP_721_ABI
];
var MultiOracleStablecoinEvents = [
  {
    name: "OracleAdded",
    values: [
      { name: "oracle", type: ABIDataTypes.ADDRESS },
      { name: "addedBy", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "OracleRemoved",
    values: [
      { name: "oracle", type: ABIDataTypes.ADDRESS },
      { name: "removedBy", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PriceSubmitted",
    values: [
      { name: "oracle", type: ABIDataTypes.ADDRESS },
      { name: "price", type: ABIDataTypes.UINT256 },
      { name: "blockNumber", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PriceAggregated",
    values: [
      { name: "medianPrice", type: ABIDataTypes.UINT256 },
      { name: "oracleCount", type: ABIDataTypes.UINT32 },
      { name: "blockNumber", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Minted",
    values: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var MultiOracleStablecoin_ABI = [
  {
    name: "addOracle",
    inputs: [{ name: "oracle", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "removeOracle",
    inputs: [{ name: "oracle", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "submitPrice",
    inputs: [{ name: "price", type: ABIDataTypes.UINT256 }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "aggregatePrice",
    inputs: [{ name: "oracles", type: ABIDataTypes.ARRAY_OF_ADDRESSES }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "mint",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "oracleCount",
    constant: true,
    inputs: [],
    outputs: [{ name: "count", type: ABIDataTypes.UINT256 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "minOracles",
    constant: true,
    inputs: [],
    outputs: [{ name: "min", type: ABIDataTypes.UINT256 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "isOracleActive",
    constant: true,
    inputs: [{ name: "oracle", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "active", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "oracleSubmission",
    constant: true,
    inputs: [{ name: "oracle", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "price", type: ABIDataTypes.UINT256 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "admin",
    constant: true,
    inputs: [],
    outputs: [{ name: "admin", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  ...MultiOracleStablecoinEvents,
  ...OP_20S_ABI
];
var StableCoinEvents = [
  {
    name: "Minted",
    values: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Burned",
    values: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Blacklisted",
    values: [
      { name: "account", type: ABIDataTypes.ADDRESS },
      { name: "blacklister", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Unblacklisted",
    values: [
      { name: "account", type: ABIDataTypes.ADDRESS },
      { name: "blacklister", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Paused",
    values: [{ name: "pauser", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Unpaused",
    values: [{ name: "pauser", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "OwnershipTransferStarted",
    values: [
      { name: "currentOwner", type: ABIDataTypes.ADDRESS },
      { name: "pendingOwner", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "OwnershipTransferred",
    values: [
      { name: "previousOwner", type: ABIDataTypes.ADDRESS },
      { name: "newOwner", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "MinterChanged",
    values: [
      { name: "previousMinter", type: ABIDataTypes.ADDRESS },
      { name: "newMinter", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "BlacklisterChanged",
    values: [
      { name: "previousBlacklister", type: ABIDataTypes.ADDRESS },
      { name: "newBlacklister", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PauserChanged",
    values: [
      { name: "previousPauser", type: ABIDataTypes.ADDRESS },
      { name: "newPauser", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var StableCoin_ABI = [
  {
    name: "mint",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "burnFrom",
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "blacklist",
    inputs: [{ name: "account", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "unblacklist",
    inputs: [{ name: "account", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "isBlacklisted",
    constant: true,
    inputs: [{ name: "account", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "blacklisted", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pause",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "unpause",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "isPaused",
    constant: true,
    inputs: [],
    outputs: [{ name: "paused", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transferOwnership",
    inputs: [{ name: "newOwner", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "acceptOwnership",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "setMinter",
    inputs: [{ name: "newMinter", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "setBlacklister",
    inputs: [{ name: "newBlacklister", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "setPauser",
    inputs: [{ name: "newPauser", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "owner",
    constant: true,
    inputs: [],
    outputs: [{ name: "owner", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "minter",
    constant: true,
    inputs: [],
    outputs: [{ name: "minter", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "blacklister",
    constant: true,
    inputs: [],
    outputs: [{ name: "blacklister", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pauser",
    constant: true,
    inputs: [],
    outputs: [{ name: "pauser", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  ...StableCoinEvents,
  ...OP_20S_ABI
];
var PeggedTokenEvents = [
  {
    name: "Minted",
    values: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Burned",
    values: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "CustodianChanged",
    values: [
      { name: "previousCustodian", type: ABIDataTypes.ADDRESS },
      { name: "newCustodian", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  }
];
var PeggedToken_ABI = [
  {
    name: "mint",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "burnFrom",
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transferCustodian",
    inputs: [{ name: "newCustodian", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "acceptCustodian",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "custodian",
    constant: true,
    inputs: [],
    outputs: [{ name: "custodian", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pendingCustodian",
    constant: true,
    inputs: [],
    outputs: [{ name: "pendingCustodian", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  ...PeggedTokenEvents,
  ...OP_20S_ABI
];
var opnet = Object.freeze(Object.defineProperty({
  __proto__: null,
  get ABIDataTypes() {
    return ABIDataTypes;
  },
  AbiTypeToStr: AbiTypeToStr2,
  AbstractRpcProvider,
  AuthError,
  BaseContract,
  BitcoinAbiTypes,
  BitcoinInterface,
  BitcoinUtils: BitcoinUtils2,
  Block,
  BlockGasParameters,
  BlockWitness,
  BlockWitnessAPI,
  CallResult,
  CallResultSerializer,
  ConnectionState,
  ContractData,
  DEFAULT_CONFIG: DEFAULT_CONFIG2,
  DeploymentTransaction: DeploymentTransaction2,
  EXTENDED_OP721_ABI,
  EXTENDED_OP721_EVENTS,
  Epoch,
  EpochDifficultyConverter,
  EpochMiner,
  EpochSubmission,
  EpochTemplate,
  EpochWithSubmissions,
  ErrorMessages,
  GenericTransaction,
  IBaseContract,
  InteractionTransaction: InteractionTransaction2,
  InternalError,
  JSONRPCErrorCode,
  JSONRPCErrorHttpCodes,
  JSONRpcMethods,
  JSONRpcProvider,
  MOTOCHEF_ABI,
  MOTOSWAP_ROUTER_ABI,
  MOTOSWAP_STAKING_ABI,
  MOTO_ABI,
  MempoolDeploymentTransactionData,
  MempoolGenericTransactionData,
  MempoolInteractionTransactionData,
  MempoolOPNetTransactionData,
  MempoolTransactionData,
  MempoolTransactionParser,
  MotoSwapFactoryAbi,
  MotoSwapFactoryEvents,
  MotoSwapPoolEvents,
  MotoswapPoolAbi,
  MultiOracleStablecoinEvents,
  MultiOracleStablecoin_ABI,
  NativeSwapAbi,
  NetworkName,
  OP20Events,
  OP721Events,
  OPNetEvent,
  OPNetTransactionTypes,
  OP_20S_ABI,
  OP_20_ABI,
  OP_721_ABI,
  OP_NET_ABI,
  P2MR_MS,
  P2TR_MS,
  PeggedTokenEvents,
  PeggedToken_ABI,
  ProtocolError,
  ResourceError,
  STAKING_ABI,
  StableCoinEvents,
  StableCoin_ABI,
  StoredValue,
  SubmissionStatus,
  SubmittedEpoch,
  SubscriptionType,
  TransactionBase,
  TransactionInput,
  TransactionInputFlags,
  TransactionOutput,
  TransactionOutputFlags,
  TransactionParser,
  TransactionReceipt,
  UTXO,
  UTXOsManager,
  ValidationError,
  WebSocketClientEvent,
  WebSocketRequestOpcode,
  WebSocketResponseOpcode,
  WebSocketRpcProvider,
  decodeRevertData,
  getConnectionStateName,
  getContract,
  getErrorMessage,
  getSubscriptionTypeName,
  isP2MRAddress,
  parseBlockWitnesses,
  stringBase64ToBuffer,
  stringToBuffer: stringToBuffer2,
  version
}, Symbol.toStringTag, { value: "Module" }));

export {
  P2TR_MS,
  P2MR_MS,
  ABIDataTypes,
  version,
  OPNetTransactionTypes,
  TransactionInput,
  TransactionOutput,
  decodeRevertData,
  TransactionReceipt,
  TransactionBase,
  DeploymentTransaction2 as DeploymentTransaction,
  GenericTransaction,
  InteractionTransaction2 as InteractionTransaction,
  TransactionParser,
  Block,
  BlockGasParameters,
  stringToBuffer2 as stringToBuffer,
  stringBase64ToBuffer,
  BlockWitnessAPI,
  BlockWitness,
  parseBlockWitnesses,
  NetworkName,
  CallResultSerializer,
  CallResult,
  ContractData,
  TransactionInputFlags,
  TransactionOutputFlags,
  EpochMiner,
  Epoch,
  EpochSubmission,
  EpochWithSubmissions,
  EpochTemplate,
  SubmittedEpoch,
  StoredValue,
  UTXO,
  JSONRpcMethods,
  UTXOsManager,
  MempoolTransactionData,
  MempoolOPNetTransactionData,
  MempoolDeploymentTransactionData,
  MempoolGenericTransactionData,
  MempoolInteractionTransactionData,
  MempoolTransactionParser,
  AbstractRpcProvider,
  JSONRpcProvider,
  WebSocketRequestOpcode,
  WebSocketResponseOpcode,
  ProtocolError,
  AuthError,
  ResourceError,
  ValidationError,
  InternalError,
  ErrorMessages,
  getErrorMessage,
  ConnectionState,
  getConnectionStateName,
  SubscriptionType,
  getSubscriptionTypeName,
  DEFAULT_CONFIG2 as DEFAULT_CONFIG,
  WebSocketClientEvent,
  WebSocketRpcProvider,
  SubmissionStatus,
  EpochDifficultyConverter,
  BitcoinAbiTypes,
  BitcoinInterface,
  OPNetEvent,
  IBaseContract,
  BaseContract,
  getContract,
  AbiTypeToStr2 as AbiTypeToStr,
  BitcoinUtils2 as BitcoinUtils,
  JSONRPCErrorCode,
  JSONRPCErrorHttpCodes,
  isP2MRAddress,
  STAKING_ABI,
  OP_NET_ABI,
  OP20Events,
  OP_20_ABI,
  MOTO_ABI,
  MOTOCHEF_ABI,
  MotoSwapFactoryEvents,
  MotoSwapFactoryAbi,
  MotoSwapPoolEvents,
  MotoswapPoolAbi,
  MOTOSWAP_ROUTER_ABI,
  NativeSwapAbi,
  OP_20S_ABI,
  MOTOSWAP_STAKING_ABI,
  OP721Events,
  OP_721_ABI,
  EXTENDED_OP721_EVENTS,
  EXTENDED_OP721_ABI,
  MultiOracleStablecoinEvents,
  MultiOracleStablecoin_ABI,
  StableCoinEvents,
  StableCoin_ABI,
  PeggedTokenEvents,
  PeggedToken_ABI,
  opnet
};
/*! Bundled license information:

opnet/browser/noble-hashes.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

opnet/browser/noble-curves.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

opnet/browser/vendors.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
  (*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)

opnet/browser/protobuf.js:
  (*!
   * protobuf.js v8.0.0 (c) 2016, daniel wirtz
   * compiled tue, 16 dec 2025 22:00:06 utc
   * licensed under the bsd-3-clause license
   * see: https://github.com/dcodeio/protobuf.js for details
   *)
*/
//# sourceMappingURL=chunk-525VUOQE.js.map
